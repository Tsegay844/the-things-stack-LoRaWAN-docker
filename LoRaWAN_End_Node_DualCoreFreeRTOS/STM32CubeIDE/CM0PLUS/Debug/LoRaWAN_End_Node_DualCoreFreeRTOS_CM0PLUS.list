
LoRaWAN_End_Node_DualCoreFreeRTOS_CM0PLUS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08020000  08020000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00014bc8  080200c0  080200c0  000100c0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00001330  08034c88  08034c88  00024c88  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08035fb8  08035fb8  0003e758  2**0
                  CONTENTS
  4 .ARM          00000008  08035fb8  08035fb8  00025fb8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08035fc0  08035fc0  0003e758  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000008  08035fc0  08035fc0  00025fc0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000008  08035fc8  08035fc8  00025fc8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .USER_embedded_Keys 00000258  0803e500  0803e500  0003e500  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .data         00000178  2000b000  08035fd0  0002b000  2**2
                  CONTENTS, ALLOC, LOAD, CODE
 10 LW_NVM_RAM    000009f8  2000a000  2000a000  0004a000  2**2
                  ALLOC
 11 .MB_MEM2      00000058  20009000  08036148  00039000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .MB_MEM3      00000648  20009058  080361a0  00039058  2**2
                  ALLOC
 13 .bss          000017e8  2000b178  2000b178  0004b178  2**2
                  ALLOC
 14 ._user_heap_stack 00001400  2000c960  2000c960  0004b178  2**0
                  ALLOC
 15 .ARM.attributes 00000028  00000000  00000000  0003e758  2**0
                  CONTENTS, READONLY
 16 .debug_info   0005ff16  00000000  00000000  0003e780  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_abbrev 0000d5a8  00000000  00000000  0009e696  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_loc    0002db2d  00000000  00000000  000abc3e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_aranges 00003138  00000000  00000000  000d9770  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_ranges 000032d0  00000000  00000000  000dc8a8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_macro  0001b0a7  00000000  00000000  000dfb78  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line   00066c22  00000000  00000000  000fac1f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_str    000e0524  00000000  00000000  00161841  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 24 .comment      00000050  00000000  00000000  00241d65  2**0
                  CONTENTS, READONLY
 25 .debug_frame  00008418  00000000  00000000  00241db8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080200c0 <__do_global_dtors_aux>:
 80200c0:	b510      	push	{r4, lr}
 80200c2:	4c06      	ldr	r4, [pc, #24]	; (80200dc <__do_global_dtors_aux+0x1c>)
 80200c4:	7823      	ldrb	r3, [r4, #0]
 80200c6:	2b00      	cmp	r3, #0
 80200c8:	d107      	bne.n	80200da <__do_global_dtors_aux+0x1a>
 80200ca:	4b05      	ldr	r3, [pc, #20]	; (80200e0 <__do_global_dtors_aux+0x20>)
 80200cc:	2b00      	cmp	r3, #0
 80200ce:	d002      	beq.n	80200d6 <__do_global_dtors_aux+0x16>
 80200d0:	4804      	ldr	r0, [pc, #16]	; (80200e4 <__do_global_dtors_aux+0x24>)
 80200d2:	e000      	b.n	80200d6 <__do_global_dtors_aux+0x16>
 80200d4:	bf00      	nop
 80200d6:	2301      	movs	r3, #1
 80200d8:	7023      	strb	r3, [r4, #0]
 80200da:	bd10      	pop	{r4, pc}
 80200dc:	2000b178 	.word	0x2000b178
 80200e0:	00000000 	.word	0x00000000
 80200e4:	08034c5c 	.word	0x08034c5c

080200e8 <frame_dummy>:
 80200e8:	4b04      	ldr	r3, [pc, #16]	; (80200fc <frame_dummy+0x14>)
 80200ea:	b510      	push	{r4, lr}
 80200ec:	2b00      	cmp	r3, #0
 80200ee:	d003      	beq.n	80200f8 <frame_dummy+0x10>
 80200f0:	4903      	ldr	r1, [pc, #12]	; (8020100 <frame_dummy+0x18>)
 80200f2:	4804      	ldr	r0, [pc, #16]	; (8020104 <frame_dummy+0x1c>)
 80200f4:	e000      	b.n	80200f8 <frame_dummy+0x10>
 80200f6:	bf00      	nop
 80200f8:	bd10      	pop	{r4, pc}
 80200fa:	46c0      	nop			; (mov r8, r8)
 80200fc:	00000000 	.word	0x00000000
 8020100:	2000b17c 	.word	0x2000b17c
 8020104:	08034c5c 	.word	0x08034c5c

08020108 <strlen>:
 8020108:	2300      	movs	r3, #0
 802010a:	5cc2      	ldrb	r2, [r0, r3]
 802010c:	3301      	adds	r3, #1
 802010e:	2a00      	cmp	r2, #0
 8020110:	d1fb      	bne.n	802010a <strlen+0x2>
 8020112:	1e58      	subs	r0, r3, #1
 8020114:	4770      	bx	lr
	...

08020118 <__udivsi3>:
 8020118:	2200      	movs	r2, #0
 802011a:	0843      	lsrs	r3, r0, #1
 802011c:	428b      	cmp	r3, r1
 802011e:	d374      	bcc.n	802020a <__udivsi3+0xf2>
 8020120:	0903      	lsrs	r3, r0, #4
 8020122:	428b      	cmp	r3, r1
 8020124:	d35f      	bcc.n	80201e6 <__udivsi3+0xce>
 8020126:	0a03      	lsrs	r3, r0, #8
 8020128:	428b      	cmp	r3, r1
 802012a:	d344      	bcc.n	80201b6 <__udivsi3+0x9e>
 802012c:	0b03      	lsrs	r3, r0, #12
 802012e:	428b      	cmp	r3, r1
 8020130:	d328      	bcc.n	8020184 <__udivsi3+0x6c>
 8020132:	0c03      	lsrs	r3, r0, #16
 8020134:	428b      	cmp	r3, r1
 8020136:	d30d      	bcc.n	8020154 <__udivsi3+0x3c>
 8020138:	22ff      	movs	r2, #255	; 0xff
 802013a:	0209      	lsls	r1, r1, #8
 802013c:	ba12      	rev	r2, r2
 802013e:	0c03      	lsrs	r3, r0, #16
 8020140:	428b      	cmp	r3, r1
 8020142:	d302      	bcc.n	802014a <__udivsi3+0x32>
 8020144:	1212      	asrs	r2, r2, #8
 8020146:	0209      	lsls	r1, r1, #8
 8020148:	d065      	beq.n	8020216 <__udivsi3+0xfe>
 802014a:	0b03      	lsrs	r3, r0, #12
 802014c:	428b      	cmp	r3, r1
 802014e:	d319      	bcc.n	8020184 <__udivsi3+0x6c>
 8020150:	e000      	b.n	8020154 <__udivsi3+0x3c>
 8020152:	0a09      	lsrs	r1, r1, #8
 8020154:	0bc3      	lsrs	r3, r0, #15
 8020156:	428b      	cmp	r3, r1
 8020158:	d301      	bcc.n	802015e <__udivsi3+0x46>
 802015a:	03cb      	lsls	r3, r1, #15
 802015c:	1ac0      	subs	r0, r0, r3
 802015e:	4152      	adcs	r2, r2
 8020160:	0b83      	lsrs	r3, r0, #14
 8020162:	428b      	cmp	r3, r1
 8020164:	d301      	bcc.n	802016a <__udivsi3+0x52>
 8020166:	038b      	lsls	r3, r1, #14
 8020168:	1ac0      	subs	r0, r0, r3
 802016a:	4152      	adcs	r2, r2
 802016c:	0b43      	lsrs	r3, r0, #13
 802016e:	428b      	cmp	r3, r1
 8020170:	d301      	bcc.n	8020176 <__udivsi3+0x5e>
 8020172:	034b      	lsls	r3, r1, #13
 8020174:	1ac0      	subs	r0, r0, r3
 8020176:	4152      	adcs	r2, r2
 8020178:	0b03      	lsrs	r3, r0, #12
 802017a:	428b      	cmp	r3, r1
 802017c:	d301      	bcc.n	8020182 <__udivsi3+0x6a>
 802017e:	030b      	lsls	r3, r1, #12
 8020180:	1ac0      	subs	r0, r0, r3
 8020182:	4152      	adcs	r2, r2
 8020184:	0ac3      	lsrs	r3, r0, #11
 8020186:	428b      	cmp	r3, r1
 8020188:	d301      	bcc.n	802018e <__udivsi3+0x76>
 802018a:	02cb      	lsls	r3, r1, #11
 802018c:	1ac0      	subs	r0, r0, r3
 802018e:	4152      	adcs	r2, r2
 8020190:	0a83      	lsrs	r3, r0, #10
 8020192:	428b      	cmp	r3, r1
 8020194:	d301      	bcc.n	802019a <__udivsi3+0x82>
 8020196:	028b      	lsls	r3, r1, #10
 8020198:	1ac0      	subs	r0, r0, r3
 802019a:	4152      	adcs	r2, r2
 802019c:	0a43      	lsrs	r3, r0, #9
 802019e:	428b      	cmp	r3, r1
 80201a0:	d301      	bcc.n	80201a6 <__udivsi3+0x8e>
 80201a2:	024b      	lsls	r3, r1, #9
 80201a4:	1ac0      	subs	r0, r0, r3
 80201a6:	4152      	adcs	r2, r2
 80201a8:	0a03      	lsrs	r3, r0, #8
 80201aa:	428b      	cmp	r3, r1
 80201ac:	d301      	bcc.n	80201b2 <__udivsi3+0x9a>
 80201ae:	020b      	lsls	r3, r1, #8
 80201b0:	1ac0      	subs	r0, r0, r3
 80201b2:	4152      	adcs	r2, r2
 80201b4:	d2cd      	bcs.n	8020152 <__udivsi3+0x3a>
 80201b6:	09c3      	lsrs	r3, r0, #7
 80201b8:	428b      	cmp	r3, r1
 80201ba:	d301      	bcc.n	80201c0 <__udivsi3+0xa8>
 80201bc:	01cb      	lsls	r3, r1, #7
 80201be:	1ac0      	subs	r0, r0, r3
 80201c0:	4152      	adcs	r2, r2
 80201c2:	0983      	lsrs	r3, r0, #6
 80201c4:	428b      	cmp	r3, r1
 80201c6:	d301      	bcc.n	80201cc <__udivsi3+0xb4>
 80201c8:	018b      	lsls	r3, r1, #6
 80201ca:	1ac0      	subs	r0, r0, r3
 80201cc:	4152      	adcs	r2, r2
 80201ce:	0943      	lsrs	r3, r0, #5
 80201d0:	428b      	cmp	r3, r1
 80201d2:	d301      	bcc.n	80201d8 <__udivsi3+0xc0>
 80201d4:	014b      	lsls	r3, r1, #5
 80201d6:	1ac0      	subs	r0, r0, r3
 80201d8:	4152      	adcs	r2, r2
 80201da:	0903      	lsrs	r3, r0, #4
 80201dc:	428b      	cmp	r3, r1
 80201de:	d301      	bcc.n	80201e4 <__udivsi3+0xcc>
 80201e0:	010b      	lsls	r3, r1, #4
 80201e2:	1ac0      	subs	r0, r0, r3
 80201e4:	4152      	adcs	r2, r2
 80201e6:	08c3      	lsrs	r3, r0, #3
 80201e8:	428b      	cmp	r3, r1
 80201ea:	d301      	bcc.n	80201f0 <__udivsi3+0xd8>
 80201ec:	00cb      	lsls	r3, r1, #3
 80201ee:	1ac0      	subs	r0, r0, r3
 80201f0:	4152      	adcs	r2, r2
 80201f2:	0883      	lsrs	r3, r0, #2
 80201f4:	428b      	cmp	r3, r1
 80201f6:	d301      	bcc.n	80201fc <__udivsi3+0xe4>
 80201f8:	008b      	lsls	r3, r1, #2
 80201fa:	1ac0      	subs	r0, r0, r3
 80201fc:	4152      	adcs	r2, r2
 80201fe:	0843      	lsrs	r3, r0, #1
 8020200:	428b      	cmp	r3, r1
 8020202:	d301      	bcc.n	8020208 <__udivsi3+0xf0>
 8020204:	004b      	lsls	r3, r1, #1
 8020206:	1ac0      	subs	r0, r0, r3
 8020208:	4152      	adcs	r2, r2
 802020a:	1a41      	subs	r1, r0, r1
 802020c:	d200      	bcs.n	8020210 <__udivsi3+0xf8>
 802020e:	4601      	mov	r1, r0
 8020210:	4152      	adcs	r2, r2
 8020212:	4610      	mov	r0, r2
 8020214:	4770      	bx	lr
 8020216:	e7ff      	b.n	8020218 <__udivsi3+0x100>
 8020218:	b501      	push	{r0, lr}
 802021a:	2000      	movs	r0, #0
 802021c:	f000 f8f0 	bl	8020400 <__aeabi_idiv0>
 8020220:	bd02      	pop	{r1, pc}
 8020222:	46c0      	nop			; (mov r8, r8)

08020224 <__aeabi_uidivmod>:
 8020224:	2900      	cmp	r1, #0
 8020226:	d0f7      	beq.n	8020218 <__udivsi3+0x100>
 8020228:	e776      	b.n	8020118 <__udivsi3>
 802022a:	4770      	bx	lr

0802022c <__divsi3>:
 802022c:	4603      	mov	r3, r0
 802022e:	430b      	orrs	r3, r1
 8020230:	d47f      	bmi.n	8020332 <__divsi3+0x106>
 8020232:	2200      	movs	r2, #0
 8020234:	0843      	lsrs	r3, r0, #1
 8020236:	428b      	cmp	r3, r1
 8020238:	d374      	bcc.n	8020324 <__divsi3+0xf8>
 802023a:	0903      	lsrs	r3, r0, #4
 802023c:	428b      	cmp	r3, r1
 802023e:	d35f      	bcc.n	8020300 <__divsi3+0xd4>
 8020240:	0a03      	lsrs	r3, r0, #8
 8020242:	428b      	cmp	r3, r1
 8020244:	d344      	bcc.n	80202d0 <__divsi3+0xa4>
 8020246:	0b03      	lsrs	r3, r0, #12
 8020248:	428b      	cmp	r3, r1
 802024a:	d328      	bcc.n	802029e <__divsi3+0x72>
 802024c:	0c03      	lsrs	r3, r0, #16
 802024e:	428b      	cmp	r3, r1
 8020250:	d30d      	bcc.n	802026e <__divsi3+0x42>
 8020252:	22ff      	movs	r2, #255	; 0xff
 8020254:	0209      	lsls	r1, r1, #8
 8020256:	ba12      	rev	r2, r2
 8020258:	0c03      	lsrs	r3, r0, #16
 802025a:	428b      	cmp	r3, r1
 802025c:	d302      	bcc.n	8020264 <__divsi3+0x38>
 802025e:	1212      	asrs	r2, r2, #8
 8020260:	0209      	lsls	r1, r1, #8
 8020262:	d065      	beq.n	8020330 <__divsi3+0x104>
 8020264:	0b03      	lsrs	r3, r0, #12
 8020266:	428b      	cmp	r3, r1
 8020268:	d319      	bcc.n	802029e <__divsi3+0x72>
 802026a:	e000      	b.n	802026e <__divsi3+0x42>
 802026c:	0a09      	lsrs	r1, r1, #8
 802026e:	0bc3      	lsrs	r3, r0, #15
 8020270:	428b      	cmp	r3, r1
 8020272:	d301      	bcc.n	8020278 <__divsi3+0x4c>
 8020274:	03cb      	lsls	r3, r1, #15
 8020276:	1ac0      	subs	r0, r0, r3
 8020278:	4152      	adcs	r2, r2
 802027a:	0b83      	lsrs	r3, r0, #14
 802027c:	428b      	cmp	r3, r1
 802027e:	d301      	bcc.n	8020284 <__divsi3+0x58>
 8020280:	038b      	lsls	r3, r1, #14
 8020282:	1ac0      	subs	r0, r0, r3
 8020284:	4152      	adcs	r2, r2
 8020286:	0b43      	lsrs	r3, r0, #13
 8020288:	428b      	cmp	r3, r1
 802028a:	d301      	bcc.n	8020290 <__divsi3+0x64>
 802028c:	034b      	lsls	r3, r1, #13
 802028e:	1ac0      	subs	r0, r0, r3
 8020290:	4152      	adcs	r2, r2
 8020292:	0b03      	lsrs	r3, r0, #12
 8020294:	428b      	cmp	r3, r1
 8020296:	d301      	bcc.n	802029c <__divsi3+0x70>
 8020298:	030b      	lsls	r3, r1, #12
 802029a:	1ac0      	subs	r0, r0, r3
 802029c:	4152      	adcs	r2, r2
 802029e:	0ac3      	lsrs	r3, r0, #11
 80202a0:	428b      	cmp	r3, r1
 80202a2:	d301      	bcc.n	80202a8 <__divsi3+0x7c>
 80202a4:	02cb      	lsls	r3, r1, #11
 80202a6:	1ac0      	subs	r0, r0, r3
 80202a8:	4152      	adcs	r2, r2
 80202aa:	0a83      	lsrs	r3, r0, #10
 80202ac:	428b      	cmp	r3, r1
 80202ae:	d301      	bcc.n	80202b4 <__divsi3+0x88>
 80202b0:	028b      	lsls	r3, r1, #10
 80202b2:	1ac0      	subs	r0, r0, r3
 80202b4:	4152      	adcs	r2, r2
 80202b6:	0a43      	lsrs	r3, r0, #9
 80202b8:	428b      	cmp	r3, r1
 80202ba:	d301      	bcc.n	80202c0 <__divsi3+0x94>
 80202bc:	024b      	lsls	r3, r1, #9
 80202be:	1ac0      	subs	r0, r0, r3
 80202c0:	4152      	adcs	r2, r2
 80202c2:	0a03      	lsrs	r3, r0, #8
 80202c4:	428b      	cmp	r3, r1
 80202c6:	d301      	bcc.n	80202cc <__divsi3+0xa0>
 80202c8:	020b      	lsls	r3, r1, #8
 80202ca:	1ac0      	subs	r0, r0, r3
 80202cc:	4152      	adcs	r2, r2
 80202ce:	d2cd      	bcs.n	802026c <__divsi3+0x40>
 80202d0:	09c3      	lsrs	r3, r0, #7
 80202d2:	428b      	cmp	r3, r1
 80202d4:	d301      	bcc.n	80202da <__divsi3+0xae>
 80202d6:	01cb      	lsls	r3, r1, #7
 80202d8:	1ac0      	subs	r0, r0, r3
 80202da:	4152      	adcs	r2, r2
 80202dc:	0983      	lsrs	r3, r0, #6
 80202de:	428b      	cmp	r3, r1
 80202e0:	d301      	bcc.n	80202e6 <__divsi3+0xba>
 80202e2:	018b      	lsls	r3, r1, #6
 80202e4:	1ac0      	subs	r0, r0, r3
 80202e6:	4152      	adcs	r2, r2
 80202e8:	0943      	lsrs	r3, r0, #5
 80202ea:	428b      	cmp	r3, r1
 80202ec:	d301      	bcc.n	80202f2 <__divsi3+0xc6>
 80202ee:	014b      	lsls	r3, r1, #5
 80202f0:	1ac0      	subs	r0, r0, r3
 80202f2:	4152      	adcs	r2, r2
 80202f4:	0903      	lsrs	r3, r0, #4
 80202f6:	428b      	cmp	r3, r1
 80202f8:	d301      	bcc.n	80202fe <__divsi3+0xd2>
 80202fa:	010b      	lsls	r3, r1, #4
 80202fc:	1ac0      	subs	r0, r0, r3
 80202fe:	4152      	adcs	r2, r2
 8020300:	08c3      	lsrs	r3, r0, #3
 8020302:	428b      	cmp	r3, r1
 8020304:	d301      	bcc.n	802030a <__divsi3+0xde>
 8020306:	00cb      	lsls	r3, r1, #3
 8020308:	1ac0      	subs	r0, r0, r3
 802030a:	4152      	adcs	r2, r2
 802030c:	0883      	lsrs	r3, r0, #2
 802030e:	428b      	cmp	r3, r1
 8020310:	d301      	bcc.n	8020316 <__divsi3+0xea>
 8020312:	008b      	lsls	r3, r1, #2
 8020314:	1ac0      	subs	r0, r0, r3
 8020316:	4152      	adcs	r2, r2
 8020318:	0843      	lsrs	r3, r0, #1
 802031a:	428b      	cmp	r3, r1
 802031c:	d301      	bcc.n	8020322 <__divsi3+0xf6>
 802031e:	004b      	lsls	r3, r1, #1
 8020320:	1ac0      	subs	r0, r0, r3
 8020322:	4152      	adcs	r2, r2
 8020324:	1a41      	subs	r1, r0, r1
 8020326:	d200      	bcs.n	802032a <__divsi3+0xfe>
 8020328:	4601      	mov	r1, r0
 802032a:	4152      	adcs	r2, r2
 802032c:	4610      	mov	r0, r2
 802032e:	4770      	bx	lr
 8020330:	e05d      	b.n	80203ee <__divsi3+0x1c2>
 8020332:	0fca      	lsrs	r2, r1, #31
 8020334:	d000      	beq.n	8020338 <__divsi3+0x10c>
 8020336:	4249      	negs	r1, r1
 8020338:	1003      	asrs	r3, r0, #32
 802033a:	d300      	bcc.n	802033e <__divsi3+0x112>
 802033c:	4240      	negs	r0, r0
 802033e:	4053      	eors	r3, r2
 8020340:	2200      	movs	r2, #0
 8020342:	469c      	mov	ip, r3
 8020344:	0903      	lsrs	r3, r0, #4
 8020346:	428b      	cmp	r3, r1
 8020348:	d32d      	bcc.n	80203a6 <__divsi3+0x17a>
 802034a:	0a03      	lsrs	r3, r0, #8
 802034c:	428b      	cmp	r3, r1
 802034e:	d312      	bcc.n	8020376 <__divsi3+0x14a>
 8020350:	22fc      	movs	r2, #252	; 0xfc
 8020352:	0189      	lsls	r1, r1, #6
 8020354:	ba12      	rev	r2, r2
 8020356:	0a03      	lsrs	r3, r0, #8
 8020358:	428b      	cmp	r3, r1
 802035a:	d30c      	bcc.n	8020376 <__divsi3+0x14a>
 802035c:	0189      	lsls	r1, r1, #6
 802035e:	1192      	asrs	r2, r2, #6
 8020360:	428b      	cmp	r3, r1
 8020362:	d308      	bcc.n	8020376 <__divsi3+0x14a>
 8020364:	0189      	lsls	r1, r1, #6
 8020366:	1192      	asrs	r2, r2, #6
 8020368:	428b      	cmp	r3, r1
 802036a:	d304      	bcc.n	8020376 <__divsi3+0x14a>
 802036c:	0189      	lsls	r1, r1, #6
 802036e:	d03a      	beq.n	80203e6 <__divsi3+0x1ba>
 8020370:	1192      	asrs	r2, r2, #6
 8020372:	e000      	b.n	8020376 <__divsi3+0x14a>
 8020374:	0989      	lsrs	r1, r1, #6
 8020376:	09c3      	lsrs	r3, r0, #7
 8020378:	428b      	cmp	r3, r1
 802037a:	d301      	bcc.n	8020380 <__divsi3+0x154>
 802037c:	01cb      	lsls	r3, r1, #7
 802037e:	1ac0      	subs	r0, r0, r3
 8020380:	4152      	adcs	r2, r2
 8020382:	0983      	lsrs	r3, r0, #6
 8020384:	428b      	cmp	r3, r1
 8020386:	d301      	bcc.n	802038c <__divsi3+0x160>
 8020388:	018b      	lsls	r3, r1, #6
 802038a:	1ac0      	subs	r0, r0, r3
 802038c:	4152      	adcs	r2, r2
 802038e:	0943      	lsrs	r3, r0, #5
 8020390:	428b      	cmp	r3, r1
 8020392:	d301      	bcc.n	8020398 <__divsi3+0x16c>
 8020394:	014b      	lsls	r3, r1, #5
 8020396:	1ac0      	subs	r0, r0, r3
 8020398:	4152      	adcs	r2, r2
 802039a:	0903      	lsrs	r3, r0, #4
 802039c:	428b      	cmp	r3, r1
 802039e:	d301      	bcc.n	80203a4 <__divsi3+0x178>
 80203a0:	010b      	lsls	r3, r1, #4
 80203a2:	1ac0      	subs	r0, r0, r3
 80203a4:	4152      	adcs	r2, r2
 80203a6:	08c3      	lsrs	r3, r0, #3
 80203a8:	428b      	cmp	r3, r1
 80203aa:	d301      	bcc.n	80203b0 <__divsi3+0x184>
 80203ac:	00cb      	lsls	r3, r1, #3
 80203ae:	1ac0      	subs	r0, r0, r3
 80203b0:	4152      	adcs	r2, r2
 80203b2:	0883      	lsrs	r3, r0, #2
 80203b4:	428b      	cmp	r3, r1
 80203b6:	d301      	bcc.n	80203bc <__divsi3+0x190>
 80203b8:	008b      	lsls	r3, r1, #2
 80203ba:	1ac0      	subs	r0, r0, r3
 80203bc:	4152      	adcs	r2, r2
 80203be:	d2d9      	bcs.n	8020374 <__divsi3+0x148>
 80203c0:	0843      	lsrs	r3, r0, #1
 80203c2:	428b      	cmp	r3, r1
 80203c4:	d301      	bcc.n	80203ca <__divsi3+0x19e>
 80203c6:	004b      	lsls	r3, r1, #1
 80203c8:	1ac0      	subs	r0, r0, r3
 80203ca:	4152      	adcs	r2, r2
 80203cc:	1a41      	subs	r1, r0, r1
 80203ce:	d200      	bcs.n	80203d2 <__divsi3+0x1a6>
 80203d0:	4601      	mov	r1, r0
 80203d2:	4663      	mov	r3, ip
 80203d4:	4152      	adcs	r2, r2
 80203d6:	105b      	asrs	r3, r3, #1
 80203d8:	4610      	mov	r0, r2
 80203da:	d301      	bcc.n	80203e0 <__divsi3+0x1b4>
 80203dc:	4240      	negs	r0, r0
 80203de:	2b00      	cmp	r3, #0
 80203e0:	d500      	bpl.n	80203e4 <__divsi3+0x1b8>
 80203e2:	4249      	negs	r1, r1
 80203e4:	4770      	bx	lr
 80203e6:	4663      	mov	r3, ip
 80203e8:	105b      	asrs	r3, r3, #1
 80203ea:	d300      	bcc.n	80203ee <__divsi3+0x1c2>
 80203ec:	4240      	negs	r0, r0
 80203ee:	b501      	push	{r0, lr}
 80203f0:	2000      	movs	r0, #0
 80203f2:	f000 f805 	bl	8020400 <__aeabi_idiv0>
 80203f6:	bd02      	pop	{r1, pc}

080203f8 <__aeabi_idivmod>:
 80203f8:	2900      	cmp	r1, #0
 80203fa:	d0f8      	beq.n	80203ee <__divsi3+0x1c2>
 80203fc:	e716      	b.n	802022c <__divsi3>
 80203fe:	4770      	bx	lr

08020400 <__aeabi_idiv0>:
 8020400:	4770      	bx	lr
 8020402:	46c0      	nop			; (mov r8, r8)

08020404 <__aeabi_cdrcmple>:
 8020404:	4684      	mov	ip, r0
 8020406:	0010      	movs	r0, r2
 8020408:	4662      	mov	r2, ip
 802040a:	468c      	mov	ip, r1
 802040c:	0019      	movs	r1, r3
 802040e:	4663      	mov	r3, ip
 8020410:	e000      	b.n	8020414 <__aeabi_cdcmpeq>
 8020412:	46c0      	nop			; (mov r8, r8)

08020414 <__aeabi_cdcmpeq>:
 8020414:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8020416:	f000 ff21 	bl	802125c <__ledf2>
 802041a:	2800      	cmp	r0, #0
 802041c:	d401      	bmi.n	8020422 <__aeabi_cdcmpeq+0xe>
 802041e:	2100      	movs	r1, #0
 8020420:	42c8      	cmn	r0, r1
 8020422:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}

08020424 <__aeabi_dcmpeq>:
 8020424:	b510      	push	{r4, lr}
 8020426:	f000 fe71 	bl	802110c <__eqdf2>
 802042a:	4240      	negs	r0, r0
 802042c:	3001      	adds	r0, #1
 802042e:	bd10      	pop	{r4, pc}

08020430 <__aeabi_dcmplt>:
 8020430:	b510      	push	{r4, lr}
 8020432:	f000 ff13 	bl	802125c <__ledf2>
 8020436:	2800      	cmp	r0, #0
 8020438:	db01      	blt.n	802043e <__aeabi_dcmplt+0xe>
 802043a:	2000      	movs	r0, #0
 802043c:	bd10      	pop	{r4, pc}
 802043e:	2001      	movs	r0, #1
 8020440:	bd10      	pop	{r4, pc}
 8020442:	46c0      	nop			; (mov r8, r8)

08020444 <__aeabi_dcmple>:
 8020444:	b510      	push	{r4, lr}
 8020446:	f000 ff09 	bl	802125c <__ledf2>
 802044a:	2800      	cmp	r0, #0
 802044c:	dd01      	ble.n	8020452 <__aeabi_dcmple+0xe>
 802044e:	2000      	movs	r0, #0
 8020450:	bd10      	pop	{r4, pc}
 8020452:	2001      	movs	r0, #1
 8020454:	bd10      	pop	{r4, pc}
 8020456:	46c0      	nop			; (mov r8, r8)

08020458 <__aeabi_dcmpgt>:
 8020458:	b510      	push	{r4, lr}
 802045a:	f000 fe99 	bl	8021190 <__gedf2>
 802045e:	2800      	cmp	r0, #0
 8020460:	dc01      	bgt.n	8020466 <__aeabi_dcmpgt+0xe>
 8020462:	2000      	movs	r0, #0
 8020464:	bd10      	pop	{r4, pc}
 8020466:	2001      	movs	r0, #1
 8020468:	bd10      	pop	{r4, pc}
 802046a:	46c0      	nop			; (mov r8, r8)

0802046c <__aeabi_dcmpge>:
 802046c:	b510      	push	{r4, lr}
 802046e:	f000 fe8f 	bl	8021190 <__gedf2>
 8020472:	2800      	cmp	r0, #0
 8020474:	da01      	bge.n	802047a <__aeabi_dcmpge+0xe>
 8020476:	2000      	movs	r0, #0
 8020478:	bd10      	pop	{r4, pc}
 802047a:	2001      	movs	r0, #1
 802047c:	bd10      	pop	{r4, pc}
 802047e:	46c0      	nop			; (mov r8, r8)

08020480 <__aeabi_uldivmod>:
 8020480:	2b00      	cmp	r3, #0
 8020482:	d111      	bne.n	80204a8 <__aeabi_uldivmod+0x28>
 8020484:	2a00      	cmp	r2, #0
 8020486:	d10f      	bne.n	80204a8 <__aeabi_uldivmod+0x28>
 8020488:	2900      	cmp	r1, #0
 802048a:	d100      	bne.n	802048e <__aeabi_uldivmod+0xe>
 802048c:	2800      	cmp	r0, #0
 802048e:	d002      	beq.n	8020496 <__aeabi_uldivmod+0x16>
 8020490:	2100      	movs	r1, #0
 8020492:	43c9      	mvns	r1, r1
 8020494:	0008      	movs	r0, r1
 8020496:	b407      	push	{r0, r1, r2}
 8020498:	4802      	ldr	r0, [pc, #8]	; (80204a4 <__aeabi_uldivmod+0x24>)
 802049a:	a102      	add	r1, pc, #8	; (adr r1, 80204a4 <__aeabi_uldivmod+0x24>)
 802049c:	1840      	adds	r0, r0, r1
 802049e:	9002      	str	r0, [sp, #8]
 80204a0:	bd03      	pop	{r0, r1, pc}
 80204a2:	46c0      	nop			; (mov r8, r8)
 80204a4:	ffffff5d 	.word	0xffffff5d
 80204a8:	b403      	push	{r0, r1}
 80204aa:	4668      	mov	r0, sp
 80204ac:	b501      	push	{r0, lr}
 80204ae:	9802      	ldr	r0, [sp, #8]
 80204b0:	f000 f834 	bl	802051c <__udivmoddi4>
 80204b4:	9b01      	ldr	r3, [sp, #4]
 80204b6:	469e      	mov	lr, r3
 80204b8:	b002      	add	sp, #8
 80204ba:	bc0c      	pop	{r2, r3}
 80204bc:	4770      	bx	lr
 80204be:	46c0      	nop			; (mov r8, r8)

080204c0 <__aeabi_lmul>:
 80204c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80204c2:	46ce      	mov	lr, r9
 80204c4:	4647      	mov	r7, r8
 80204c6:	b580      	push	{r7, lr}
 80204c8:	0007      	movs	r7, r0
 80204ca:	4699      	mov	r9, r3
 80204cc:	0c3b      	lsrs	r3, r7, #16
 80204ce:	469c      	mov	ip, r3
 80204d0:	0413      	lsls	r3, r2, #16
 80204d2:	0c1b      	lsrs	r3, r3, #16
 80204d4:	001d      	movs	r5, r3
 80204d6:	000e      	movs	r6, r1
 80204d8:	4661      	mov	r1, ip
 80204da:	0400      	lsls	r0, r0, #16
 80204dc:	0c14      	lsrs	r4, r2, #16
 80204de:	0c00      	lsrs	r0, r0, #16
 80204e0:	4345      	muls	r5, r0
 80204e2:	434b      	muls	r3, r1
 80204e4:	4360      	muls	r0, r4
 80204e6:	4361      	muls	r1, r4
 80204e8:	18c0      	adds	r0, r0, r3
 80204ea:	0c2c      	lsrs	r4, r5, #16
 80204ec:	1820      	adds	r0, r4, r0
 80204ee:	468c      	mov	ip, r1
 80204f0:	4283      	cmp	r3, r0
 80204f2:	d903      	bls.n	80204fc <__aeabi_lmul+0x3c>
 80204f4:	2380      	movs	r3, #128	; 0x80
 80204f6:	025b      	lsls	r3, r3, #9
 80204f8:	4698      	mov	r8, r3
 80204fa:	44c4      	add	ip, r8
 80204fc:	4649      	mov	r1, r9
 80204fe:	4379      	muls	r1, r7
 8020500:	4372      	muls	r2, r6
 8020502:	0c03      	lsrs	r3, r0, #16
 8020504:	4463      	add	r3, ip
 8020506:	042d      	lsls	r5, r5, #16
 8020508:	0c2d      	lsrs	r5, r5, #16
 802050a:	18c9      	adds	r1, r1, r3
 802050c:	0400      	lsls	r0, r0, #16
 802050e:	1940      	adds	r0, r0, r5
 8020510:	1889      	adds	r1, r1, r2
 8020512:	bcc0      	pop	{r6, r7}
 8020514:	46b9      	mov	r9, r7
 8020516:	46b0      	mov	r8, r6
 8020518:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802051a:	46c0      	nop			; (mov r8, r8)

0802051c <__udivmoddi4>:
 802051c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802051e:	4657      	mov	r7, sl
 8020520:	464e      	mov	r6, r9
 8020522:	4645      	mov	r5, r8
 8020524:	46de      	mov	lr, fp
 8020526:	b5e0      	push	{r5, r6, r7, lr}
 8020528:	0004      	movs	r4, r0
 802052a:	000d      	movs	r5, r1
 802052c:	4692      	mov	sl, r2
 802052e:	4699      	mov	r9, r3
 8020530:	b083      	sub	sp, #12
 8020532:	428b      	cmp	r3, r1
 8020534:	d830      	bhi.n	8020598 <__udivmoddi4+0x7c>
 8020536:	d02d      	beq.n	8020594 <__udivmoddi4+0x78>
 8020538:	4649      	mov	r1, r9
 802053a:	4650      	mov	r0, sl
 802053c:	f000 ff8e 	bl	802145c <__clzdi2>
 8020540:	0029      	movs	r1, r5
 8020542:	0006      	movs	r6, r0
 8020544:	0020      	movs	r0, r4
 8020546:	f000 ff89 	bl	802145c <__clzdi2>
 802054a:	1a33      	subs	r3, r6, r0
 802054c:	4698      	mov	r8, r3
 802054e:	3b20      	subs	r3, #32
 8020550:	469b      	mov	fp, r3
 8020552:	d433      	bmi.n	80205bc <__udivmoddi4+0xa0>
 8020554:	465a      	mov	r2, fp
 8020556:	4653      	mov	r3, sl
 8020558:	4093      	lsls	r3, r2
 802055a:	4642      	mov	r2, r8
 802055c:	001f      	movs	r7, r3
 802055e:	4653      	mov	r3, sl
 8020560:	4093      	lsls	r3, r2
 8020562:	001e      	movs	r6, r3
 8020564:	42af      	cmp	r7, r5
 8020566:	d83a      	bhi.n	80205de <__udivmoddi4+0xc2>
 8020568:	42af      	cmp	r7, r5
 802056a:	d100      	bne.n	802056e <__udivmoddi4+0x52>
 802056c:	e078      	b.n	8020660 <__udivmoddi4+0x144>
 802056e:	465b      	mov	r3, fp
 8020570:	1ba4      	subs	r4, r4, r6
 8020572:	41bd      	sbcs	r5, r7
 8020574:	2b00      	cmp	r3, #0
 8020576:	da00      	bge.n	802057a <__udivmoddi4+0x5e>
 8020578:	e075      	b.n	8020666 <__udivmoddi4+0x14a>
 802057a:	2200      	movs	r2, #0
 802057c:	2300      	movs	r3, #0
 802057e:	9200      	str	r2, [sp, #0]
 8020580:	9301      	str	r3, [sp, #4]
 8020582:	2301      	movs	r3, #1
 8020584:	465a      	mov	r2, fp
 8020586:	4093      	lsls	r3, r2
 8020588:	9301      	str	r3, [sp, #4]
 802058a:	2301      	movs	r3, #1
 802058c:	4642      	mov	r2, r8
 802058e:	4093      	lsls	r3, r2
 8020590:	9300      	str	r3, [sp, #0]
 8020592:	e028      	b.n	80205e6 <__udivmoddi4+0xca>
 8020594:	4282      	cmp	r2, r0
 8020596:	d9cf      	bls.n	8020538 <__udivmoddi4+0x1c>
 8020598:	2200      	movs	r2, #0
 802059a:	2300      	movs	r3, #0
 802059c:	9200      	str	r2, [sp, #0]
 802059e:	9301      	str	r3, [sp, #4]
 80205a0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80205a2:	2b00      	cmp	r3, #0
 80205a4:	d001      	beq.n	80205aa <__udivmoddi4+0x8e>
 80205a6:	601c      	str	r4, [r3, #0]
 80205a8:	605d      	str	r5, [r3, #4]
 80205aa:	9800      	ldr	r0, [sp, #0]
 80205ac:	9901      	ldr	r1, [sp, #4]
 80205ae:	b003      	add	sp, #12
 80205b0:	bcf0      	pop	{r4, r5, r6, r7}
 80205b2:	46bb      	mov	fp, r7
 80205b4:	46b2      	mov	sl, r6
 80205b6:	46a9      	mov	r9, r5
 80205b8:	46a0      	mov	r8, r4
 80205ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80205bc:	4642      	mov	r2, r8
 80205be:	2320      	movs	r3, #32
 80205c0:	1a9b      	subs	r3, r3, r2
 80205c2:	4652      	mov	r2, sl
 80205c4:	40da      	lsrs	r2, r3
 80205c6:	4641      	mov	r1, r8
 80205c8:	0013      	movs	r3, r2
 80205ca:	464a      	mov	r2, r9
 80205cc:	408a      	lsls	r2, r1
 80205ce:	0017      	movs	r7, r2
 80205d0:	4642      	mov	r2, r8
 80205d2:	431f      	orrs	r7, r3
 80205d4:	4653      	mov	r3, sl
 80205d6:	4093      	lsls	r3, r2
 80205d8:	001e      	movs	r6, r3
 80205da:	42af      	cmp	r7, r5
 80205dc:	d9c4      	bls.n	8020568 <__udivmoddi4+0x4c>
 80205de:	2200      	movs	r2, #0
 80205e0:	2300      	movs	r3, #0
 80205e2:	9200      	str	r2, [sp, #0]
 80205e4:	9301      	str	r3, [sp, #4]
 80205e6:	4643      	mov	r3, r8
 80205e8:	2b00      	cmp	r3, #0
 80205ea:	d0d9      	beq.n	80205a0 <__udivmoddi4+0x84>
 80205ec:	07fb      	lsls	r3, r7, #31
 80205ee:	0872      	lsrs	r2, r6, #1
 80205f0:	431a      	orrs	r2, r3
 80205f2:	4646      	mov	r6, r8
 80205f4:	087b      	lsrs	r3, r7, #1
 80205f6:	e00e      	b.n	8020616 <__udivmoddi4+0xfa>
 80205f8:	42ab      	cmp	r3, r5
 80205fa:	d101      	bne.n	8020600 <__udivmoddi4+0xe4>
 80205fc:	42a2      	cmp	r2, r4
 80205fe:	d80c      	bhi.n	802061a <__udivmoddi4+0xfe>
 8020600:	1aa4      	subs	r4, r4, r2
 8020602:	419d      	sbcs	r5, r3
 8020604:	2001      	movs	r0, #1
 8020606:	1924      	adds	r4, r4, r4
 8020608:	416d      	adcs	r5, r5
 802060a:	2100      	movs	r1, #0
 802060c:	3e01      	subs	r6, #1
 802060e:	1824      	adds	r4, r4, r0
 8020610:	414d      	adcs	r5, r1
 8020612:	2e00      	cmp	r6, #0
 8020614:	d006      	beq.n	8020624 <__udivmoddi4+0x108>
 8020616:	42ab      	cmp	r3, r5
 8020618:	d9ee      	bls.n	80205f8 <__udivmoddi4+0xdc>
 802061a:	3e01      	subs	r6, #1
 802061c:	1924      	adds	r4, r4, r4
 802061e:	416d      	adcs	r5, r5
 8020620:	2e00      	cmp	r6, #0
 8020622:	d1f8      	bne.n	8020616 <__udivmoddi4+0xfa>
 8020624:	9800      	ldr	r0, [sp, #0]
 8020626:	9901      	ldr	r1, [sp, #4]
 8020628:	465b      	mov	r3, fp
 802062a:	1900      	adds	r0, r0, r4
 802062c:	4169      	adcs	r1, r5
 802062e:	2b00      	cmp	r3, #0
 8020630:	db24      	blt.n	802067c <__udivmoddi4+0x160>
 8020632:	002b      	movs	r3, r5
 8020634:	465a      	mov	r2, fp
 8020636:	4644      	mov	r4, r8
 8020638:	40d3      	lsrs	r3, r2
 802063a:	002a      	movs	r2, r5
 802063c:	40e2      	lsrs	r2, r4
 802063e:	001c      	movs	r4, r3
 8020640:	465b      	mov	r3, fp
 8020642:	0015      	movs	r5, r2
 8020644:	2b00      	cmp	r3, #0
 8020646:	db2a      	blt.n	802069e <__udivmoddi4+0x182>
 8020648:	0026      	movs	r6, r4
 802064a:	409e      	lsls	r6, r3
 802064c:	0033      	movs	r3, r6
 802064e:	0026      	movs	r6, r4
 8020650:	4647      	mov	r7, r8
 8020652:	40be      	lsls	r6, r7
 8020654:	0032      	movs	r2, r6
 8020656:	1a80      	subs	r0, r0, r2
 8020658:	4199      	sbcs	r1, r3
 802065a:	9000      	str	r0, [sp, #0]
 802065c:	9101      	str	r1, [sp, #4]
 802065e:	e79f      	b.n	80205a0 <__udivmoddi4+0x84>
 8020660:	42a3      	cmp	r3, r4
 8020662:	d8bc      	bhi.n	80205de <__udivmoddi4+0xc2>
 8020664:	e783      	b.n	802056e <__udivmoddi4+0x52>
 8020666:	4642      	mov	r2, r8
 8020668:	2320      	movs	r3, #32
 802066a:	2100      	movs	r1, #0
 802066c:	1a9b      	subs	r3, r3, r2
 802066e:	2200      	movs	r2, #0
 8020670:	9100      	str	r1, [sp, #0]
 8020672:	9201      	str	r2, [sp, #4]
 8020674:	2201      	movs	r2, #1
 8020676:	40da      	lsrs	r2, r3
 8020678:	9201      	str	r2, [sp, #4]
 802067a:	e786      	b.n	802058a <__udivmoddi4+0x6e>
 802067c:	4642      	mov	r2, r8
 802067e:	2320      	movs	r3, #32
 8020680:	1a9b      	subs	r3, r3, r2
 8020682:	002a      	movs	r2, r5
 8020684:	4646      	mov	r6, r8
 8020686:	409a      	lsls	r2, r3
 8020688:	0023      	movs	r3, r4
 802068a:	40f3      	lsrs	r3, r6
 802068c:	4644      	mov	r4, r8
 802068e:	4313      	orrs	r3, r2
 8020690:	002a      	movs	r2, r5
 8020692:	40e2      	lsrs	r2, r4
 8020694:	001c      	movs	r4, r3
 8020696:	465b      	mov	r3, fp
 8020698:	0015      	movs	r5, r2
 802069a:	2b00      	cmp	r3, #0
 802069c:	dad4      	bge.n	8020648 <__udivmoddi4+0x12c>
 802069e:	4642      	mov	r2, r8
 80206a0:	002f      	movs	r7, r5
 80206a2:	2320      	movs	r3, #32
 80206a4:	0026      	movs	r6, r4
 80206a6:	4097      	lsls	r7, r2
 80206a8:	1a9b      	subs	r3, r3, r2
 80206aa:	40de      	lsrs	r6, r3
 80206ac:	003b      	movs	r3, r7
 80206ae:	4333      	orrs	r3, r6
 80206b0:	e7cd      	b.n	802064e <__udivmoddi4+0x132>
 80206b2:	46c0      	nop			; (mov r8, r8)

080206b4 <__aeabi_fsub>:
 80206b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80206b6:	46ce      	mov	lr, r9
 80206b8:	4647      	mov	r7, r8
 80206ba:	0243      	lsls	r3, r0, #9
 80206bc:	0a5b      	lsrs	r3, r3, #9
 80206be:	024e      	lsls	r6, r1, #9
 80206c0:	00da      	lsls	r2, r3, #3
 80206c2:	4694      	mov	ip, r2
 80206c4:	0a72      	lsrs	r2, r6, #9
 80206c6:	4691      	mov	r9, r2
 80206c8:	0045      	lsls	r5, r0, #1
 80206ca:	004a      	lsls	r2, r1, #1
 80206cc:	b580      	push	{r7, lr}
 80206ce:	0e2d      	lsrs	r5, r5, #24
 80206d0:	001f      	movs	r7, r3
 80206d2:	0fc4      	lsrs	r4, r0, #31
 80206d4:	0e12      	lsrs	r2, r2, #24
 80206d6:	0fc9      	lsrs	r1, r1, #31
 80206d8:	09b6      	lsrs	r6, r6, #6
 80206da:	2aff      	cmp	r2, #255	; 0xff
 80206dc:	d05b      	beq.n	8020796 <__aeabi_fsub+0xe2>
 80206de:	2001      	movs	r0, #1
 80206e0:	4041      	eors	r1, r0
 80206e2:	428c      	cmp	r4, r1
 80206e4:	d039      	beq.n	802075a <__aeabi_fsub+0xa6>
 80206e6:	1aa8      	subs	r0, r5, r2
 80206e8:	2800      	cmp	r0, #0
 80206ea:	dd5a      	ble.n	80207a2 <__aeabi_fsub+0xee>
 80206ec:	2a00      	cmp	r2, #0
 80206ee:	d06a      	beq.n	80207c6 <__aeabi_fsub+0x112>
 80206f0:	2dff      	cmp	r5, #255	; 0xff
 80206f2:	d100      	bne.n	80206f6 <__aeabi_fsub+0x42>
 80206f4:	e0d9      	b.n	80208aa <__aeabi_fsub+0x1f6>
 80206f6:	2280      	movs	r2, #128	; 0x80
 80206f8:	04d2      	lsls	r2, r2, #19
 80206fa:	4316      	orrs	r6, r2
 80206fc:	281b      	cmp	r0, #27
 80206fe:	dc00      	bgt.n	8020702 <__aeabi_fsub+0x4e>
 8020700:	e0e9      	b.n	80208d6 <__aeabi_fsub+0x222>
 8020702:	2001      	movs	r0, #1
 8020704:	4663      	mov	r3, ip
 8020706:	1a18      	subs	r0, r3, r0
 8020708:	0143      	lsls	r3, r0, #5
 802070a:	d400      	bmi.n	802070e <__aeabi_fsub+0x5a>
 802070c:	e0b4      	b.n	8020878 <__aeabi_fsub+0x1c4>
 802070e:	0180      	lsls	r0, r0, #6
 8020710:	0987      	lsrs	r7, r0, #6
 8020712:	0038      	movs	r0, r7
 8020714:	f000 fe84 	bl	8021420 <__clzsi2>
 8020718:	3805      	subs	r0, #5
 802071a:	4087      	lsls	r7, r0
 802071c:	4285      	cmp	r5, r0
 802071e:	dc00      	bgt.n	8020722 <__aeabi_fsub+0x6e>
 8020720:	e0cc      	b.n	80208bc <__aeabi_fsub+0x208>
 8020722:	1a2d      	subs	r5, r5, r0
 8020724:	48b5      	ldr	r0, [pc, #724]	; (80209fc <__aeabi_fsub+0x348>)
 8020726:	4038      	ands	r0, r7
 8020728:	0743      	lsls	r3, r0, #29
 802072a:	d004      	beq.n	8020736 <__aeabi_fsub+0x82>
 802072c:	230f      	movs	r3, #15
 802072e:	4003      	ands	r3, r0
 8020730:	2b04      	cmp	r3, #4
 8020732:	d000      	beq.n	8020736 <__aeabi_fsub+0x82>
 8020734:	3004      	adds	r0, #4
 8020736:	0143      	lsls	r3, r0, #5
 8020738:	d400      	bmi.n	802073c <__aeabi_fsub+0x88>
 802073a:	e0a0      	b.n	802087e <__aeabi_fsub+0x1ca>
 802073c:	1c6a      	adds	r2, r5, #1
 802073e:	2dfe      	cmp	r5, #254	; 0xfe
 8020740:	d100      	bne.n	8020744 <__aeabi_fsub+0x90>
 8020742:	e08d      	b.n	8020860 <__aeabi_fsub+0x1ac>
 8020744:	0180      	lsls	r0, r0, #6
 8020746:	0a47      	lsrs	r7, r0, #9
 8020748:	b2d2      	uxtb	r2, r2
 802074a:	05d0      	lsls	r0, r2, #23
 802074c:	4338      	orrs	r0, r7
 802074e:	07e4      	lsls	r4, r4, #31
 8020750:	4320      	orrs	r0, r4
 8020752:	bcc0      	pop	{r6, r7}
 8020754:	46b9      	mov	r9, r7
 8020756:	46b0      	mov	r8, r6
 8020758:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802075a:	1aa8      	subs	r0, r5, r2
 802075c:	4680      	mov	r8, r0
 802075e:	2800      	cmp	r0, #0
 8020760:	dd45      	ble.n	80207ee <__aeabi_fsub+0x13a>
 8020762:	2a00      	cmp	r2, #0
 8020764:	d070      	beq.n	8020848 <__aeabi_fsub+0x194>
 8020766:	2dff      	cmp	r5, #255	; 0xff
 8020768:	d100      	bne.n	802076c <__aeabi_fsub+0xb8>
 802076a:	e09e      	b.n	80208aa <__aeabi_fsub+0x1f6>
 802076c:	2380      	movs	r3, #128	; 0x80
 802076e:	04db      	lsls	r3, r3, #19
 8020770:	431e      	orrs	r6, r3
 8020772:	4643      	mov	r3, r8
 8020774:	2b1b      	cmp	r3, #27
 8020776:	dc00      	bgt.n	802077a <__aeabi_fsub+0xc6>
 8020778:	e0d2      	b.n	8020920 <__aeabi_fsub+0x26c>
 802077a:	2001      	movs	r0, #1
 802077c:	4460      	add	r0, ip
 802077e:	0143      	lsls	r3, r0, #5
 8020780:	d57a      	bpl.n	8020878 <__aeabi_fsub+0x1c4>
 8020782:	3501      	adds	r5, #1
 8020784:	2dff      	cmp	r5, #255	; 0xff
 8020786:	d06b      	beq.n	8020860 <__aeabi_fsub+0x1ac>
 8020788:	2301      	movs	r3, #1
 802078a:	4a9d      	ldr	r2, [pc, #628]	; (8020a00 <__aeabi_fsub+0x34c>)
 802078c:	4003      	ands	r3, r0
 802078e:	0840      	lsrs	r0, r0, #1
 8020790:	4010      	ands	r0, r2
 8020792:	4318      	orrs	r0, r3
 8020794:	e7c8      	b.n	8020728 <__aeabi_fsub+0x74>
 8020796:	2e00      	cmp	r6, #0
 8020798:	d020      	beq.n	80207dc <__aeabi_fsub+0x128>
 802079a:	428c      	cmp	r4, r1
 802079c:	d023      	beq.n	80207e6 <__aeabi_fsub+0x132>
 802079e:	0028      	movs	r0, r5
 80207a0:	38ff      	subs	r0, #255	; 0xff
 80207a2:	2800      	cmp	r0, #0
 80207a4:	d039      	beq.n	802081a <__aeabi_fsub+0x166>
 80207a6:	1b57      	subs	r7, r2, r5
 80207a8:	2d00      	cmp	r5, #0
 80207aa:	d000      	beq.n	80207ae <__aeabi_fsub+0xfa>
 80207ac:	e09d      	b.n	80208ea <__aeabi_fsub+0x236>
 80207ae:	4663      	mov	r3, ip
 80207b0:	2b00      	cmp	r3, #0
 80207b2:	d100      	bne.n	80207b6 <__aeabi_fsub+0x102>
 80207b4:	e0db      	b.n	802096e <__aeabi_fsub+0x2ba>
 80207b6:	1e7b      	subs	r3, r7, #1
 80207b8:	2f01      	cmp	r7, #1
 80207ba:	d100      	bne.n	80207be <__aeabi_fsub+0x10a>
 80207bc:	e10d      	b.n	80209da <__aeabi_fsub+0x326>
 80207be:	2fff      	cmp	r7, #255	; 0xff
 80207c0:	d071      	beq.n	80208a6 <__aeabi_fsub+0x1f2>
 80207c2:	001f      	movs	r7, r3
 80207c4:	e098      	b.n	80208f8 <__aeabi_fsub+0x244>
 80207c6:	2e00      	cmp	r6, #0
 80207c8:	d100      	bne.n	80207cc <__aeabi_fsub+0x118>
 80207ca:	e0a7      	b.n	802091c <__aeabi_fsub+0x268>
 80207cc:	1e42      	subs	r2, r0, #1
 80207ce:	2801      	cmp	r0, #1
 80207d0:	d100      	bne.n	80207d4 <__aeabi_fsub+0x120>
 80207d2:	e0e6      	b.n	80209a2 <__aeabi_fsub+0x2ee>
 80207d4:	28ff      	cmp	r0, #255	; 0xff
 80207d6:	d068      	beq.n	80208aa <__aeabi_fsub+0x1f6>
 80207d8:	0010      	movs	r0, r2
 80207da:	e78f      	b.n	80206fc <__aeabi_fsub+0x48>
 80207dc:	2001      	movs	r0, #1
 80207de:	4041      	eors	r1, r0
 80207e0:	42a1      	cmp	r1, r4
 80207e2:	d000      	beq.n	80207e6 <__aeabi_fsub+0x132>
 80207e4:	e77f      	b.n	80206e6 <__aeabi_fsub+0x32>
 80207e6:	20ff      	movs	r0, #255	; 0xff
 80207e8:	4240      	negs	r0, r0
 80207ea:	4680      	mov	r8, r0
 80207ec:	44a8      	add	r8, r5
 80207ee:	4640      	mov	r0, r8
 80207f0:	2800      	cmp	r0, #0
 80207f2:	d038      	beq.n	8020866 <__aeabi_fsub+0x1b2>
 80207f4:	1b51      	subs	r1, r2, r5
 80207f6:	2d00      	cmp	r5, #0
 80207f8:	d100      	bne.n	80207fc <__aeabi_fsub+0x148>
 80207fa:	e0ae      	b.n	802095a <__aeabi_fsub+0x2a6>
 80207fc:	2aff      	cmp	r2, #255	; 0xff
 80207fe:	d100      	bne.n	8020802 <__aeabi_fsub+0x14e>
 8020800:	e0df      	b.n	80209c2 <__aeabi_fsub+0x30e>
 8020802:	2380      	movs	r3, #128	; 0x80
 8020804:	4660      	mov	r0, ip
 8020806:	04db      	lsls	r3, r3, #19
 8020808:	4318      	orrs	r0, r3
 802080a:	4684      	mov	ip, r0
 802080c:	291b      	cmp	r1, #27
 802080e:	dc00      	bgt.n	8020812 <__aeabi_fsub+0x15e>
 8020810:	e0d9      	b.n	80209c6 <__aeabi_fsub+0x312>
 8020812:	2001      	movs	r0, #1
 8020814:	0015      	movs	r5, r2
 8020816:	1980      	adds	r0, r0, r6
 8020818:	e7b1      	b.n	802077e <__aeabi_fsub+0xca>
 802081a:	20fe      	movs	r0, #254	; 0xfe
 802081c:	1c6a      	adds	r2, r5, #1
 802081e:	4210      	tst	r0, r2
 8020820:	d171      	bne.n	8020906 <__aeabi_fsub+0x252>
 8020822:	2d00      	cmp	r5, #0
 8020824:	d000      	beq.n	8020828 <__aeabi_fsub+0x174>
 8020826:	e0a6      	b.n	8020976 <__aeabi_fsub+0x2c2>
 8020828:	4663      	mov	r3, ip
 802082a:	2b00      	cmp	r3, #0
 802082c:	d100      	bne.n	8020830 <__aeabi_fsub+0x17c>
 802082e:	e0d9      	b.n	80209e4 <__aeabi_fsub+0x330>
 8020830:	2200      	movs	r2, #0
 8020832:	2e00      	cmp	r6, #0
 8020834:	d100      	bne.n	8020838 <__aeabi_fsub+0x184>
 8020836:	e788      	b.n	802074a <__aeabi_fsub+0x96>
 8020838:	1b98      	subs	r0, r3, r6
 802083a:	0143      	lsls	r3, r0, #5
 802083c:	d400      	bmi.n	8020840 <__aeabi_fsub+0x18c>
 802083e:	e0e1      	b.n	8020a04 <__aeabi_fsub+0x350>
 8020840:	4663      	mov	r3, ip
 8020842:	000c      	movs	r4, r1
 8020844:	1af0      	subs	r0, r6, r3
 8020846:	e76f      	b.n	8020728 <__aeabi_fsub+0x74>
 8020848:	2e00      	cmp	r6, #0
 802084a:	d100      	bne.n	802084e <__aeabi_fsub+0x19a>
 802084c:	e0b7      	b.n	80209be <__aeabi_fsub+0x30a>
 802084e:	0002      	movs	r2, r0
 8020850:	3a01      	subs	r2, #1
 8020852:	2801      	cmp	r0, #1
 8020854:	d100      	bne.n	8020858 <__aeabi_fsub+0x1a4>
 8020856:	e09c      	b.n	8020992 <__aeabi_fsub+0x2de>
 8020858:	28ff      	cmp	r0, #255	; 0xff
 802085a:	d026      	beq.n	80208aa <__aeabi_fsub+0x1f6>
 802085c:	4690      	mov	r8, r2
 802085e:	e788      	b.n	8020772 <__aeabi_fsub+0xbe>
 8020860:	22ff      	movs	r2, #255	; 0xff
 8020862:	2700      	movs	r7, #0
 8020864:	e771      	b.n	802074a <__aeabi_fsub+0x96>
 8020866:	20fe      	movs	r0, #254	; 0xfe
 8020868:	1c6a      	adds	r2, r5, #1
 802086a:	4210      	tst	r0, r2
 802086c:	d064      	beq.n	8020938 <__aeabi_fsub+0x284>
 802086e:	2aff      	cmp	r2, #255	; 0xff
 8020870:	d0f6      	beq.n	8020860 <__aeabi_fsub+0x1ac>
 8020872:	0015      	movs	r5, r2
 8020874:	4466      	add	r6, ip
 8020876:	0870      	lsrs	r0, r6, #1
 8020878:	0743      	lsls	r3, r0, #29
 802087a:	d000      	beq.n	802087e <__aeabi_fsub+0x1ca>
 802087c:	e756      	b.n	802072c <__aeabi_fsub+0x78>
 802087e:	08c3      	lsrs	r3, r0, #3
 8020880:	2dff      	cmp	r5, #255	; 0xff
 8020882:	d012      	beq.n	80208aa <__aeabi_fsub+0x1f6>
 8020884:	025b      	lsls	r3, r3, #9
 8020886:	0a5f      	lsrs	r7, r3, #9
 8020888:	b2ea      	uxtb	r2, r5
 802088a:	e75e      	b.n	802074a <__aeabi_fsub+0x96>
 802088c:	4662      	mov	r2, ip
 802088e:	2a00      	cmp	r2, #0
 8020890:	d100      	bne.n	8020894 <__aeabi_fsub+0x1e0>
 8020892:	e096      	b.n	80209c2 <__aeabi_fsub+0x30e>
 8020894:	2e00      	cmp	r6, #0
 8020896:	d008      	beq.n	80208aa <__aeabi_fsub+0x1f6>
 8020898:	2280      	movs	r2, #128	; 0x80
 802089a:	03d2      	lsls	r2, r2, #15
 802089c:	4213      	tst	r3, r2
 802089e:	d004      	beq.n	80208aa <__aeabi_fsub+0x1f6>
 80208a0:	4648      	mov	r0, r9
 80208a2:	4210      	tst	r0, r2
 80208a4:	d101      	bne.n	80208aa <__aeabi_fsub+0x1f6>
 80208a6:	000c      	movs	r4, r1
 80208a8:	464b      	mov	r3, r9
 80208aa:	2b00      	cmp	r3, #0
 80208ac:	d0d8      	beq.n	8020860 <__aeabi_fsub+0x1ac>
 80208ae:	2780      	movs	r7, #128	; 0x80
 80208b0:	03ff      	lsls	r7, r7, #15
 80208b2:	431f      	orrs	r7, r3
 80208b4:	027f      	lsls	r7, r7, #9
 80208b6:	22ff      	movs	r2, #255	; 0xff
 80208b8:	0a7f      	lsrs	r7, r7, #9
 80208ba:	e746      	b.n	802074a <__aeabi_fsub+0x96>
 80208bc:	2320      	movs	r3, #32
 80208be:	003a      	movs	r2, r7
 80208c0:	1b45      	subs	r5, r0, r5
 80208c2:	0038      	movs	r0, r7
 80208c4:	3501      	adds	r5, #1
 80208c6:	40ea      	lsrs	r2, r5
 80208c8:	1b5d      	subs	r5, r3, r5
 80208ca:	40a8      	lsls	r0, r5
 80208cc:	1e43      	subs	r3, r0, #1
 80208ce:	4198      	sbcs	r0, r3
 80208d0:	2500      	movs	r5, #0
 80208d2:	4310      	orrs	r0, r2
 80208d4:	e728      	b.n	8020728 <__aeabi_fsub+0x74>
 80208d6:	2320      	movs	r3, #32
 80208d8:	1a1b      	subs	r3, r3, r0
 80208da:	0032      	movs	r2, r6
 80208dc:	409e      	lsls	r6, r3
 80208de:	40c2      	lsrs	r2, r0
 80208e0:	0030      	movs	r0, r6
 80208e2:	1e43      	subs	r3, r0, #1
 80208e4:	4198      	sbcs	r0, r3
 80208e6:	4310      	orrs	r0, r2
 80208e8:	e70c      	b.n	8020704 <__aeabi_fsub+0x50>
 80208ea:	2aff      	cmp	r2, #255	; 0xff
 80208ec:	d0db      	beq.n	80208a6 <__aeabi_fsub+0x1f2>
 80208ee:	2380      	movs	r3, #128	; 0x80
 80208f0:	4660      	mov	r0, ip
 80208f2:	04db      	lsls	r3, r3, #19
 80208f4:	4318      	orrs	r0, r3
 80208f6:	4684      	mov	ip, r0
 80208f8:	2f1b      	cmp	r7, #27
 80208fa:	dd56      	ble.n	80209aa <__aeabi_fsub+0x2f6>
 80208fc:	2001      	movs	r0, #1
 80208fe:	000c      	movs	r4, r1
 8020900:	0015      	movs	r5, r2
 8020902:	1a30      	subs	r0, r6, r0
 8020904:	e700      	b.n	8020708 <__aeabi_fsub+0x54>
 8020906:	4663      	mov	r3, ip
 8020908:	1b9f      	subs	r7, r3, r6
 802090a:	017b      	lsls	r3, r7, #5
 802090c:	d43d      	bmi.n	802098a <__aeabi_fsub+0x2d6>
 802090e:	2f00      	cmp	r7, #0
 8020910:	d000      	beq.n	8020914 <__aeabi_fsub+0x260>
 8020912:	e6fe      	b.n	8020712 <__aeabi_fsub+0x5e>
 8020914:	2400      	movs	r4, #0
 8020916:	2200      	movs	r2, #0
 8020918:	2700      	movs	r7, #0
 802091a:	e716      	b.n	802074a <__aeabi_fsub+0x96>
 802091c:	0005      	movs	r5, r0
 802091e:	e7af      	b.n	8020880 <__aeabi_fsub+0x1cc>
 8020920:	0032      	movs	r2, r6
 8020922:	4643      	mov	r3, r8
 8020924:	4641      	mov	r1, r8
 8020926:	40da      	lsrs	r2, r3
 8020928:	2320      	movs	r3, #32
 802092a:	1a5b      	subs	r3, r3, r1
 802092c:	409e      	lsls	r6, r3
 802092e:	0030      	movs	r0, r6
 8020930:	1e43      	subs	r3, r0, #1
 8020932:	4198      	sbcs	r0, r3
 8020934:	4310      	orrs	r0, r2
 8020936:	e721      	b.n	802077c <__aeabi_fsub+0xc8>
 8020938:	2d00      	cmp	r5, #0
 802093a:	d1a7      	bne.n	802088c <__aeabi_fsub+0x1d8>
 802093c:	4663      	mov	r3, ip
 802093e:	2b00      	cmp	r3, #0
 8020940:	d059      	beq.n	80209f6 <__aeabi_fsub+0x342>
 8020942:	2200      	movs	r2, #0
 8020944:	2e00      	cmp	r6, #0
 8020946:	d100      	bne.n	802094a <__aeabi_fsub+0x296>
 8020948:	e6ff      	b.n	802074a <__aeabi_fsub+0x96>
 802094a:	0030      	movs	r0, r6
 802094c:	4460      	add	r0, ip
 802094e:	0143      	lsls	r3, r0, #5
 8020950:	d592      	bpl.n	8020878 <__aeabi_fsub+0x1c4>
 8020952:	4b2a      	ldr	r3, [pc, #168]	; (80209fc <__aeabi_fsub+0x348>)
 8020954:	3501      	adds	r5, #1
 8020956:	4018      	ands	r0, r3
 8020958:	e78e      	b.n	8020878 <__aeabi_fsub+0x1c4>
 802095a:	4663      	mov	r3, ip
 802095c:	2b00      	cmp	r3, #0
 802095e:	d047      	beq.n	80209f0 <__aeabi_fsub+0x33c>
 8020960:	1e4b      	subs	r3, r1, #1
 8020962:	2901      	cmp	r1, #1
 8020964:	d015      	beq.n	8020992 <__aeabi_fsub+0x2de>
 8020966:	29ff      	cmp	r1, #255	; 0xff
 8020968:	d02b      	beq.n	80209c2 <__aeabi_fsub+0x30e>
 802096a:	0019      	movs	r1, r3
 802096c:	e74e      	b.n	802080c <__aeabi_fsub+0x158>
 802096e:	000c      	movs	r4, r1
 8020970:	464b      	mov	r3, r9
 8020972:	003d      	movs	r5, r7
 8020974:	e784      	b.n	8020880 <__aeabi_fsub+0x1cc>
 8020976:	4662      	mov	r2, ip
 8020978:	2a00      	cmp	r2, #0
 802097a:	d18b      	bne.n	8020894 <__aeabi_fsub+0x1e0>
 802097c:	2e00      	cmp	r6, #0
 802097e:	d192      	bne.n	80208a6 <__aeabi_fsub+0x1f2>
 8020980:	2780      	movs	r7, #128	; 0x80
 8020982:	2400      	movs	r4, #0
 8020984:	22ff      	movs	r2, #255	; 0xff
 8020986:	03ff      	lsls	r7, r7, #15
 8020988:	e6df      	b.n	802074a <__aeabi_fsub+0x96>
 802098a:	4663      	mov	r3, ip
 802098c:	000c      	movs	r4, r1
 802098e:	1af7      	subs	r7, r6, r3
 8020990:	e6bf      	b.n	8020712 <__aeabi_fsub+0x5e>
 8020992:	0030      	movs	r0, r6
 8020994:	4460      	add	r0, ip
 8020996:	2501      	movs	r5, #1
 8020998:	0143      	lsls	r3, r0, #5
 802099a:	d400      	bmi.n	802099e <__aeabi_fsub+0x2ea>
 802099c:	e76c      	b.n	8020878 <__aeabi_fsub+0x1c4>
 802099e:	2502      	movs	r5, #2
 80209a0:	e6f2      	b.n	8020788 <__aeabi_fsub+0xd4>
 80209a2:	4663      	mov	r3, ip
 80209a4:	2501      	movs	r5, #1
 80209a6:	1b98      	subs	r0, r3, r6
 80209a8:	e6ae      	b.n	8020708 <__aeabi_fsub+0x54>
 80209aa:	2320      	movs	r3, #32
 80209ac:	4664      	mov	r4, ip
 80209ae:	4660      	mov	r0, ip
 80209b0:	40fc      	lsrs	r4, r7
 80209b2:	1bdf      	subs	r7, r3, r7
 80209b4:	40b8      	lsls	r0, r7
 80209b6:	1e43      	subs	r3, r0, #1
 80209b8:	4198      	sbcs	r0, r3
 80209ba:	4320      	orrs	r0, r4
 80209bc:	e79f      	b.n	80208fe <__aeabi_fsub+0x24a>
 80209be:	0005      	movs	r5, r0
 80209c0:	e75e      	b.n	8020880 <__aeabi_fsub+0x1cc>
 80209c2:	464b      	mov	r3, r9
 80209c4:	e771      	b.n	80208aa <__aeabi_fsub+0x1f6>
 80209c6:	2320      	movs	r3, #32
 80209c8:	4665      	mov	r5, ip
 80209ca:	4660      	mov	r0, ip
 80209cc:	40cd      	lsrs	r5, r1
 80209ce:	1a59      	subs	r1, r3, r1
 80209d0:	4088      	lsls	r0, r1
 80209d2:	1e43      	subs	r3, r0, #1
 80209d4:	4198      	sbcs	r0, r3
 80209d6:	4328      	orrs	r0, r5
 80209d8:	e71c      	b.n	8020814 <__aeabi_fsub+0x160>
 80209da:	4663      	mov	r3, ip
 80209dc:	000c      	movs	r4, r1
 80209de:	2501      	movs	r5, #1
 80209e0:	1af0      	subs	r0, r6, r3
 80209e2:	e691      	b.n	8020708 <__aeabi_fsub+0x54>
 80209e4:	2e00      	cmp	r6, #0
 80209e6:	d095      	beq.n	8020914 <__aeabi_fsub+0x260>
 80209e8:	000c      	movs	r4, r1
 80209ea:	464f      	mov	r7, r9
 80209ec:	2200      	movs	r2, #0
 80209ee:	e6ac      	b.n	802074a <__aeabi_fsub+0x96>
 80209f0:	464b      	mov	r3, r9
 80209f2:	000d      	movs	r5, r1
 80209f4:	e744      	b.n	8020880 <__aeabi_fsub+0x1cc>
 80209f6:	464f      	mov	r7, r9
 80209f8:	2200      	movs	r2, #0
 80209fa:	e6a6      	b.n	802074a <__aeabi_fsub+0x96>
 80209fc:	fbffffff 	.word	0xfbffffff
 8020a00:	7dffffff 	.word	0x7dffffff
 8020a04:	2800      	cmp	r0, #0
 8020a06:	d000      	beq.n	8020a0a <__aeabi_fsub+0x356>
 8020a08:	e736      	b.n	8020878 <__aeabi_fsub+0x1c4>
 8020a0a:	2400      	movs	r4, #0
 8020a0c:	2700      	movs	r7, #0
 8020a0e:	e69c      	b.n	802074a <__aeabi_fsub+0x96>

08020a10 <__aeabi_ui2f>:
 8020a10:	b570      	push	{r4, r5, r6, lr}
 8020a12:	1e05      	subs	r5, r0, #0
 8020a14:	d00e      	beq.n	8020a34 <__aeabi_ui2f+0x24>
 8020a16:	f000 fd03 	bl	8021420 <__clzsi2>
 8020a1a:	239e      	movs	r3, #158	; 0x9e
 8020a1c:	0004      	movs	r4, r0
 8020a1e:	1a1b      	subs	r3, r3, r0
 8020a20:	2b96      	cmp	r3, #150	; 0x96
 8020a22:	dc0c      	bgt.n	8020a3e <__aeabi_ui2f+0x2e>
 8020a24:	2808      	cmp	r0, #8
 8020a26:	dd01      	ble.n	8020a2c <__aeabi_ui2f+0x1c>
 8020a28:	3c08      	subs	r4, #8
 8020a2a:	40a5      	lsls	r5, r4
 8020a2c:	026d      	lsls	r5, r5, #9
 8020a2e:	0a6d      	lsrs	r5, r5, #9
 8020a30:	b2d8      	uxtb	r0, r3
 8020a32:	e001      	b.n	8020a38 <__aeabi_ui2f+0x28>
 8020a34:	2000      	movs	r0, #0
 8020a36:	2500      	movs	r5, #0
 8020a38:	05c0      	lsls	r0, r0, #23
 8020a3a:	4328      	orrs	r0, r5
 8020a3c:	bd70      	pop	{r4, r5, r6, pc}
 8020a3e:	2b99      	cmp	r3, #153	; 0x99
 8020a40:	dd09      	ble.n	8020a56 <__aeabi_ui2f+0x46>
 8020a42:	0002      	movs	r2, r0
 8020a44:	0029      	movs	r1, r5
 8020a46:	321b      	adds	r2, #27
 8020a48:	4091      	lsls	r1, r2
 8020a4a:	1e4a      	subs	r2, r1, #1
 8020a4c:	4191      	sbcs	r1, r2
 8020a4e:	2205      	movs	r2, #5
 8020a50:	1a12      	subs	r2, r2, r0
 8020a52:	40d5      	lsrs	r5, r2
 8020a54:	430d      	orrs	r5, r1
 8020a56:	2c05      	cmp	r4, #5
 8020a58:	dc12      	bgt.n	8020a80 <__aeabi_ui2f+0x70>
 8020a5a:	0029      	movs	r1, r5
 8020a5c:	4e0c      	ldr	r6, [pc, #48]	; (8020a90 <__aeabi_ui2f+0x80>)
 8020a5e:	4031      	ands	r1, r6
 8020a60:	076a      	lsls	r2, r5, #29
 8020a62:	d009      	beq.n	8020a78 <__aeabi_ui2f+0x68>
 8020a64:	200f      	movs	r0, #15
 8020a66:	4028      	ands	r0, r5
 8020a68:	2804      	cmp	r0, #4
 8020a6a:	d005      	beq.n	8020a78 <__aeabi_ui2f+0x68>
 8020a6c:	3104      	adds	r1, #4
 8020a6e:	014a      	lsls	r2, r1, #5
 8020a70:	d502      	bpl.n	8020a78 <__aeabi_ui2f+0x68>
 8020a72:	239f      	movs	r3, #159	; 0x9f
 8020a74:	4031      	ands	r1, r6
 8020a76:	1b1b      	subs	r3, r3, r4
 8020a78:	0189      	lsls	r1, r1, #6
 8020a7a:	0a4d      	lsrs	r5, r1, #9
 8020a7c:	b2d8      	uxtb	r0, r3
 8020a7e:	e7db      	b.n	8020a38 <__aeabi_ui2f+0x28>
 8020a80:	1f62      	subs	r2, r4, #5
 8020a82:	4095      	lsls	r5, r2
 8020a84:	0029      	movs	r1, r5
 8020a86:	4e02      	ldr	r6, [pc, #8]	; (8020a90 <__aeabi_ui2f+0x80>)
 8020a88:	4031      	ands	r1, r6
 8020a8a:	076a      	lsls	r2, r5, #29
 8020a8c:	d0f4      	beq.n	8020a78 <__aeabi_ui2f+0x68>
 8020a8e:	e7e9      	b.n	8020a64 <__aeabi_ui2f+0x54>
 8020a90:	fbffffff 	.word	0xfbffffff

08020a94 <__aeabi_dadd>:
 8020a94:	b5f0      	push	{r4, r5, r6, r7, lr}
 8020a96:	464f      	mov	r7, r9
 8020a98:	4646      	mov	r6, r8
 8020a9a:	46d6      	mov	lr, sl
 8020a9c:	000d      	movs	r5, r1
 8020a9e:	0004      	movs	r4, r0
 8020aa0:	b5c0      	push	{r6, r7, lr}
 8020aa2:	001f      	movs	r7, r3
 8020aa4:	0011      	movs	r1, r2
 8020aa6:	0328      	lsls	r0, r5, #12
 8020aa8:	0f62      	lsrs	r2, r4, #29
 8020aaa:	0a40      	lsrs	r0, r0, #9
 8020aac:	4310      	orrs	r0, r2
 8020aae:	007a      	lsls	r2, r7, #1
 8020ab0:	0d52      	lsrs	r2, r2, #21
 8020ab2:	00e3      	lsls	r3, r4, #3
 8020ab4:	033c      	lsls	r4, r7, #12
 8020ab6:	4691      	mov	r9, r2
 8020ab8:	0a64      	lsrs	r4, r4, #9
 8020aba:	0ffa      	lsrs	r2, r7, #31
 8020abc:	0f4f      	lsrs	r7, r1, #29
 8020abe:	006e      	lsls	r6, r5, #1
 8020ac0:	4327      	orrs	r7, r4
 8020ac2:	4692      	mov	sl, r2
 8020ac4:	46b8      	mov	r8, r7
 8020ac6:	0d76      	lsrs	r6, r6, #21
 8020ac8:	0fed      	lsrs	r5, r5, #31
 8020aca:	00c9      	lsls	r1, r1, #3
 8020acc:	4295      	cmp	r5, r2
 8020ace:	d100      	bne.n	8020ad2 <__aeabi_dadd+0x3e>
 8020ad0:	e099      	b.n	8020c06 <__aeabi_dadd+0x172>
 8020ad2:	464c      	mov	r4, r9
 8020ad4:	1b34      	subs	r4, r6, r4
 8020ad6:	46a4      	mov	ip, r4
 8020ad8:	2c00      	cmp	r4, #0
 8020ada:	dc00      	bgt.n	8020ade <__aeabi_dadd+0x4a>
 8020adc:	e07c      	b.n	8020bd8 <__aeabi_dadd+0x144>
 8020ade:	464a      	mov	r2, r9
 8020ae0:	2a00      	cmp	r2, #0
 8020ae2:	d100      	bne.n	8020ae6 <__aeabi_dadd+0x52>
 8020ae4:	e0b8      	b.n	8020c58 <__aeabi_dadd+0x1c4>
 8020ae6:	4ac5      	ldr	r2, [pc, #788]	; (8020dfc <__aeabi_dadd+0x368>)
 8020ae8:	4296      	cmp	r6, r2
 8020aea:	d100      	bne.n	8020aee <__aeabi_dadd+0x5a>
 8020aec:	e11c      	b.n	8020d28 <__aeabi_dadd+0x294>
 8020aee:	2280      	movs	r2, #128	; 0x80
 8020af0:	003c      	movs	r4, r7
 8020af2:	0412      	lsls	r2, r2, #16
 8020af4:	4314      	orrs	r4, r2
 8020af6:	46a0      	mov	r8, r4
 8020af8:	4662      	mov	r2, ip
 8020afa:	2a38      	cmp	r2, #56	; 0x38
 8020afc:	dd00      	ble.n	8020b00 <__aeabi_dadd+0x6c>
 8020afe:	e161      	b.n	8020dc4 <__aeabi_dadd+0x330>
 8020b00:	2a1f      	cmp	r2, #31
 8020b02:	dd00      	ble.n	8020b06 <__aeabi_dadd+0x72>
 8020b04:	e1cc      	b.n	8020ea0 <__aeabi_dadd+0x40c>
 8020b06:	4664      	mov	r4, ip
 8020b08:	2220      	movs	r2, #32
 8020b0a:	1b12      	subs	r2, r2, r4
 8020b0c:	4644      	mov	r4, r8
 8020b0e:	4094      	lsls	r4, r2
 8020b10:	000f      	movs	r7, r1
 8020b12:	46a1      	mov	r9, r4
 8020b14:	4664      	mov	r4, ip
 8020b16:	4091      	lsls	r1, r2
 8020b18:	40e7      	lsrs	r7, r4
 8020b1a:	464c      	mov	r4, r9
 8020b1c:	1e4a      	subs	r2, r1, #1
 8020b1e:	4191      	sbcs	r1, r2
 8020b20:	433c      	orrs	r4, r7
 8020b22:	4642      	mov	r2, r8
 8020b24:	4321      	orrs	r1, r4
 8020b26:	4664      	mov	r4, ip
 8020b28:	40e2      	lsrs	r2, r4
 8020b2a:	1a80      	subs	r0, r0, r2
 8020b2c:	1a5c      	subs	r4, r3, r1
 8020b2e:	42a3      	cmp	r3, r4
 8020b30:	419b      	sbcs	r3, r3
 8020b32:	425f      	negs	r7, r3
 8020b34:	1bc7      	subs	r7, r0, r7
 8020b36:	023b      	lsls	r3, r7, #8
 8020b38:	d400      	bmi.n	8020b3c <__aeabi_dadd+0xa8>
 8020b3a:	e0d0      	b.n	8020cde <__aeabi_dadd+0x24a>
 8020b3c:	027f      	lsls	r7, r7, #9
 8020b3e:	0a7f      	lsrs	r7, r7, #9
 8020b40:	2f00      	cmp	r7, #0
 8020b42:	d100      	bne.n	8020b46 <__aeabi_dadd+0xb2>
 8020b44:	e0ff      	b.n	8020d46 <__aeabi_dadd+0x2b2>
 8020b46:	0038      	movs	r0, r7
 8020b48:	f000 fc6a 	bl	8021420 <__clzsi2>
 8020b4c:	0001      	movs	r1, r0
 8020b4e:	3908      	subs	r1, #8
 8020b50:	2320      	movs	r3, #32
 8020b52:	0022      	movs	r2, r4
 8020b54:	1a5b      	subs	r3, r3, r1
 8020b56:	408f      	lsls	r7, r1
 8020b58:	40da      	lsrs	r2, r3
 8020b5a:	408c      	lsls	r4, r1
 8020b5c:	4317      	orrs	r7, r2
 8020b5e:	42b1      	cmp	r1, r6
 8020b60:	da00      	bge.n	8020b64 <__aeabi_dadd+0xd0>
 8020b62:	e0ff      	b.n	8020d64 <__aeabi_dadd+0x2d0>
 8020b64:	1b89      	subs	r1, r1, r6
 8020b66:	1c4b      	adds	r3, r1, #1
 8020b68:	2b1f      	cmp	r3, #31
 8020b6a:	dd00      	ble.n	8020b6e <__aeabi_dadd+0xda>
 8020b6c:	e0a8      	b.n	8020cc0 <__aeabi_dadd+0x22c>
 8020b6e:	2220      	movs	r2, #32
 8020b70:	0039      	movs	r1, r7
 8020b72:	1ad2      	subs	r2, r2, r3
 8020b74:	0020      	movs	r0, r4
 8020b76:	4094      	lsls	r4, r2
 8020b78:	4091      	lsls	r1, r2
 8020b7a:	40d8      	lsrs	r0, r3
 8020b7c:	1e62      	subs	r2, r4, #1
 8020b7e:	4194      	sbcs	r4, r2
 8020b80:	40df      	lsrs	r7, r3
 8020b82:	2600      	movs	r6, #0
 8020b84:	4301      	orrs	r1, r0
 8020b86:	430c      	orrs	r4, r1
 8020b88:	0763      	lsls	r3, r4, #29
 8020b8a:	d009      	beq.n	8020ba0 <__aeabi_dadd+0x10c>
 8020b8c:	230f      	movs	r3, #15
 8020b8e:	4023      	ands	r3, r4
 8020b90:	2b04      	cmp	r3, #4
 8020b92:	d005      	beq.n	8020ba0 <__aeabi_dadd+0x10c>
 8020b94:	1d23      	adds	r3, r4, #4
 8020b96:	42a3      	cmp	r3, r4
 8020b98:	41a4      	sbcs	r4, r4
 8020b9a:	4264      	negs	r4, r4
 8020b9c:	193f      	adds	r7, r7, r4
 8020b9e:	001c      	movs	r4, r3
 8020ba0:	023b      	lsls	r3, r7, #8
 8020ba2:	d400      	bmi.n	8020ba6 <__aeabi_dadd+0x112>
 8020ba4:	e09e      	b.n	8020ce4 <__aeabi_dadd+0x250>
 8020ba6:	4b95      	ldr	r3, [pc, #596]	; (8020dfc <__aeabi_dadd+0x368>)
 8020ba8:	3601      	adds	r6, #1
 8020baa:	429e      	cmp	r6, r3
 8020bac:	d100      	bne.n	8020bb0 <__aeabi_dadd+0x11c>
 8020bae:	e0b7      	b.n	8020d20 <__aeabi_dadd+0x28c>
 8020bb0:	4a93      	ldr	r2, [pc, #588]	; (8020e00 <__aeabi_dadd+0x36c>)
 8020bb2:	08e4      	lsrs	r4, r4, #3
 8020bb4:	4017      	ands	r7, r2
 8020bb6:	077b      	lsls	r3, r7, #29
 8020bb8:	0571      	lsls	r1, r6, #21
 8020bba:	027f      	lsls	r7, r7, #9
 8020bbc:	4323      	orrs	r3, r4
 8020bbe:	0b3f      	lsrs	r7, r7, #12
 8020bc0:	0d4a      	lsrs	r2, r1, #21
 8020bc2:	0512      	lsls	r2, r2, #20
 8020bc4:	433a      	orrs	r2, r7
 8020bc6:	07ed      	lsls	r5, r5, #31
 8020bc8:	432a      	orrs	r2, r5
 8020bca:	0018      	movs	r0, r3
 8020bcc:	0011      	movs	r1, r2
 8020bce:	bce0      	pop	{r5, r6, r7}
 8020bd0:	46ba      	mov	sl, r7
 8020bd2:	46b1      	mov	r9, r6
 8020bd4:	46a8      	mov	r8, r5
 8020bd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8020bd8:	2c00      	cmp	r4, #0
 8020bda:	d04b      	beq.n	8020c74 <__aeabi_dadd+0x1e0>
 8020bdc:	464c      	mov	r4, r9
 8020bde:	1ba4      	subs	r4, r4, r6
 8020be0:	46a4      	mov	ip, r4
 8020be2:	2e00      	cmp	r6, #0
 8020be4:	d000      	beq.n	8020be8 <__aeabi_dadd+0x154>
 8020be6:	e123      	b.n	8020e30 <__aeabi_dadd+0x39c>
 8020be8:	0004      	movs	r4, r0
 8020bea:	431c      	orrs	r4, r3
 8020bec:	d100      	bne.n	8020bf0 <__aeabi_dadd+0x15c>
 8020bee:	e1af      	b.n	8020f50 <__aeabi_dadd+0x4bc>
 8020bf0:	4662      	mov	r2, ip
 8020bf2:	1e54      	subs	r4, r2, #1
 8020bf4:	2a01      	cmp	r2, #1
 8020bf6:	d100      	bne.n	8020bfa <__aeabi_dadd+0x166>
 8020bf8:	e215      	b.n	8021026 <__aeabi_dadd+0x592>
 8020bfa:	4d80      	ldr	r5, [pc, #512]	; (8020dfc <__aeabi_dadd+0x368>)
 8020bfc:	45ac      	cmp	ip, r5
 8020bfe:	d100      	bne.n	8020c02 <__aeabi_dadd+0x16e>
 8020c00:	e1c8      	b.n	8020f94 <__aeabi_dadd+0x500>
 8020c02:	46a4      	mov	ip, r4
 8020c04:	e11b      	b.n	8020e3e <__aeabi_dadd+0x3aa>
 8020c06:	464a      	mov	r2, r9
 8020c08:	1ab2      	subs	r2, r6, r2
 8020c0a:	4694      	mov	ip, r2
 8020c0c:	2a00      	cmp	r2, #0
 8020c0e:	dc00      	bgt.n	8020c12 <__aeabi_dadd+0x17e>
 8020c10:	e0ac      	b.n	8020d6c <__aeabi_dadd+0x2d8>
 8020c12:	464a      	mov	r2, r9
 8020c14:	2a00      	cmp	r2, #0
 8020c16:	d043      	beq.n	8020ca0 <__aeabi_dadd+0x20c>
 8020c18:	4a78      	ldr	r2, [pc, #480]	; (8020dfc <__aeabi_dadd+0x368>)
 8020c1a:	4296      	cmp	r6, r2
 8020c1c:	d100      	bne.n	8020c20 <__aeabi_dadd+0x18c>
 8020c1e:	e1af      	b.n	8020f80 <__aeabi_dadd+0x4ec>
 8020c20:	2280      	movs	r2, #128	; 0x80
 8020c22:	003c      	movs	r4, r7
 8020c24:	0412      	lsls	r2, r2, #16
 8020c26:	4314      	orrs	r4, r2
 8020c28:	46a0      	mov	r8, r4
 8020c2a:	4662      	mov	r2, ip
 8020c2c:	2a38      	cmp	r2, #56	; 0x38
 8020c2e:	dc67      	bgt.n	8020d00 <__aeabi_dadd+0x26c>
 8020c30:	2a1f      	cmp	r2, #31
 8020c32:	dc00      	bgt.n	8020c36 <__aeabi_dadd+0x1a2>
 8020c34:	e15f      	b.n	8020ef6 <__aeabi_dadd+0x462>
 8020c36:	4647      	mov	r7, r8
 8020c38:	3a20      	subs	r2, #32
 8020c3a:	40d7      	lsrs	r7, r2
 8020c3c:	4662      	mov	r2, ip
 8020c3e:	2a20      	cmp	r2, #32
 8020c40:	d005      	beq.n	8020c4e <__aeabi_dadd+0x1ba>
 8020c42:	4664      	mov	r4, ip
 8020c44:	2240      	movs	r2, #64	; 0x40
 8020c46:	1b12      	subs	r2, r2, r4
 8020c48:	4644      	mov	r4, r8
 8020c4a:	4094      	lsls	r4, r2
 8020c4c:	4321      	orrs	r1, r4
 8020c4e:	1e4a      	subs	r2, r1, #1
 8020c50:	4191      	sbcs	r1, r2
 8020c52:	000c      	movs	r4, r1
 8020c54:	433c      	orrs	r4, r7
 8020c56:	e057      	b.n	8020d08 <__aeabi_dadd+0x274>
 8020c58:	003a      	movs	r2, r7
 8020c5a:	430a      	orrs	r2, r1
 8020c5c:	d100      	bne.n	8020c60 <__aeabi_dadd+0x1cc>
 8020c5e:	e105      	b.n	8020e6c <__aeabi_dadd+0x3d8>
 8020c60:	0022      	movs	r2, r4
 8020c62:	3a01      	subs	r2, #1
 8020c64:	2c01      	cmp	r4, #1
 8020c66:	d100      	bne.n	8020c6a <__aeabi_dadd+0x1d6>
 8020c68:	e182      	b.n	8020f70 <__aeabi_dadd+0x4dc>
 8020c6a:	4c64      	ldr	r4, [pc, #400]	; (8020dfc <__aeabi_dadd+0x368>)
 8020c6c:	45a4      	cmp	ip, r4
 8020c6e:	d05b      	beq.n	8020d28 <__aeabi_dadd+0x294>
 8020c70:	4694      	mov	ip, r2
 8020c72:	e741      	b.n	8020af8 <__aeabi_dadd+0x64>
 8020c74:	4c63      	ldr	r4, [pc, #396]	; (8020e04 <__aeabi_dadd+0x370>)
 8020c76:	1c77      	adds	r7, r6, #1
 8020c78:	4227      	tst	r7, r4
 8020c7a:	d000      	beq.n	8020c7e <__aeabi_dadd+0x1ea>
 8020c7c:	e0c4      	b.n	8020e08 <__aeabi_dadd+0x374>
 8020c7e:	0004      	movs	r4, r0
 8020c80:	431c      	orrs	r4, r3
 8020c82:	2e00      	cmp	r6, #0
 8020c84:	d000      	beq.n	8020c88 <__aeabi_dadd+0x1f4>
 8020c86:	e169      	b.n	8020f5c <__aeabi_dadd+0x4c8>
 8020c88:	2c00      	cmp	r4, #0
 8020c8a:	d100      	bne.n	8020c8e <__aeabi_dadd+0x1fa>
 8020c8c:	e1bf      	b.n	802100e <__aeabi_dadd+0x57a>
 8020c8e:	4644      	mov	r4, r8
 8020c90:	430c      	orrs	r4, r1
 8020c92:	d000      	beq.n	8020c96 <__aeabi_dadd+0x202>
 8020c94:	e1d0      	b.n	8021038 <__aeabi_dadd+0x5a4>
 8020c96:	0742      	lsls	r2, r0, #29
 8020c98:	08db      	lsrs	r3, r3, #3
 8020c9a:	4313      	orrs	r3, r2
 8020c9c:	08c0      	lsrs	r0, r0, #3
 8020c9e:	e029      	b.n	8020cf4 <__aeabi_dadd+0x260>
 8020ca0:	003a      	movs	r2, r7
 8020ca2:	430a      	orrs	r2, r1
 8020ca4:	d100      	bne.n	8020ca8 <__aeabi_dadd+0x214>
 8020ca6:	e170      	b.n	8020f8a <__aeabi_dadd+0x4f6>
 8020ca8:	4662      	mov	r2, ip
 8020caa:	4664      	mov	r4, ip
 8020cac:	3a01      	subs	r2, #1
 8020cae:	2c01      	cmp	r4, #1
 8020cb0:	d100      	bne.n	8020cb4 <__aeabi_dadd+0x220>
 8020cb2:	e0e0      	b.n	8020e76 <__aeabi_dadd+0x3e2>
 8020cb4:	4c51      	ldr	r4, [pc, #324]	; (8020dfc <__aeabi_dadd+0x368>)
 8020cb6:	45a4      	cmp	ip, r4
 8020cb8:	d100      	bne.n	8020cbc <__aeabi_dadd+0x228>
 8020cba:	e161      	b.n	8020f80 <__aeabi_dadd+0x4ec>
 8020cbc:	4694      	mov	ip, r2
 8020cbe:	e7b4      	b.n	8020c2a <__aeabi_dadd+0x196>
 8020cc0:	003a      	movs	r2, r7
 8020cc2:	391f      	subs	r1, #31
 8020cc4:	40ca      	lsrs	r2, r1
 8020cc6:	0011      	movs	r1, r2
 8020cc8:	2b20      	cmp	r3, #32
 8020cca:	d003      	beq.n	8020cd4 <__aeabi_dadd+0x240>
 8020ccc:	2240      	movs	r2, #64	; 0x40
 8020cce:	1ad3      	subs	r3, r2, r3
 8020cd0:	409f      	lsls	r7, r3
 8020cd2:	433c      	orrs	r4, r7
 8020cd4:	1e63      	subs	r3, r4, #1
 8020cd6:	419c      	sbcs	r4, r3
 8020cd8:	2700      	movs	r7, #0
 8020cda:	2600      	movs	r6, #0
 8020cdc:	430c      	orrs	r4, r1
 8020cde:	0763      	lsls	r3, r4, #29
 8020ce0:	d000      	beq.n	8020ce4 <__aeabi_dadd+0x250>
 8020ce2:	e753      	b.n	8020b8c <__aeabi_dadd+0xf8>
 8020ce4:	46b4      	mov	ip, r6
 8020ce6:	08e4      	lsrs	r4, r4, #3
 8020ce8:	077b      	lsls	r3, r7, #29
 8020cea:	4323      	orrs	r3, r4
 8020cec:	08f8      	lsrs	r0, r7, #3
 8020cee:	4a43      	ldr	r2, [pc, #268]	; (8020dfc <__aeabi_dadd+0x368>)
 8020cf0:	4594      	cmp	ip, r2
 8020cf2:	d01d      	beq.n	8020d30 <__aeabi_dadd+0x29c>
 8020cf4:	4662      	mov	r2, ip
 8020cf6:	0307      	lsls	r7, r0, #12
 8020cf8:	0552      	lsls	r2, r2, #21
 8020cfa:	0b3f      	lsrs	r7, r7, #12
 8020cfc:	0d52      	lsrs	r2, r2, #21
 8020cfe:	e760      	b.n	8020bc2 <__aeabi_dadd+0x12e>
 8020d00:	4644      	mov	r4, r8
 8020d02:	430c      	orrs	r4, r1
 8020d04:	1e62      	subs	r2, r4, #1
 8020d06:	4194      	sbcs	r4, r2
 8020d08:	18e4      	adds	r4, r4, r3
 8020d0a:	429c      	cmp	r4, r3
 8020d0c:	419b      	sbcs	r3, r3
 8020d0e:	425f      	negs	r7, r3
 8020d10:	183f      	adds	r7, r7, r0
 8020d12:	023b      	lsls	r3, r7, #8
 8020d14:	d5e3      	bpl.n	8020cde <__aeabi_dadd+0x24a>
 8020d16:	4b39      	ldr	r3, [pc, #228]	; (8020dfc <__aeabi_dadd+0x368>)
 8020d18:	3601      	adds	r6, #1
 8020d1a:	429e      	cmp	r6, r3
 8020d1c:	d000      	beq.n	8020d20 <__aeabi_dadd+0x28c>
 8020d1e:	e0b5      	b.n	8020e8c <__aeabi_dadd+0x3f8>
 8020d20:	0032      	movs	r2, r6
 8020d22:	2700      	movs	r7, #0
 8020d24:	2300      	movs	r3, #0
 8020d26:	e74c      	b.n	8020bc2 <__aeabi_dadd+0x12e>
 8020d28:	0742      	lsls	r2, r0, #29
 8020d2a:	08db      	lsrs	r3, r3, #3
 8020d2c:	4313      	orrs	r3, r2
 8020d2e:	08c0      	lsrs	r0, r0, #3
 8020d30:	001a      	movs	r2, r3
 8020d32:	4302      	orrs	r2, r0
 8020d34:	d100      	bne.n	8020d38 <__aeabi_dadd+0x2a4>
 8020d36:	e1e1      	b.n	80210fc <__aeabi_dadd+0x668>
 8020d38:	2780      	movs	r7, #128	; 0x80
 8020d3a:	033f      	lsls	r7, r7, #12
 8020d3c:	4307      	orrs	r7, r0
 8020d3e:	033f      	lsls	r7, r7, #12
 8020d40:	4a2e      	ldr	r2, [pc, #184]	; (8020dfc <__aeabi_dadd+0x368>)
 8020d42:	0b3f      	lsrs	r7, r7, #12
 8020d44:	e73d      	b.n	8020bc2 <__aeabi_dadd+0x12e>
 8020d46:	0020      	movs	r0, r4
 8020d48:	f000 fb6a 	bl	8021420 <__clzsi2>
 8020d4c:	0001      	movs	r1, r0
 8020d4e:	3118      	adds	r1, #24
 8020d50:	291f      	cmp	r1, #31
 8020d52:	dc00      	bgt.n	8020d56 <__aeabi_dadd+0x2c2>
 8020d54:	e6fc      	b.n	8020b50 <__aeabi_dadd+0xbc>
 8020d56:	3808      	subs	r0, #8
 8020d58:	4084      	lsls	r4, r0
 8020d5a:	0027      	movs	r7, r4
 8020d5c:	2400      	movs	r4, #0
 8020d5e:	42b1      	cmp	r1, r6
 8020d60:	db00      	blt.n	8020d64 <__aeabi_dadd+0x2d0>
 8020d62:	e6ff      	b.n	8020b64 <__aeabi_dadd+0xd0>
 8020d64:	4a26      	ldr	r2, [pc, #152]	; (8020e00 <__aeabi_dadd+0x36c>)
 8020d66:	1a76      	subs	r6, r6, r1
 8020d68:	4017      	ands	r7, r2
 8020d6a:	e70d      	b.n	8020b88 <__aeabi_dadd+0xf4>
 8020d6c:	2a00      	cmp	r2, #0
 8020d6e:	d02f      	beq.n	8020dd0 <__aeabi_dadd+0x33c>
 8020d70:	464a      	mov	r2, r9
 8020d72:	1b92      	subs	r2, r2, r6
 8020d74:	4694      	mov	ip, r2
 8020d76:	2e00      	cmp	r6, #0
 8020d78:	d100      	bne.n	8020d7c <__aeabi_dadd+0x2e8>
 8020d7a:	e0ad      	b.n	8020ed8 <__aeabi_dadd+0x444>
 8020d7c:	4a1f      	ldr	r2, [pc, #124]	; (8020dfc <__aeabi_dadd+0x368>)
 8020d7e:	4591      	cmp	r9, r2
 8020d80:	d100      	bne.n	8020d84 <__aeabi_dadd+0x2f0>
 8020d82:	e10f      	b.n	8020fa4 <__aeabi_dadd+0x510>
 8020d84:	2280      	movs	r2, #128	; 0x80
 8020d86:	0412      	lsls	r2, r2, #16
 8020d88:	4310      	orrs	r0, r2
 8020d8a:	4662      	mov	r2, ip
 8020d8c:	2a38      	cmp	r2, #56	; 0x38
 8020d8e:	dd00      	ble.n	8020d92 <__aeabi_dadd+0x2fe>
 8020d90:	e10f      	b.n	8020fb2 <__aeabi_dadd+0x51e>
 8020d92:	2a1f      	cmp	r2, #31
 8020d94:	dd00      	ble.n	8020d98 <__aeabi_dadd+0x304>
 8020d96:	e180      	b.n	802109a <__aeabi_dadd+0x606>
 8020d98:	4664      	mov	r4, ip
 8020d9a:	2220      	movs	r2, #32
 8020d9c:	001e      	movs	r6, r3
 8020d9e:	1b12      	subs	r2, r2, r4
 8020da0:	4667      	mov	r7, ip
 8020da2:	0004      	movs	r4, r0
 8020da4:	4093      	lsls	r3, r2
 8020da6:	4094      	lsls	r4, r2
 8020da8:	40fe      	lsrs	r6, r7
 8020daa:	1e5a      	subs	r2, r3, #1
 8020dac:	4193      	sbcs	r3, r2
 8020dae:	40f8      	lsrs	r0, r7
 8020db0:	4334      	orrs	r4, r6
 8020db2:	431c      	orrs	r4, r3
 8020db4:	4480      	add	r8, r0
 8020db6:	1864      	adds	r4, r4, r1
 8020db8:	428c      	cmp	r4, r1
 8020dba:	41bf      	sbcs	r7, r7
 8020dbc:	427f      	negs	r7, r7
 8020dbe:	464e      	mov	r6, r9
 8020dc0:	4447      	add	r7, r8
 8020dc2:	e7a6      	b.n	8020d12 <__aeabi_dadd+0x27e>
 8020dc4:	4642      	mov	r2, r8
 8020dc6:	430a      	orrs	r2, r1
 8020dc8:	0011      	movs	r1, r2
 8020dca:	1e4a      	subs	r2, r1, #1
 8020dcc:	4191      	sbcs	r1, r2
 8020dce:	e6ad      	b.n	8020b2c <__aeabi_dadd+0x98>
 8020dd0:	4c0c      	ldr	r4, [pc, #48]	; (8020e04 <__aeabi_dadd+0x370>)
 8020dd2:	1c72      	adds	r2, r6, #1
 8020dd4:	4222      	tst	r2, r4
 8020dd6:	d000      	beq.n	8020dda <__aeabi_dadd+0x346>
 8020dd8:	e0a1      	b.n	8020f1e <__aeabi_dadd+0x48a>
 8020dda:	0002      	movs	r2, r0
 8020ddc:	431a      	orrs	r2, r3
 8020dde:	2e00      	cmp	r6, #0
 8020de0:	d000      	beq.n	8020de4 <__aeabi_dadd+0x350>
 8020de2:	e0fa      	b.n	8020fda <__aeabi_dadd+0x546>
 8020de4:	2a00      	cmp	r2, #0
 8020de6:	d100      	bne.n	8020dea <__aeabi_dadd+0x356>
 8020de8:	e145      	b.n	8021076 <__aeabi_dadd+0x5e2>
 8020dea:	003a      	movs	r2, r7
 8020dec:	430a      	orrs	r2, r1
 8020dee:	d000      	beq.n	8020df2 <__aeabi_dadd+0x35e>
 8020df0:	e146      	b.n	8021080 <__aeabi_dadd+0x5ec>
 8020df2:	0742      	lsls	r2, r0, #29
 8020df4:	08db      	lsrs	r3, r3, #3
 8020df6:	4313      	orrs	r3, r2
 8020df8:	08c0      	lsrs	r0, r0, #3
 8020dfa:	e77b      	b.n	8020cf4 <__aeabi_dadd+0x260>
 8020dfc:	000007ff 	.word	0x000007ff
 8020e00:	ff7fffff 	.word	0xff7fffff
 8020e04:	000007fe 	.word	0x000007fe
 8020e08:	4647      	mov	r7, r8
 8020e0a:	1a5c      	subs	r4, r3, r1
 8020e0c:	1bc2      	subs	r2, r0, r7
 8020e0e:	42a3      	cmp	r3, r4
 8020e10:	41bf      	sbcs	r7, r7
 8020e12:	427f      	negs	r7, r7
 8020e14:	46b9      	mov	r9, r7
 8020e16:	0017      	movs	r7, r2
 8020e18:	464a      	mov	r2, r9
 8020e1a:	1abf      	subs	r7, r7, r2
 8020e1c:	023a      	lsls	r2, r7, #8
 8020e1e:	d500      	bpl.n	8020e22 <__aeabi_dadd+0x38e>
 8020e20:	e08d      	b.n	8020f3e <__aeabi_dadd+0x4aa>
 8020e22:	0023      	movs	r3, r4
 8020e24:	433b      	orrs	r3, r7
 8020e26:	d000      	beq.n	8020e2a <__aeabi_dadd+0x396>
 8020e28:	e68a      	b.n	8020b40 <__aeabi_dadd+0xac>
 8020e2a:	2000      	movs	r0, #0
 8020e2c:	2500      	movs	r5, #0
 8020e2e:	e761      	b.n	8020cf4 <__aeabi_dadd+0x260>
 8020e30:	4cb4      	ldr	r4, [pc, #720]	; (8021104 <__aeabi_dadd+0x670>)
 8020e32:	45a1      	cmp	r9, r4
 8020e34:	d100      	bne.n	8020e38 <__aeabi_dadd+0x3a4>
 8020e36:	e0ad      	b.n	8020f94 <__aeabi_dadd+0x500>
 8020e38:	2480      	movs	r4, #128	; 0x80
 8020e3a:	0424      	lsls	r4, r4, #16
 8020e3c:	4320      	orrs	r0, r4
 8020e3e:	4664      	mov	r4, ip
 8020e40:	2c38      	cmp	r4, #56	; 0x38
 8020e42:	dc3d      	bgt.n	8020ec0 <__aeabi_dadd+0x42c>
 8020e44:	4662      	mov	r2, ip
 8020e46:	2c1f      	cmp	r4, #31
 8020e48:	dd00      	ble.n	8020e4c <__aeabi_dadd+0x3b8>
 8020e4a:	e0b7      	b.n	8020fbc <__aeabi_dadd+0x528>
 8020e4c:	2520      	movs	r5, #32
 8020e4e:	001e      	movs	r6, r3
 8020e50:	1b2d      	subs	r5, r5, r4
 8020e52:	0004      	movs	r4, r0
 8020e54:	40ab      	lsls	r3, r5
 8020e56:	40ac      	lsls	r4, r5
 8020e58:	40d6      	lsrs	r6, r2
 8020e5a:	40d0      	lsrs	r0, r2
 8020e5c:	4642      	mov	r2, r8
 8020e5e:	1e5d      	subs	r5, r3, #1
 8020e60:	41ab      	sbcs	r3, r5
 8020e62:	4334      	orrs	r4, r6
 8020e64:	1a12      	subs	r2, r2, r0
 8020e66:	4690      	mov	r8, r2
 8020e68:	4323      	orrs	r3, r4
 8020e6a:	e02c      	b.n	8020ec6 <__aeabi_dadd+0x432>
 8020e6c:	0742      	lsls	r2, r0, #29
 8020e6e:	08db      	lsrs	r3, r3, #3
 8020e70:	4313      	orrs	r3, r2
 8020e72:	08c0      	lsrs	r0, r0, #3
 8020e74:	e73b      	b.n	8020cee <__aeabi_dadd+0x25a>
 8020e76:	185c      	adds	r4, r3, r1
 8020e78:	429c      	cmp	r4, r3
 8020e7a:	419b      	sbcs	r3, r3
 8020e7c:	4440      	add	r0, r8
 8020e7e:	425b      	negs	r3, r3
 8020e80:	18c7      	adds	r7, r0, r3
 8020e82:	2601      	movs	r6, #1
 8020e84:	023b      	lsls	r3, r7, #8
 8020e86:	d400      	bmi.n	8020e8a <__aeabi_dadd+0x3f6>
 8020e88:	e729      	b.n	8020cde <__aeabi_dadd+0x24a>
 8020e8a:	2602      	movs	r6, #2
 8020e8c:	4a9e      	ldr	r2, [pc, #632]	; (8021108 <__aeabi_dadd+0x674>)
 8020e8e:	0863      	lsrs	r3, r4, #1
 8020e90:	4017      	ands	r7, r2
 8020e92:	2201      	movs	r2, #1
 8020e94:	4014      	ands	r4, r2
 8020e96:	431c      	orrs	r4, r3
 8020e98:	07fb      	lsls	r3, r7, #31
 8020e9a:	431c      	orrs	r4, r3
 8020e9c:	087f      	lsrs	r7, r7, #1
 8020e9e:	e673      	b.n	8020b88 <__aeabi_dadd+0xf4>
 8020ea0:	4644      	mov	r4, r8
 8020ea2:	3a20      	subs	r2, #32
 8020ea4:	40d4      	lsrs	r4, r2
 8020ea6:	4662      	mov	r2, ip
 8020ea8:	2a20      	cmp	r2, #32
 8020eaa:	d005      	beq.n	8020eb8 <__aeabi_dadd+0x424>
 8020eac:	4667      	mov	r7, ip
 8020eae:	2240      	movs	r2, #64	; 0x40
 8020eb0:	1bd2      	subs	r2, r2, r7
 8020eb2:	4647      	mov	r7, r8
 8020eb4:	4097      	lsls	r7, r2
 8020eb6:	4339      	orrs	r1, r7
 8020eb8:	1e4a      	subs	r2, r1, #1
 8020eba:	4191      	sbcs	r1, r2
 8020ebc:	4321      	orrs	r1, r4
 8020ebe:	e635      	b.n	8020b2c <__aeabi_dadd+0x98>
 8020ec0:	4303      	orrs	r3, r0
 8020ec2:	1e58      	subs	r0, r3, #1
 8020ec4:	4183      	sbcs	r3, r0
 8020ec6:	1acc      	subs	r4, r1, r3
 8020ec8:	42a1      	cmp	r1, r4
 8020eca:	41bf      	sbcs	r7, r7
 8020ecc:	4643      	mov	r3, r8
 8020ece:	427f      	negs	r7, r7
 8020ed0:	4655      	mov	r5, sl
 8020ed2:	464e      	mov	r6, r9
 8020ed4:	1bdf      	subs	r7, r3, r7
 8020ed6:	e62e      	b.n	8020b36 <__aeabi_dadd+0xa2>
 8020ed8:	0002      	movs	r2, r0
 8020eda:	431a      	orrs	r2, r3
 8020edc:	d100      	bne.n	8020ee0 <__aeabi_dadd+0x44c>
 8020ede:	e0bd      	b.n	802105c <__aeabi_dadd+0x5c8>
 8020ee0:	4662      	mov	r2, ip
 8020ee2:	4664      	mov	r4, ip
 8020ee4:	3a01      	subs	r2, #1
 8020ee6:	2c01      	cmp	r4, #1
 8020ee8:	d100      	bne.n	8020eec <__aeabi_dadd+0x458>
 8020eea:	e0e5      	b.n	80210b8 <__aeabi_dadd+0x624>
 8020eec:	4c85      	ldr	r4, [pc, #532]	; (8021104 <__aeabi_dadd+0x670>)
 8020eee:	45a4      	cmp	ip, r4
 8020ef0:	d058      	beq.n	8020fa4 <__aeabi_dadd+0x510>
 8020ef2:	4694      	mov	ip, r2
 8020ef4:	e749      	b.n	8020d8a <__aeabi_dadd+0x2f6>
 8020ef6:	4664      	mov	r4, ip
 8020ef8:	2220      	movs	r2, #32
 8020efa:	1b12      	subs	r2, r2, r4
 8020efc:	4644      	mov	r4, r8
 8020efe:	4094      	lsls	r4, r2
 8020f00:	000f      	movs	r7, r1
 8020f02:	46a1      	mov	r9, r4
 8020f04:	4664      	mov	r4, ip
 8020f06:	4091      	lsls	r1, r2
 8020f08:	40e7      	lsrs	r7, r4
 8020f0a:	464c      	mov	r4, r9
 8020f0c:	1e4a      	subs	r2, r1, #1
 8020f0e:	4191      	sbcs	r1, r2
 8020f10:	433c      	orrs	r4, r7
 8020f12:	4642      	mov	r2, r8
 8020f14:	430c      	orrs	r4, r1
 8020f16:	4661      	mov	r1, ip
 8020f18:	40ca      	lsrs	r2, r1
 8020f1a:	1880      	adds	r0, r0, r2
 8020f1c:	e6f4      	b.n	8020d08 <__aeabi_dadd+0x274>
 8020f1e:	4c79      	ldr	r4, [pc, #484]	; (8021104 <__aeabi_dadd+0x670>)
 8020f20:	42a2      	cmp	r2, r4
 8020f22:	d100      	bne.n	8020f26 <__aeabi_dadd+0x492>
 8020f24:	e6fd      	b.n	8020d22 <__aeabi_dadd+0x28e>
 8020f26:	1859      	adds	r1, r3, r1
 8020f28:	4299      	cmp	r1, r3
 8020f2a:	419b      	sbcs	r3, r3
 8020f2c:	4440      	add	r0, r8
 8020f2e:	425f      	negs	r7, r3
 8020f30:	19c7      	adds	r7, r0, r7
 8020f32:	07fc      	lsls	r4, r7, #31
 8020f34:	0849      	lsrs	r1, r1, #1
 8020f36:	0016      	movs	r6, r2
 8020f38:	430c      	orrs	r4, r1
 8020f3a:	087f      	lsrs	r7, r7, #1
 8020f3c:	e6cf      	b.n	8020cde <__aeabi_dadd+0x24a>
 8020f3e:	1acc      	subs	r4, r1, r3
 8020f40:	42a1      	cmp	r1, r4
 8020f42:	41bf      	sbcs	r7, r7
 8020f44:	4643      	mov	r3, r8
 8020f46:	427f      	negs	r7, r7
 8020f48:	1a18      	subs	r0, r3, r0
 8020f4a:	4655      	mov	r5, sl
 8020f4c:	1bc7      	subs	r7, r0, r7
 8020f4e:	e5f7      	b.n	8020b40 <__aeabi_dadd+0xac>
 8020f50:	08c9      	lsrs	r1, r1, #3
 8020f52:	077b      	lsls	r3, r7, #29
 8020f54:	4655      	mov	r5, sl
 8020f56:	430b      	orrs	r3, r1
 8020f58:	08f8      	lsrs	r0, r7, #3
 8020f5a:	e6c8      	b.n	8020cee <__aeabi_dadd+0x25a>
 8020f5c:	2c00      	cmp	r4, #0
 8020f5e:	d000      	beq.n	8020f62 <__aeabi_dadd+0x4ce>
 8020f60:	e081      	b.n	8021066 <__aeabi_dadd+0x5d2>
 8020f62:	4643      	mov	r3, r8
 8020f64:	430b      	orrs	r3, r1
 8020f66:	d115      	bne.n	8020f94 <__aeabi_dadd+0x500>
 8020f68:	2080      	movs	r0, #128	; 0x80
 8020f6a:	2500      	movs	r5, #0
 8020f6c:	0300      	lsls	r0, r0, #12
 8020f6e:	e6e3      	b.n	8020d38 <__aeabi_dadd+0x2a4>
 8020f70:	1a5c      	subs	r4, r3, r1
 8020f72:	42a3      	cmp	r3, r4
 8020f74:	419b      	sbcs	r3, r3
 8020f76:	1bc7      	subs	r7, r0, r7
 8020f78:	425b      	negs	r3, r3
 8020f7a:	2601      	movs	r6, #1
 8020f7c:	1aff      	subs	r7, r7, r3
 8020f7e:	e5da      	b.n	8020b36 <__aeabi_dadd+0xa2>
 8020f80:	0742      	lsls	r2, r0, #29
 8020f82:	08db      	lsrs	r3, r3, #3
 8020f84:	4313      	orrs	r3, r2
 8020f86:	08c0      	lsrs	r0, r0, #3
 8020f88:	e6d2      	b.n	8020d30 <__aeabi_dadd+0x29c>
 8020f8a:	0742      	lsls	r2, r0, #29
 8020f8c:	08db      	lsrs	r3, r3, #3
 8020f8e:	4313      	orrs	r3, r2
 8020f90:	08c0      	lsrs	r0, r0, #3
 8020f92:	e6ac      	b.n	8020cee <__aeabi_dadd+0x25a>
 8020f94:	4643      	mov	r3, r8
 8020f96:	4642      	mov	r2, r8
 8020f98:	08c9      	lsrs	r1, r1, #3
 8020f9a:	075b      	lsls	r3, r3, #29
 8020f9c:	4655      	mov	r5, sl
 8020f9e:	430b      	orrs	r3, r1
 8020fa0:	08d0      	lsrs	r0, r2, #3
 8020fa2:	e6c5      	b.n	8020d30 <__aeabi_dadd+0x29c>
 8020fa4:	4643      	mov	r3, r8
 8020fa6:	4642      	mov	r2, r8
 8020fa8:	075b      	lsls	r3, r3, #29
 8020faa:	08c9      	lsrs	r1, r1, #3
 8020fac:	430b      	orrs	r3, r1
 8020fae:	08d0      	lsrs	r0, r2, #3
 8020fb0:	e6be      	b.n	8020d30 <__aeabi_dadd+0x29c>
 8020fb2:	4303      	orrs	r3, r0
 8020fb4:	001c      	movs	r4, r3
 8020fb6:	1e63      	subs	r3, r4, #1
 8020fb8:	419c      	sbcs	r4, r3
 8020fba:	e6fc      	b.n	8020db6 <__aeabi_dadd+0x322>
 8020fbc:	0002      	movs	r2, r0
 8020fbe:	3c20      	subs	r4, #32
 8020fc0:	40e2      	lsrs	r2, r4
 8020fc2:	0014      	movs	r4, r2
 8020fc4:	4662      	mov	r2, ip
 8020fc6:	2a20      	cmp	r2, #32
 8020fc8:	d003      	beq.n	8020fd2 <__aeabi_dadd+0x53e>
 8020fca:	2540      	movs	r5, #64	; 0x40
 8020fcc:	1aad      	subs	r5, r5, r2
 8020fce:	40a8      	lsls	r0, r5
 8020fd0:	4303      	orrs	r3, r0
 8020fd2:	1e58      	subs	r0, r3, #1
 8020fd4:	4183      	sbcs	r3, r0
 8020fd6:	4323      	orrs	r3, r4
 8020fd8:	e775      	b.n	8020ec6 <__aeabi_dadd+0x432>
 8020fda:	2a00      	cmp	r2, #0
 8020fdc:	d0e2      	beq.n	8020fa4 <__aeabi_dadd+0x510>
 8020fde:	003a      	movs	r2, r7
 8020fe0:	430a      	orrs	r2, r1
 8020fe2:	d0cd      	beq.n	8020f80 <__aeabi_dadd+0x4ec>
 8020fe4:	0742      	lsls	r2, r0, #29
 8020fe6:	08db      	lsrs	r3, r3, #3
 8020fe8:	4313      	orrs	r3, r2
 8020fea:	2280      	movs	r2, #128	; 0x80
 8020fec:	08c0      	lsrs	r0, r0, #3
 8020fee:	0312      	lsls	r2, r2, #12
 8020ff0:	4210      	tst	r0, r2
 8020ff2:	d006      	beq.n	8021002 <__aeabi_dadd+0x56e>
 8020ff4:	08fc      	lsrs	r4, r7, #3
 8020ff6:	4214      	tst	r4, r2
 8020ff8:	d103      	bne.n	8021002 <__aeabi_dadd+0x56e>
 8020ffa:	0020      	movs	r0, r4
 8020ffc:	08cb      	lsrs	r3, r1, #3
 8020ffe:	077a      	lsls	r2, r7, #29
 8021000:	4313      	orrs	r3, r2
 8021002:	0f5a      	lsrs	r2, r3, #29
 8021004:	00db      	lsls	r3, r3, #3
 8021006:	0752      	lsls	r2, r2, #29
 8021008:	08db      	lsrs	r3, r3, #3
 802100a:	4313      	orrs	r3, r2
 802100c:	e690      	b.n	8020d30 <__aeabi_dadd+0x29c>
 802100e:	4643      	mov	r3, r8
 8021010:	430b      	orrs	r3, r1
 8021012:	d100      	bne.n	8021016 <__aeabi_dadd+0x582>
 8021014:	e709      	b.n	8020e2a <__aeabi_dadd+0x396>
 8021016:	4643      	mov	r3, r8
 8021018:	4642      	mov	r2, r8
 802101a:	08c9      	lsrs	r1, r1, #3
 802101c:	075b      	lsls	r3, r3, #29
 802101e:	4655      	mov	r5, sl
 8021020:	430b      	orrs	r3, r1
 8021022:	08d0      	lsrs	r0, r2, #3
 8021024:	e666      	b.n	8020cf4 <__aeabi_dadd+0x260>
 8021026:	1acc      	subs	r4, r1, r3
 8021028:	42a1      	cmp	r1, r4
 802102a:	4189      	sbcs	r1, r1
 802102c:	1a3f      	subs	r7, r7, r0
 802102e:	4249      	negs	r1, r1
 8021030:	4655      	mov	r5, sl
 8021032:	2601      	movs	r6, #1
 8021034:	1a7f      	subs	r7, r7, r1
 8021036:	e57e      	b.n	8020b36 <__aeabi_dadd+0xa2>
 8021038:	4642      	mov	r2, r8
 802103a:	1a5c      	subs	r4, r3, r1
 802103c:	1a87      	subs	r7, r0, r2
 802103e:	42a3      	cmp	r3, r4
 8021040:	4192      	sbcs	r2, r2
 8021042:	4252      	negs	r2, r2
 8021044:	1abf      	subs	r7, r7, r2
 8021046:	023a      	lsls	r2, r7, #8
 8021048:	d53d      	bpl.n	80210c6 <__aeabi_dadd+0x632>
 802104a:	1acc      	subs	r4, r1, r3
 802104c:	42a1      	cmp	r1, r4
 802104e:	4189      	sbcs	r1, r1
 8021050:	4643      	mov	r3, r8
 8021052:	4249      	negs	r1, r1
 8021054:	1a1f      	subs	r7, r3, r0
 8021056:	4655      	mov	r5, sl
 8021058:	1a7f      	subs	r7, r7, r1
 802105a:	e595      	b.n	8020b88 <__aeabi_dadd+0xf4>
 802105c:	077b      	lsls	r3, r7, #29
 802105e:	08c9      	lsrs	r1, r1, #3
 8021060:	430b      	orrs	r3, r1
 8021062:	08f8      	lsrs	r0, r7, #3
 8021064:	e643      	b.n	8020cee <__aeabi_dadd+0x25a>
 8021066:	4644      	mov	r4, r8
 8021068:	08db      	lsrs	r3, r3, #3
 802106a:	430c      	orrs	r4, r1
 802106c:	d130      	bne.n	80210d0 <__aeabi_dadd+0x63c>
 802106e:	0742      	lsls	r2, r0, #29
 8021070:	4313      	orrs	r3, r2
 8021072:	08c0      	lsrs	r0, r0, #3
 8021074:	e65c      	b.n	8020d30 <__aeabi_dadd+0x29c>
 8021076:	077b      	lsls	r3, r7, #29
 8021078:	08c9      	lsrs	r1, r1, #3
 802107a:	430b      	orrs	r3, r1
 802107c:	08f8      	lsrs	r0, r7, #3
 802107e:	e639      	b.n	8020cf4 <__aeabi_dadd+0x260>
 8021080:	185c      	adds	r4, r3, r1
 8021082:	429c      	cmp	r4, r3
 8021084:	419b      	sbcs	r3, r3
 8021086:	4440      	add	r0, r8
 8021088:	425b      	negs	r3, r3
 802108a:	18c7      	adds	r7, r0, r3
 802108c:	023b      	lsls	r3, r7, #8
 802108e:	d400      	bmi.n	8021092 <__aeabi_dadd+0x5fe>
 8021090:	e625      	b.n	8020cde <__aeabi_dadd+0x24a>
 8021092:	4b1d      	ldr	r3, [pc, #116]	; (8021108 <__aeabi_dadd+0x674>)
 8021094:	2601      	movs	r6, #1
 8021096:	401f      	ands	r7, r3
 8021098:	e621      	b.n	8020cde <__aeabi_dadd+0x24a>
 802109a:	0004      	movs	r4, r0
 802109c:	3a20      	subs	r2, #32
 802109e:	40d4      	lsrs	r4, r2
 80210a0:	4662      	mov	r2, ip
 80210a2:	2a20      	cmp	r2, #32
 80210a4:	d004      	beq.n	80210b0 <__aeabi_dadd+0x61c>
 80210a6:	2240      	movs	r2, #64	; 0x40
 80210a8:	4666      	mov	r6, ip
 80210aa:	1b92      	subs	r2, r2, r6
 80210ac:	4090      	lsls	r0, r2
 80210ae:	4303      	orrs	r3, r0
 80210b0:	1e5a      	subs	r2, r3, #1
 80210b2:	4193      	sbcs	r3, r2
 80210b4:	431c      	orrs	r4, r3
 80210b6:	e67e      	b.n	8020db6 <__aeabi_dadd+0x322>
 80210b8:	185c      	adds	r4, r3, r1
 80210ba:	428c      	cmp	r4, r1
 80210bc:	4189      	sbcs	r1, r1
 80210be:	4440      	add	r0, r8
 80210c0:	4249      	negs	r1, r1
 80210c2:	1847      	adds	r7, r0, r1
 80210c4:	e6dd      	b.n	8020e82 <__aeabi_dadd+0x3ee>
 80210c6:	0023      	movs	r3, r4
 80210c8:	433b      	orrs	r3, r7
 80210ca:	d100      	bne.n	80210ce <__aeabi_dadd+0x63a>
 80210cc:	e6ad      	b.n	8020e2a <__aeabi_dadd+0x396>
 80210ce:	e606      	b.n	8020cde <__aeabi_dadd+0x24a>
 80210d0:	0744      	lsls	r4, r0, #29
 80210d2:	4323      	orrs	r3, r4
 80210d4:	2480      	movs	r4, #128	; 0x80
 80210d6:	08c0      	lsrs	r0, r0, #3
 80210d8:	0324      	lsls	r4, r4, #12
 80210da:	4220      	tst	r0, r4
 80210dc:	d008      	beq.n	80210f0 <__aeabi_dadd+0x65c>
 80210de:	4642      	mov	r2, r8
 80210e0:	08d6      	lsrs	r6, r2, #3
 80210e2:	4226      	tst	r6, r4
 80210e4:	d104      	bne.n	80210f0 <__aeabi_dadd+0x65c>
 80210e6:	4655      	mov	r5, sl
 80210e8:	0030      	movs	r0, r6
 80210ea:	08cb      	lsrs	r3, r1, #3
 80210ec:	0751      	lsls	r1, r2, #29
 80210ee:	430b      	orrs	r3, r1
 80210f0:	0f5a      	lsrs	r2, r3, #29
 80210f2:	00db      	lsls	r3, r3, #3
 80210f4:	08db      	lsrs	r3, r3, #3
 80210f6:	0752      	lsls	r2, r2, #29
 80210f8:	4313      	orrs	r3, r2
 80210fa:	e619      	b.n	8020d30 <__aeabi_dadd+0x29c>
 80210fc:	2300      	movs	r3, #0
 80210fe:	4a01      	ldr	r2, [pc, #4]	; (8021104 <__aeabi_dadd+0x670>)
 8021100:	001f      	movs	r7, r3
 8021102:	e55e      	b.n	8020bc2 <__aeabi_dadd+0x12e>
 8021104:	000007ff 	.word	0x000007ff
 8021108:	ff7fffff 	.word	0xff7fffff

0802110c <__eqdf2>:
 802110c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802110e:	464e      	mov	r6, r9
 8021110:	4645      	mov	r5, r8
 8021112:	46de      	mov	lr, fp
 8021114:	4657      	mov	r7, sl
 8021116:	4690      	mov	r8, r2
 8021118:	b5e0      	push	{r5, r6, r7, lr}
 802111a:	0017      	movs	r7, r2
 802111c:	031a      	lsls	r2, r3, #12
 802111e:	0b12      	lsrs	r2, r2, #12
 8021120:	0005      	movs	r5, r0
 8021122:	4684      	mov	ip, r0
 8021124:	4819      	ldr	r0, [pc, #100]	; (802118c <__eqdf2+0x80>)
 8021126:	030e      	lsls	r6, r1, #12
 8021128:	004c      	lsls	r4, r1, #1
 802112a:	4691      	mov	r9, r2
 802112c:	005a      	lsls	r2, r3, #1
 802112e:	0fdb      	lsrs	r3, r3, #31
 8021130:	469b      	mov	fp, r3
 8021132:	0b36      	lsrs	r6, r6, #12
 8021134:	0d64      	lsrs	r4, r4, #21
 8021136:	0fc9      	lsrs	r1, r1, #31
 8021138:	0d52      	lsrs	r2, r2, #21
 802113a:	4284      	cmp	r4, r0
 802113c:	d019      	beq.n	8021172 <__eqdf2+0x66>
 802113e:	4282      	cmp	r2, r0
 8021140:	d010      	beq.n	8021164 <__eqdf2+0x58>
 8021142:	2001      	movs	r0, #1
 8021144:	4294      	cmp	r4, r2
 8021146:	d10e      	bne.n	8021166 <__eqdf2+0x5a>
 8021148:	454e      	cmp	r6, r9
 802114a:	d10c      	bne.n	8021166 <__eqdf2+0x5a>
 802114c:	2001      	movs	r0, #1
 802114e:	45c4      	cmp	ip, r8
 8021150:	d109      	bne.n	8021166 <__eqdf2+0x5a>
 8021152:	4559      	cmp	r1, fp
 8021154:	d017      	beq.n	8021186 <__eqdf2+0x7a>
 8021156:	2c00      	cmp	r4, #0
 8021158:	d105      	bne.n	8021166 <__eqdf2+0x5a>
 802115a:	0030      	movs	r0, r6
 802115c:	4328      	orrs	r0, r5
 802115e:	1e43      	subs	r3, r0, #1
 8021160:	4198      	sbcs	r0, r3
 8021162:	e000      	b.n	8021166 <__eqdf2+0x5a>
 8021164:	2001      	movs	r0, #1
 8021166:	bcf0      	pop	{r4, r5, r6, r7}
 8021168:	46bb      	mov	fp, r7
 802116a:	46b2      	mov	sl, r6
 802116c:	46a9      	mov	r9, r5
 802116e:	46a0      	mov	r8, r4
 8021170:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8021172:	0033      	movs	r3, r6
 8021174:	2001      	movs	r0, #1
 8021176:	432b      	orrs	r3, r5
 8021178:	d1f5      	bne.n	8021166 <__eqdf2+0x5a>
 802117a:	42a2      	cmp	r2, r4
 802117c:	d1f3      	bne.n	8021166 <__eqdf2+0x5a>
 802117e:	464b      	mov	r3, r9
 8021180:	433b      	orrs	r3, r7
 8021182:	d1f0      	bne.n	8021166 <__eqdf2+0x5a>
 8021184:	e7e2      	b.n	802114c <__eqdf2+0x40>
 8021186:	2000      	movs	r0, #0
 8021188:	e7ed      	b.n	8021166 <__eqdf2+0x5a>
 802118a:	46c0      	nop			; (mov r8, r8)
 802118c:	000007ff 	.word	0x000007ff

08021190 <__gedf2>:
 8021190:	b5f0      	push	{r4, r5, r6, r7, lr}
 8021192:	4647      	mov	r7, r8
 8021194:	46ce      	mov	lr, r9
 8021196:	0004      	movs	r4, r0
 8021198:	0018      	movs	r0, r3
 802119a:	0016      	movs	r6, r2
 802119c:	031b      	lsls	r3, r3, #12
 802119e:	0b1b      	lsrs	r3, r3, #12
 80211a0:	4d2d      	ldr	r5, [pc, #180]	; (8021258 <__gedf2+0xc8>)
 80211a2:	004a      	lsls	r2, r1, #1
 80211a4:	4699      	mov	r9, r3
 80211a6:	b580      	push	{r7, lr}
 80211a8:	0043      	lsls	r3, r0, #1
 80211aa:	030f      	lsls	r7, r1, #12
 80211ac:	46a4      	mov	ip, r4
 80211ae:	46b0      	mov	r8, r6
 80211b0:	0b3f      	lsrs	r7, r7, #12
 80211b2:	0d52      	lsrs	r2, r2, #21
 80211b4:	0fc9      	lsrs	r1, r1, #31
 80211b6:	0d5b      	lsrs	r3, r3, #21
 80211b8:	0fc0      	lsrs	r0, r0, #31
 80211ba:	42aa      	cmp	r2, r5
 80211bc:	d021      	beq.n	8021202 <__gedf2+0x72>
 80211be:	42ab      	cmp	r3, r5
 80211c0:	d013      	beq.n	80211ea <__gedf2+0x5a>
 80211c2:	2a00      	cmp	r2, #0
 80211c4:	d122      	bne.n	802120c <__gedf2+0x7c>
 80211c6:	433c      	orrs	r4, r7
 80211c8:	2b00      	cmp	r3, #0
 80211ca:	d102      	bne.n	80211d2 <__gedf2+0x42>
 80211cc:	464d      	mov	r5, r9
 80211ce:	432e      	orrs	r6, r5
 80211d0:	d022      	beq.n	8021218 <__gedf2+0x88>
 80211d2:	2c00      	cmp	r4, #0
 80211d4:	d010      	beq.n	80211f8 <__gedf2+0x68>
 80211d6:	4281      	cmp	r1, r0
 80211d8:	d022      	beq.n	8021220 <__gedf2+0x90>
 80211da:	2002      	movs	r0, #2
 80211dc:	3901      	subs	r1, #1
 80211de:	4008      	ands	r0, r1
 80211e0:	3801      	subs	r0, #1
 80211e2:	bcc0      	pop	{r6, r7}
 80211e4:	46b9      	mov	r9, r7
 80211e6:	46b0      	mov	r8, r6
 80211e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80211ea:	464d      	mov	r5, r9
 80211ec:	432e      	orrs	r6, r5
 80211ee:	d129      	bne.n	8021244 <__gedf2+0xb4>
 80211f0:	2a00      	cmp	r2, #0
 80211f2:	d1f0      	bne.n	80211d6 <__gedf2+0x46>
 80211f4:	433c      	orrs	r4, r7
 80211f6:	d1ee      	bne.n	80211d6 <__gedf2+0x46>
 80211f8:	2800      	cmp	r0, #0
 80211fa:	d1f2      	bne.n	80211e2 <__gedf2+0x52>
 80211fc:	2001      	movs	r0, #1
 80211fe:	4240      	negs	r0, r0
 8021200:	e7ef      	b.n	80211e2 <__gedf2+0x52>
 8021202:	003d      	movs	r5, r7
 8021204:	4325      	orrs	r5, r4
 8021206:	d11d      	bne.n	8021244 <__gedf2+0xb4>
 8021208:	4293      	cmp	r3, r2
 802120a:	d0ee      	beq.n	80211ea <__gedf2+0x5a>
 802120c:	2b00      	cmp	r3, #0
 802120e:	d1e2      	bne.n	80211d6 <__gedf2+0x46>
 8021210:	464c      	mov	r4, r9
 8021212:	4326      	orrs	r6, r4
 8021214:	d1df      	bne.n	80211d6 <__gedf2+0x46>
 8021216:	e7e0      	b.n	80211da <__gedf2+0x4a>
 8021218:	2000      	movs	r0, #0
 802121a:	2c00      	cmp	r4, #0
 802121c:	d0e1      	beq.n	80211e2 <__gedf2+0x52>
 802121e:	e7dc      	b.n	80211da <__gedf2+0x4a>
 8021220:	429a      	cmp	r2, r3
 8021222:	dc0a      	bgt.n	802123a <__gedf2+0xaa>
 8021224:	dbe8      	blt.n	80211f8 <__gedf2+0x68>
 8021226:	454f      	cmp	r7, r9
 8021228:	d8d7      	bhi.n	80211da <__gedf2+0x4a>
 802122a:	d00e      	beq.n	802124a <__gedf2+0xba>
 802122c:	2000      	movs	r0, #0
 802122e:	454f      	cmp	r7, r9
 8021230:	d2d7      	bcs.n	80211e2 <__gedf2+0x52>
 8021232:	2900      	cmp	r1, #0
 8021234:	d0e2      	beq.n	80211fc <__gedf2+0x6c>
 8021236:	0008      	movs	r0, r1
 8021238:	e7d3      	b.n	80211e2 <__gedf2+0x52>
 802123a:	4243      	negs	r3, r0
 802123c:	4158      	adcs	r0, r3
 802123e:	0040      	lsls	r0, r0, #1
 8021240:	3801      	subs	r0, #1
 8021242:	e7ce      	b.n	80211e2 <__gedf2+0x52>
 8021244:	2002      	movs	r0, #2
 8021246:	4240      	negs	r0, r0
 8021248:	e7cb      	b.n	80211e2 <__gedf2+0x52>
 802124a:	45c4      	cmp	ip, r8
 802124c:	d8c5      	bhi.n	80211da <__gedf2+0x4a>
 802124e:	2000      	movs	r0, #0
 8021250:	45c4      	cmp	ip, r8
 8021252:	d2c6      	bcs.n	80211e2 <__gedf2+0x52>
 8021254:	e7ed      	b.n	8021232 <__gedf2+0xa2>
 8021256:	46c0      	nop			; (mov r8, r8)
 8021258:	000007ff 	.word	0x000007ff

0802125c <__ledf2>:
 802125c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802125e:	4647      	mov	r7, r8
 8021260:	46ce      	mov	lr, r9
 8021262:	0004      	movs	r4, r0
 8021264:	0018      	movs	r0, r3
 8021266:	0016      	movs	r6, r2
 8021268:	031b      	lsls	r3, r3, #12
 802126a:	0b1b      	lsrs	r3, r3, #12
 802126c:	4d2c      	ldr	r5, [pc, #176]	; (8021320 <__ledf2+0xc4>)
 802126e:	004a      	lsls	r2, r1, #1
 8021270:	4699      	mov	r9, r3
 8021272:	b580      	push	{r7, lr}
 8021274:	0043      	lsls	r3, r0, #1
 8021276:	030f      	lsls	r7, r1, #12
 8021278:	46a4      	mov	ip, r4
 802127a:	46b0      	mov	r8, r6
 802127c:	0b3f      	lsrs	r7, r7, #12
 802127e:	0d52      	lsrs	r2, r2, #21
 8021280:	0fc9      	lsrs	r1, r1, #31
 8021282:	0d5b      	lsrs	r3, r3, #21
 8021284:	0fc0      	lsrs	r0, r0, #31
 8021286:	42aa      	cmp	r2, r5
 8021288:	d00d      	beq.n	80212a6 <__ledf2+0x4a>
 802128a:	42ab      	cmp	r3, r5
 802128c:	d010      	beq.n	80212b0 <__ledf2+0x54>
 802128e:	2a00      	cmp	r2, #0
 8021290:	d127      	bne.n	80212e2 <__ledf2+0x86>
 8021292:	433c      	orrs	r4, r7
 8021294:	2b00      	cmp	r3, #0
 8021296:	d111      	bne.n	80212bc <__ledf2+0x60>
 8021298:	464d      	mov	r5, r9
 802129a:	432e      	orrs	r6, r5
 802129c:	d10e      	bne.n	80212bc <__ledf2+0x60>
 802129e:	2000      	movs	r0, #0
 80212a0:	2c00      	cmp	r4, #0
 80212a2:	d015      	beq.n	80212d0 <__ledf2+0x74>
 80212a4:	e00e      	b.n	80212c4 <__ledf2+0x68>
 80212a6:	003d      	movs	r5, r7
 80212a8:	4325      	orrs	r5, r4
 80212aa:	d110      	bne.n	80212ce <__ledf2+0x72>
 80212ac:	4293      	cmp	r3, r2
 80212ae:	d118      	bne.n	80212e2 <__ledf2+0x86>
 80212b0:	464d      	mov	r5, r9
 80212b2:	432e      	orrs	r6, r5
 80212b4:	d10b      	bne.n	80212ce <__ledf2+0x72>
 80212b6:	2a00      	cmp	r2, #0
 80212b8:	d102      	bne.n	80212c0 <__ledf2+0x64>
 80212ba:	433c      	orrs	r4, r7
 80212bc:	2c00      	cmp	r4, #0
 80212be:	d00b      	beq.n	80212d8 <__ledf2+0x7c>
 80212c0:	4281      	cmp	r1, r0
 80212c2:	d014      	beq.n	80212ee <__ledf2+0x92>
 80212c4:	2002      	movs	r0, #2
 80212c6:	3901      	subs	r1, #1
 80212c8:	4008      	ands	r0, r1
 80212ca:	3801      	subs	r0, #1
 80212cc:	e000      	b.n	80212d0 <__ledf2+0x74>
 80212ce:	2002      	movs	r0, #2
 80212d0:	bcc0      	pop	{r6, r7}
 80212d2:	46b9      	mov	r9, r7
 80212d4:	46b0      	mov	r8, r6
 80212d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80212d8:	2800      	cmp	r0, #0
 80212da:	d1f9      	bne.n	80212d0 <__ledf2+0x74>
 80212dc:	2001      	movs	r0, #1
 80212de:	4240      	negs	r0, r0
 80212e0:	e7f6      	b.n	80212d0 <__ledf2+0x74>
 80212e2:	2b00      	cmp	r3, #0
 80212e4:	d1ec      	bne.n	80212c0 <__ledf2+0x64>
 80212e6:	464c      	mov	r4, r9
 80212e8:	4326      	orrs	r6, r4
 80212ea:	d1e9      	bne.n	80212c0 <__ledf2+0x64>
 80212ec:	e7ea      	b.n	80212c4 <__ledf2+0x68>
 80212ee:	429a      	cmp	r2, r3
 80212f0:	dd04      	ble.n	80212fc <__ledf2+0xa0>
 80212f2:	4243      	negs	r3, r0
 80212f4:	4158      	adcs	r0, r3
 80212f6:	0040      	lsls	r0, r0, #1
 80212f8:	3801      	subs	r0, #1
 80212fa:	e7e9      	b.n	80212d0 <__ledf2+0x74>
 80212fc:	429a      	cmp	r2, r3
 80212fe:	dbeb      	blt.n	80212d8 <__ledf2+0x7c>
 8021300:	454f      	cmp	r7, r9
 8021302:	d8df      	bhi.n	80212c4 <__ledf2+0x68>
 8021304:	d006      	beq.n	8021314 <__ledf2+0xb8>
 8021306:	2000      	movs	r0, #0
 8021308:	454f      	cmp	r7, r9
 802130a:	d2e1      	bcs.n	80212d0 <__ledf2+0x74>
 802130c:	2900      	cmp	r1, #0
 802130e:	d0e5      	beq.n	80212dc <__ledf2+0x80>
 8021310:	0008      	movs	r0, r1
 8021312:	e7dd      	b.n	80212d0 <__ledf2+0x74>
 8021314:	45c4      	cmp	ip, r8
 8021316:	d8d5      	bhi.n	80212c4 <__ledf2+0x68>
 8021318:	2000      	movs	r0, #0
 802131a:	45c4      	cmp	ip, r8
 802131c:	d2d8      	bcs.n	80212d0 <__ledf2+0x74>
 802131e:	e7f5      	b.n	802130c <__ledf2+0xb0>
 8021320:	000007ff 	.word	0x000007ff

08021324 <__aeabi_d2iz>:
 8021324:	000a      	movs	r2, r1
 8021326:	b530      	push	{r4, r5, lr}
 8021328:	4c13      	ldr	r4, [pc, #76]	; (8021378 <__aeabi_d2iz+0x54>)
 802132a:	0053      	lsls	r3, r2, #1
 802132c:	0309      	lsls	r1, r1, #12
 802132e:	0005      	movs	r5, r0
 8021330:	0b09      	lsrs	r1, r1, #12
 8021332:	2000      	movs	r0, #0
 8021334:	0d5b      	lsrs	r3, r3, #21
 8021336:	0fd2      	lsrs	r2, r2, #31
 8021338:	42a3      	cmp	r3, r4
 802133a:	dd04      	ble.n	8021346 <__aeabi_d2iz+0x22>
 802133c:	480f      	ldr	r0, [pc, #60]	; (802137c <__aeabi_d2iz+0x58>)
 802133e:	4283      	cmp	r3, r0
 8021340:	dd02      	ble.n	8021348 <__aeabi_d2iz+0x24>
 8021342:	4b0f      	ldr	r3, [pc, #60]	; (8021380 <__aeabi_d2iz+0x5c>)
 8021344:	18d0      	adds	r0, r2, r3
 8021346:	bd30      	pop	{r4, r5, pc}
 8021348:	2080      	movs	r0, #128	; 0x80
 802134a:	0340      	lsls	r0, r0, #13
 802134c:	4301      	orrs	r1, r0
 802134e:	480d      	ldr	r0, [pc, #52]	; (8021384 <__aeabi_d2iz+0x60>)
 8021350:	1ac0      	subs	r0, r0, r3
 8021352:	281f      	cmp	r0, #31
 8021354:	dd08      	ble.n	8021368 <__aeabi_d2iz+0x44>
 8021356:	480c      	ldr	r0, [pc, #48]	; (8021388 <__aeabi_d2iz+0x64>)
 8021358:	1ac3      	subs	r3, r0, r3
 802135a:	40d9      	lsrs	r1, r3
 802135c:	000b      	movs	r3, r1
 802135e:	4258      	negs	r0, r3
 8021360:	2a00      	cmp	r2, #0
 8021362:	d1f0      	bne.n	8021346 <__aeabi_d2iz+0x22>
 8021364:	0018      	movs	r0, r3
 8021366:	e7ee      	b.n	8021346 <__aeabi_d2iz+0x22>
 8021368:	4c08      	ldr	r4, [pc, #32]	; (802138c <__aeabi_d2iz+0x68>)
 802136a:	40c5      	lsrs	r5, r0
 802136c:	46a4      	mov	ip, r4
 802136e:	4463      	add	r3, ip
 8021370:	4099      	lsls	r1, r3
 8021372:	000b      	movs	r3, r1
 8021374:	432b      	orrs	r3, r5
 8021376:	e7f2      	b.n	802135e <__aeabi_d2iz+0x3a>
 8021378:	000003fe 	.word	0x000003fe
 802137c:	0000041d 	.word	0x0000041d
 8021380:	7fffffff 	.word	0x7fffffff
 8021384:	00000433 	.word	0x00000433
 8021388:	00000413 	.word	0x00000413
 802138c:	fffffbed 	.word	0xfffffbed

08021390 <__aeabi_f2d>:
 8021390:	b570      	push	{r4, r5, r6, lr}
 8021392:	0043      	lsls	r3, r0, #1
 8021394:	0246      	lsls	r6, r0, #9
 8021396:	0fc4      	lsrs	r4, r0, #31
 8021398:	20fe      	movs	r0, #254	; 0xfe
 802139a:	0e1b      	lsrs	r3, r3, #24
 802139c:	1c59      	adds	r1, r3, #1
 802139e:	0a75      	lsrs	r5, r6, #9
 80213a0:	4208      	tst	r0, r1
 80213a2:	d00c      	beq.n	80213be <__aeabi_f2d+0x2e>
 80213a4:	22e0      	movs	r2, #224	; 0xe0
 80213a6:	0092      	lsls	r2, r2, #2
 80213a8:	4694      	mov	ip, r2
 80213aa:	076d      	lsls	r5, r5, #29
 80213ac:	0b36      	lsrs	r6, r6, #12
 80213ae:	4463      	add	r3, ip
 80213b0:	051b      	lsls	r3, r3, #20
 80213b2:	4333      	orrs	r3, r6
 80213b4:	07e4      	lsls	r4, r4, #31
 80213b6:	4323      	orrs	r3, r4
 80213b8:	0028      	movs	r0, r5
 80213ba:	0019      	movs	r1, r3
 80213bc:	bd70      	pop	{r4, r5, r6, pc}
 80213be:	2b00      	cmp	r3, #0
 80213c0:	d114      	bne.n	80213ec <__aeabi_f2d+0x5c>
 80213c2:	2d00      	cmp	r5, #0
 80213c4:	d01b      	beq.n	80213fe <__aeabi_f2d+0x6e>
 80213c6:	0028      	movs	r0, r5
 80213c8:	f000 f82a 	bl	8021420 <__clzsi2>
 80213cc:	280a      	cmp	r0, #10
 80213ce:	dc1c      	bgt.n	802140a <__aeabi_f2d+0x7a>
 80213d0:	230b      	movs	r3, #11
 80213d2:	002e      	movs	r6, r5
 80213d4:	1a1b      	subs	r3, r3, r0
 80213d6:	40de      	lsrs	r6, r3
 80213d8:	0003      	movs	r3, r0
 80213da:	3315      	adds	r3, #21
 80213dc:	409d      	lsls	r5, r3
 80213de:	4a0e      	ldr	r2, [pc, #56]	; (8021418 <__aeabi_f2d+0x88>)
 80213e0:	0336      	lsls	r6, r6, #12
 80213e2:	1a12      	subs	r2, r2, r0
 80213e4:	0552      	lsls	r2, r2, #21
 80213e6:	0b36      	lsrs	r6, r6, #12
 80213e8:	0d53      	lsrs	r3, r2, #21
 80213ea:	e7e1      	b.n	80213b0 <__aeabi_f2d+0x20>
 80213ec:	2d00      	cmp	r5, #0
 80213ee:	d009      	beq.n	8021404 <__aeabi_f2d+0x74>
 80213f0:	2280      	movs	r2, #128	; 0x80
 80213f2:	0b36      	lsrs	r6, r6, #12
 80213f4:	0312      	lsls	r2, r2, #12
 80213f6:	4b09      	ldr	r3, [pc, #36]	; (802141c <__aeabi_f2d+0x8c>)
 80213f8:	076d      	lsls	r5, r5, #29
 80213fa:	4316      	orrs	r6, r2
 80213fc:	e7d8      	b.n	80213b0 <__aeabi_f2d+0x20>
 80213fe:	2300      	movs	r3, #0
 8021400:	2600      	movs	r6, #0
 8021402:	e7d5      	b.n	80213b0 <__aeabi_f2d+0x20>
 8021404:	2600      	movs	r6, #0
 8021406:	4b05      	ldr	r3, [pc, #20]	; (802141c <__aeabi_f2d+0x8c>)
 8021408:	e7d2      	b.n	80213b0 <__aeabi_f2d+0x20>
 802140a:	0003      	movs	r3, r0
 802140c:	3b0b      	subs	r3, #11
 802140e:	409d      	lsls	r5, r3
 8021410:	002e      	movs	r6, r5
 8021412:	2500      	movs	r5, #0
 8021414:	e7e3      	b.n	80213de <__aeabi_f2d+0x4e>
 8021416:	46c0      	nop			; (mov r8, r8)
 8021418:	00000389 	.word	0x00000389
 802141c:	000007ff 	.word	0x000007ff

08021420 <__clzsi2>:
 8021420:	211c      	movs	r1, #28
 8021422:	2301      	movs	r3, #1
 8021424:	041b      	lsls	r3, r3, #16
 8021426:	4298      	cmp	r0, r3
 8021428:	d301      	bcc.n	802142e <__clzsi2+0xe>
 802142a:	0c00      	lsrs	r0, r0, #16
 802142c:	3910      	subs	r1, #16
 802142e:	0a1b      	lsrs	r3, r3, #8
 8021430:	4298      	cmp	r0, r3
 8021432:	d301      	bcc.n	8021438 <__clzsi2+0x18>
 8021434:	0a00      	lsrs	r0, r0, #8
 8021436:	3908      	subs	r1, #8
 8021438:	091b      	lsrs	r3, r3, #4
 802143a:	4298      	cmp	r0, r3
 802143c:	d301      	bcc.n	8021442 <__clzsi2+0x22>
 802143e:	0900      	lsrs	r0, r0, #4
 8021440:	3904      	subs	r1, #4
 8021442:	a202      	add	r2, pc, #8	; (adr r2, 802144c <__clzsi2+0x2c>)
 8021444:	5c10      	ldrb	r0, [r2, r0]
 8021446:	1840      	adds	r0, r0, r1
 8021448:	4770      	bx	lr
 802144a:	46c0      	nop			; (mov r8, r8)
 802144c:	02020304 	.word	0x02020304
 8021450:	01010101 	.word	0x01010101
	...

0802145c <__clzdi2>:
 802145c:	b510      	push	{r4, lr}
 802145e:	2900      	cmp	r1, #0
 8021460:	d103      	bne.n	802146a <__clzdi2+0xe>
 8021462:	f7ff ffdd 	bl	8021420 <__clzsi2>
 8021466:	3020      	adds	r0, #32
 8021468:	e002      	b.n	8021470 <__clzdi2+0x14>
 802146a:	0008      	movs	r0, r1
 802146c:	f7ff ffd8 	bl	8021420 <__clzsi2>
 8021470:	bd10      	pop	{r4, pc}
 8021472:	46c0      	nop			; (mov r8, r8)

08021474 <HAL_CRYP_MspInit>:
  * This function configures the hardware resources
  * @param hcryp: CRYP handle pointer
  * @retval None
  */
void HAL_CRYP_MspInit(CRYP_HandleTypeDef *hcryp)
{
 8021474:	b082      	sub	sp, #8
  /* USER CODE BEGIN HAL_CRYP_MspInit */
  if (hcryp->Instance == CA_AES_INSTANCE)
 8021476:	6802      	ldr	r2, [r0, #0]
 8021478:	4b0b      	ldr	r3, [pc, #44]	; (80214a8 <HAL_CRYP_MspInit+0x34>)
 802147a:	429a      	cmp	r2, r3
 802147c:	d001      	beq.n	8021482 <HAL_CRYP_MspInit+0xe>
    __HAL_RCC_AES_RELEASE_RESET();
    /* Peripheral clock enable */
    __HAL_RCC_AES_CLK_ENABLE();
  }
  /* USER CODE END HAL_CRYP_MspInit */
}
 802147e:	b002      	add	sp, #8
 8021480:	4770      	bx	lr
  */

#endif /* DUAL_CORE */
__STATIC_INLINE void LL_AHB3_GRP1_ReleaseReset(uint32_t Periphs)
{
  CLEAR_BIT(RCC->AHB3RSTR, Periphs);
 8021482:	23b0      	movs	r3, #176	; 0xb0
 8021484:	05db      	lsls	r3, r3, #23
 8021486:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8021488:	4908      	ldr	r1, [pc, #32]	; (80214ac <HAL_CRYP_MspInit+0x38>)
 802148a:	400a      	ands	r2, r1
 802148c:	631a      	str	r2, [r3, #48]	; 0x30
  * @retval None
  */
__STATIC_INLINE void LL_C2_AHB3_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->C2AHB3ENR, Periphs);
 802148e:	22a8      	movs	r2, #168	; 0xa8
 8021490:	0052      	lsls	r2, r2, #1
 8021492:	5899      	ldr	r1, [r3, r2]
 8021494:	2080      	movs	r0, #128	; 0x80
 8021496:	0280      	lsls	r0, r0, #10
 8021498:	4301      	orrs	r1, r0
 802149a:	5099      	str	r1, [r3, r2]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->C2AHB3ENR, Periphs);
 802149c:	589b      	ldr	r3, [r3, r2]
 802149e:	4003      	ands	r3, r0
 80214a0:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 80214a2:	9b01      	ldr	r3, [sp, #4]
 80214a4:	e7eb      	b.n	802147e <HAL_CRYP_MspInit+0xa>
 80214a6:	46c0      	nop			; (mov r8, r8)
 80214a8:	58001800 	.word	0x58001800
 80214ac:	fffdffff 	.word	0xfffdffff

080214b0 <HAL_CRYP_MspDeInit>:
  * @retval None
  */
void HAL_CRYP_MspDeInit(CRYP_HandleTypeDef *hcryp)
{
  /* USER CODE BEGIN HAL_CRYP_MspDeInit */
  if (hcryp->Instance == CA_AES_INSTANCE)
 80214b0:	6802      	ldr	r2, [r0, #0]
 80214b2:	4b09      	ldr	r3, [pc, #36]	; (80214d8 <HAL_CRYP_MspDeInit+0x28>)
 80214b4:	429a      	cmp	r2, r3
 80214b6:	d000      	beq.n	80214ba <HAL_CRYP_MspDeInit+0xa>
    __HAL_RCC_AES_CLK_DISABLE();
    /* Force AES/CRYP into reset state */
    __HAL_RCC_AES_FORCE_RESET();
  }
  /* USER CODE END HAL_CRYP_MspDeInit */
}
 80214b8:	4770      	bx	lr
  *         @arg @ref LL_C2_AHB3_GRP1_PERIPH_FLASH
  * @retval None
  */
__STATIC_INLINE void LL_C2_AHB3_GRP1_DisableClock(uint32_t Periphs)
{
  CLEAR_BIT(RCC->C2AHB3ENR, Periphs);
 80214ba:	23b0      	movs	r3, #176	; 0xb0
 80214bc:	05db      	lsls	r3, r3, #23
 80214be:	21a8      	movs	r1, #168	; 0xa8
 80214c0:	0049      	lsls	r1, r1, #1
 80214c2:	585a      	ldr	r2, [r3, r1]
 80214c4:	4805      	ldr	r0, [pc, #20]	; (80214dc <HAL_CRYP_MspDeInit+0x2c>)
 80214c6:	4002      	ands	r2, r0
 80214c8:	505a      	str	r2, [r3, r1]
  SET_BIT(RCC->AHB3RSTR, Periphs);
 80214ca:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80214cc:	2280      	movs	r2, #128	; 0x80
 80214ce:	0292      	lsls	r2, r2, #10
 80214d0:	430a      	orrs	r2, r1
 80214d2:	631a      	str	r2, [r3, #48]	; 0x30
 80214d4:	e7f0      	b.n	80214b8 <HAL_CRYP_MspDeInit+0x8>
 80214d6:	46c0      	nop			; (mov r8, r8)
 80214d8:	58001800 	.word	0x58001800
 80214dc:	fffdffff 	.word	0xfffdffff

080214e0 <MX_GPIO_Init>:
/* USER CODE END 1 */

/** Configure pins
*/
void MX_GPIO_Init(void)
{
 80214e0:	b530      	push	{r4, r5, lr}
 80214e2:	b087      	sub	sp, #28

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80214e4:	2214      	movs	r2, #20
 80214e6:	2100      	movs	r1, #0
 80214e8:	a801      	add	r0, sp, #4
 80214ea:	f013 fb24 	bl	8034b36 <memset>
  SET_BIT(RCC->C2AHB2ENR, Periphs);
 80214ee:	21b0      	movs	r1, #176	; 0xb0
 80214f0:	05c9      	lsls	r1, r1, #23
 80214f2:	22a6      	movs	r2, #166	; 0xa6
 80214f4:	0052      	lsls	r2, r2, #1
 80214f6:	5888      	ldr	r0, [r1, r2]
 80214f8:	2302      	movs	r3, #2
 80214fa:	4318      	orrs	r0, r3
 80214fc:	5088      	str	r0, [r1, r2]
  tmpreg = READ_BIT(RCC->C2AHB2ENR, Periphs);
 80214fe:	588a      	ldr	r2, [r1, r2]
 8021500:	4013      	ands	r3, r2
 8021502:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 8021504:	9b00      	ldr	r3, [sp, #0]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, PROB2_Pin|PROB1_Pin, GPIO_PIN_RESET);
 8021506:	25c0      	movs	r5, #192	; 0xc0
 8021508:	01ad      	lsls	r5, r5, #6
 802150a:	4c09      	ldr	r4, [pc, #36]	; (8021530 <MX_GPIO_Init+0x50>)
 802150c:	2200      	movs	r2, #0
 802150e:	0029      	movs	r1, r5
 8021510:	0020      	movs	r0, r4
 8021512:	f003 f8e3 	bl	80246dc <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PBPin PBPin */
  GPIO_InitStruct.Pin = PROB2_Pin|PROB1_Pin;
 8021516:	9501      	str	r5, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8021518:	2301      	movs	r3, #1
 802151a:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 802151c:	2300      	movs	r3, #0
 802151e:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8021520:	3303      	adds	r3, #3
 8021522:	9304      	str	r3, [sp, #16]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8021524:	a901      	add	r1, sp, #4
 8021526:	0020      	movs	r0, r4
 8021528:	f003 f822 	bl	8024570 <HAL_GPIO_Init>

}
 802152c:	b007      	add	sp, #28
 802152e:	bd30      	pop	{r4, r5, pc}
 8021530:	48000400 	.word	0x48000400

08021534 <MX_IPCC_Init>:

IPCC_HandleTypeDef hipcc;

/* IPCC init function */
void MX_IPCC_Init(void)
{
 8021534:	b510      	push	{r4, lr}
  /* USER CODE END IPCC_Init 0 */

  /* USER CODE BEGIN IPCC_Init 1 */

  /* USER CODE END IPCC_Init 1 */
  hipcc.Instance = IPCC;
 8021536:	4805      	ldr	r0, [pc, #20]	; (802154c <MX_IPCC_Init+0x18>)
 8021538:	4b05      	ldr	r3, [pc, #20]	; (8021550 <MX_IPCC_Init+0x1c>)
 802153a:	6003      	str	r3, [r0, #0]
  if (HAL_IPCC_Init(&hipcc) != HAL_OK)
 802153c:	f003 f9b2 	bl	80248a4 <HAL_IPCC_Init>
 8021540:	2800      	cmp	r0, #0
 8021542:	d100      	bne.n	8021546 <MX_IPCC_Init+0x12>
  }
  /* USER CODE BEGIN IPCC_Init 2 */

  /* USER CODE END IPCC_Init 2 */

}
 8021544:	bd10      	pop	{r4, pc}
    Error_Handler();
 8021546:	f000 f8a4 	bl	8021692 <Error_Handler>
}
 802154a:	e7fb      	b.n	8021544 <MX_IPCC_Init+0x10>
 802154c:	2000b194 	.word	0x2000b194
 8021550:	58000c00 	.word	0x58000c00

08021554 <HAL_IPCC_MspInit>:

void HAL_IPCC_MspInit(IPCC_HandleTypeDef* ipccHandle)
{
 8021554:	b510      	push	{r4, lr}
 8021556:	b082      	sub	sp, #8

  if(ipccHandle->Instance==IPCC)
 8021558:	6802      	ldr	r2, [r0, #0]
 802155a:	4b0d      	ldr	r3, [pc, #52]	; (8021590 <HAL_IPCC_MspInit+0x3c>)
 802155c:	429a      	cmp	r2, r3
 802155e:	d001      	beq.n	8021564 <HAL_IPCC_MspInit+0x10>
    HAL_NVIC_EnableIRQ(IPCC_C2_RX_C2_TX_IRQn);
  /* USER CODE BEGIN IPCC_MspInit 1 */

  /* USER CODE END IPCC_MspInit 1 */
  }
}
 8021560:	b002      	add	sp, #8
 8021562:	bd10      	pop	{r4, pc}
  SET_BIT(RCC->C2AHB3ENR, Periphs);
 8021564:	21b0      	movs	r1, #176	; 0xb0
 8021566:	05c9      	lsls	r1, r1, #23
 8021568:	22a8      	movs	r2, #168	; 0xa8
 802156a:	0052      	lsls	r2, r2, #1
 802156c:	5888      	ldr	r0, [r1, r2]
 802156e:	2480      	movs	r4, #128	; 0x80
 8021570:	0364      	lsls	r4, r4, #13
 8021572:	4320      	orrs	r0, r4
 8021574:	5088      	str	r0, [r1, r2]
  tmpreg = READ_BIT(RCC->C2AHB3ENR, Periphs);
 8021576:	588b      	ldr	r3, [r1, r2]
 8021578:	4023      	ands	r3, r4
 802157a:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 802157c:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(IPCC_C2_RX_C2_TX_IRQn, 1, 0);
 802157e:	2200      	movs	r2, #0
 8021580:	2101      	movs	r1, #1
 8021582:	2012      	movs	r0, #18
 8021584:	f001 fe96 	bl	80232b4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(IPCC_C2_RX_C2_TX_IRQn);
 8021588:	2012      	movs	r0, #18
 802158a:	f001 fec3 	bl	8023314 <HAL_NVIC_EnableIRQ>
}
 802158e:	e7e7      	b.n	8021560 <HAL_IPCC_MspInit+0xc>
 8021590:	58000c00 	.word	0x58000c00

08021594 <IpccIfIsrTxCb>:
/* USER CODE END EF */

/* Private Functions Definition -----------------------------------------------*/

static void IpccIfIsrTxCb(IPCC_HandleTypeDef *hIpcc, uint32_t ChannelIndex, IPCC_CHANNELDirTypeDef ChannelDir)
{
 8021594:	b510      	push	{r4, lr}
 8021596:	0008      	movs	r0, r1

  /* USER CODE END IpccIfIsrTxCb_1 */
  UNUSED(hIpcc);
  UNUSED(ChannelDir);

  IpccAcknowledgeRcv(ChannelIndex);
 8021598:	4b01      	ldr	r3, [pc, #4]	; (80215a0 <IpccIfIsrTxCb+0xc>)
 802159a:	681b      	ldr	r3, [r3, #0]
 802159c:	4798      	blx	r3
  return;
  /* USER CODE BEGIN IpccIfIsrTxCb_2 */

  /* USER CODE END IpccIfIsrTxCb_2 */
}
 802159e:	bd10      	pop	{r4, pc}
 80215a0:	2000b1d0 	.word	0x2000b1d0

080215a4 <IpccIfIsrRxCb>:

static void IpccIfIsrRxCb(IPCC_HandleTypeDef *hIpcc, uint32_t ChannelIndex, IPCC_CHANNELDirTypeDef ChannelDir)
{
 80215a4:	b510      	push	{r4, lr}
 80215a6:	0008      	movs	r0, r1

  /* USER CODE END IpccIfIsrRxCb_1 */
  UNUSED(hIpcc);
  UNUSED(ChannelDir);

  IpccCommandRcv(ChannelIndex);
 80215a8:	4b01      	ldr	r3, [pc, #4]	; (80215b0 <IpccIfIsrRxCb+0xc>)
 80215aa:	681b      	ldr	r3, [r3, #0]
 80215ac:	4798      	blx	r3
  return;
  /* USER CODE BEGIN IpccIfIsrRxCb_2 */

  /* USER CODE END IpccIfIsrRxCb_2 */
}
 80215ae:	bd10      	pop	{r4, pc}
 80215b0:	2000b1d4 	.word	0x2000b1d4

080215b4 <IPCC_IF_Init>:
{
 80215b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80215b6:	b083      	sub	sp, #12
 80215b8:	0007      	movs	r7, r0
 80215ba:	000e      	movs	r6, r1
  MX_IPCC_Init();
 80215bc:	f7ff ffba 	bl	8021534 <MX_IPCC_Init>
  SET_BIT(RCC->C2AHB3ENR, Periphs);
 80215c0:	21b0      	movs	r1, #176	; 0xb0
 80215c2:	05c9      	lsls	r1, r1, #23
 80215c4:	22a8      	movs	r2, #168	; 0xa8
 80215c6:	0052      	lsls	r2, r2, #1
 80215c8:	5888      	ldr	r0, [r1, r2]
 80215ca:	2480      	movs	r4, #128	; 0x80
 80215cc:	0364      	lsls	r4, r4, #13
 80215ce:	4320      	orrs	r0, r4
 80215d0:	5088      	str	r0, [r1, r2]
  tmpreg = READ_BIT(RCC->C2AHB3ENR, Periphs);
 80215d2:	588b      	ldr	r3, [r1, r2]
 80215d4:	4023      	ands	r3, r4
 80215d6:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 80215d8:	9b01      	ldr	r3, [sp, #4]
  *         (*) value not defined in all devices
  * @retval None
  */
__STATIC_INLINE void LL_C2_EXTI_EnableIT_32_63(uint32_t ExtiLine)
{
  SET_BIT(EXTI->C2IMR2, ExtiLine);
 80215da:	4b10      	ldr	r3, [pc, #64]	; (802161c <IPCC_IF_Init+0x68>)
 80215dc:	3a80      	subs	r2, #128	; 0x80
 80215de:	5899      	ldr	r1, [r3, r2]
 80215e0:	2020      	movs	r0, #32
 80215e2:	4301      	orrs	r1, r0
 80215e4:	5099      	str	r1, [r3, r2]
  *         @arg @ref LL_EXTI_LINE_45
  * @retval None
  */
__STATIC_INLINE void LL_EXTI_EnableRisingTrig_32_63(uint32_t ExtiLine)
{
  SET_BIT(EXTI->RTSR2, ExtiLine);
 80215e6:	6a1a      	ldr	r2, [r3, #32]
 80215e8:	4302      	orrs	r2, r0
 80215ea:	621a      	str	r2, [r3, #32]
  for (int32_t i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 80215ec:	2400      	movs	r4, #0
 80215ee:	e00d      	b.n	802160c <IPCC_IF_Init+0x58>
    HAL_IPCC_ActivateNotification(&hipcc, i, IPCC_CHANNEL_DIR_TX, IpccIfIsrTxCb);
 80215f0:	4d0b      	ldr	r5, [pc, #44]	; (8021620 <IPCC_IF_Init+0x6c>)
 80215f2:	4b0c      	ldr	r3, [pc, #48]	; (8021624 <IPCC_IF_Init+0x70>)
 80215f4:	2200      	movs	r2, #0
 80215f6:	0021      	movs	r1, r4
 80215f8:	0028      	movs	r0, r5
 80215fa:	f003 f8e1 	bl	80247c0 <HAL_IPCC_ActivateNotification>
    HAL_IPCC_ActivateNotification(&hipcc, i, IPCC_CHANNEL_DIR_RX, IpccIfIsrRxCb);
 80215fe:	4b0a      	ldr	r3, [pc, #40]	; (8021628 <IPCC_IF_Init+0x74>)
 8021600:	2201      	movs	r2, #1
 8021602:	0021      	movs	r1, r4
 8021604:	0028      	movs	r0, r5
 8021606:	f003 f8db 	bl	80247c0 <HAL_IPCC_ActivateNotification>
  for (int32_t i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 802160a:	3401      	adds	r4, #1
 802160c:	2c05      	cmp	r4, #5
 802160e:	d9ef      	bls.n	80215f0 <IPCC_IF_Init+0x3c>
  IpccCommandRcv = IPCC_IF_CommandRcv_cb;
 8021610:	4b06      	ldr	r3, [pc, #24]	; (802162c <IPCC_IF_Init+0x78>)
 8021612:	601f      	str	r7, [r3, #0]
  IpccAcknowledgeRcv = IPCC_IF_AcknowledgeRcv_cb;
 8021614:	4b06      	ldr	r3, [pc, #24]	; (8021630 <IPCC_IF_Init+0x7c>)
 8021616:	601e      	str	r6, [r3, #0]
}
 8021618:	b003      	add	sp, #12
 802161a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802161c:	58000800 	.word	0x58000800
 8021620:	2000b194 	.word	0x2000b194
 8021624:	08021595 	.word	0x08021595
 8021628:	080215a5 	.word	0x080215a5
 802162c:	2000b1d4 	.word	0x2000b1d4
 8021630:	2000b1d0 	.word	0x2000b1d0

08021634 <IPCC_IF_NotificationSnd>:
{
 8021634:	b510      	push	{r4, lr}
 8021636:	0001      	movs	r1, r0
  if (HAL_OK != HAL_IPCC_NotifyCPU(&hipcc, channelIdx, IPCC_CHANNEL_DIR_TX))
 8021638:	2200      	movs	r2, #0
 802163a:	4805      	ldr	r0, [pc, #20]	; (8021650 <IPCC_IF_NotificationSnd+0x1c>)
 802163c:	f003 f8f0 	bl	8024820 <HAL_IPCC_NotifyCPU>
 8021640:	2800      	cmp	r0, #0
 8021642:	d101      	bne.n	8021648 <IPCC_IF_NotificationSnd+0x14>
    return 0;
 8021644:	2000      	movs	r0, #0
}
 8021646:	bd10      	pop	{r4, pc}
    return -1;
 8021648:	2001      	movs	r0, #1
 802164a:	4240      	negs	r0, r0
 802164c:	e7fb      	b.n	8021646 <IPCC_IF_NotificationSnd+0x12>
 802164e:	46c0      	nop			; (mov r8, r8)
 8021650:	2000b194 	.word	0x2000b194

08021654 <IPCC_IF_ResponseSnd>:
{
 8021654:	b510      	push	{r4, lr}
 8021656:	0001      	movs	r1, r0
  if (HAL_OK != HAL_IPCC_NotifyCPU(&hipcc, channelIdx, IPCC_CHANNEL_DIR_RX))
 8021658:	2201      	movs	r2, #1
 802165a:	4805      	ldr	r0, [pc, #20]	; (8021670 <IPCC_IF_ResponseSnd+0x1c>)
 802165c:	f003 f8e0 	bl	8024820 <HAL_IPCC_NotifyCPU>
 8021660:	2800      	cmp	r0, #0
 8021662:	d101      	bne.n	8021668 <IPCC_IF_ResponseSnd+0x14>
    return 0;
 8021664:	2000      	movs	r0, #0
}
 8021666:	bd10      	pop	{r4, pc}
    return -1;
 8021668:	2001      	movs	r0, #1
 802166a:	4240      	negs	r0, r0
 802166c:	e7fb      	b.n	8021666 <IPCC_IF_ResponseSnd+0x12>
 802166e:	46c0      	nop			; (mov r8, r8)
 8021670:	2000b194 	.word	0x2000b194

08021674 <KMS_LL_Initialize>:
CK_RV KMS_LL_Initialize(void)
{
  /* USER CODE BEGIN KMS_LL_Initialize */
  return CKR_OK;
  /* USER CODE END KMS_LL_Initialize */
}
 8021674:	2000      	movs	r0, #0
 8021676:	4770      	bx	lr

08021678 <KMS_LL_ReportError>:
void KMS_LL_ReportError(uint32_t Error)
{
  /* USER CODE BEGIN KMS_LL_ReportError */

  /* USER CODE END KMS_LL_ReportError */
}
 8021678:	4770      	bx	lr

0802167a <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 802167a:	b510      	push	{r4, lr}
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 802167c:	f001 fde6 	bl	802324c <HAL_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8021680:	f7ff ff2e 	bl	80214e0 <MX_GPIO_Init>
  MX_KMS_Init();
 8021684:	f000 fbfb 	bl	8021e7e <MX_KMS_Init>
  MX_LoRaWAN_Init();
 8021688:	f000 fbfe 	bl	8021e88 <MX_LoRaWAN_Init>
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */
    MX_LoRaWAN_Process();
 802168c:	f000 fc00 	bl	8021e90 <MX_LoRaWAN_Process>
  while (1)
 8021690:	e7fc      	b.n	802168c <main+0x12>

08021692 <Error_Handler>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8021692:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8021694:	e7fe      	b.n	8021694 <Error_Handler+0x2>

08021696 <get_page>:
  */
static uint32_t get_page(uint32_t Addr)
{
  uint32_t page;

  page = (Addr - FLASH_BASE) / FLASH_PAGE_SIZE;
 8021696:	23f8      	movs	r3, #248	; 0xf8
 8021698:	061b      	lsls	r3, r3, #24
 802169a:	469c      	mov	ip, r3
 802169c:	4460      	add	r0, ip
 802169e:	0ac0      	lsrs	r0, r0, #11

  return page;
}
 80216a0:	4770      	bx	lr
	...

080216a4 <page_write>:
{
 80216a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80216a6:	b083      	sub	sp, #12
 80216a8:	0006      	movs	r6, r0
                     ((uint32_t) * destinationp & (NVMS_LL_PAGE_SIZE - 1UL)));
 80216aa:	680f      	ldr	r7, [r1, #0]
 80216ac:	2507      	movs	r5, #7
 80216ae:	403d      	ands	r5, r7
  maxsize = (size_t)(NVMS_LL_PAGE_SIZE -
 80216b0:	2308      	movs	r3, #8
 80216b2:	1b5d      	subs	r5, r3, r5
  if (maxsize > *sizep)
 80216b4:	6813      	ldr	r3, [r2, #0]
 80216b6:	42ab      	cmp	r3, r5
 80216b8:	d200      	bcs.n	80216bc <page_write+0x18>
    maxsize = *sizep;
 80216ba:	001d      	movs	r5, r3
  *sizep        -= maxsize;
 80216bc:	1b5b      	subs	r3, r3, r5
 80216be:	6013      	str	r3, [r2, #0]
  *destinationp += maxsize;
 80216c0:	680b      	ldr	r3, [r1, #0]
 80216c2:	195b      	adds	r3, r3, r5
 80216c4:	600b      	str	r3, [r1, #0]
  (void)HAL_FLASH_Unlock();
 80216c6:	f002 fcfd 	bl	80240c4 <HAL_FLASH_Unlock>
  HAL_StatusTypeDef ret = HAL_OK;
 80216ca:	2400      	movs	r4, #0
  while ((maxsize >= 8UL) && (ret == HAL_OK))
 80216cc:	e00c      	b.n	80216e8 <page_write+0x44>
    ret = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, (uint32_t)p, (uint64_t) * ((uint64_t *)(uint32_t) * sourcep));
 80216ce:	6833      	ldr	r3, [r6, #0]
 80216d0:	681a      	ldr	r2, [r3, #0]
 80216d2:	685b      	ldr	r3, [r3, #4]
 80216d4:	0039      	movs	r1, r7
 80216d6:	2001      	movs	r0, #1
 80216d8:	f002 fd5a 	bl	8024190 <HAL_FLASH_Program>
 80216dc:	0004      	movs	r4, r0
    p = &p[8];
 80216de:	3708      	adds	r7, #8
    *sourcep = &((*sourcep)[8]);
 80216e0:	6833      	ldr	r3, [r6, #0]
 80216e2:	3308      	adds	r3, #8
 80216e4:	6033      	str	r3, [r6, #0]
    maxsize -= 8UL;
 80216e6:	3d08      	subs	r5, #8
  while ((maxsize >= 8UL) && (ret == HAL_OK))
 80216e8:	2d07      	cmp	r5, #7
 80216ea:	d901      	bls.n	80216f0 <page_write+0x4c>
 80216ec:	2c00      	cmp	r4, #0
 80216ee:	d0ee      	beq.n	80216ce <page_write+0x2a>
  if (maxsize != 0UL)
 80216f0:	2d00      	cmp	r5, #0
 80216f2:	d106      	bne.n	8021702 <page_write+0x5e>
  (void)HAL_FLASH_Lock();
 80216f4:	f002 fcfe 	bl	80240f4 <HAL_FLASH_Lock>
  if (ret == HAL_OK)
 80216f8:	2c00      	cmp	r4, #0
 80216fa:	d014      	beq.n	8021726 <page_write+0x82>
  return true;
 80216fc:	2001      	movs	r0, #1
}
 80216fe:	b003      	add	sp, #12
 8021700:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uint8_t block[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
 8021702:	4668      	mov	r0, sp
 8021704:	4b09      	ldr	r3, [pc, #36]	; (802172c <page_write+0x88>)
 8021706:	0002      	movs	r2, r0
 8021708:	cb12      	ldmia	r3!, {r1, r4}
 802170a:	c212      	stmia	r2!, {r1, r4}
    (void)memcpy(block, *sourcep, maxsize);
 802170c:	002a      	movs	r2, r5
 802170e:	6831      	ldr	r1, [r6, #0]
 8021710:	f013 fa08 	bl	8034b24 <memcpy>
    ret = HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, (uint32_t)p, (uint64_t) * ((uint64_t *)(uint32_t) * sourcep));
 8021714:	6833      	ldr	r3, [r6, #0]
 8021716:	681a      	ldr	r2, [r3, #0]
 8021718:	685b      	ldr	r3, [r3, #4]
 802171a:	0039      	movs	r1, r7
 802171c:	2001      	movs	r0, #1
 802171e:	f002 fd37 	bl	8024190 <HAL_FLASH_Program>
 8021722:	0004      	movs	r4, r0
 8021724:	e7e6      	b.n	80216f4 <page_write+0x50>
    return false;
 8021726:	2000      	movs	r0, #0
 8021728:	e7e9      	b.n	80216fe <page_write+0x5a>
 802172a:	46c0      	nop			; (mov r8, r8)
 802172c:	08034c88 	.word	0x08034c88

08021730 <NVMS_LL_Init>:
  */
void NVMS_LL_Init(void)
{
  /* USER CODE BEGIN NVMS_LL_Init */
  /* USER CODE END NVMS_LL_Init */
}
 8021730:	4770      	bx	lr
	...

08021734 <NVMS_LL_IsBlockErased>:
/* Template version of the function */
bool NVMS_LL_IsBlockErased(nvms_block_t block)
{
  /* USER CODE BEGIN NVMS_LL_IsBlockErased */
  uint32_t i;
  uint32_t *p = (uint32_t *)((block == NVMS_BLOCK0) ? NVMS_LL_BLOCK0_ADDRESS :
 8021734:	2800      	cmp	r0, #0
 8021736:	d10b      	bne.n	8021750 <NVMS_LL_IsBlockErased+0x1c>
 8021738:	4a08      	ldr	r2, [pc, #32]	; (802175c <NVMS_LL_IsBlockErased+0x28>)
 802173a:	2300      	movs	r3, #0
                             NVMS_LL_BLOCK1_ADDRESS);

  for (i = 0; i < (NVMS_LL_BLOCK_SIZE / sizeof(uint32_t)); i++)
 802173c:	2180      	movs	r1, #128	; 0x80
 802173e:	0089      	lsls	r1, r1, #2
 8021740:	428b      	cmp	r3, r1
 8021742:	d207      	bcs.n	8021754 <NVMS_LL_IsBlockErased+0x20>
  {
    if (*p != NVMS_LL_ERASED)
 8021744:	6811      	ldr	r1, [r2, #0]
 8021746:	3101      	adds	r1, #1
 8021748:	d106      	bne.n	8021758 <NVMS_LL_IsBlockErased+0x24>
    {
      return false;
    }
    p++;
 802174a:	3204      	adds	r2, #4
  for (i = 0; i < (NVMS_LL_BLOCK_SIZE / sizeof(uint32_t)); i++)
 802174c:	3301      	adds	r3, #1
 802174e:	e7f5      	b.n	802173c <NVMS_LL_IsBlockErased+0x8>
  uint32_t *p = (uint32_t *)((block == NVMS_BLOCK0) ? NVMS_LL_BLOCK0_ADDRESS :
 8021750:	4a03      	ldr	r2, [pc, #12]	; (8021760 <NVMS_LL_IsBlockErased+0x2c>)
 8021752:	e7f2      	b.n	802173a <NVMS_LL_IsBlockErased+0x6>
  }
  return true;
 8021754:	2001      	movs	r0, #1
 8021756:	e000      	b.n	802175a <NVMS_LL_IsBlockErased+0x26>
      return false;
 8021758:	2000      	movs	r0, #0
  /* USER CODE END NVMS_LL_IsBlockErased */
}
 802175a:	4770      	bx	lr
 802175c:	0803d000 	.word	0x0803d000
 8021760:	0803d800 	.word	0x0803d800

08021764 <NVMS_LL_BlockErase>:
  * @retval false            if the operation is successful.
  * @retval true             if the erase operation failed.
  */
/* Template version of the function */
bool NVMS_LL_BlockErase(nvms_block_t block)
{
 8021764:	b510      	push	{r4, lr}
 8021766:	b084      	sub	sp, #16
 8021768:	0004      	movs	r4, r0
  /* USER CODE BEGIN NVMS_LL_BlockErase */
  /* Erase First Flash sector */
  FLASH_EraseInitTypeDef EraseInitStruct;
  uint32_t SectorError = 0;
 802176a:	2300      	movs	r3, #0
 802176c:	9300      	str	r3, [sp, #0]

  EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
 802176e:	3302      	adds	r3, #2
 8021770:	9301      	str	r3, [sp, #4]
  EraseInitStruct.Page        = get_page((block == NVMS_BLOCK0) ? NVMS_LL_BLOCK0_ADDRESS : NVMS_LL_BLOCK1_ADDRESS);
 8021772:	2800      	cmp	r0, #0
 8021774:	d115      	bne.n	80217a2 <NVMS_LL_BlockErase+0x3e>
 8021776:	480c      	ldr	r0, [pc, #48]	; (80217a8 <NVMS_LL_BlockErase+0x44>)
 8021778:	f7ff ff8d 	bl	8021696 <get_page>
 802177c:	9002      	str	r0, [sp, #8]
  EraseInitStruct.NbPages     = NVMS_LL_NB_PAGE_PER_BLOCK;
 802177e:	2301      	movs	r3, #1
 8021780:	9303      	str	r3, [sp, #12]

  /* Unlock the Flash to enable the flash control register access *************/
  (void)HAL_FLASH_Unlock();
 8021782:	f002 fc9f 	bl	80240c4 <HAL_FLASH_Unlock>

  if (HAL_FLASHEx_Erase(&EraseInitStruct, &SectorError) != HAL_OK)
 8021786:	4669      	mov	r1, sp
 8021788:	a801      	add	r0, sp, #4
 802178a:	f002 feb1 	bl	80244f0 <HAL_FLASHEx_Erase>
      FLASH_ErrorTypeDef errorcode = HAL_FLASH_GetError(); */
  }

  /* Lock the Flash to disable the flash control register access (recommended
  to protect the FLASH memory against possible unwanted operation) *********/
  (void)HAL_FLASH_Lock();
 802178e:	f002 fcb1 	bl	80240f4 <HAL_FLASH_Lock>

  /* Operation verification.*/
  return !NVMS_LL_IsBlockErased(block);
 8021792:	0020      	movs	r0, r4
 8021794:	f7ff ffce 	bl	8021734 <NVMS_LL_IsBlockErased>
 8021798:	2301      	movs	r3, #1
 802179a:	4058      	eors	r0, r3
 802179c:	b2c0      	uxtb	r0, r0
  /* USER CODE END NVMS_LL_BlockErase */
}
 802179e:	b004      	add	sp, #16
 80217a0:	bd10      	pop	{r4, pc}
  EraseInitStruct.Page        = get_page((block == NVMS_BLOCK0) ? NVMS_LL_BLOCK0_ADDRESS : NVMS_LL_BLOCK1_ADDRESS);
 80217a2:	4802      	ldr	r0, [pc, #8]	; (80217ac <NVMS_LL_BlockErase+0x48>)
 80217a4:	e7e8      	b.n	8021778 <NVMS_LL_BlockErase+0x14>
 80217a6:	46c0      	nop			; (mov r8, r8)
 80217a8:	0803d000 	.word	0x0803d000
 80217ac:	0803d800 	.word	0x0803d800

080217b0 <NVMS_LL_Write>:
  * @retval false            if the operation is successful.
  * @retval true             if the write operation failed.
  */
/* Template version of the function */
bool NVMS_LL_Write(const uint8_t *source, uint8_t *destination, size_t size)
{
 80217b0:	b570      	push	{r4, r5, r6, lr}
 80217b2:	b084      	sub	sp, #16
 80217b4:	0004      	movs	r4, r0
 80217b6:	000d      	movs	r5, r1
 80217b8:	0016      	movs	r6, r2
  /* USER CODE BEGIN NVMS_LL_Write */
  const uint8_t *s = source;
 80217ba:	9003      	str	r0, [sp, #12]
  uint8_t *d = destination;
 80217bc:	9102      	str	r1, [sp, #8]
  size_t sz = size;
 80217be:	9201      	str	r2, [sp, #4]

  while (sz > 0UL)
 80217c0:	9b01      	ldr	r3, [sp, #4]
 80217c2:	2b00      	cmp	r3, #0
 80217c4:	d007      	beq.n	80217d6 <NVMS_LL_Write+0x26>
  {
    /* Writes as much as a single operation allows.*/
    if (page_write(&s, &d, &sz))
 80217c6:	aa01      	add	r2, sp, #4
 80217c8:	a902      	add	r1, sp, #8
 80217ca:	a803      	add	r0, sp, #12
 80217cc:	f7ff ff6a 	bl	80216a4 <page_write>
 80217d0:	2800      	cmp	r0, #0
 80217d2:	d0f5      	beq.n	80217c0 <NVMS_LL_Write+0x10>
 80217d4:	e007      	b.n	80217e6 <NVMS_LL_Write+0x36>
      return true;
    }
  }

  /* Operation verification.*/
  return (bool)(memcmp(source, destination, size) != 0);
 80217d6:	0032      	movs	r2, r6
 80217d8:	0029      	movs	r1, r5
 80217da:	0020      	movs	r0, r4
 80217dc:	f013 f994 	bl	8034b08 <memcmp>
 80217e0:	1e43      	subs	r3, r0, #1
 80217e2:	4198      	sbcs	r0, r3
 80217e4:	b2c0      	uxtb	r0, r0
  /* USER CODE END NVMS_LL_Write */
}
 80217e6:	b004      	add	sp, #16
 80217e8:	bd70      	pop	{r4, r5, r6, pc}
	...

080217ec <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 80217ec:	b500      	push	{lr}
 80217ee:	b08d      	sub	sp, #52	; 0x34

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_AlarmTypeDef sAlarm = {0};
 80217f0:	222c      	movs	r2, #44	; 0x2c
 80217f2:	2100      	movs	r1, #0
 80217f4:	a801      	add	r0, sp, #4
 80217f6:	f013 f99e 	bl	8034b36 <memset>

  /* USER CODE END RTC_Init 1 */

  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
 80217fa:	4821      	ldr	r0, [pc, #132]	; (8021880 <MX_RTC_Init+0x94>)
 80217fc:	4b21      	ldr	r3, [pc, #132]	; (8021884 <MX_RTC_Init+0x98>)
 80217fe:	6003      	str	r3, [r0, #0]
  hrtc.Init.AsynchPrediv = RTC_PREDIV_A;
 8021800:	231f      	movs	r3, #31
 8021802:	6083      	str	r3, [r0, #8]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 8021804:	2300      	movs	r3, #0
 8021806:	6103      	str	r3, [r0, #16]
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 8021808:	6143      	str	r3, [r0, #20]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 802180a:	6183      	str	r3, [r0, #24]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 802180c:	2280      	movs	r2, #128	; 0x80
 802180e:	05d2      	lsls	r2, r2, #23
 8021810:	61c2      	str	r2, [r0, #28]
  hrtc.Init.OutPutPullUp = RTC_OUTPUT_PULLUP_NONE;
 8021812:	6203      	str	r3, [r0, #32]
  hrtc.Init.BinMode = RTC_BINARY_ONLY;
 8021814:	3301      	adds	r3, #1
 8021816:	33ff      	adds	r3, #255	; 0xff
 8021818:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 802181a:	f003 fb8f 	bl	8024f3c <HAL_RTC_Init>
 802181e:	2800      	cmp	r0, #0
 8021820:	d121      	bne.n	8021866 <MX_RTC_Init+0x7a>

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  if (HAL_RTCEx_SetSSRU_IT(&hrtc) != HAL_OK)
 8021822:	4817      	ldr	r0, [pc, #92]	; (8021880 <MX_RTC_Init+0x94>)
 8021824:	f003 fcde 	bl	80251e4 <HAL_RTCEx_SetSSRU_IT>
 8021828:	2800      	cmp	r0, #0
 802182a:	d11f      	bne.n	802186c <MX_RTC_Init+0x80>
    Error_Handler();
  }

  /** Enable the Alarm A
  */
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 802182c:	2300      	movs	r3, #0
 802182e:	9308      	str	r3, [sp, #32]
  sAlarm.AlarmTime.SubSeconds = 0x0;
 8021830:	9302      	str	r3, [sp, #8]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 8021832:	9306      	str	r3, [sp, #24]
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 8021834:	2380      	movs	r3, #128	; 0x80
 8021836:	059b      	lsls	r3, r3, #22
 8021838:	9307      	str	r3, [sp, #28]
  sAlarm.Alarm = RTC_ALARM_A;
 802183a:	2380      	movs	r3, #128	; 0x80
 802183c:	005b      	lsls	r3, r3, #1
 802183e:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 8021840:	2200      	movs	r2, #0
 8021842:	a901      	add	r1, sp, #4
 8021844:	480e      	ldr	r0, [pc, #56]	; (8021880 <MX_RTC_Init+0x94>)
 8021846:	f003 fbe1 	bl	802500c <HAL_RTC_SetAlarm_IT>
 802184a:	2800      	cmp	r0, #0
 802184c:	d111      	bne.n	8021872 <MX_RTC_Init+0x86>
    Error_Handler();
  }

  /** Enable the Alarm B
  */
  sAlarm.Alarm = RTC_ALARM_B;
 802184e:	2380      	movs	r3, #128	; 0x80
 8021850:	009b      	lsls	r3, r3, #2
 8021852:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, 0) != HAL_OK)
 8021854:	2200      	movs	r2, #0
 8021856:	a901      	add	r1, sp, #4
 8021858:	4809      	ldr	r0, [pc, #36]	; (8021880 <MX_RTC_Init+0x94>)
 802185a:	f003 fbd7 	bl	802500c <HAL_RTC_SetAlarm_IT>
 802185e:	2800      	cmp	r0, #0
 8021860:	d10a      	bne.n	8021878 <MX_RTC_Init+0x8c>
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}
 8021862:	b00d      	add	sp, #52	; 0x34
 8021864:	bd00      	pop	{pc}
    Error_Handler();
 8021866:	f7ff ff14 	bl	8021692 <Error_Handler>
 802186a:	e7da      	b.n	8021822 <MX_RTC_Init+0x36>
    Error_Handler();
 802186c:	f7ff ff11 	bl	8021692 <Error_Handler>
 8021870:	e7dc      	b.n	802182c <MX_RTC_Init+0x40>
    Error_Handler();
 8021872:	f7ff ff0e 	bl	8021692 <Error_Handler>
 8021876:	e7ea      	b.n	802184e <MX_RTC_Init+0x62>
    Error_Handler();
 8021878:	f7ff ff0b 	bl	8021692 <Error_Handler>
}
 802187c:	e7f1      	b.n	8021862 <MX_RTC_Init+0x76>
 802187e:	46c0      	nop			; (mov r8, r8)
 8021880:	2000b1d8 	.word	0x2000b1d8
 8021884:	40002800 	.word	0x40002800

08021888 <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{
 8021888:	b510      	push	{r4, lr}
 802188a:	b090      	sub	sp, #64	; 0x40
 802188c:	0004      	movs	r4, r0

  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 802188e:	2238      	movs	r2, #56	; 0x38
 8021890:	2100      	movs	r1, #0
 8021892:	a802      	add	r0, sp, #8
 8021894:	f013 f94f 	bl	8034b36 <memset>
  if(rtcHandle->Instance==RTC)
 8021898:	6822      	ldr	r2, [r4, #0]
 802189a:	4b17      	ldr	r3, [pc, #92]	; (80218f8 <HAL_RTC_MspInit+0x70>)
 802189c:	429a      	cmp	r2, r3
 802189e:	d001      	beq.n	80218a4 <HAL_RTC_MspInit+0x1c>
    HAL_NVIC_EnableIRQ(RTC_LSECSS_IRQn);
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
 80218a0:	b010      	add	sp, #64	; 0x40
 80218a2:	bd10      	pop	{r4, pc}
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 80218a4:	2380      	movs	r3, #128	; 0x80
 80218a6:	025b      	lsls	r3, r3, #9
 80218a8:	9302      	str	r3, [sp, #8]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 80218aa:	2380      	movs	r3, #128	; 0x80
 80218ac:	005b      	lsls	r3, r3, #1
 80218ae:	930f      	str	r3, [sp, #60]	; 0x3c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80218b0:	a802      	add	r0, sp, #8
 80218b2:	f003 f941 	bl	8024b38 <HAL_RCCEx_PeriphCLKConfig>
 80218b6:	2800      	cmp	r0, #0
 80218b8:	d11b      	bne.n	80218f2 <HAL_RTC_MspInit+0x6a>
  * @rmtoll BDCR         RTCEN         LL_RCC_EnableRTC
  * @retval None
  */
__STATIC_INLINE void LL_RCC_EnableRTC(void)
{
  SET_BIT(RCC->BDCR, RCC_BDCR_RTCEN);
 80218ba:	23b0      	movs	r3, #176	; 0xb0
 80218bc:	05db      	lsls	r3, r3, #23
 80218be:	2190      	movs	r1, #144	; 0x90
 80218c0:	5858      	ldr	r0, [r3, r1]
 80218c2:	2280      	movs	r2, #128	; 0x80
 80218c4:	0212      	lsls	r2, r2, #8
 80218c6:	4302      	orrs	r2, r0
 80218c8:	505a      	str	r2, [r3, r1]
  * @retval None
  */
__STATIC_INLINE void LL_C2_APB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->C2APB1ENR1, Periphs);
 80218ca:	22ac      	movs	r2, #172	; 0xac
 80218cc:	0052      	lsls	r2, r2, #1
 80218ce:	5899      	ldr	r1, [r3, r2]
 80218d0:	2080      	movs	r0, #128	; 0x80
 80218d2:	00c0      	lsls	r0, r0, #3
 80218d4:	4301      	orrs	r1, r0
 80218d6:	5099      	str	r1, [r3, r2]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->C2APB1ENR1, Periphs);
 80218d8:	589b      	ldr	r3, [r3, r2]
 80218da:	4003      	ands	r3, r0
 80218dc:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 80218de:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(RTC_LSECSS_IRQn, 0, 0);
 80218e0:	2200      	movs	r2, #0
 80218e2:	2100      	movs	r1, #0
 80218e4:	2002      	movs	r0, #2
 80218e6:	f001 fce5 	bl	80232b4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RTC_LSECSS_IRQn);
 80218ea:	2002      	movs	r0, #2
 80218ec:	f001 fd12 	bl	8023314 <HAL_NVIC_EnableIRQ>
}
 80218f0:	e7d6      	b.n	80218a0 <HAL_RTC_MspInit+0x18>
      Error_Handler();
 80218f2:	f7ff fece 	bl	8021692 <Error_Handler>
 80218f6:	e7e0      	b.n	80218ba <HAL_RTC_MspInit+0x32>
 80218f8:	40002800 	.word	0x40002800

080218fc <PWR_EnterOffMode>:
void PWR_EnterOffMode(void)
{
  /* USER CODE BEGIN EnterOffMode_1 */

  /* USER CODE END EnterOffMode_1 */
}
 80218fc:	4770      	bx	lr

080218fe <PWR_ExitOffMode>:
void PWR_ExitOffMode(void)
{
  /* USER CODE BEGIN ExitOffMode_1 */

  /* USER CODE END ExitOffMode_1 */
}
 80218fe:	4770      	bx	lr

08021900 <PWR_EnterStopMode>:

void PWR_EnterStopMode(void)
{
 8021900:	b510      	push	{r4, lr}
  /* USER CODE BEGIN EnterStopMode_1 */

  /* USER CODE END EnterStopMode_1 */
  HAL_SuspendTick();
 8021902:	f001 fcb5 	bl	8023270 <HAL_SuspendTick>
  * @rmtoll EXTSCR       C2CSSF        LL_PWR_ClearFlag_C2STOP_C2STB
  * @retval None
  */
__STATIC_INLINE void LL_PWR_ClearFlag_C2STOP_C2STB(void)
{
  WRITE_REG(PWR->EXTSCR, PWR_EXTSCR_C2CSSF);
 8021906:	4a04      	ldr	r2, [pc, #16]	; (8021918 <PWR_EnterStopMode+0x18>)
 8021908:	2388      	movs	r3, #136	; 0x88
 802190a:	2102      	movs	r1, #2
 802190c:	50d1      	str	r1, [r2, r3]
  LL_PWR_ClearFlag_C2STOP_C2STB();

  /* USER CODE BEGIN EnterStopMode_2 */

  /* USER CODE END EnterStopMode_2 */
  HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
 802190e:	2001      	movs	r0, #1
 8021910:	f003 f84a 	bl	80249a8 <HAL_PWREx_EnterSTOP2Mode>
  /* USER CODE BEGIN EnterStopMode_3 */

  /* USER CODE END EnterStopMode_3 */
}
 8021914:	bd10      	pop	{r4, pc}
 8021916:	46c0      	nop			; (mov r8, r8)
 8021918:	58000400 	.word	0x58000400

0802191c <PWR_ExitStopMode>:

void PWR_ExitStopMode(void)
{
 802191c:	b510      	push	{r4, lr}
  /* USER CODE BEGIN ExitStopMode_1 */

  /* USER CODE END ExitStopMode_1 */
  /* Resume sysTick : work around for debugger problem in dual core */
  HAL_ResumeTick();
 802191e:	f001 fcaf 	bl	8023280 <HAL_ResumeTick>
    SRAM ctrls, DMAx, DMAMux, AES, RNG, HSEM  */

  /* USER CODE BEGIN ExitStopMode_2 */

  /* USER CODE END ExitStopMode_2 */
}
 8021922:	bd10      	pop	{r4, pc}

08021924 <PWR_ExitSleepMode>:

  /* USER CODE END EnterSleepMode_3 */
}

void PWR_ExitSleepMode(void)
{
 8021924:	b510      	push	{r4, lr}
  /* USER CODE BEGIN ExitSleepMode_1 */

  /* USER CODE END ExitSleepMode_1 */
  /* Resume sysTick */
  HAL_ResumeTick();
 8021926:	f001 fcab 	bl	8023280 <HAL_ResumeTick>

  /* USER CODE BEGIN ExitSleepMode_2 */

  /* USER CODE END ExitSleepMode_2 */
}
 802192a:	bd10      	pop	{r4, pc}

0802192c <PWR_EnterSleepMode>:
{
 802192c:	b510      	push	{r4, lr}
  HAL_SuspendTick();
 802192e:	f001 fc9f 	bl	8023270 <HAL_SuspendTick>
  HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
 8021932:	2101      	movs	r1, #1
 8021934:	2000      	movs	r0, #0
 8021936:	f002 ffe1 	bl	80248fc <HAL_PWR_EnterSLEEPMode>
}
 802193a:	bd10      	pop	{r4, pc}

0802193c <HAL_MspInit>:
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 802193c:	4770      	bx	lr

0802193e <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 802193e:	e7fe      	b.n	802193e <NMI_Handler>

08021940 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8021940:	e7fe      	b.n	8021940 <HardFault_Handler>

08021942 <SVC_Handler>:

  /* USER CODE END SVC_IRQn 0 */
  /* USER CODE BEGIN SVC_IRQn 1 */

  /* USER CODE END SVC_IRQn 1 */
}
 8021942:	4770      	bx	lr

08021944 <PendSV_Handler>:

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8021944:	4770      	bx	lr

08021946 <SysTick_Handler>:

  /* USER CODE END SysTick_IRQn 0 */
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8021946:	4770      	bx	lr

08021948 <RTC_LSECSS_IRQHandler>:

/**
  * @brief This function handles RTC Wakeup + RTC Tamper and RTC TimeStamp + RTC Alarms (A & B) and RTC SSRU Interrupts and LSECSS Interrupts.
  */
void RTC_LSECSS_IRQHandler(void)
{
 8021948:	b510      	push	{r4, lr}
  /* USER CODE BEGIN RTC_LSECSS_IRQn 0 */

  /* USER CODE END RTC_LSECSS_IRQn 0 */
  HAL_RTC_AlarmIRQHandler(&hrtc);
 802194a:	4c04      	ldr	r4, [pc, #16]	; (802195c <RTC_LSECSS_IRQHandler+0x14>)
 802194c:	0020      	movs	r0, r4
 802194e:	f003 fa6f 	bl	8024e30 <HAL_RTC_AlarmIRQHandler>
  HAL_RTCEx_SSRUIRQHandler(&hrtc);
 8021952:	0020      	movs	r0, r4
 8021954:	f003 fc76 	bl	8025244 <HAL_RTCEx_SSRUIRQHandler>
  /* USER CODE BEGIN RTC_LSECSS_IRQn 1 */

  /* USER CODE END RTC_LSECSS_IRQn 1 */
}
 8021958:	bd10      	pop	{r4, pc}
 802195a:	46c0      	nop			; (mov r8, r8)
 802195c:	2000b1d8 	.word	0x2000b1d8

08021960 <IPCC_C2_RX_C2_TX_IRQHandler>:

/**
  * @brief This function handles IPCC RX Occupied and TX Free Interrupt.
  */
void IPCC_C2_RX_C2_TX_IRQHandler(void)
{
 8021960:	b510      	push	{r4, lr}
  /* USER CODE BEGIN IPCC_C2_RX_C2_TX_IRQn 0 */

  /* USER CODE END IPCC_C2_RX_C2_TX_IRQn 0 */
  HAL_IPCC_RX_IRQHandler(&hipcc);
 8021962:	4c04      	ldr	r4, [pc, #16]	; (8021974 <IPCC_C2_RX_C2_TX_IRQHandler+0x14>)
 8021964:	0020      	movs	r0, r4
 8021966:	f002 feeb 	bl	8024740 <HAL_IPCC_RX_IRQHandler>
  HAL_IPCC_TX_IRQHandler(&hipcc);
 802196a:	0020      	movs	r0, r4
 802196c:	f002 febe 	bl	80246ec <HAL_IPCC_TX_IRQHandler>
  /* USER CODE BEGIN IPCC_C2_RX_C2_TX_IRQn 1 */

  /* USER CODE END IPCC_C2_RX_C2_TX_IRQn 1 */
}
 8021970:	bd10      	pop	{r4, pc}
 8021972:	46c0      	nop			; (mov r8, r8)
 8021974:	2000b194 	.word	0x2000b194

08021978 <SUBGHZ_Radio_IRQHandler>:

/**
  * @brief This function handles SUBGHZ Radio Interrupt.
  */
void SUBGHZ_Radio_IRQHandler(void)
{
 8021978:	b510      	push	{r4, lr}
  /* USER CODE BEGIN SUBGHZ_Radio_IRQn 0 */

  /* USER CODE END SUBGHZ_Radio_IRQn 0 */
  HAL_SUBGHZ_IRQHandler(&hsubghz);
 802197a:	4802      	ldr	r0, [pc, #8]	; (8021984 <SUBGHZ_Radio_IRQHandler+0xc>)
 802197c:	f003 ff24 	bl	80257c8 <HAL_SUBGHZ_IRQHandler>
  /* USER CODE BEGIN SUBGHZ_Radio_IRQn 1 */

  /* USER CODE END SUBGHZ_Radio_IRQn 1 */
}
 8021980:	bd10      	pop	{r4, pc}
 8021982:	46c0      	nop			; (mov r8, r8)
 8021984:	2000b210 	.word	0x2000b210

08021988 <MX_SUBGHZ_Init>:

SUBGHZ_HandleTypeDef hsubghz;

/* SUBGHZ init function */
void MX_SUBGHZ_Init(void)
{
 8021988:	b510      	push	{r4, lr}
  /* USER CODE END SUBGHZ_Init 0 */

  /* USER CODE BEGIN SUBGHZ_Init 1 */

  /* USER CODE END SUBGHZ_Init 1 */
  hsubghz.Init.BaudratePrescaler = SUBGHZSPI_BAUDRATEPRESCALER_4;
 802198a:	4805      	ldr	r0, [pc, #20]	; (80219a0 <MX_SUBGHZ_Init+0x18>)
 802198c:	2308      	movs	r3, #8
 802198e:	6003      	str	r3, [r0, #0]
  if (HAL_SUBGHZ_Init(&hsubghz) != HAL_OK)
 8021990:	f003 fc8e 	bl	80252b0 <HAL_SUBGHZ_Init>
 8021994:	2800      	cmp	r0, #0
 8021996:	d100      	bne.n	802199a <MX_SUBGHZ_Init+0x12>
  }
  /* USER CODE BEGIN SUBGHZ_Init 2 */

  /* USER CODE END SUBGHZ_Init 2 */

}
 8021998:	bd10      	pop	{r4, pc}
    Error_Handler();
 802199a:	f7ff fe7a 	bl	8021692 <Error_Handler>
}
 802199e:	e7fb      	b.n	8021998 <MX_SUBGHZ_Init+0x10>
 80219a0:	2000b210 	.word	0x2000b210

080219a4 <HAL_SUBGHZ_MspInit>:

void HAL_SUBGHZ_MspInit(SUBGHZ_HandleTypeDef* subghzHandle)
{
 80219a4:	b500      	push	{lr}
 80219a6:	b083      	sub	sp, #12
  * @retval None
  */
__STATIC_INLINE void LL_C2_APB3_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->C2APB3ENR, Periphs);
 80219a8:	21b0      	movs	r1, #176	; 0xb0
 80219aa:	05c9      	lsls	r1, r1, #23
 80219ac:	22b2      	movs	r2, #178	; 0xb2
 80219ae:	0052      	lsls	r2, r2, #1
 80219b0:	5888      	ldr	r0, [r1, r2]
 80219b2:	2301      	movs	r3, #1
 80219b4:	4318      	orrs	r0, r3
 80219b6:	5088      	str	r0, [r1, r2]
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->C2APB3ENR, Periphs);
 80219b8:	588a      	ldr	r2, [r1, r2]
 80219ba:	4013      	ands	r3, r2
 80219bc:	9301      	str	r3, [sp, #4]
  (void)tmpreg;
 80219be:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE END SUBGHZ_MspInit 0 */
    /* SUBGHZ clock enable */
    __HAL_RCC_SUBGHZSPI_CLK_ENABLE();

    /* SUBGHZ interrupt Init */
    HAL_NVIC_SetPriority(SUBGHZ_Radio_IRQn, 0, 0);
 80219c0:	2200      	movs	r2, #0
 80219c2:	2100      	movs	r1, #0
 80219c4:	201f      	movs	r0, #31
 80219c6:	f001 fc75 	bl	80232b4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SUBGHZ_Radio_IRQn);
 80219ca:	201f      	movs	r0, #31
 80219cc:	f001 fca2 	bl	8023314 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN SUBGHZ_MspInit 1 */

  /* USER CODE END SUBGHZ_MspInit 1 */
}
 80219d0:	b003      	add	sp, #12
 80219d2:	bd00      	pop	{pc}

080219d4 <System_Init>:

/* USER CODE END EF */

/* Private functions ---------------------------------------------------------*/
static void System_Init(void)
{
 80219d4:	b570      	push	{r4, r5, r6, lr}
  CLEAR_BIT(PWR->C2CR3, PWR_C2CR3_EIWUL);
 80219d6:	4d13      	ldr	r5, [pc, #76]	; (8021a24 <System_Init+0x50>)
 80219d8:	2484      	movs	r4, #132	; 0x84
 80219da:	592b      	ldr	r3, [r5, r4]
 80219dc:	4e12      	ldr	r6, [pc, #72]	; (8021a28 <System_Init+0x54>)
 80219de:	4033      	ands	r3, r6
 80219e0:	512b      	str	r3, [r5, r4]
  CLEAR_BIT(EXTI->C2IMR1, ExtiLine);
 80219e2:	4b12      	ldr	r3, [pc, #72]	; (8021a2c <System_Init+0x58>)
 80219e4:	21c0      	movs	r1, #192	; 0xc0
 80219e6:	585a      	ldr	r2, [r3, r1]
 80219e8:	2090      	movs	r0, #144	; 0x90
 80219ea:	0340      	lsls	r0, r0, #13
 80219ec:	4002      	ands	r2, r0
 80219ee:	505a      	str	r2, [r3, r1]
  CLEAR_BIT(EXTI->C2IMR2, ExtiLine);
 80219f0:	22d0      	movs	r2, #208	; 0xd0
 80219f2:	5899      	ldr	r1, [r3, r2]
 80219f4:	480e      	ldr	r0, [pc, #56]	; (8021a30 <System_Init+0x5c>)
 80219f6:	4001      	ands	r1, r0
 80219f8:	5099      	str	r1, [r3, r2]
  MODIFY_REG(PWR->C2CR3, PWR_C2CR3_EWRFIRQ, RadioIRQTrigger);
 80219fa:	5929      	ldr	r1, [r5, r4]
 80219fc:	480d      	ldr	r0, [pc, #52]	; (8021a34 <System_Init+0x60>)
 80219fe:	4001      	ands	r1, r0
 8021a00:	2080      	movs	r0, #128	; 0x80
 8021a02:	0180      	lsls	r0, r0, #6
 8021a04:	4301      	orrs	r1, r0
 8021a06:	5129      	str	r1, [r5, r4]
  SET_BIT(EXTI->C2IMR2, ExtiLine);
 8021a08:	589c      	ldr	r4, [r3, r2]
 8021a0a:	2180      	movs	r1, #128	; 0x80
 8021a0c:	0149      	lsls	r1, r1, #5
 8021a0e:	4321      	orrs	r1, r4
 8021a10:	5099      	str	r1, [r3, r2]
 8021a12:	5899      	ldr	r1, [r3, r2]
 8021a14:	4308      	orrs	r0, r1
 8021a16:	5098      	str	r0, [r3, r2]
  MODIFY_REG(RCC->CFGR, RCC_CFGR_STOPWUCK, Clock);
 8021a18:	22b0      	movs	r2, #176	; 0xb0
 8021a1a:	05d2      	lsls	r2, r2, #23
 8021a1c:	6893      	ldr	r3, [r2, #8]
 8021a1e:	4033      	ands	r3, r6
 8021a20:	6093      	str	r3, [r2, #8]
  /* Ensure that MSI is wake-up system clock */
  __HAL_RCC_WAKEUPSTOP_CLK_CONFIG(RCC_STOP_WAKEUPCLOCK_MSI);
  /* USER CODE BEGIN System_Init_Last */

  /* USER CODE END System_Init_Last */
}
 8021a22:	bd70      	pop	{r4, r5, r6, pc}
 8021a24:	58000400 	.word	0x58000400
 8021a28:	ffff7fff 	.word	0xffff7fff
 8021a2c:	58000800 	.word	0x58000800
 8021a30:	000070a0 	.word	0x000070a0
 8021a34:	ffffdfff 	.word	0xffffdfff

08021a38 <tiny_snprintf_like>:

  /* USER CODE END UTIL_LPM_SetStopMode_2 */
}

static void tiny_snprintf_like(char *buf, uint32_t maxsize, const char *strFormat, ...)
{
 8021a38:	b40c      	push	{r2, r3}
 8021a3a:	b500      	push	{lr}
 8021a3c:	b083      	sub	sp, #12
 8021a3e:	ab04      	add	r3, sp, #16
 8021a40:	cb04      	ldmia	r3!, {r2}
  /* USER CODE BEGIN tiny_snprintf_like_1 */

  /* USER CODE END tiny_snprintf_like_1 */
  va_list vaArgs;
  va_start(vaArgs, strFormat);
 8021a42:	9301      	str	r3, [sp, #4]
  UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
 8021a44:	f012 ff78 	bl	8034938 <tiny_vsnprintf_like>
  va_end(vaArgs);
  /* USER CODE BEGIN tiny_snprintf_like_2 */

  /* USER CODE END tiny_snprintf_like_2 */
}
 8021a48:	b003      	add	sp, #12
 8021a4a:	bc08      	pop	{r3}
 8021a4c:	b002      	add	sp, #8
 8021a4e:	4718      	bx	r3

08021a50 <SystemApp_Init>:
{
 8021a50:	b510      	push	{r4, lr}
  UTIL_TIMER_Init();
 8021a52:	f012 fd33 	bl	80344bc <UTIL_TIMER_Init>
  SYS_TimerInitialisedFlag = 1;
 8021a56:	4b0a      	ldr	r3, [pc, #40]	; (8021a80 <SystemApp_Init+0x30>)
 8021a58:	2201      	movs	r2, #1
 8021a5a:	701a      	strb	r2, [r3, #0]
  UTIL_LPM_Init();
 8021a5c:	f012 fac4 	bl	8033fe8 <UTIL_LPM_Init>
  UTIL_LPM_SetOffMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
 8021a60:	2101      	movs	r1, #1
 8021a62:	2001      	movs	r0, #1
 8021a64:	f012 fae0 	bl	8034028 <UTIL_LPM_SetOffMode>
  FEAT_INFO_Init();
 8021a68:	f000 fd7e 	bl	8022568 <FEAT_INFO_Init>
  init_status = MBMUXIF_SystemInit();
 8021a6c:	f001 f81a 	bl	8022aa4 <MBMUXIF_SystemInit>
  if (init_status < 0)
 8021a70:	2800      	cmp	r0, #0
 8021a72:	db02      	blt.n	8021a7a <SystemApp_Init+0x2a>
  System_Init();
 8021a74:	f7ff ffae 	bl	80219d4 <System_Init>
}
 8021a78:	bd10      	pop	{r4, pc}
    Error_Handler();
 8021a7a:	f7ff fe0a 	bl	8021692 <Error_Handler>
 8021a7e:	e7f9      	b.n	8021a74 <SystemApp_Init+0x24>
 8021a80:	2000b21c 	.word	0x2000b21c

08021a84 <TimestampNow>:
{
 8021a84:	b570      	push	{r4, r5, r6, lr}
 8021a86:	b084      	sub	sp, #16
 8021a88:	0004      	movs	r4, r0
 8021a8a:	000d      	movs	r5, r1
  SysTime_t curtime = SysTimeGet();
 8021a8c:	ae02      	add	r6, sp, #8
 8021a8e:	0030      	movs	r0, r6
 8021a90:	f012 fc92 	bl	80343b8 <SysTimeGet>
  tiny_snprintf_like((char *)buff, MAX_TS_SIZE, "%ds%03d:", curtime.Seconds, curtime.SubSeconds);
 8021a94:	2204      	movs	r2, #4
 8021a96:	5eb3      	ldrsh	r3, [r6, r2]
 8021a98:	9300      	str	r3, [sp, #0]
 8021a9a:	9b02      	ldr	r3, [sp, #8]
 8021a9c:	4a05      	ldr	r2, [pc, #20]	; (8021ab4 <TimestampNow+0x30>)
 8021a9e:	2110      	movs	r1, #16
 8021aa0:	0020      	movs	r0, r4
 8021aa2:	f7ff ffc9 	bl	8021a38 <tiny_snprintf_like>
  *size = strlen((char *)buff);
 8021aa6:	0020      	movs	r0, r4
 8021aa8:	f7fe fb2e 	bl	8020108 <strlen>
 8021aac:	8028      	strh	r0, [r5, #0]
}
 8021aae:	b004      	add	sp, #16
 8021ab0:	bd70      	pop	{r4, r5, r6, pc}
 8021ab2:	46c0      	nop			; (mov r8, r8)
 8021ab4:	08034d44 	.word	0x08034d44

08021ab8 <Process_Sys_Cmd>:
{
 8021ab8:	b510      	push	{r4, lr}
  APP_LOG(TS_ON, VLEVEL_L, ">CM0PLUS(System)\r\n");
 8021aba:	4b08      	ldr	r3, [pc, #32]	; (8021adc <Process_Sys_Cmd+0x24>)
 8021abc:	2201      	movs	r2, #1
 8021abe:	2100      	movs	r1, #0
 8021ac0:	2001      	movs	r0, #1
 8021ac2:	f012 f9d5 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
  APP_LOG(TS_ON, VLEVEL_M, "<CM0PLUS(System)\r\n");
 8021ac6:	4b06      	ldr	r3, [pc, #24]	; (8021ae0 <Process_Sys_Cmd+0x28>)
 8021ac8:	2201      	movs	r2, #1
 8021aca:	2100      	movs	r1, #0
 8021acc:	2002      	movs	r0, #2
 8021ace:	f012 f9cf 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
  MBMUX_ResponseSnd(FEAT_INFO_SYSTEM_ID);
 8021ad2:	2000      	movs	r0, #0
 8021ad4:	f000 fe68 	bl	80227a8 <MBMUX_ResponseSnd>
}
 8021ad8:	bd10      	pop	{r4, pc}
 8021ada:	46c0      	nop			; (mov r8, r8)
 8021adc:	08034d50 	.word	0x08034d50
 8021ae0:	08034d64 	.word	0x08034d64

08021ae4 <UTIL_SEQ_EvtIdle>:
{
 8021ae4:	b510      	push	{r4, lr}
  UTIL_SEQ_Run(~TaskId_bm);
 8021ae6:	43c0      	mvns	r0, r0
 8021ae8:	f012 fb2e 	bl	8034148 <UTIL_SEQ_Run>
}
 8021aec:	bd10      	pop	{r4, pc}

08021aee <UTIL_SEQ_Idle>:
{
 8021aee:	b510      	push	{r4, lr}
  UTIL_LPM_EnterLowPower();
 8021af0:	f012 fab0 	bl	8034054 <UTIL_LPM_EnterLowPower>
}
 8021af4:	bd10      	pop	{r4, pc}
	...

08021af8 <GetUniqueId>:
{
 8021af8:	b570      	push	{r4, r5, r6, lr}
 8021afa:	0004      	movs	r4, r0
  * @brief  Return the Unique Device Number
  * @retval Values between Min_Data=0x00000000 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_FLASH_GetUDN(void)
{
  return (READ_REG(*((uint32_t *)UID64_BASE)));
 8021afc:	4b16      	ldr	r3, [pc, #88]	; (8021b58 <GetUniqueId+0x60>)
 8021afe:	681b      	ldr	r3, [r3, #0]
  if (val == 0xFFFFFFFF)  /* Normally this should not happen */
 8021b00:	1c5a      	adds	r2, r3, #1
 8021b02:	d011      	beq.n	8021b28 <GetUniqueId+0x30>
    id[7] = val & 0xFF;
 8021b04:	71c3      	strb	r3, [r0, #7]
    id[6] = (val >> 8) & 0xFF;
 8021b06:	0a1a      	lsrs	r2, r3, #8
 8021b08:	7182      	strb	r2, [r0, #6]
    id[5] = (val >> 16) & 0xFF;
 8021b0a:	0c1a      	lsrs	r2, r3, #16
 8021b0c:	7142      	strb	r2, [r0, #5]
    id[4] = (val >> 24) & 0xFF;
 8021b0e:	0e1b      	lsrs	r3, r3, #24
 8021b10:	7103      	strb	r3, [r0, #4]
  *         For STM32WLxxxx devices, the device ID is 0x15
  * @retval Values between Min_Data=0x00 and Max_Data=0xFF (ex: Device ID is 0x15)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetDeviceID(void)
{
  return ((READ_REG(*((uint32_t *)UID64_BASE + 1U))) & 0x000000FFU);
 8021b12:	4b12      	ldr	r3, [pc, #72]	; (8021b5c <GetUniqueId+0x64>)
    id[3] = val & 0xFF;
 8021b14:	681a      	ldr	r2, [r3, #0]
 8021b16:	70c2      	strb	r2, [r0, #3]
  * @note   For STM32WLxxxx devices, the ST Company ID is 0x0080E1
  * @retval Values between Min_Data=0x00 and Max_Data=0xFFFFFF (ex: ST Company ID is 0x0080E1)
  */
__STATIC_INLINE uint32_t LL_FLASH_GetSTCompanyID(void)
{
  return (((READ_REG(*((uint32_t *)UID64_BASE + 1U))) >> 8U) & 0x00FFFFFFU);
 8021b18:	681b      	ldr	r3, [r3, #0]
 8021b1a:	0a1a      	lsrs	r2, r3, #8
    id[2] = val & 0xFF;
 8021b1c:	7082      	strb	r2, [r0, #2]
    id[1] = (val >> 8) & 0xFF;
 8021b1e:	0c1a      	lsrs	r2, r3, #16
 8021b20:	7042      	strb	r2, [r0, #1]
    id[0] = (val >> 16) & 0xFF;
 8021b22:	0e1b      	lsrs	r3, r3, #24
 8021b24:	7003      	strb	r3, [r0, #0]
}
 8021b26:	bd70      	pop	{r4, r5, r6, pc}
    uint32_t ID_1_3_val = HAL_GetUIDw0() + HAL_GetUIDw2();
 8021b28:	f001 fbb2 	bl	8023290 <HAL_GetUIDw0>
 8021b2c:	0005      	movs	r5, r0
 8021b2e:	f001 fbbb 	bl	80232a8 <HAL_GetUIDw2>
 8021b32:	182d      	adds	r5, r5, r0
    uint32_t ID_2_val = HAL_GetUIDw1();
 8021b34:	f001 fbb2 	bl	802329c <HAL_GetUIDw1>
    id[7] = (ID_1_3_val) >> 24;
 8021b38:	0e2b      	lsrs	r3, r5, #24
 8021b3a:	71e3      	strb	r3, [r4, #7]
    id[6] = (ID_1_3_val) >> 16;
 8021b3c:	0c2b      	lsrs	r3, r5, #16
 8021b3e:	71a3      	strb	r3, [r4, #6]
    id[5] = (ID_1_3_val) >> 8;
 8021b40:	0a2b      	lsrs	r3, r5, #8
 8021b42:	7163      	strb	r3, [r4, #5]
    id[4] = (ID_1_3_val);
 8021b44:	7125      	strb	r5, [r4, #4]
    id[3] = (ID_2_val) >> 24;
 8021b46:	0e03      	lsrs	r3, r0, #24
 8021b48:	70e3      	strb	r3, [r4, #3]
    id[2] = (ID_2_val) >> 16;
 8021b4a:	0c03      	lsrs	r3, r0, #16
 8021b4c:	70a3      	strb	r3, [r4, #2]
    id[1] = (ID_2_val) >> 8;
 8021b4e:	0a03      	lsrs	r3, r0, #8
 8021b50:	7063      	strb	r3, [r4, #1]
    id[0] = (ID_2_val);
 8021b52:	7020      	strb	r0, [r4, #0]
 8021b54:	e7e7      	b.n	8021b26 <GetUniqueId+0x2e>
 8021b56:	46c0      	nop			; (mov r8, r8)
 8021b58:	1fff7580 	.word	0x1fff7580
 8021b5c:	1fff7584 	.word	0x1fff7584

08021b60 <GetDevAddr>:
{
 8021b60:	b570      	push	{r4, r5, r6, lr}
 8021b62:	0004      	movs	r4, r0
  return (READ_REG(*((uint32_t *)UID64_BASE)));
 8021b64:	4b08      	ldr	r3, [pc, #32]	; (8021b88 <GetDevAddr+0x28>)
 8021b66:	681b      	ldr	r3, [r3, #0]
  *devAddr = LL_FLASH_GetUDN();
 8021b68:	6003      	str	r3, [r0, #0]
  if (*devAddr == 0xFFFFFFFF)
 8021b6a:	3301      	adds	r3, #1
 8021b6c:	d000      	beq.n	8021b70 <GetDevAddr+0x10>
}
 8021b6e:	bd70      	pop	{r4, r5, r6, pc}
    *devAddr = ((HAL_GetUIDw0()) ^ (HAL_GetUIDw1()) ^ (HAL_GetUIDw2()));
 8021b70:	f001 fb8e 	bl	8023290 <HAL_GetUIDw0>
 8021b74:	0005      	movs	r5, r0
 8021b76:	f001 fb91 	bl	802329c <HAL_GetUIDw1>
 8021b7a:	4045      	eors	r5, r0
 8021b7c:	f001 fb94 	bl	80232a8 <HAL_GetUIDw2>
 8021b80:	4045      	eors	r5, r0
 8021b82:	6025      	str	r5, [r4, #0]
}
 8021b84:	e7f3      	b.n	8021b6e <GetDevAddr+0xe>
 8021b86:	46c0      	nop			; (mov r8, r8)
 8021b88:	1fff7580 	.word	0x1fff7580

08021b8c <UTIL_ADV_TRACE_PreSendHook>:
{
 8021b8c:	b510      	push	{r4, lr}
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_DISABLE);
 8021b8e:	2101      	movs	r1, #1
 8021b90:	2002      	movs	r0, #2
 8021b92:	f012 fa33 	bl	8033ffc <UTIL_LPM_SetStopMode>
}
 8021b96:	bd10      	pop	{r4, pc}

08021b98 <UTIL_ADV_TRACE_PostSendHook>:
{
 8021b98:	b510      	push	{r4, lr}
  UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_ENABLE);
 8021b9a:	2100      	movs	r1, #0
 8021b9c:	2002      	movs	r0, #2
 8021b9e:	f012 fa2d 	bl	8033ffc <UTIL_LPM_SetStopMode>
}
 8021ba2:	bd10      	pop	{r4, pc}

08021ba4 <HAL_InitTick>:
  /* USER CODE END HAL_InitTick_1 */
  return HAL_OK;
  /* USER CODE BEGIN HAL_InitTick_2 */

  /* USER CODE END HAL_InitTick_2 */
}
 8021ba4:	2000      	movs	r0, #0
 8021ba6:	4770      	bx	lr

08021ba8 <HAL_GetTick>:

/**
  * @note This function overwrites the __weak one from HAL
  */
uint32_t HAL_GetTick(void)
{
 8021ba8:	b510      	push	{r4, lr}
  uint32_t ret = 0;
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_GetTick_1 */

  /* USER CODE END HAL_GetTick_1 */
  if (SYS_TimerInitialisedFlag == 0)
 8021baa:	4b04      	ldr	r3, [pc, #16]	; (8021bbc <HAL_GetTick+0x14>)
 8021bac:	781b      	ldrb	r3, [r3, #0]
 8021bae:	2b00      	cmp	r3, #0
 8021bb0:	d101      	bne.n	8021bb6 <HAL_GetTick+0xe>
  uint32_t ret = 0;
 8021bb2:	2000      	movs	r0, #0
  }
  /* USER CODE BEGIN HAL_GetTick_2 */

  /* USER CODE END HAL_GetTick_2 */
  return ret;
}
 8021bb4:	bd10      	pop	{r4, pc}
    ret = TIMER_IF_GetTimerValue();
 8021bb6:	f000 f835 	bl	8021c24 <TIMER_IF_GetTimerValue>
 8021bba:	e7fb      	b.n	8021bb4 <HAL_GetTick+0xc>
 8021bbc:	2000b21c 	.word	0x2000b21c

08021bc0 <HAL_Delay>:

/**
  * @note This function overwrites the __weak one from HAL
  */
void HAL_Delay(__IO uint32_t Delay)
{
 8021bc0:	b500      	push	{lr}
 8021bc2:	b083      	sub	sp, #12
 8021bc4:	9001      	str	r0, [sp, #4]
  /* TIMER_IF can be based on other counter the SysTick e.g. RTC */
  /* USER CODE BEGIN HAL_Delay_1 */

  /* USER CODE END HAL_Delay_1 */
  TIMER_IF_DelayMs(Delay);
 8021bc6:	9801      	ldr	r0, [sp, #4]
 8021bc8:	f000 f918 	bl	8021dfc <TIMER_IF_DelayMs>
  /* USER CODE BEGIN HAL_Delay_2 */

  /* USER CODE END HAL_Delay_2 */
}
 8021bcc:	b003      	add	sp, #12
 8021bce:	bd00      	pop	{pc}

08021bd0 <TIMER_IF_SetTimerContext>:
  * @retval If binary mode is none, Value between Min_Data=0x0 and Max_Data=0x7FFF
  *         else Value between Min_Data=0x0 and Max_Data=0xFFFFFFFF
  */
__STATIC_INLINE uint32_t LL_RTC_TIME_GetSubSecond(RTC_TypeDef *RTCx)
{
  return (uint32_t)(READ_BIT(RTCx->SSR, RTC_SSR_SS));
 8021bd0:	4b06      	ldr	r3, [pc, #24]	; (8021bec <TIMER_IF_SetTimerContext+0x1c>)
 8021bd2:	6898      	ldr	r0, [r3, #8]
  /* USER CODE BEGIN GetTimerTicks */

  /* USER CODE END GetTimerTicks */
  uint32_t ssr = LL_RTC_TIME_GetSubSecond(RTC);
  /* read twice to make sure value it valid*/
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8021bd4:	e001      	b.n	8021bda <TIMER_IF_SetTimerContext+0xa>
 8021bd6:	4b05      	ldr	r3, [pc, #20]	; (8021bec <TIMER_IF_SetTimerContext+0x1c>)
 8021bd8:	6898      	ldr	r0, [r3, #8]
 8021bda:	4b04      	ldr	r3, [pc, #16]	; (8021bec <TIMER_IF_SetTimerContext+0x1c>)
 8021bdc:	689b      	ldr	r3, [r3, #8]
 8021bde:	4283      	cmp	r3, r0
 8021be0:	d1f9      	bne.n	8021bd6 <TIMER_IF_SetTimerContext+0x6>
  {
    ssr = LL_RTC_TIME_GetSubSecond(RTC);
  }
  return UINT32_MAX - ssr;
 8021be2:	43c0      	mvns	r0, r0
  RtcTimerContext = GetTimerTicks();
 8021be4:	4b02      	ldr	r3, [pc, #8]	; (8021bf0 <TIMER_IF_SetTimerContext+0x20>)
 8021be6:	6018      	str	r0, [r3, #0]
}
 8021be8:	4770      	bx	lr
 8021bea:	46c0      	nop			; (mov r8, r8)
 8021bec:	40002800 	.word	0x40002800
 8021bf0:	2000b220 	.word	0x2000b220

08021bf4 <TIMER_IF_GetTimerContext>:
  return RtcTimerContext;
 8021bf4:	4b01      	ldr	r3, [pc, #4]	; (8021bfc <TIMER_IF_GetTimerContext+0x8>)
 8021bf6:	6818      	ldr	r0, [r3, #0]
}
 8021bf8:	4770      	bx	lr
 8021bfa:	46c0      	nop			; (mov r8, r8)
 8021bfc:	2000b220 	.word	0x2000b220

08021c00 <TIMER_IF_GetTimerElapsedTime>:
 8021c00:	4b06      	ldr	r3, [pc, #24]	; (8021c1c <TIMER_IF_GetTimerElapsedTime+0x1c>)
 8021c02:	6898      	ldr	r0, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8021c04:	e001      	b.n	8021c0a <TIMER_IF_GetTimerElapsedTime+0xa>
 8021c06:	4b05      	ldr	r3, [pc, #20]	; (8021c1c <TIMER_IF_GetTimerElapsedTime+0x1c>)
 8021c08:	6898      	ldr	r0, [r3, #8]
 8021c0a:	4b04      	ldr	r3, [pc, #16]	; (8021c1c <TIMER_IF_GetTimerElapsedTime+0x1c>)
 8021c0c:	689b      	ldr	r3, [r3, #8]
 8021c0e:	4283      	cmp	r3, r0
 8021c10:	d1f9      	bne.n	8021c06 <TIMER_IF_GetTimerElapsedTime+0x6>
  return UINT32_MAX - ssr;
 8021c12:	43c0      	mvns	r0, r0
  ret = ((uint32_t)(GetTimerTicks() - RtcTimerContext));
 8021c14:	4b02      	ldr	r3, [pc, #8]	; (8021c20 <TIMER_IF_GetTimerElapsedTime+0x20>)
 8021c16:	681b      	ldr	r3, [r3, #0]
 8021c18:	1ac0      	subs	r0, r0, r3
}
 8021c1a:	4770      	bx	lr
 8021c1c:	40002800 	.word	0x40002800
 8021c20:	2000b220 	.word	0x2000b220

08021c24 <TIMER_IF_GetTimerValue>:
  if (RTC_Initialized == true)
 8021c24:	4b08      	ldr	r3, [pc, #32]	; (8021c48 <TIMER_IF_GetTimerValue+0x24>)
 8021c26:	781b      	ldrb	r3, [r3, #0]
 8021c28:	2b00      	cmp	r3, #0
 8021c2a:	d00a      	beq.n	8021c42 <TIMER_IF_GetTimerValue+0x1e>
 8021c2c:	4b07      	ldr	r3, [pc, #28]	; (8021c4c <TIMER_IF_GetTimerValue+0x28>)
 8021c2e:	6898      	ldr	r0, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8021c30:	e001      	b.n	8021c36 <TIMER_IF_GetTimerValue+0x12>
 8021c32:	4b06      	ldr	r3, [pc, #24]	; (8021c4c <TIMER_IF_GetTimerValue+0x28>)
 8021c34:	6898      	ldr	r0, [r3, #8]
 8021c36:	4b05      	ldr	r3, [pc, #20]	; (8021c4c <TIMER_IF_GetTimerValue+0x28>)
 8021c38:	689b      	ldr	r3, [r3, #8]
 8021c3a:	4283      	cmp	r3, r0
 8021c3c:	d1f9      	bne.n	8021c32 <TIMER_IF_GetTimerValue+0xe>
  return UINT32_MAX - ssr;
 8021c3e:	43c0      	mvns	r0, r0
}
 8021c40:	4770      	bx	lr
  uint32_t ret = 0;
 8021c42:	2000      	movs	r0, #0
  return ret;
 8021c44:	e7fc      	b.n	8021c40 <TIMER_IF_GetTimerValue+0x1c>
 8021c46:	46c0      	nop			; (mov r8, r8)
 8021c48:	2000b21d 	.word	0x2000b21d
 8021c4c:	40002800 	.word	0x40002800

08021c50 <TIMER_IF_GetMinimumTimeout>:
}
 8021c50:	2003      	movs	r0, #3
 8021c52:	4770      	bx	lr

08021c54 <TIMER_IF_Convert_ms2Tick>:
{
 8021c54:	b510      	push	{r4, lr}
  ret = ((uint32_t)((((uint64_t) timeMilliSec) << RTC_N_PREDIV_S) / 1000));
 8021c56:	0d81      	lsrs	r1, r0, #22
 8021c58:	0280      	lsls	r0, r0, #10
 8021c5a:	22fa      	movs	r2, #250	; 0xfa
 8021c5c:	0092      	lsls	r2, r2, #2
 8021c5e:	2300      	movs	r3, #0
 8021c60:	f7fe fc0e 	bl	8020480 <__aeabi_uldivmod>
}
 8021c64:	bd10      	pop	{r4, pc}

08021c66 <TIMER_IF_Convert_Tick2ms>:
{
 8021c66:	b510      	push	{r4, lr}
  ret = ((uint32_t)((((uint64_t)(tick)) * 1000) >> RTC_N_PREDIV_S));
 8021c68:	22fa      	movs	r2, #250	; 0xfa
 8021c6a:	0092      	lsls	r2, r2, #2
 8021c6c:	2300      	movs	r3, #0
 8021c6e:	2100      	movs	r1, #0
 8021c70:	f7fe fc26 	bl	80204c0 <__aeabi_lmul>
 8021c74:	0589      	lsls	r1, r1, #22
 8021c76:	0a80      	lsrs	r0, r0, #10
 8021c78:	4308      	orrs	r0, r1
}
 8021c7a:	bd10      	pop	{r4, pc}

08021c7c <TIMER_IF_StopTimer>:
{
 8021c7c:	b510      	push	{r4, lr}
  __HAL_RTC_ALARM_CLEAR_FLAG(&hrtc, RTC_FLAG_ALRBF);
 8021c7e:	4b07      	ldr	r3, [pc, #28]	; (8021c9c <TIMER_IF_StopTimer+0x20>)
 8021c80:	2202      	movs	r2, #2
 8021c82:	65da      	str	r2, [r3, #92]	; 0x5c
  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_B);
 8021c84:	2180      	movs	r1, #128	; 0x80
 8021c86:	4c06      	ldr	r4, [pc, #24]	; (8021ca0 <TIMER_IF_StopTimer+0x24>)
 8021c88:	0089      	lsls	r1, r1, #2
 8021c8a:	0020      	movs	r0, r4
 8021c8c:	f003 f88c 	bl	8024da8 <HAL_RTC_DeactivateAlarm>
  hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8021c90:	2301      	movs	r3, #1
 8021c92:	425b      	negs	r3, r3
 8021c94:	6323      	str	r3, [r4, #48]	; 0x30
}
 8021c96:	2000      	movs	r0, #0
 8021c98:	bd10      	pop	{r4, pc}
 8021c9a:	46c0      	nop			; (mov r8, r8)
 8021c9c:	40002800 	.word	0x40002800
 8021ca0:	2000b1d8 	.word	0x2000b1d8

08021ca4 <TIMER_IF_BkUp_Write_MSBticks>:
{
 8021ca4:	b510      	push	{r4, lr}
 8021ca6:	0002      	movs	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_MSBTICKS, MSBticks);
 8021ca8:	2102      	movs	r1, #2
 8021caa:	4802      	ldr	r0, [pc, #8]	; (8021cb4 <TIMER_IF_BkUp_Write_MSBticks+0x10>)
 8021cac:	f003 fadc 	bl	8025268 <HAL_RTCEx_BKUPWrite>
}
 8021cb0:	bd10      	pop	{r4, pc}
 8021cb2:	46c0      	nop			; (mov r8, r8)
 8021cb4:	2000b1d8 	.word	0x2000b1d8

08021cb8 <TIMER_IF_Init>:
{
 8021cb8:	b570      	push	{r4, r5, r6, lr}
  if (RTC_Initialized == false)
 8021cba:	4b12      	ldr	r3, [pc, #72]	; (8021d04 <TIMER_IF_Init+0x4c>)
 8021cbc:	781b      	ldrb	r3, [r3, #0]
 8021cbe:	2b00      	cmp	r3, #0
 8021cc0:	d001      	beq.n	8021cc6 <TIMER_IF_Init+0xe>
}
 8021cc2:	2000      	movs	r0, #0
 8021cc4:	bd70      	pop	{r4, r5, r6, pc}
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8021cc6:	4c10      	ldr	r4, [pc, #64]	; (8021d08 <TIMER_IF_Init+0x50>)
 8021cc8:	2501      	movs	r5, #1
 8021cca:	426d      	negs	r5, r5
 8021ccc:	6325      	str	r5, [r4, #48]	; 0x30
    MX_RTC_Init();
 8021cce:	f7ff fd8d 	bl	80217ec <MX_RTC_Init>
    TIMER_IF_StopTimer();
 8021cd2:	f7ff ffd3 	bl	8021c7c <TIMER_IF_StopTimer>
    HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A); /* handled by Cm4 */
 8021cd6:	2180      	movs	r1, #128	; 0x80
 8021cd8:	0049      	lsls	r1, r1, #1
 8021cda:	0020      	movs	r0, r4
 8021cdc:	f003 f864 	bl	8024da8 <HAL_RTC_DeactivateAlarm>
    HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_B); /* handled by Cm0plus */
 8021ce0:	2180      	movs	r1, #128	; 0x80
 8021ce2:	0089      	lsls	r1, r1, #2
 8021ce4:	0020      	movs	r0, r4
 8021ce6:	f003 f85f 	bl	8024da8 <HAL_RTC_DeactivateAlarm>
    hrtc.IsEnabled.RtcFeatures = UINT32_MAX;
 8021cea:	6325      	str	r5, [r4, #48]	; 0x30
    HAL_RTCEx_EnableBypassShadow(&hrtc);
 8021cec:	0020      	movs	r0, r4
 8021cee:	f003 fa59 	bl	80251a4 <HAL_RTCEx_EnableBypassShadow>
    TIMER_IF_BkUp_Write_MSBticks(0);
 8021cf2:	2000      	movs	r0, #0
 8021cf4:	f7ff ffd6 	bl	8021ca4 <TIMER_IF_BkUp_Write_MSBticks>
    TIMER_IF_SetTimerContext();
 8021cf8:	f7ff ff6a 	bl	8021bd0 <TIMER_IF_SetTimerContext>
    RTC_Initialized = true;
 8021cfc:	4b01      	ldr	r3, [pc, #4]	; (8021d04 <TIMER_IF_Init+0x4c>)
 8021cfe:	2201      	movs	r2, #1
 8021d00:	701a      	strb	r2, [r3, #0]
 8021d02:	e7de      	b.n	8021cc2 <TIMER_IF_Init+0xa>
 8021d04:	2000b21d 	.word	0x2000b21d
 8021d08:	2000b1d8 	.word	0x2000b1d8

08021d0c <TIMER_IF_BkUp_Write_Seconds>:
{
 8021d0c:	b510      	push	{r4, lr}
 8021d0e:	0002      	movs	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SECONDS, Seconds);
 8021d10:	2100      	movs	r1, #0
 8021d12:	4802      	ldr	r0, [pc, #8]	; (8021d1c <TIMER_IF_BkUp_Write_Seconds+0x10>)
 8021d14:	f003 faa8 	bl	8025268 <HAL_RTCEx_BKUPWrite>
}
 8021d18:	bd10      	pop	{r4, pc}
 8021d1a:	46c0      	nop			; (mov r8, r8)
 8021d1c:	2000b1d8 	.word	0x2000b1d8

08021d20 <TIMER_IF_BkUp_Write_SubSeconds>:
{
 8021d20:	b510      	push	{r4, lr}
 8021d22:	0002      	movs	r2, r0
  HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_SUBSECONDS, SubSeconds);
 8021d24:	2101      	movs	r1, #1
 8021d26:	4802      	ldr	r0, [pc, #8]	; (8021d30 <TIMER_IF_BkUp_Write_SubSeconds+0x10>)
 8021d28:	f003 fa9e 	bl	8025268 <HAL_RTCEx_BKUPWrite>
}
 8021d2c:	bd10      	pop	{r4, pc}
 8021d2e:	46c0      	nop			; (mov r8, r8)
 8021d30:	2000b1d8 	.word	0x2000b1d8

08021d34 <TIMER_IF_StartTimer>:
{
 8021d34:	b510      	push	{r4, lr}
 8021d36:	b08c      	sub	sp, #48	; 0x30
 8021d38:	0004      	movs	r4, r0
  RTC_AlarmTypeDef sAlarm = {0};
 8021d3a:	222c      	movs	r2, #44	; 0x2c
 8021d3c:	2100      	movs	r1, #0
 8021d3e:	a801      	add	r0, sp, #4
 8021d40:	f012 fef9 	bl	8034b36 <memset>
  TIMER_IF_StopTimer();
 8021d44:	f7ff ff9a 	bl	8021c7c <TIMER_IF_StopTimer>
  timeout += RtcTimerContext;
 8021d48:	4b0d      	ldr	r3, [pc, #52]	; (8021d80 <TIMER_IF_StartTimer+0x4c>)
 8021d4a:	6818      	ldr	r0, [r3, #0]
 8021d4c:	1824      	adds	r4, r4, r0
  sAlarm.BinaryAutoClr = RTC_ALARMSUBSECONDBIN_AUTOCLR_NO;
 8021d4e:	2300      	movs	r3, #0
 8021d50:	9308      	str	r3, [sp, #32]
  sAlarm.AlarmTime.SubSeconds = UINT32_MAX - timeout;
 8021d52:	43e4      	mvns	r4, r4
 8021d54:	9402      	str	r4, [sp, #8]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 8021d56:	9306      	str	r3, [sp, #24]
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDBINMASK_NONE;
 8021d58:	2380      	movs	r3, #128	; 0x80
 8021d5a:	059b      	lsls	r3, r3, #22
 8021d5c:	9307      	str	r3, [sp, #28]
  sAlarm.Alarm = RTC_ALARM_B;
 8021d5e:	2380      	movs	r3, #128	; 0x80
 8021d60:	009b      	lsls	r3, r3, #2
 8021d62:	930b      	str	r3, [sp, #44]	; 0x2c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 8021d64:	2201      	movs	r2, #1
 8021d66:	a901      	add	r1, sp, #4
 8021d68:	4806      	ldr	r0, [pc, #24]	; (8021d84 <TIMER_IF_StartTimer+0x50>)
 8021d6a:	f003 f94f 	bl	802500c <HAL_RTC_SetAlarm_IT>
 8021d6e:	2800      	cmp	r0, #0
 8021d70:	d102      	bne.n	8021d78 <TIMER_IF_StartTimer+0x44>
}
 8021d72:	2000      	movs	r0, #0
 8021d74:	b00c      	add	sp, #48	; 0x30
 8021d76:	bd10      	pop	{r4, pc}
    Error_Handler();
 8021d78:	f7ff fc8b 	bl	8021692 <Error_Handler>
 8021d7c:	e7f9      	b.n	8021d72 <TIMER_IF_StartTimer+0x3e>
 8021d7e:	46c0      	nop			; (mov r8, r8)
 8021d80:	2000b220 	.word	0x2000b220
 8021d84:	2000b1d8 	.word	0x2000b1d8

08021d88 <TIMER_IF_BkUp_Read_MSBticks>:
{
 8021d88:	b510      	push	{r4, lr}
  MSBticks = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_MSBTICKS);
 8021d8a:	2102      	movs	r1, #2
 8021d8c:	4801      	ldr	r0, [pc, #4]	; (8021d94 <TIMER_IF_BkUp_Read_MSBticks+0xc>)
 8021d8e:	f003 fa73 	bl	8025278 <HAL_RTCEx_BKUPRead>
}
 8021d92:	bd10      	pop	{r4, pc}
 8021d94:	2000b1d8 	.word	0x2000b1d8

08021d98 <TIMER_IF_GetTime>:
{
 8021d98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8021d9a:	0005      	movs	r5, r0
 8021d9c:	4b0e      	ldr	r3, [pc, #56]	; (8021dd8 <TIMER_IF_GetTime+0x40>)
 8021d9e:	689c      	ldr	r4, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8021da0:	e001      	b.n	8021da6 <TIMER_IF_GetTime+0xe>
 8021da2:	4b0d      	ldr	r3, [pc, #52]	; (8021dd8 <TIMER_IF_GetTime+0x40>)
 8021da4:	689c      	ldr	r4, [r3, #8]
 8021da6:	4a0c      	ldr	r2, [pc, #48]	; (8021dd8 <TIMER_IF_GetTime+0x40>)
 8021da8:	6892      	ldr	r2, [r2, #8]
 8021daa:	42a2      	cmp	r2, r4
 8021dac:	d1f9      	bne.n	8021da2 <TIMER_IF_GetTime+0xa>
  return UINT32_MAX - ssr;
 8021dae:	43e4      	mvns	r4, r4
  uint32_t timerValueMSB = TIMER_IF_BkUp_Read_MSBticks();
 8021db0:	f7ff ffea 	bl	8021d88 <TIMER_IF_BkUp_Read_MSBticks>
  ticks = (((uint64_t) timerValueMSB) << 32) + timerValueLsb;
 8021db4:	2200      	movs	r2, #0
 8021db6:	0003      	movs	r3, r0
 8021db8:	0026      	movs	r6, r4
 8021dba:	2700      	movs	r7, #0
 8021dbc:	1992      	adds	r2, r2, r6
 8021dbe:	417b      	adcs	r3, r7
 8021dc0:	0011      	movs	r1, r2
  seconds = (uint32_t)(ticks >> RTC_N_PREDIV_S);
 8021dc2:	059b      	lsls	r3, r3, #22
 8021dc4:	0a8c      	lsrs	r4, r1, #10
 8021dc6:	431c      	orrs	r4, r3
  ticks = (uint32_t) ticks & RTC_PREDIV_S;
 8021dc8:	058a      	lsls	r2, r1, #22
 8021dca:	0d90      	lsrs	r0, r2, #22
  *mSeconds = TIMER_IF_Convert_Tick2ms(ticks);
 8021dcc:	f7ff ff4b 	bl	8021c66 <TIMER_IF_Convert_Tick2ms>
 8021dd0:	8028      	strh	r0, [r5, #0]
}
 8021dd2:	0020      	movs	r0, r4
 8021dd4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8021dd6:	46c0      	nop			; (mov r8, r8)
 8021dd8:	40002800 	.word	0x40002800

08021ddc <TIMER_IF_BkUp_Read_Seconds>:
{
 8021ddc:	b510      	push	{r4, lr}
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SECONDS);
 8021dde:	2100      	movs	r1, #0
 8021de0:	4801      	ldr	r0, [pc, #4]	; (8021de8 <TIMER_IF_BkUp_Read_Seconds+0xc>)
 8021de2:	f003 fa49 	bl	8025278 <HAL_RTCEx_BKUPRead>
}
 8021de6:	bd10      	pop	{r4, pc}
 8021de8:	2000b1d8 	.word	0x2000b1d8

08021dec <TIMER_IF_BkUp_Read_SubSeconds>:
{
 8021dec:	b510      	push	{r4, lr}
  ret = HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_SUBSECONDS);
 8021dee:	2101      	movs	r1, #1
 8021df0:	4801      	ldr	r0, [pc, #4]	; (8021df8 <TIMER_IF_BkUp_Read_SubSeconds+0xc>)
 8021df2:	f003 fa41 	bl	8025278 <HAL_RTCEx_BKUPRead>
}
 8021df6:	bd10      	pop	{r4, pc}
 8021df8:	2000b1d8 	.word	0x2000b1d8

08021dfc <TIMER_IF_DelayMs>:
{
 8021dfc:	b510      	push	{r4, lr}
  uint32_t delayTicks = TIMER_IF_Convert_ms2Tick(delay);
 8021dfe:	f7ff ff29 	bl	8021c54 <TIMER_IF_Convert_ms2Tick>
 8021e02:	4b0d      	ldr	r3, [pc, #52]	; (8021e38 <TIMER_IF_DelayMs+0x3c>)
 8021e04:	6899      	ldr	r1, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8021e06:	e001      	b.n	8021e0c <TIMER_IF_DelayMs+0x10>
 8021e08:	4b0b      	ldr	r3, [pc, #44]	; (8021e38 <TIMER_IF_DelayMs+0x3c>)
 8021e0a:	6899      	ldr	r1, [r3, #8]
 8021e0c:	4a0a      	ldr	r2, [pc, #40]	; (8021e38 <TIMER_IF_DelayMs+0x3c>)
 8021e0e:	6892      	ldr	r2, [r2, #8]
 8021e10:	428a      	cmp	r2, r1
 8021e12:	d1f9      	bne.n	8021e08 <TIMER_IF_DelayMs+0xc>
  return UINT32_MAX - ssr;
 8021e14:	43c9      	mvns	r1, r1
  while (((GetTimerTicks() - timeout)) < delayTicks)
 8021e16:	e00a      	b.n	8021e2e <TIMER_IF_DelayMs+0x32>
 8021e18:	4b07      	ldr	r3, [pc, #28]	; (8021e38 <TIMER_IF_DelayMs+0x3c>)
 8021e1a:	689b      	ldr	r3, [r3, #8]
 8021e1c:	4a06      	ldr	r2, [pc, #24]	; (8021e38 <TIMER_IF_DelayMs+0x3c>)
 8021e1e:	6892      	ldr	r2, [r2, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8021e20:	429a      	cmp	r2, r3
 8021e22:	d1f9      	bne.n	8021e18 <TIMER_IF_DelayMs+0x1c>
  return UINT32_MAX - ssr;
 8021e24:	43db      	mvns	r3, r3
  while (((GetTimerTicks() - timeout)) < delayTicks)
 8021e26:	1a5b      	subs	r3, r3, r1
 8021e28:	4283      	cmp	r3, r0
 8021e2a:	d203      	bcs.n	8021e34 <TIMER_IF_DelayMs+0x38>
    __NOP();
 8021e2c:	46c0      	nop			; (mov r8, r8)
 8021e2e:	4b02      	ldr	r3, [pc, #8]	; (8021e38 <TIMER_IF_DelayMs+0x3c>)
 8021e30:	689b      	ldr	r3, [r3, #8]
  while (ssr != LL_RTC_TIME_GetSubSecond(RTC))
 8021e32:	e7f3      	b.n	8021e1c <TIMER_IF_DelayMs+0x20>
}
 8021e34:	bd10      	pop	{r4, pc}
 8021e36:	46c0      	nop			; (mov r8, r8)
 8021e38:	40002800 	.word	0x40002800

08021e3c <HAL_RTC_AlarmAEventCallback>:
{
 8021e3c:	b510      	push	{r4, lr}
  if (MBMUXIF_GetCpusSynchroFlag() == CPUS_BOOT_SYNC_RTC_REGISTERED)
 8021e3e:	f000 fe75 	bl	8022b2c <MBMUXIF_GetCpusSynchroFlag>
 8021e42:	4b08      	ldr	r3, [pc, #32]	; (8021e64 <HAL_RTC_AlarmAEventCallback+0x28>)
 8021e44:	4298      	cmp	r0, r3
 8021e46:	d000      	beq.n	8021e4a <HAL_RTC_AlarmAEventCallback+0xe>
}
 8021e48:	bd10      	pop	{r4, pc}
    com_obj = MBMUXIF_GetSystemFeatureNotifComPtr(FEAT_INFO_SYSTEM_NOTIF_PRIO_A_ID);
 8021e4a:	2002      	movs	r0, #2
 8021e4c:	f000 fe78 	bl	8022b40 <MBMUXIF_GetSystemFeatureNotifComPtr>
    if (com_obj != NULL)
 8021e50:	2800      	cmp	r0, #0
 8021e52:	d0f9      	beq.n	8021e48 <HAL_RTC_AlarmAEventCallback+0xc>
      com_obj->MsgId = SYS_RTC_ALARM_MSG_ID;
 8021e54:	2302      	movs	r3, #2
 8021e56:	6003      	str	r3, [r0, #0]
      com_obj->ParamCnt = 0;
 8021e58:	2300      	movs	r3, #0
 8021e5a:	81c3      	strh	r3, [r0, #14]
      MBMUXIF_SystemSendNotif_NoWait(FEAT_INFO_SYSTEM_NOTIF_PRIO_A_ID);
 8021e5c:	2002      	movs	r0, #2
 8021e5e:	f000 fe7a 	bl	8022b56 <MBMUXIF_SystemSendNotif_NoWait>
}
 8021e62:	e7f1      	b.n	8021e48 <HAL_RTC_AlarmAEventCallback+0xc>
 8021e64:	00009999 	.word	0x00009999

08021e68 <HAL_RTCEx_AlarmBEventCallback>:
{
 8021e68:	b510      	push	{r4, lr}
  UTIL_TIMER_IRQ_MAP_PROCESS();
 8021e6a:	f012 fc57 	bl	803471c <UTIL_TIMER_IRQ_Handler>
}
 8021e6e:	bd10      	pop	{r4, pc}

08021e70 <HAL_RTCEx_SSRUEventCallback>:
{
 8021e70:	b510      	push	{r4, lr}
  uint32_t MSB_ticks = TIMER_IF_BkUp_Read_MSBticks();
 8021e72:	f7ff ff89 	bl	8021d88 <TIMER_IF_BkUp_Read_MSBticks>
  TIMER_IF_BkUp_Write_MSBticks(MSB_ticks + 1);
 8021e76:	3001      	adds	r0, #1
 8021e78:	f7ff ff14 	bl	8021ca4 <TIMER_IF_BkUp_Write_MSBticks>
}
 8021e7c:	bd10      	pop	{r4, pc}

08021e7e <MX_KMS_Init>:
/* USER CODE BEGIN 2 */
/* USER CODE END 2 */

/* KMS init function */
void MX_KMS_Init(void)
{
 8021e7e:	b510      	push	{r4, lr}
/***************************************/
   /**
  */

  C_Initialize(NULL);
 8021e80:	2000      	movs	r0, #0
 8021e82:	f005 fa9d 	bl	80273c0 <KMS_Initialize>

  /* USER CODE BEGIN 3 */
  /* USER CODE END 3 */

}
 8021e86:	bd10      	pop	{r4, pc}

08021e88 <MX_LoRaWAN_Init>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/

void MX_LoRaWAN_Init(void)
{
 8021e88:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MX_LoRaWAN_Init_1 */

  /* USER CODE END MX_LoRaWAN_Init_1 */
  SystemApp_Init();
 8021e8a:	f7ff fde1 	bl	8021a50 <SystemApp_Init>
  /* USER CODE BEGIN MX_LoRaWAN_Init_2 */

  /* USER CODE END MX_LoRaWAN_Init_2 */
}
 8021e8e:	bd10      	pop	{r4, pc}

08021e90 <MX_LoRaWAN_Process>:

void MX_LoRaWAN_Process(void)
{
 8021e90:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MX_LoRaWAN_Process_1 */

  /* USER CODE END MX_LoRaWAN_Process_1 */
  UTIL_SEQ_Run(UTIL_SEQ_DEFAULT);
 8021e92:	2001      	movs	r0, #1
 8021e94:	4240      	negs	r0, r0
 8021e96:	f012 f957 	bl	8034148 <UTIL_SEQ_Run>
  /* USER CODE BEGIN MX_LoRaWAN_Process_2 */

  /* USER CODE END MX_LoRaWAN_Process_2 */
}
 8021e9a:	bd10      	pop	{r4, pc}

08021e9c <InitPackageProcess>:
/* USER CODE BEGIN EF */

/* USER CODE END EF */

void InitPackageProcess(void)
{
 8021e9c:	b510      	push	{r4, lr}
  /* USER CODE BEGIN InitPackageProcess_1 */

  /* USER CODE END InitPackageProcess_1 */
  UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_LmHandlerProcess), UTIL_SEQ_RFU, LmHandlerProcess);
 8021e9e:	4a03      	ldr	r2, [pc, #12]	; (8021eac <InitPackageProcess+0x10>)
 8021ea0:	2100      	movs	r1, #0
 8021ea2:	2040      	movs	r0, #64	; 0x40
 8021ea4:	f012 fa0e 	bl	80342c4 <UTIL_SEQ_RegTask>
  /* USER CODE BEGIN InitPackageProcess_2 */

  /* USER CODE END InitPackageProcess_2 */
}
 8021ea8:	bd10      	pop	{r4, pc}
 8021eaa:	46c0      	nop			; (mov r8, r8)
 8021eac:	08029431 	.word	0x08029431

08021eb0 <OnMacProcessNotify>:

void OnMacProcessNotify(void)
{
 8021eb0:	b510      	push	{r4, lr}
  /* USER CODE BEGIN OnMacProcessNotify_1 */

  /* USER CODE END OnMacProcessNotify_1 */
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_LmHandlerProcess), CFG_SEQ_Prio_0);
 8021eb2:	2100      	movs	r1, #0
 8021eb4:	2040      	movs	r0, #64	; 0x40
 8021eb6:	f012 f907 	bl	80340c8 <UTIL_SEQ_SetTask>
  /* USER CODE BEGIN OnMacProcessNotify_2 */

  /* USER CODE END OnMacProcessNotify_2 */
}
 8021eba:	bd10      	pop	{r4, pc}

08021ebc <RBI_Init>:

/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/
int32_t RBI_Init(void)
{
 8021ebc:	b510      	push	{r4, lr}
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration
   *       on maximum output power that the board can deliver*/
  return BSP_RADIO_Init();
 8021ebe:	f001 f927 	bl	8023110 <BSP_RADIO_Init>
  /* USER CODE BEGIN RBI_Init_2 */
#warning user to provide its board code or to call his board driver functions
  /* USER CODE END RBI_Init_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER  */
}
 8021ec2:	bd10      	pop	{r4, pc}

08021ec4 <RBI_ConfigRFSwitch>:
  return retcode;
#endif  /* USE_BSP_DRIVER */
}

int32_t RBI_ConfigRFSwitch(RBI_Switch_TypeDef Config)
{
 8021ec4:	b510      	push	{r4, lr}
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration
   *       on maximum output power that the board can deliver*/
  return BSP_RADIO_ConfigRFSwitch((BSP_RADIO_Switch_TypeDef) Config);
 8021ec6:	f001 f961 	bl	802318c <BSP_RADIO_ConfigRFSwitch>
  /* USER CODE BEGIN RBI_ConfigRFSwitch_2 */
#warning user to provide its board code or to call his board driver functions
  /* USER CODE END RBI_ConfigRFSwitch_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER */
}
 8021eca:	bd10      	pop	{r4, pc}

08021ecc <RBI_GetTxConfig>:

int32_t RBI_GetTxConfig(void)
{
 8021ecc:	b510      	push	{r4, lr}
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration
   *       on maximum output power that the board can deliver*/
  return BSP_RADIO_GetTxConfig();
 8021ece:	f001 f9af 	bl	8023230 <BSP_RADIO_GetTxConfig>
  /* USER CODE BEGIN RBI_GetTxConfig_2 */
#warning user to provide its board code or to call his board driver functions
  /* USER CODE END RBI_GetTxConfig_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER */
}
 8021ed2:	bd10      	pop	{r4, pc}

08021ed4 <RBI_IsTCXO>:

int32_t RBI_IsTCXO(void)
{
 8021ed4:	b510      	push	{r4, lr}
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration
   *       on maximum output power that the board can deliver*/
  return BSP_RADIO_IsTCXO();
 8021ed6:	f001 f9ad 	bl	8023234 <BSP_RADIO_IsTCXO>
  /* USER CODE BEGIN RBI_IsTCXO_2 */
#warning user to provide its board code or to call his board driver functions
  /* USER CODE END RBI_IsTCXO_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER  */
}
 8021eda:	bd10      	pop	{r4, pc}

08021edc <RBI_IsDCDC>:

int32_t RBI_IsDCDC(void)
{
 8021edc:	b510      	push	{r4, lr}
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration
   *       on maximum output power that the board can deliver*/
  return BSP_RADIO_IsDCDC();
 8021ede:	f001 f9ab 	bl	8023238 <BSP_RADIO_IsDCDC>
  /* USER CODE BEGIN RBI_IsDCDC_2 */
#warning user to provide its board code or to call his board driver functions
  /* USER CODE END RBI_IsDCDC_2 */
  return retcode;
#endif  /* USE_BSP_DRIVER  */
}
 8021ee2:	bd10      	pop	{r4, pc}

08021ee4 <RBI_GetRFOMaxPowerConfig>:

int32_t RBI_GetRFOMaxPowerConfig(RBI_RFOMaxPowerConfig_TypeDef Config)
{
 8021ee4:	b510      	push	{r4, lr}
   * 1/ For User boards, the BSP/STM32WLxx_Nucleo/ directory can be copied and replaced in the project. The copy must then be updated depending:
   *       on board RF switch configuration (pin control, number of port etc)
   *       on TCXO configuration
   *       on DC/DC configuration
   *       on maximum output power that the board can deliver*/
  return BSP_RADIO_GetRFOMaxPowerConfig((BSP_RADIO_RFOMaxPowerConfig_TypeDef) Config);
 8021ee6:	f001 f9a9 	bl	802323c <BSP_RADIO_GetRFOMaxPowerConfig>
    ret = 22; /*dBm*/
  }
  /* USER CODE END RBI_GetRFOMaxPowerConfig_2 */
  return ret;
#endif  /* USE_BSP_DRIVER  */
}
 8021eea:	bd10      	pop	{r4, pc}

08021eec <OnSystemReset_mbwrapper>:

  /* USER CODE END OnPingSlotPeriodicityChanged_mbwrapper_2 */
}

static void OnSystemReset_mbwrapper(void)
{
 8021eec:	b510      	push	{r4, lr}
  /* USER CODE BEGIN OnSystemReset_mbwrapper_1 */

  /* USER CODE END OnSystemReset_mbwrapper_1 */
  MBMUX_ComParam_t *com_obj;

  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8021eee:	f000 fccd 	bl	802288c <MBMUXIF_GetLoraFeatureNotifComPtr>
  com_obj->MsgId = LMHANDLER_ON_SYSTEM_RESET_CB_ID;
 8021ef2:	2342      	movs	r3, #66	; 0x42
 8021ef4:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8021ef6:	2300      	movs	r3, #0
 8021ef8:	81c3      	strh	r3, [r0, #14]

  MBMUXIF_LoraSendNotif();
 8021efa:	f000 fcd3 	bl	80228a4 <MBMUXIF_LoraSendNotif>
  /* once event is received and semaphore released: */
  return;
  /* USER CODE BEGIN OnSystemReset_mbwrapper_2 */

  /* USER CODE END OnSystemReset_mbwrapper_2 */
}
 8021efe:	bd10      	pop	{r4, pc}

08021f00 <OnPingSlotPeriodicityChanged_mbwrapper>:
{
 8021f00:	b570      	push	{r4, r5, r6, lr}
 8021f02:	0005      	movs	r5, r0
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8021f04:	f000 fcc2 	bl	802288c <MBMUXIF_GetLoraFeatureNotifComPtr>
 8021f08:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_PING_SLOT_PERIOD_CHANGED_CB_ID;
 8021f0a:	2341      	movs	r3, #65	; 0x41
 8021f0c:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8021f0e:	8981      	ldrh	r1, [r0, #12]
 8021f10:	6900      	ldr	r0, [r0, #16]
 8021f12:	f000 fc50 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
  com_buffer[0] = (uint32_t)pingSlotPeriodicity;
 8021f16:	6005      	str	r5, [r0, #0]
  com_obj->ParamCnt = 1;
 8021f18:	2301      	movs	r3, #1
 8021f1a:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 8021f1c:	f000 fcc2 	bl	80228a4 <MBMUXIF_LoraSendNotif>
}
 8021f20:	bd70      	pop	{r4, r5, r6, pc}

08021f22 <OnTxFrameCtrlChanged_mbwrapper>:
{
 8021f22:	b570      	push	{r4, r5, r6, lr}
 8021f24:	0005      	movs	r5, r0
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8021f26:	f000 fcb1 	bl	802288c <MBMUXIF_GetLoraFeatureNotifComPtr>
 8021f2a:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_TX_CTRL_CHANGED_CB_ID;
 8021f2c:	2340      	movs	r3, #64	; 0x40
 8021f2e:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8021f30:	8981      	ldrh	r1, [r0, #12]
 8021f32:	6900      	ldr	r0, [r0, #16]
 8021f34:	f000 fc3f 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
  com_buffer[0] = (uint32_t)isTxConfirmed;
 8021f38:	6005      	str	r5, [r0, #0]
  com_obj->ParamCnt = 1;
 8021f3a:	2301      	movs	r3, #1
 8021f3c:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 8021f3e:	f000 fcb1 	bl	80228a4 <MBMUXIF_LoraSendNotif>
}
 8021f42:	bd70      	pop	{r4, r5, r6, pc}

08021f44 <OnTxPeriodicityChanged_mbwrapper>:
{
 8021f44:	b570      	push	{r4, r5, r6, lr}
 8021f46:	0005      	movs	r5, r0
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8021f48:	f000 fca0 	bl	802288c <MBMUXIF_GetLoraFeatureNotifComPtr>
 8021f4c:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_TX_PERIOD_CHANGED_CB_ID;
 8021f4e:	233f      	movs	r3, #63	; 0x3f
 8021f50:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8021f52:	8981      	ldrh	r1, [r0, #12]
 8021f54:	6900      	ldr	r0, [r0, #16]
 8021f56:	f000 fc2e 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
  com_buffer[0] = periodicity;
 8021f5a:	6005      	str	r5, [r0, #0]
  com_obj->ParamCnt = 1;
 8021f5c:	2301      	movs	r3, #1
 8021f5e:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 8021f60:	f000 fca0 	bl	80228a4 <MBMUXIF_LoraSendNotif>
}
 8021f64:	bd70      	pop	{r4, r5, r6, pc}

08021f66 <OnSysTimeUpdate_mbwrapper>:
{
 8021f66:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8021f68:	f000 fc90 	bl	802288c <MBMUXIF_GetLoraFeatureNotifComPtr>
  com_obj->MsgId = LMHANDLER_ON_SYS_TIME_UPDATE_CB_ID;
 8021f6c:	233e      	movs	r3, #62	; 0x3e
 8021f6e:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8021f70:	2300      	movs	r3, #0
 8021f72:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_LoraSendNotif();
 8021f74:	f000 fc96 	bl	80228a4 <MBMUXIF_LoraSendNotif>
}
 8021f78:	bd10      	pop	{r4, pc}

08021f7a <OnClassChange_mbwrapper>:
{
 8021f7a:	b570      	push	{r4, r5, r6, lr}
 8021f7c:	0005      	movs	r5, r0
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8021f7e:	f000 fc85 	bl	802288c <MBMUXIF_GetLoraFeatureNotifComPtr>
 8021f82:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_CLASS_CHANGE_CB_ID;
 8021f84:	233c      	movs	r3, #60	; 0x3c
 8021f86:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8021f88:	8981      	ldrh	r1, [r0, #12]
 8021f8a:	6900      	ldr	r0, [r0, #16]
 8021f8c:	f000 fc13 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
  com_buffer[0] = (uint32_t)deviceClass;
 8021f90:	6005      	str	r5, [r0, #0]
  com_obj->ParamCnt = 1;
 8021f92:	2301      	movs	r3, #1
 8021f94:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 8021f96:	f000 fc85 	bl	80228a4 <MBMUXIF_LoraSendNotif>
}
 8021f9a:	bd70      	pop	{r4, r5, r6, pc}

08021f9c <OnNvmDataChange_mbwrapper>:
{
 8021f9c:	b570      	push	{r4, r5, r6, lr}
 8021f9e:	0005      	movs	r5, r0
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8021fa0:	f000 fc74 	bl	802288c <MBMUXIF_GetLoraFeatureNotifComPtr>
 8021fa4:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_NVM_DATA_CHANGE_CB_ID;
 8021fa6:	2337      	movs	r3, #55	; 0x37
 8021fa8:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8021faa:	8981      	ldrh	r1, [r0, #12]
 8021fac:	6900      	ldr	r0, [r0, #16]
 8021fae:	f000 fc02 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
  com_buffer[0] = (uint32_t)state;
 8021fb2:	6005      	str	r5, [r0, #0]
  com_obj->ParamCnt = 1;
 8021fb4:	2301      	movs	r3, #1
 8021fb6:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 8021fb8:	f000 fc74 	bl	80228a4 <MBMUXIF_LoraSendNotif>
}
 8021fbc:	bd70      	pop	{r4, r5, r6, pc}

08021fbe <OnStoreContextRequest_mbwrapper>:
{
 8021fbe:	b570      	push	{r4, r5, r6, lr}
 8021fc0:	0006      	movs	r6, r0
 8021fc2:	000d      	movs	r5, r1
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8021fc4:	f000 fc62 	bl	802288c <MBMUXIF_GetLoraFeatureNotifComPtr>
 8021fc8:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_STORE_CONTEXT_REQ_CB_ID;
 8021fca:	2336      	movs	r3, #54	; 0x36
 8021fcc:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8021fce:	8981      	ldrh	r1, [r0, #12]
 8021fd0:	6900      	ldr	r0, [r0, #16]
 8021fd2:	f000 fbf0 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
  com_buffer[0] = (uint32_t)nvm;
 8021fd6:	6006      	str	r6, [r0, #0]
  com_buffer[1] = nvm_size;
 8021fd8:	6045      	str	r5, [r0, #4]
  com_obj->ParamCnt = 2;
 8021fda:	2302      	movs	r3, #2
 8021fdc:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 8021fde:	f000 fc61 	bl	80228a4 <MBMUXIF_LoraSendNotif>
}
 8021fe2:	bd70      	pop	{r4, r5, r6, pc}

08021fe4 <OnRestoreContextRequest_mbwrapper>:
{
 8021fe4:	b570      	push	{r4, r5, r6, lr}
 8021fe6:	0006      	movs	r6, r0
 8021fe8:	000d      	movs	r5, r1
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8021fea:	f000 fc4f 	bl	802288c <MBMUXIF_GetLoraFeatureNotifComPtr>
 8021fee:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_RESTORE_CONTEXT_REQ_CB_ID;
 8021ff0:	2335      	movs	r3, #53	; 0x35
 8021ff2:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8021ff4:	8981      	ldrh	r1, [r0, #12]
 8021ff6:	6900      	ldr	r0, [r0, #16]
 8021ff8:	f000 fbdd 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
  com_buffer[0] = (uint32_t)nvm;
 8021ffc:	6006      	str	r6, [r0, #0]
  com_buffer[1] = nvm_size;
 8021ffe:	6045      	str	r5, [r0, #4]
  com_obj->ParamCnt = 2;
 8022000:	2302      	movs	r3, #2
 8022002:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 8022004:	f000 fc4e 	bl	80228a4 <MBMUXIF_LoraSendNotif>
}
 8022008:	bd70      	pop	{r4, r5, r6, pc}

0802200a <GetTemperatureLevel_mbwrapper>:
{
 802200a:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 802200c:	f000 fc3e 	bl	802288c <MBMUXIF_GetLoraFeatureNotifComPtr>
 8022010:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_GET_TEMPERATURE_CB_ID;
 8022012:	2334      	movs	r3, #52	; 0x34
 8022014:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8022016:	2300      	movs	r3, #0
 8022018:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_LoraSendNotif();
 802201a:	f000 fc43 	bl	80228a4 <MBMUXIF_LoraSendNotif>
  return (int16_t) com_obj->ReturnVal;
 802201e:	2314      	movs	r3, #20
 8022020:	5ee0      	ldrsh	r0, [r4, r3]
}
 8022022:	bd10      	pop	{r4, pc}

08022024 <GetBatteryLevel_mbwrapper>:
{
 8022024:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 8022026:	f000 fc31 	bl	802288c <MBMUXIF_GetLoraFeatureNotifComPtr>
 802202a:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_GET_BATTERY_LEVEL_CB_ID;
 802202c:	2333      	movs	r3, #51	; 0x33
 802202e:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8022030:	2300      	movs	r3, #0
 8022032:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_LoraSendNotif();
 8022034:	f000 fc36 	bl	80228a4 <MBMUXIF_LoraSendNotif>
  return (uint8_t) com_obj->ReturnVal;
 8022038:	7d20      	ldrb	r0, [r4, #20]
}
 802203a:	bd10      	pop	{r4, pc}

0802203c <OnBeaconStatusChange_mbwrapper>:
{
 802203c:	b570      	push	{r4, r5, r6, lr}
 802203e:	1e05      	subs	r5, r0, #0
  if (params != NULL)
 8022040:	d004      	beq.n	802204c <OnBeaconStatusChange_mbwrapper+0x10>
    UTIL_MEM_cpy_8(aLoraMbWrapShare2Buffer, params, sizeof(LmHandlerBeaconParams_t));
 8022042:	2220      	movs	r2, #32
 8022044:	0001      	movs	r1, r0
 8022046:	480c      	ldr	r0, [pc, #48]	; (8022078 <OnBeaconStatusChange_mbwrapper+0x3c>)
 8022048:	f012 f82a 	bl	80340a0 <UTIL_MEM_cpy_8>
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 802204c:	f000 fc1e 	bl	802288c <MBMUXIF_GetLoraFeatureNotifComPtr>
 8022050:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_BEACON_STATUS_CHANGE_CB_ID;
 8022052:	233d      	movs	r3, #61	; 0x3d
 8022054:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8022056:	8981      	ldrh	r1, [r0, #12]
 8022058:	6900      	ldr	r0, [r0, #16]
 802205a:	f000 fbac 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
  if (params == NULL)
 802205e:	2d00      	cmp	r5, #0
 8022060:	d006      	beq.n	8022070 <OnBeaconStatusChange_mbwrapper+0x34>
    com_buffer[0] = (uint32_t) aLoraMbWrapShare2Buffer;
 8022062:	4b05      	ldr	r3, [pc, #20]	; (8022078 <OnBeaconStatusChange_mbwrapper+0x3c>)
 8022064:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 1;
 8022066:	2301      	movs	r3, #1
 8022068:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 802206a:	f000 fc1b 	bl	80228a4 <MBMUXIF_LoraSendNotif>
}
 802206e:	bd70      	pop	{r4, r5, r6, pc}
    com_buffer[0] = (uint32_t)NULL;
 8022070:	2300      	movs	r3, #0
 8022072:	6003      	str	r3, [r0, #0]
 8022074:	e7f7      	b.n	8022066 <OnBeaconStatusChange_mbwrapper+0x2a>
 8022076:	46c0      	nop			; (mov r8, r8)
 8022078:	20009058 	.word	0x20009058

0802207c <OnRxData_mbwrapper>:
{
 802207c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802207e:	46c6      	mov	lr, r8
 8022080:	b500      	push	{lr}
 8022082:	0005      	movs	r5, r0
 8022084:	000e      	movs	r6, r1
  if (appData != NULL)
 8022086:	2800      	cmp	r0, #0
 8022088:	d018      	beq.n	80220bc <OnRxData_mbwrapper+0x40>
    UTIL_MEM_cpy_8(aLoraMbWrapShare2Buffer, appData, sizeof(LmHandlerAppData_t));
 802208a:	2208      	movs	r2, #8
 802208c:	0001      	movs	r1, r0
 802208e:	4828      	ldr	r0, [pc, #160]	; (8022130 <OnRxData_mbwrapper+0xb4>)
 8022090:	f012 f806 	bl	80340a0 <UTIL_MEM_cpy_8>
    if (appData->BufferSize > 0)
 8022094:	786a      	ldrb	r2, [r5, #1]
 8022096:	2a00      	cmp	r2, #0
 8022098:	d101      	bne.n	802209e <OnRxData_mbwrapper+0x22>
    next_addr += ALIGN_X(sizeof(LmHandlerAppData_t), 8);
 802209a:	2708      	movs	r7, #8
 802209c:	e00f      	b.n	80220be <OnRxData_mbwrapper+0x42>
      UTIL_MEM_cpy_8(&aLoraMbWrapShare2Buffer[next_addr], appData->Buffer, appData->BufferSize);
 802209e:	b292      	uxth	r2, r2
 80220a0:	4c24      	ldr	r4, [pc, #144]	; (8022134 <OnRxData_mbwrapper+0xb8>)
 80220a2:	6869      	ldr	r1, [r5, #4]
 80220a4:	0020      	movs	r0, r4
 80220a6:	f011 fffb 	bl	80340a0 <UTIL_MEM_cpy_8>
      ((LmHandlerAppData_t *)aLoraMbWrapShare2Buffer)->Buffer = &aLoraMbWrapShare2Buffer[next_addr];
 80220aa:	0023      	movs	r3, r4
 80220ac:	3b08      	subs	r3, #8
 80220ae:	605c      	str	r4, [r3, #4]
      next_addr += ALIGN_X(appData->BufferSize, 8);
 80220b0:	786f      	ldrb	r7, [r5, #1]
 80220b2:	3707      	adds	r7, #7
 80220b4:	2307      	movs	r3, #7
 80220b6:	439f      	bics	r7, r3
 80220b8:	3708      	adds	r7, #8
 80220ba:	e000      	b.n	80220be <OnRxData_mbwrapper+0x42>
  uint32_t next_addr = 0;
 80220bc:	2700      	movs	r7, #0
  if (params != NULL)
 80220be:	2e00      	cmp	r6, #0
 80220c0:	d015      	beq.n	80220ee <OnRxData_mbwrapper+0x72>
    UTIL_MEM_cpy_8(&aLoraMbWrapShare2Buffer[next_addr], params, sizeof(LmHandlerRxParams_t));
 80220c2:	4c1b      	ldr	r4, [pc, #108]	; (8022130 <OnRxData_mbwrapper+0xb4>)
 80220c4:	193c      	adds	r4, r7, r4
 80220c6:	2214      	movs	r2, #20
 80220c8:	0031      	movs	r1, r6
 80220ca:	0020      	movs	r0, r4
 80220cc:	f011 ffe8 	bl	80340a0 <UTIL_MEM_cpy_8>
    next_addr += ALIGN_X(sizeof(CommissioningParams_t), 8);
 80220d0:	003b      	movs	r3, r7
 80220d2:	3318      	adds	r3, #24
    if (params->CommissioningParams != NULL)
 80220d4:	6871      	ldr	r1, [r6, #4]
 80220d6:	2900      	cmp	r1, #0
 80220d8:	d00a      	beq.n	80220f0 <OnRxData_mbwrapper+0x74>
      UTIL_MEM_cpy_8(&aLoraMbWrapShare2Buffer[next_addr], params->CommissioningParams, sizeof(CommissioningParams_t));
 80220da:	4a15      	ldr	r2, [pc, #84]	; (8022130 <OnRxData_mbwrapper+0xb4>)
 80220dc:	4698      	mov	r8, r3
 80220de:	4490      	add	r8, r2
 80220e0:	2218      	movs	r2, #24
 80220e2:	4640      	mov	r0, r8
 80220e4:	f011 ffdc 	bl	80340a0 <UTIL_MEM_cpy_8>
      ((LmHandlerRxParams_t *)&aLoraMbWrapShare2Buffer[param_addr])->CommissioningParams = (CommissioningParams_t *)&aLoraMbWrapShare2Buffer[next_addr];
 80220e8:	4643      	mov	r3, r8
 80220ea:	6063      	str	r3, [r4, #4]
 80220ec:	e000      	b.n	80220f0 <OnRxData_mbwrapper+0x74>
  uint32_t param_addr = 0;
 80220ee:	2700      	movs	r7, #0
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 80220f0:	f000 fbcc 	bl	802288c <MBMUXIF_GetLoraFeatureNotifComPtr>
 80220f4:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_RX_DATA_CB_ID;
 80220f6:	233b      	movs	r3, #59	; 0x3b
 80220f8:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 80220fa:	8981      	ldrh	r1, [r0, #12]
 80220fc:	6900      	ldr	r0, [r0, #16]
 80220fe:	f000 fb5a 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
  if (appData == NULL)
 8022102:	2d00      	cmp	r5, #0
 8022104:	d00d      	beq.n	8022122 <OnRxData_mbwrapper+0xa6>
    com_buffer[0] = (uint32_t) aLoraMbWrapShare2Buffer;
 8022106:	4b0a      	ldr	r3, [pc, #40]	; (8022130 <OnRxData_mbwrapper+0xb4>)
 8022108:	6003      	str	r3, [r0, #0]
  if (params == NULL)
 802210a:	2e00      	cmp	r6, #0
 802210c:	d00c      	beq.n	8022128 <OnRxData_mbwrapper+0xac>
    com_buffer[1] = (uint32_t) &aLoraMbWrapShare2Buffer[param_addr];
 802210e:	4b08      	ldr	r3, [pc, #32]	; (8022130 <OnRxData_mbwrapper+0xb4>)
 8022110:	18ff      	adds	r7, r7, r3
 8022112:	6047      	str	r7, [r0, #4]
  com_obj->ParamCnt = 2;
 8022114:	2302      	movs	r3, #2
 8022116:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 8022118:	f000 fbc4 	bl	80228a4 <MBMUXIF_LoraSendNotif>
}
 802211c:	bc80      	pop	{r7}
 802211e:	46b8      	mov	r8, r7
 8022120:	bdf0      	pop	{r4, r5, r6, r7, pc}
    com_buffer[0] = (uint32_t)NULL;
 8022122:	2300      	movs	r3, #0
 8022124:	6003      	str	r3, [r0, #0]
 8022126:	e7f0      	b.n	802210a <OnRxData_mbwrapper+0x8e>
    com_buffer[1] = (uint32_t)NULL;
 8022128:	2300      	movs	r3, #0
 802212a:	6043      	str	r3, [r0, #4]
 802212c:	e7f2      	b.n	8022114 <OnRxData_mbwrapper+0x98>
 802212e:	46c0      	nop			; (mov r8, r8)
 8022130:	20009058 	.word	0x20009058
 8022134:	20009060 	.word	0x20009060

08022138 <OnTxData_mbwrapper>:
{
 8022138:	b570      	push	{r4, r5, r6, lr}
 802213a:	1e05      	subs	r5, r0, #0
  if (params != NULL)
 802213c:	d00f      	beq.n	802215e <OnTxData_mbwrapper+0x26>
    UTIL_MEM_cpy_8(aLoraMbWrapShare2Buffer, params, sizeof(LmHandlerTxParams_t));
 802213e:	221c      	movs	r2, #28
 8022140:	0001      	movs	r1, r0
 8022142:	4811      	ldr	r0, [pc, #68]	; (8022188 <OnTxData_mbwrapper+0x50>)
 8022144:	f011 ffac 	bl	80340a0 <UTIL_MEM_cpy_8>
    if (params->CommissioningParams != NULL)
 8022148:	6869      	ldr	r1, [r5, #4]
 802214a:	2900      	cmp	r1, #0
 802214c:	d007      	beq.n	802215e <OnTxData_mbwrapper+0x26>
      UTIL_MEM_cpy_8(&aLoraMbWrapShare2Buffer[next_addr], params->CommissioningParams, sizeof(CommissioningParams_t));
 802214e:	4c0f      	ldr	r4, [pc, #60]	; (802218c <OnTxData_mbwrapper+0x54>)
 8022150:	2218      	movs	r2, #24
 8022152:	0020      	movs	r0, r4
 8022154:	f011 ffa4 	bl	80340a0 <UTIL_MEM_cpy_8>
      ((LmHandlerTxParams_t *)aLoraMbWrapShare2Buffer)->CommissioningParams = (CommissioningParams_t *)&aLoraMbWrapShare2Buffer[next_addr];
 8022158:	0023      	movs	r3, r4
 802215a:	3b20      	subs	r3, #32
 802215c:	605c      	str	r4, [r3, #4]
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 802215e:	f000 fb95 	bl	802288c <MBMUXIF_GetLoraFeatureNotifComPtr>
 8022162:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_TX_DATA_CB_ID;
 8022164:	233a      	movs	r3, #58	; 0x3a
 8022166:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8022168:	8981      	ldrh	r1, [r0, #12]
 802216a:	6900      	ldr	r0, [r0, #16]
 802216c:	f000 fb23 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
  if (params == NULL)
 8022170:	2d00      	cmp	r5, #0
 8022172:	d006      	beq.n	8022182 <OnTxData_mbwrapper+0x4a>
    com_buffer[0] = (uint32_t) aLoraMbWrapShare2Buffer;
 8022174:	4b04      	ldr	r3, [pc, #16]	; (8022188 <OnTxData_mbwrapper+0x50>)
 8022176:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 1;
 8022178:	2301      	movs	r3, #1
 802217a:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 802217c:	f000 fb92 	bl	80228a4 <MBMUXIF_LoraSendNotif>
}
 8022180:	bd70      	pop	{r4, r5, r6, pc}
    com_buffer[0] = (uint32_t)NULL;
 8022182:	2300      	movs	r3, #0
 8022184:	6003      	str	r3, [r0, #0]
 8022186:	e7f7      	b.n	8022178 <OnTxData_mbwrapper+0x40>
 8022188:	20009058 	.word	0x20009058
 802218c:	20009078 	.word	0x20009078

08022190 <OnJoinRequest_mbwrapper>:
{
 8022190:	b570      	push	{r4, r5, r6, lr}
 8022192:	1e05      	subs	r5, r0, #0
  if (joinParams != NULL)
 8022194:	d00f      	beq.n	80221b6 <OnJoinRequest_mbwrapper+0x26>
    UTIL_MEM_cpy_8(aLoraMbWrapShare2Buffer, joinParams, sizeof(LmHandlerJoinParams_t));
 8022196:	220c      	movs	r2, #12
 8022198:	0001      	movs	r1, r0
 802219a:	4811      	ldr	r0, [pc, #68]	; (80221e0 <OnJoinRequest_mbwrapper+0x50>)
 802219c:	f011 ff80 	bl	80340a0 <UTIL_MEM_cpy_8>
    if (joinParams->CommissioningParams != NULL)
 80221a0:	6829      	ldr	r1, [r5, #0]
 80221a2:	2900      	cmp	r1, #0
 80221a4:	d007      	beq.n	80221b6 <OnJoinRequest_mbwrapper+0x26>
      UTIL_MEM_cpy_8(&aLoraMbWrapShare2Buffer[next_addr], joinParams->CommissioningParams, sizeof(CommissioningParams_t));
 80221a6:	4c0f      	ldr	r4, [pc, #60]	; (80221e4 <OnJoinRequest_mbwrapper+0x54>)
 80221a8:	2218      	movs	r2, #24
 80221aa:	0020      	movs	r0, r4
 80221ac:	f011 ff78 	bl	80340a0 <UTIL_MEM_cpy_8>
      ((LmHandlerJoinParams_t *)aLoraMbWrapShare2Buffer)->CommissioningParams = (CommissioningParams_t *)&aLoraMbWrapShare2Buffer[next_addr];
 80221b0:	0023      	movs	r3, r4
 80221b2:	3b10      	subs	r3, #16
 80221b4:	601c      	str	r4, [r3, #0]
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 80221b6:	f000 fb69 	bl	802288c <MBMUXIF_GetLoraFeatureNotifComPtr>
 80221ba:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_JOIN_REQ_CB_ID;
 80221bc:	2339      	movs	r3, #57	; 0x39
 80221be:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 80221c0:	8981      	ldrh	r1, [r0, #12]
 80221c2:	6900      	ldr	r0, [r0, #16]
 80221c4:	f000 faf7 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
  if (joinParams == NULL)
 80221c8:	2d00      	cmp	r5, #0
 80221ca:	d006      	beq.n	80221da <OnJoinRequest_mbwrapper+0x4a>
    com_buffer[0] = (uint32_t) aLoraMbWrapShare2Buffer;
 80221cc:	4b04      	ldr	r3, [pc, #16]	; (80221e0 <OnJoinRequest_mbwrapper+0x50>)
 80221ce:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 1;
 80221d0:	2301      	movs	r3, #1
 80221d2:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 80221d4:	f000 fb66 	bl	80228a4 <MBMUXIF_LoraSendNotif>
}
 80221d8:	bd70      	pop	{r4, r5, r6, pc}
    com_buffer[0] = (uint32_t)NULL;
 80221da:	2300      	movs	r3, #0
 80221dc:	6003      	str	r3, [r0, #0]
 80221de:	e7f7      	b.n	80221d0 <OnJoinRequest_mbwrapper+0x40>
 80221e0:	20009058 	.word	0x20009058
 80221e4:	20009068 	.word	0x20009068

080221e8 <OnNetworkParametersChange_mbwrapper>:
{
 80221e8:	b570      	push	{r4, r5, r6, lr}
 80221ea:	1e05      	subs	r5, r0, #0
  if (params != NULL)
 80221ec:	d004      	beq.n	80221f8 <OnNetworkParametersChange_mbwrapper+0x10>
    UTIL_MEM_cpy_8(aLoraMbWrapShare2Buffer, params, sizeof(CommissioningParams_t));
 80221ee:	2218      	movs	r2, #24
 80221f0:	0001      	movs	r1, r0
 80221f2:	480c      	ldr	r0, [pc, #48]	; (8022224 <OnNetworkParametersChange_mbwrapper+0x3c>)
 80221f4:	f011 ff54 	bl	80340a0 <UTIL_MEM_cpy_8>
  com_obj = MBMUXIF_GetLoraFeatureNotifComPtr();
 80221f8:	f000 fb48 	bl	802288c <MBMUXIF_GetLoraFeatureNotifComPtr>
 80221fc:	0004      	movs	r4, r0
  com_obj->MsgId = LMHANDLER_ON_NETWORK_PARAMS_CHANGE_CB_ID;
 80221fe:	2338      	movs	r3, #56	; 0x38
 8022200:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8022202:	8981      	ldrh	r1, [r0, #12]
 8022204:	6900      	ldr	r0, [r0, #16]
 8022206:	f000 fad6 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
  if (params == NULL)
 802220a:	2d00      	cmp	r5, #0
 802220c:	d006      	beq.n	802221c <OnNetworkParametersChange_mbwrapper+0x34>
    com_buffer[0] = (uint32_t) aLoraMbWrapShare2Buffer;
 802220e:	4b05      	ldr	r3, [pc, #20]	; (8022224 <OnNetworkParametersChange_mbwrapper+0x3c>)
 8022210:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 1;
 8022212:	2301      	movs	r3, #1
 8022214:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_LoraSendNotif();
 8022216:	f000 fb45 	bl	80228a4 <MBMUXIF_LoraSendNotif>
}
 802221a:	bd70      	pop	{r4, r5, r6, pc}
    com_buffer[0] = (uint32_t)NULL;
 802221c:	2300      	movs	r3, #0
 802221e:	6003      	str	r3, [r0, #0]
 8022220:	e7f7      	b.n	8022212 <OnNetworkParametersChange_mbwrapper+0x2a>
 8022222:	46c0      	nop			; (mov r8, r8)
 8022224:	20009058 	.word	0x20009058

08022228 <Process_Lora_Cmd>:
{
 8022228:	b510      	push	{r4, lr}
 802222a:	b082      	sub	sp, #8
 802222c:	0004      	movs	r4, r0
  APP_LOG(TS_ON, VLEVEL_H, ">CM0PLUS(LoRa)\r\n");
 802222e:	4bc9      	ldr	r3, [pc, #804]	; (8022554 <Process_Lora_Cmd+0x32c>)
 8022230:	2201      	movs	r2, #1
 8022232:	2100      	movs	r1, #0
 8022234:	2003      	movs	r0, #3
 8022236:	f011 fe1b 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(ComObj->ParamBuf, ComObj->BufSize);
 802223a:	89a1      	ldrh	r1, [r4, #12]
 802223c:	6920      	ldr	r0, [r4, #16]
 802223e:	f000 faba 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
  switch (ComObj->MsgId)
 8022242:	6823      	ldr	r3, [r4, #0]
 8022244:	2b32      	cmp	r3, #50	; 0x32
 8022246:	d80c      	bhi.n	8022262 <Process_Lora_Cmd+0x3a>
 8022248:	009b      	lsls	r3, r3, #2
 802224a:	4ac3      	ldr	r2, [pc, #780]	; (8022558 <Process_Lora_Cmd+0x330>)
 802224c:	58d3      	ldr	r3, [r2, r3]
 802224e:	469f      	mov	pc, r3
      errorStatus = LmHandlerInit(&callback_mbwrapper, APP_VERSION);
 8022250:	49c2      	ldr	r1, [pc, #776]	; (802255c <Process_Lora_Cmd+0x334>)
 8022252:	48c3      	ldr	r0, [pc, #780]	; (8022560 <Process_Lora_Cmd+0x338>)
 8022254:	f007 fb38 	bl	80298c8 <LmHandlerInit>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022258:	2300      	movs	r3, #0
 802225a:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 802225c:	6160      	str	r0, [r4, #20]
      InitPackageProcess();
 802225e:	f7ff fe1d 	bl	8021e9c <InitPackageProcess>
  APP_LOG(TS_ON, VLEVEL_H, "<CM0PLUS(LoRa)\r\n");
 8022262:	4bc0      	ldr	r3, [pc, #768]	; (8022564 <Process_Lora_Cmd+0x33c>)
 8022264:	2201      	movs	r2, #1
 8022266:	2100      	movs	r1, #0
 8022268:	2003      	movs	r0, #3
 802226a:	f011 fe01 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
  MBMUX_ResponseSnd(FEAT_INFO_LORAWAN_ID);
 802226e:	2008      	movs	r0, #8
 8022270:	f000 fa9a 	bl	80227a8 <MBMUX_ResponseSnd>
}
 8022274:	b002      	add	sp, #8
 8022276:	bd10      	pop	{r4, pc}
      errorStatus = LmHandlerDeInit();
 8022278:	f007 f812 	bl	80292a0 <LmHandlerDeInit>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802227c:	2300      	movs	r3, #0
 802227e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022280:	6160      	str	r0, [r4, #20]
      break;
 8022282:	e7ee      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerConfigure((LmHandlerParams_t *) com_buffer[0]);
 8022284:	6800      	ldr	r0, [r0, #0]
 8022286:	f007 f9f7 	bl	8029678 <LmHandlerConfigure>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802228a:	2300      	movs	r3, #0
 802228c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 802228e:	6160      	str	r0, [r4, #20]
      break;
 8022290:	e7e7      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      LmHandlerFlagStatus_t flagStatus = LmHandlerJoinStatus();
 8022292:	f007 f829 	bl	80292e8 <LmHandlerJoinStatus>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022296:	2300      	movs	r3, #0
 8022298:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) flagStatus; /* */
 802229a:	6160      	str	r0, [r4, #20]
    break;
 802229c:	e7e1      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      LmHandlerJoin((ActivationType_t) com_buffer[0], (bool) com_buffer[1]);
 802229e:	6841      	ldr	r1, [r0, #4]
 80222a0:	1e4b      	subs	r3, r1, #1
 80222a2:	4199      	sbcs	r1, r3
 80222a4:	b2c9      	uxtb	r1, r1
 80222a6:	7800      	ldrb	r0, [r0, #0]
 80222a8:	f006 ff76 	bl	8029198 <LmHandlerJoin>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80222ac:	2300      	movs	r3, #0
 80222ae:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 80222b0:	6163      	str	r3, [r4, #20]
      break;
 80222b2:	e7d6      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerStop();
 80222b4:	f007 fb6c 	bl	8029990 <LmHandlerStop>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80222b8:	2300      	movs	r3, #0
 80222ba:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 80222bc:	6160      	str	r0, [r4, #20]
      break;
 80222be:	e7d0      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerHalt();
 80222c0:	f007 fb6f 	bl	80299a2 <LmHandlerHalt>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80222c4:	2300      	movs	r3, #0
 80222c6:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 80222c8:	6160      	str	r0, [r4, #20]
      break;
 80222ca:	e7ca      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      busyStatus = LmHandlerIsBusy();
 80222cc:	f007 f820 	bl	8029310 <LmHandlerIsBusy>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80222d0:	2300      	movs	r3, #0
 80222d2:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (bool) busyStatus; /* */
 80222d4:	6160      	str	r0, [r4, #20]
      break;
 80222d6:	e7c4      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      appData.Port = (uint8_t)com_buffer[0];
 80222d8:	7803      	ldrb	r3, [r0, #0]
 80222da:	466a      	mov	r2, sp
 80222dc:	7013      	strb	r3, [r2, #0]
      appData.BufferSize = (uint8_t)com_buffer[1];
 80222de:	7903      	ldrb	r3, [r0, #4]
 80222e0:	7053      	strb	r3, [r2, #1]
      appData.Buffer = (uint8_t *)com_buffer[2];
 80222e2:	6883      	ldr	r3, [r0, #8]
 80222e4:	9301      	str	r3, [sp, #4]
      errorStatus = LmHandlerSend(&appData, (LmHandlerMsgTypes_t) com_buffer[3], (bool)com_buffer[4]);
 80222e6:	6902      	ldr	r2, [r0, #16]
 80222e8:	1e53      	subs	r3, r2, #1
 80222ea:	419a      	sbcs	r2, r3
 80222ec:	b2d2      	uxtb	r2, r2
 80222ee:	7b01      	ldrb	r1, [r0, #12]
 80222f0:	4668      	mov	r0, sp
 80222f2:	f007 f823 	bl	802933c <LmHandlerSend>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80222f6:	2300      	movs	r3, #0
 80222f8:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 80222fa:	6160      	str	r0, [r4, #20]
    break;
 80222fc:	e7b1      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      LmHandlerProcess();
 80222fe:	f007 f897 	bl	8029430 <LmHandlerProcess>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022302:	2300      	movs	r3, #0
 8022304:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022306:	6163      	str	r3, [r4, #20]
      break;
 8022308:	e7ab      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      dutyCycleWaitTime = LmHandlerGetDutyCycleWaitTime();
 802230a:	f006 ffe7 	bl	80292dc <LmHandlerGetDutyCycleWaitTime>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802230e:	2300      	movs	r3, #0
 8022310:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) dutyCycleWaitTime; /* */
 8022312:	6160      	str	r0, [r4, #20]
    break;
 8022314:	e7a5      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerRequestClass((DeviceClass_t) com_buffer[0]);
 8022316:	7800      	ldrb	r0, [r0, #0]
 8022318:	f007 f8b0 	bl	802947c <LmHandlerRequestClass>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802231c:	2300      	movs	r3, #0
 802231e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022320:	6160      	str	r0, [r4, #20]
      break;
 8022322:	e79e      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetCurrentClass((DeviceClass_t *) com_buffer[0]);
 8022324:	6800      	ldr	r0, [r0, #0]
 8022326:	f007 f90d 	bl	8029544 <LmHandlerGetCurrentClass>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802232a:	2300      	movs	r3, #0
 802232c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 802232e:	6160      	str	r0, [r4, #20]
      break;
 8022330:	e797      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetDevEUI((uint8_t *) com_buffer[0]);
 8022332:	6800      	ldr	r0, [r0, #0]
 8022334:	f007 fb4c 	bl	80299d0 <LmHandlerGetDevEUI>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022338:	2300      	movs	r3, #0
 802233a:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 802233c:	6160      	str	r0, [r4, #20]
      break;
 802233e:	e790      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerSetDevEUI((uint8_t *) com_buffer[0]);
 8022340:	6800      	ldr	r0, [r0, #0]
 8022342:	f007 fb5a 	bl	80299fa <LmHandlerSetDevEUI>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022346:	2300      	movs	r3, #0
 8022348:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 802234a:	6160      	str	r0, [r4, #20]
      break;
 802234c:	e789      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetAppEUI((uint8_t *) com_buffer[0]);
 802234e:	6800      	ldr	r0, [r0, #0]
 8022350:	f007 fb6c 	bl	8029a2c <LmHandlerGetAppEUI>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022354:	2300      	movs	r3, #0
 8022356:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022358:	6160      	str	r0, [r4, #20]
      break;
 802235a:	e782      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerSetAppEUI((uint8_t *) com_buffer[0]);
 802235c:	6800      	ldr	r0, [r0, #0]
 802235e:	f007 fb7a 	bl	8029a56 <LmHandlerSetAppEUI>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022362:	2300      	movs	r3, #0
 8022364:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022366:	6160      	str	r0, [r4, #20]
      break;
 8022368:	e77b      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetKey((KeyIdentifier_t) com_buffer[0], (uint8_t *) com_buffer[1]);
 802236a:	6841      	ldr	r1, [r0, #4]
 802236c:	7800      	ldrb	r0, [r0, #0]
 802236e:	f007 fdb9 	bl	8029ee4 <LmHandlerGetKey>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022372:	2300      	movs	r3, #0
 8022374:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022376:	6160      	str	r0, [r4, #20]
      break;
 8022378:	e773      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerSetKey((KeyIdentifier_t) com_buffer[0], (uint8_t *) com_buffer[1]);
 802237a:	6841      	ldr	r1, [r0, #4]
 802237c:	7800      	ldrb	r0, [r0, #0]
 802237e:	f007 fdbf 	bl	8029f00 <LmHandlerSetKey>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022382:	2300      	movs	r3, #0
 8022384:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022386:	6160      	str	r0, [r4, #20]
      break;
 8022388:	e76b      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetNetworkID((uint32_t *) com_buffer[0]);
 802238a:	6800      	ldr	r0, [r0, #0]
 802238c:	f007 fb7c 	bl	8029a88 <LmHandlerGetNetworkID>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022390:	2300      	movs	r3, #0
 8022392:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022394:	6160      	str	r0, [r4, #20]
      break;
 8022396:	e764      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerSetNetworkID((uint32_t) com_buffer[0]);
 8022398:	6800      	ldr	r0, [r0, #0]
 802239a:	f007 fb8b 	bl	8029ab4 <LmHandlerSetNetworkID>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802239e:	2300      	movs	r3, #0
 80223a0:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 80223a2:	6160      	str	r0, [r4, #20]
      break;
 80223a4:	e75d      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetDevAddr((uint32_t *) com_buffer[0]);
 80223a6:	6800      	ldr	r0, [r0, #0]
 80223a8:	f007 fb9d 	bl	8029ae6 <LmHandlerGetDevAddr>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80223ac:	2300      	movs	r3, #0
 80223ae:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 80223b0:	6160      	str	r0, [r4, #20]
      break;
 80223b2:	e756      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerSetDevAddr((uint32_t) com_buffer[0]);
 80223b4:	6800      	ldr	r0, [r0, #0]
 80223b6:	f007 fbac 	bl	8029b12 <LmHandlerSetDevAddr>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80223ba:	2300      	movs	r3, #0
 80223bc:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 80223be:	6160      	str	r0, [r4, #20]
      break;
 80223c0:	e74f      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetActiveRegion((LoRaMacRegion_t *) com_buffer[0]);
 80223c2:	6800      	ldr	r0, [r0, #0]
 80223c4:	f007 f93c 	bl	8029640 <LmHandlerGetActiveRegion>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80223c8:	2300      	movs	r3, #0
 80223ca:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 80223cc:	6160      	str	r0, [r4, #20]
      break;
 80223ce:	e748      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerSetActiveRegion((LoRaMacRegion_t) com_buffer[0]);
 80223d0:	7800      	ldrb	r0, [r0, #0]
 80223d2:	f007 fbb7 	bl	8029b44 <LmHandlerSetActiveRegion>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80223d6:	2300      	movs	r3, #0
 80223d8:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 80223da:	6160      	str	r0, [r4, #20]
      break;
 80223dc:	e741      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetAdrEnable((bool *) com_buffer[0]);
 80223de:	6800      	ldr	r0, [r0, #0]
 80223e0:	f007 fbc0 	bl	8029b64 <LmHandlerGetAdrEnable>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80223e4:	2300      	movs	r3, #0
 80223e6:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 80223e8:	6160      	str	r0, [r4, #20]
      break;
 80223ea:	e73a      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerSetAdrEnable((bool) com_buffer[0]);
 80223ec:	6800      	ldr	r0, [r0, #0]
 80223ee:	1e43      	subs	r3, r0, #1
 80223f0:	4198      	sbcs	r0, r3
 80223f2:	b2c0      	uxtb	r0, r0
 80223f4:	f007 fbc2 	bl	8029b7c <LmHandlerSetAdrEnable>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80223f8:	2300      	movs	r3, #0
 80223fa:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 80223fc:	6160      	str	r0, [r4, #20]
      break;
 80223fe:	e730      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetTxDatarate((int8_t *) com_buffer[0]);
 8022400:	6800      	ldr	r0, [r0, #0]
 8022402:	f007 f901 	bl	8029608 <LmHandlerGetTxDatarate>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022406:	2300      	movs	r3, #0
 8022408:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 802240a:	6160      	str	r0, [r4, #20]
      break;
 802240c:	e729      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerSetTxDatarate((int8_t) com_buffer[0]);
 802240e:	7800      	ldrb	r0, [r0, #0]
 8022410:	b240      	sxtb	r0, r0
 8022412:	f007 fbc9 	bl	8029ba8 <LmHandlerSetTxDatarate>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022416:	2300      	movs	r3, #0
 8022418:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 802241a:	6160      	str	r0, [r4, #20]
      break;
 802241c:	e721      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetDutyCycleEnable((bool *) com_buffer[0]);
 802241e:	6800      	ldr	r0, [r0, #0]
 8022420:	f007 fbde 	bl	8029be0 <LmHandlerGetDutyCycleEnable>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022424:	2300      	movs	r3, #0
 8022426:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022428:	6160      	str	r0, [r4, #20]
      break;
 802242a:	e71a      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerSetDutyCycleEnable((bool) com_buffer[0]);
 802242c:	6800      	ldr	r0, [r0, #0]
 802242e:	1e43      	subs	r3, r0, #1
 8022430:	4198      	sbcs	r0, r3
 8022432:	b2c0      	uxtb	r0, r0
 8022434:	f007 fbe0 	bl	8029bf8 <LmHandlerSetDutyCycleEnable>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022438:	2300      	movs	r3, #0
 802243a:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 802243c:	6160      	str	r0, [r4, #20]
      break;
 802243e:	e710      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetRX2Params((RxChannelParams_t *) com_buffer[0]);
 8022440:	6800      	ldr	r0, [r0, #0]
 8022442:	f007 fbe3 	bl	8029c0c <LmHandlerGetRX2Params>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022446:	2300      	movs	r3, #0
 8022448:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 802244a:	6160      	str	r0, [r4, #20]
      break;
 802244c:	e709      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetTxPower((int8_t *) com_buffer[0]);
 802244e:	6800      	ldr	r0, [r0, #0]
 8022450:	f007 fbf6 	bl	8029c40 <LmHandlerGetTxPower>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022454:	2300      	movs	r3, #0
 8022456:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022458:	6160      	str	r0, [r4, #20]
      break;
 802245a:	e702      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetRx1Delay((uint32_t *) com_buffer[0]);
 802245c:	6800      	ldr	r0, [r0, #0]
 802245e:	f007 fc77 	bl	8029d50 <LmHandlerGetRx1Delay>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022462:	2300      	movs	r3, #0
 8022464:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022466:	6160      	str	r0, [r4, #20]
      break;
 8022468:	e6fb      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetRx2Delay((uint32_t *) com_buffer[0]);
 802246a:	6800      	ldr	r0, [r0, #0]
 802246c:	f007 fc86 	bl	8029d7c <LmHandlerGetRx2Delay>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022470:	2300      	movs	r3, #0
 8022472:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022474:	6160      	str	r0, [r4, #20]
      break;
 8022476:	e6f4      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetJoinRx1Delay((uint32_t *) com_buffer[0]);
 8022478:	6800      	ldr	r0, [r0, #0]
 802247a:	f007 fc95 	bl	8029da8 <LmHandlerGetJoinRx1Delay>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802247e:	2300      	movs	r3, #0
 8022480:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022482:	6160      	str	r0, [r4, #20]
      break;
 8022484:	e6ed      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetJoinRx2Delay((uint32_t *) com_buffer[0]);
 8022486:	6800      	ldr	r0, [r0, #0]
 8022488:	f007 fca4 	bl	8029dd4 <LmHandlerGetJoinRx2Delay>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802248c:	2300      	movs	r3, #0
 802248e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022490:	6160      	str	r0, [r4, #20]
      break;
 8022492:	e6e6      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerSetRX2Params((RxChannelParams_t *) com_buffer[0]);
 8022494:	6800      	ldr	r0, [r0, #0]
 8022496:	f007 fcc9 	bl	8029e2c <LmHandlerSetRX2Params>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802249a:	2300      	movs	r3, #0
 802249c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 802249e:	6160      	str	r0, [r4, #20]
      break;
 80224a0:	e6df      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerSetTxPower((int8_t) com_buffer[0]);
 80224a2:	7800      	ldrb	r0, [r0, #0]
 80224a4:	b240      	sxtb	r0, r0
 80224a6:	f007 fcab 	bl	8029e00 <LmHandlerSetTxPower>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80224aa:	2300      	movs	r3, #0
 80224ac:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 80224ae:	6160      	str	r0, [r4, #20]
      break;
 80224b0:	e6d7      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerSetRx1Delay((uint32_t) com_buffer[0]);
 80224b2:	6800      	ldr	r0, [r0, #0]
 80224b4:	f007 fccd 	bl	8029e52 <LmHandlerSetRx1Delay>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80224b8:	2300      	movs	r3, #0
 80224ba:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 80224bc:	6160      	str	r0, [r4, #20]
      break;
 80224be:	e6d0      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerSetRx2Delay((uint32_t) com_buffer[0]);
 80224c0:	6800      	ldr	r0, [r0, #0]
 80224c2:	f007 fcd6 	bl	8029e72 <LmHandlerSetRx2Delay>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80224c6:	2300      	movs	r3, #0
 80224c8:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 80224ca:	6160      	str	r0, [r4, #20]
      break;
 80224cc:	e6c9      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerSetJoinRx1Delay((uint32_t) com_buffer[0]);
 80224ce:	6800      	ldr	r0, [r0, #0]
 80224d0:	f007 fcdf 	bl	8029e92 <LmHandlerSetJoinRx1Delay>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80224d4:	2300      	movs	r3, #0
 80224d6:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 80224d8:	6160      	str	r0, [r4, #20]
      break;
 80224da:	e6c2      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerSetJoinRx2Delay((uint32_t) com_buffer[0]);
 80224dc:	6800      	ldr	r0, [r0, #0]
 80224de:	f007 fce8 	bl	8029eb2 <LmHandlerSetJoinRx2Delay>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80224e2:	2300      	movs	r3, #0
 80224e4:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 80224e6:	6160      	str	r0, [r4, #20]
      break;
 80224e8:	e6bb      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetPingPeriodicity((uint8_t *) com_buffer[0]);
 80224ea:	6800      	ldr	r0, [r0, #0]
 80224ec:	f007 fcf1 	bl	8029ed2 <LmHandlerGetPingPeriodicity>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80224f0:	2300      	movs	r3, #0
 80224f2:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 80224f4:	6160      	str	r0, [r4, #20]
      break;
 80224f6:	e6b4      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerSetPingPeriodicity((uint8_t) com_buffer[0]);
 80224f8:	7800      	ldrb	r0, [r0, #0]
 80224fa:	f007 fced 	bl	8029ed8 <LmHandlerSetPingPeriodicity>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 80224fe:	2300      	movs	r3, #0
 8022500:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022502:	6160      	str	r0, [r4, #20]
      break;
 8022504:	e6ad      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetBeaconState((BeaconState_t *) com_buffer[0]);
 8022506:	6800      	ldr	r0, [r0, #0]
 8022508:	f007 fce9 	bl	8029ede <LmHandlerGetBeaconState>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802250c:	2300      	movs	r3, #0
 802250e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022510:	6160      	str	r0, [r4, #20]
      break;
 8022512:	e6a6      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerLinkCheckReq();
 8022514:	f007 fa4e 	bl	80299b4 <LmHandlerLinkCheckReq>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022518:	2300      	movs	r3, #0
 802251a:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 802251c:	6160      	str	r0, [r4, #20]
      break;
 802251e:	e6a0      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerDeviceTimeReq();
 8022520:	f006 feaa 	bl	8029278 <LmHandlerDeviceTimeReq>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022524:	2300      	movs	r3, #0
 8022526:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022528:	6160      	str	r0, [r4, #20]
      break;
 802252a:	e69a      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerGetVersion((LmHandlerVersionType_t)com_buffer[0], (uint32_t *) com_buffer[1]);
 802252c:	6841      	ldr	r1, [r0, #4]
 802252e:	7800      	ldrb	r0, [r0, #0]
 8022530:	f007 fa16 	bl	8029960 <LmHandlerGetVersion>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022534:	2300      	movs	r3, #0
 8022536:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022538:	6160      	str	r0, [r4, #20]
      break;
 802253a:	e692      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      errorStatus = LmHandlerNvmDataStore();
 802253c:	f007 fd06 	bl	8029f4c <LmHandlerNvmDataStore>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022540:	2300      	movs	r3, #0
 8022542:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) errorStatus; /* */
 8022544:	6160      	str	r0, [r4, #20]
      break;
 8022546:	e68c      	b.n	8022262 <Process_Lora_Cmd+0x3a>
      LoraInfo_Init();
 8022548:	f000 f83c 	bl	80225c4 <LoraInfo_Init>
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802254c:	2300      	movs	r3, #0
 802254e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022550:	6163      	str	r3, [r4, #20]
      break;
 8022552:	e686      	b.n	8022262 <Process_Lora_Cmd+0x3a>
 8022554:	08034db8 	.word	0x08034db8
 8022558:	08034de0 	.word	0x08034de0
 802255c:	01030000 	.word	0x01030000
 8022560:	2000b000 	.word	0x2000b000
 8022564:	08034dcc 	.word	0x08034dcc

08022568 <FEAT_INFO_Init>:
/* USER CODE END PFP */

/* Exported functions --------------------------------------------------------*/

void FEAT_INFO_Init(void)
{
 8022568:	b510      	push	{r4, lr}
  /* USER CODE BEGIN FEAT_INFO_Init_1 */

  /* USER CODE END FEAT_INFO_Init_1 */

  /* Set LoRaWAN Info_Config */
  LoraInfo_Init();
 802256a:	f000 f82b 	bl	80225c4 <LoraInfo_Init>
  /* USER CODE BEGIN FEAT_INFO_Init_2 */

  /* USER CODE END FEAT_INFO_Init_2 */
}
 802256e:	bd10      	pop	{r4, pc}

08022570 <FEAT_INFO_GetListPtr>:
  /* USER CODE END FEAT_INFO_GetListPtr_1 */
  return (FEAT_INFO_List_t *) &Feat_Info_List;
  /* USER CODE BEGIN FEAT_INFO_GetListPtr_2 */

  /* USER CODE END FEAT_INFO_GetListPtr_2 */
}
 8022570:	4800      	ldr	r0, [pc, #0]	; (8022574 <FEAT_INFO_GetListPtr+0x4>)
 8022572:	4770      	bx	lr
 8022574:	20009000 	.word	0x20009000

08022578 <LoraInfo_GetPtr>:
{
  /* USER CODE BEGIN LoraInfo_GetPtr */

  /* USER CODE END LoraInfo_GetPtr */
  return &loraInfo;
}
 8022578:	4800      	ldr	r0, [pc, #0]	; (802257c <LoraInfo_GetPtr+0x4>)
 802257a:	4770      	bx	lr
 802257c:	20009190 	.word	0x20009190

08022580 <StoreValueInFeatureListTable>:

/* USER CODE END EF */

/* Private functions --------------------------------------------------------*/
void StoreValueInFeatureListTable(void)
{
 8022580:	b570      	push	{r4, r5, r6, lr}

  /* USER CODE BEGIN StoreValueInFeatureListTable_1 */

  /* USER CODE END StoreValueInFeatureListTable_1 */

  p_MBMUX_Cm0plusFeatureList = FEAT_INFO_GetListPtr();
 8022582:	f7ff fff5 	bl	8022570 <FEAT_INFO_GetListPtr>

  if (p_MBMUX_Cm0plusFeatureList != NULL)
 8022586:	2800      	cmp	r0, #0
 8022588:	d016      	beq.n	80225b8 <StoreValueInFeatureListTable+0x38>
  {
    cm0plus_nr_of_supported_features = p_MBMUX_Cm0plusFeatureList->Feat_Info_Cnt;
 802258a:	7805      	ldrb	r5, [r0, #0]

    for (i = 0; i < cm0plus_nr_of_supported_features;  i++)
 802258c:	2300      	movs	r3, #0
 802258e:	42ab      	cmp	r3, r5
 8022590:	d208      	bcs.n	80225a4 <StoreValueInFeatureListTable+0x24>
    {
      p_feature = i + p_MBMUX_Cm0plusFeatureList->Feat_Info_TableAddress;
 8022592:	6841      	ldr	r1, [r0, #4]
 8022594:	011a      	lsls	r2, r3, #4
 8022596:	188c      	adds	r4, r1, r2
      if (p_feature->Feat_Info_Feature_Id == FEAT_INFO_LORAWAN_ID)
 8022598:	5c8a      	ldrb	r2, [r1, r2]
 802259a:	2a08      	cmp	r2, #8
 802259c:	d00a      	beq.n	80225b4 <StoreValueInFeatureListTable+0x34>
    for (i = 0; i < cm0plus_nr_of_supported_features;  i++)
 802259e:	3301      	adds	r3, #1
 80225a0:	b2db      	uxtb	r3, r3
 80225a2:	e7f4      	b.n	802258e <StoreValueInFeatureListTable+0xe>
  uint8_t found = 0;
 80225a4:	2300      	movs	r3, #0
        break;
      }
    }
  }

  if (found)
 80225a6:	2b00      	cmp	r3, #0
 80225a8:	d006      	beq.n	80225b8 <StoreValueInFeatureListTable+0x38>
  {
    p_feature->Feat_Info_Config_Size = sizeof(LoraInfo_t) / sizeof(uint32_t);
 80225aa:	2304      	movs	r3, #4
 80225ac:	60a3      	str	r3, [r4, #8]
    p_feature->Feat_Info_Config_Ptr = &loraInfo;
 80225ae:	4b04      	ldr	r3, [pc, #16]	; (80225c0 <StoreValueInFeatureListTable+0x40>)
 80225b0:	60e3      	str	r3, [r4, #12]
 80225b2:	e003      	b.n	80225bc <StoreValueInFeatureListTable+0x3c>
        found = 1;
 80225b4:	2301      	movs	r3, #1
 80225b6:	e7f6      	b.n	80225a6 <StoreValueInFeatureListTable+0x26>
  }
  else
  {
    Error_Handler();
 80225b8:	f7ff f86b 	bl	8021692 <Error_Handler>

  /* USER CODE BEGIN StoreValueInFeatureListTable_2 */

  /* USER CODE END StoreValueInFeatureListTable_2 */
  return;
}
 80225bc:	bd70      	pop	{r4, r5, r6, pc}
 80225be:	46c0      	nop			; (mov r8, r8)
 80225c0:	20009190 	.word	0x20009190

080225c4 <LoraInfo_Init>:
{
 80225c4:	b510      	push	{r4, lr}
  loraInfo.ContextManagement = 0;
 80225c6:	4b09      	ldr	r3, [pc, #36]	; (80225ec <LoraInfo_Init+0x28>)
 80225c8:	2200      	movs	r2, #0
 80225ca:	601a      	str	r2, [r3, #0]
  loraInfo.Region = 0;
 80225cc:	605a      	str	r2, [r3, #4]
  loraInfo.ClassB = 0;
 80225ce:	609a      	str	r2, [r3, #8]
  loraInfo.Kms = 0;
 80225d0:	60da      	str	r2, [r3, #12]
  loraInfo.Region |= (1 << LORAMAC_REGION_EU868);
 80225d2:	3220      	adds	r2, #32
 80225d4:	605a      	str	r2, [r3, #4]
  loraInfo.Region |= (1 << LORAMAC_REGION_US915);
 80225d6:	3201      	adds	r2, #1
 80225d8:	32ff      	adds	r2, #255	; 0xff
 80225da:	605a      	str	r2, [r3, #4]
  loraInfo.Kms = 1;
 80225dc:	3a20      	subs	r2, #32
 80225de:	3aff      	subs	r2, #255	; 0xff
 80225e0:	60da      	str	r2, [r3, #12]
  loraInfo.ContextManagement = 1;
 80225e2:	601a      	str	r2, [r3, #0]
  StoreValueInFeatureListTable();
 80225e4:	f7ff ffcc 	bl	8022580 <StoreValueInFeatureListTable>
}
 80225e8:	bd10      	pop	{r4, pc}
 80225ea:	46c0      	nop			; (mov r8, r8)
 80225ec:	20009190 	.word	0x20009190

080225f0 <MBMUX_IsrCommandRcvCb>:

  /* USER CODE END MBMUX_RetrieveSecureSramConfig_Last */
}

static void MBMUX_IsrCommandRcvCb(uint32_t channelIdx)
{
 80225f0:	b510      	push	{r4, lr}
 80225f2:	0003      	movs	r3, r0
  /* USER CODE BEGIN MBMUX_IsrCommandRcvCb_1 */

  /* USER CODE END MBMUX_IsrCommandRcvCb_1 */
  /* retrieve pointer to com params */
  void *com_obj = (void *) &p_MBMUX_ComTable->MBCmdRespParam[channelIdx];
 80225f4:	4a05      	ldr	r2, [pc, #20]	; (802260c <MBMUX_IsrCommandRcvCb+0x1c>)
 80225f6:	6811      	ldr	r1, [r2, #0]
 80225f8:	0040      	lsls	r0, r0, #1
 80225fa:	18c0      	adds	r0, r0, r3
 80225fc:	00c0      	lsls	r0, r0, #3
 80225fe:	1808      	adds	r0, r1, r0
  /* call registered callback */
  MBMUX_MsgCbPointersTabCm0.MBCmdRespCb[channelIdx].MsgCm0plusCb(com_obj);
 8022600:	009b      	lsls	r3, r3, #2
 8022602:	4a03      	ldr	r2, [pc, #12]	; (8022610 <MBMUX_IsrCommandRcvCb+0x20>)
 8022604:	589b      	ldr	r3, [r3, r2]
 8022606:	4798      	blx	r3
  /* USER CODE BEGIN MBMUX_IsrCommandRcvCb_Last */

  /* USER CODE END MBMUX_IsrCommandRcvCb_Last */
  return;
}
 8022608:	bd10      	pop	{r4, pc}
 802260a:	46c0      	nop			; (mov r8, r8)
 802260c:	2000b2ac 	.word	0x2000b2ac
 8022610:	2000b224 	.word	0x2000b224

08022614 <MBMUX_IsrAcknowledgeRcvCb>:

static void MBMUX_IsrAcknowledgeRcvCb(uint32_t channelIdx)
{
 8022614:	b510      	push	{r4, lr}
 8022616:	0003      	movs	r3, r0
  /* USER CODE BEGIN MBMUX_IsrAcknowledgeRcvCb_1 */

  /* USER CODE END MBMUX_IsrAcknowledgeRcvCb_1 */
  /* retrieve pointer to com params */
  void *com_obj = (void *) &p_MBMUX_ComTable->MBNotifAckParam[channelIdx];
 8022618:	4a06      	ldr	r2, [pc, #24]	; (8022634 <MBMUX_IsrAcknowledgeRcvCb+0x20>)
 802261a:	6811      	ldr	r1, [r2, #0]
 802261c:	0042      	lsls	r2, r0, #1
 802261e:	1812      	adds	r2, r2, r0
 8022620:	00d2      	lsls	r2, r2, #3
 8022622:	3290      	adds	r2, #144	; 0x90
 8022624:	1888      	adds	r0, r1, r2
  /* call registered callback */
  MBMUX_MsgCbPointersTabCm0.MBNotifAckCb[channelIdx].MsgCm0plusCb(com_obj);
 8022626:	3306      	adds	r3, #6
 8022628:	009b      	lsls	r3, r3, #2
 802262a:	4a03      	ldr	r2, [pc, #12]	; (8022638 <MBMUX_IsrAcknowledgeRcvCb+0x24>)
 802262c:	589b      	ldr	r3, [r3, r2]
 802262e:	4798      	blx	r3
  /* USER CODE BEGIN MBMUX_IsrAcknowledgeRcvCb_Last */

  /* USER CODE END MBMUX_IsrAcknowledgeRcvCb_Last */
  return;
}
 8022630:	bd10      	pop	{r4, pc}
 8022632:	46c0      	nop			; (mov r8, r8)
 8022634:	2000b2ac 	.word	0x2000b2ac
 8022638:	2000b224 	.word	0x2000b224

0802263c <MBMUX_GetFeatureChIdx>:
static uint8_t MBMUX_GetFeatureChIdx(FEAT_INFO_IdTypeDef e_featID, MBMUX_ComType_t ComType)
{
  /* USER CODE BEGIN MBMUX_GetFeatureChIdx_1 */

  /* USER CODE END MBMUX_GetFeatureChIdx_1 */
  return p_MBMUX_ComTable->MBMUXMapping[e_featID][ComType];
 802263c:	4b04      	ldr	r3, [pc, #16]	; (8022650 <MBMUX_GetFeatureChIdx+0x14>)
 802263e:	681b      	ldr	r3, [r3, #0]
 8022640:	0040      	lsls	r0, r0, #1
 8022642:	181b      	adds	r3, r3, r0
 8022644:	185b      	adds	r3, r3, r1
 8022646:	3321      	adds	r3, #33	; 0x21
 8022648:	33ff      	adds	r3, #255	; 0xff
 802264a:	7818      	ldrb	r0, [r3, #0]
  /* USER CODE BEGIN MBMUX_GetFeatureChIdx_Last */

  /* USER CODE END MBMUX_GetFeatureChIdx_Last */
}
 802264c:	4770      	bx	lr
 802264e:	46c0      	nop			; (mov r8, r8)
 8022650:	2000b2ac 	.word	0x2000b2ac

08022654 <MBMUX_IsrNotRegistered>:

static void MBMUX_IsrNotRegistered(void *ComObj)
{
 8022654:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MBMUX_IsrNotRegistered_1 */

  /* USER CODE END MBMUX_IsrNotRegistered_1 */
  Error_Handler();
 8022656:	f7ff f81c 	bl	8021692 <Error_Handler>
  /* USER CODE BEGIN MBMUX_IsrNotRegistered_Last */

  /* USER CODE END MBMUX_IsrNotRegistered_Last */
}
 802265a:	bd10      	pop	{r4, pc}

0802265c <MBMUX_SEC_VerifySramBuffer>:
{
 802265c:	b510      	push	{r4, lr}
  if ((OptionsBytesStruct.SecureMode & OB_SECURE_SYSTEM_AND_FLASH_ENABLE) != 0)
 802265e:	4b13      	ldr	r3, [pc, #76]	; (80226ac <MBMUX_SEC_VerifySramBuffer+0x50>)
 8022660:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8022662:	07db      	lsls	r3, r3, #31
 8022664:	d519      	bpl.n	802269a <MBMUX_SEC_VerifySramBuffer+0x3e>
    if (((((uint32_t)(pBufferAddress)) >= SRAM1_BASE)
 8022666:	0003      	movs	r3, r0
 8022668:	2280      	movs	r2, #128	; 0x80
 802266a:	0592      	lsls	r2, r2, #22
 802266c:	4290      	cmp	r0, r2
 802266e:	d304      	bcc.n	802267a <MBMUX_SEC_VerifySramBuffer+0x1e>
         && ((((uint32_t)(pBufferAddress)) + bufferSize) <= unsecure_sram1_end)) ||
 8022670:	1842      	adds	r2, r0, r1
 8022672:	4c0f      	ldr	r4, [pc, #60]	; (80226b0 <MBMUX_SEC_VerifySramBuffer+0x54>)
 8022674:	6824      	ldr	r4, [r4, #0]
 8022676:	42a2      	cmp	r2, r4
 8022678:	d907      	bls.n	802268a <MBMUX_SEC_VerifySramBuffer+0x2e>
 802267a:	4a0e      	ldr	r2, [pc, #56]	; (80226b4 <MBMUX_SEC_VerifySramBuffer+0x58>)
 802267c:	4293      	cmp	r3, r2
 802267e:	d911      	bls.n	80226a4 <MBMUX_SEC_VerifySramBuffer+0x48>
        ((((uint32_t)(pBufferAddress)) >= SRAM2_BASE) && ((((uint32_t)(pBufferAddress)) + bufferSize) <= unsecure_sram2_end))
 8022680:	185a      	adds	r2, r3, r1
 8022682:	4c0d      	ldr	r4, [pc, #52]	; (80226b8 <MBMUX_SEC_VerifySramBuffer+0x5c>)
 8022684:	6824      	ldr	r4, [r4, #0]
 8022686:	42a2      	cmp	r2, r4
 8022688:	d80c      	bhi.n	80226a4 <MBMUX_SEC_VerifySramBuffer+0x48>
      if (((uint32_t)pBufferAddress <= unsecure_sram2_end) && (bufferSize < (SRAM1_SIZE + SRAM2_SIZE)))
 802268a:	4a0b      	ldr	r2, [pc, #44]	; (80226b8 <MBMUX_SEC_VerifySramBuffer+0x5c>)
 802268c:	6812      	ldr	r2, [r2, #0]
 802268e:	4293      	cmp	r3, r2
 8022690:	d804      	bhi.n	802269c <MBMUX_SEC_VerifySramBuffer+0x40>
 8022692:	2380      	movs	r3, #128	; 0x80
 8022694:	025b      	lsls	r3, r3, #9
 8022696:	4299      	cmp	r1, r3
 8022698:	d200      	bcs.n	802269c <MBMUX_SEC_VerifySramBuffer+0x40>
}
 802269a:	bd10      	pop	{r4, pc}
        Error_Handler();
 802269c:	f7fe fff9 	bl	8021692 <Error_Handler>
  uint32_t *p_validated_address = NULL;
 80226a0:	2000      	movs	r0, #0
 80226a2:	e7fa      	b.n	802269a <MBMUX_SEC_VerifySramBuffer+0x3e>
      Error_Handler();
 80226a4:	f7fe fff5 	bl	8021692 <Error_Handler>
  uint32_t *p_validated_address = NULL;
 80226a8:	2000      	movs	r0, #0
 80226aa:	e7f6      	b.n	802269a <MBMUX_SEC_VerifySramBuffer+0x3e>
 80226ac:	2000b254 	.word	0x2000b254
 80226b0:	2000b2b0 	.word	0x2000b2b0
 80226b4:	20007fff 	.word	0x20007fff
 80226b8:	2000b2b4 	.word	0x2000b2b4

080226bc <MBMUX_RetrieveSecureSramConfig>:
{
 80226bc:	b510      	push	{r4, lr}
  HAL_FLASHEx_OBGetConfig(&OptionsBytesStruct);
 80226be:	4c0d      	ldr	r4, [pc, #52]	; (80226f4 <MBMUX_RetrieveSecureSramConfig+0x38>)
 80226c0:	0020      	movs	r0, r4
 80226c2:	f001 febb 	bl	802443c <HAL_FLASHEx_OBGetConfig>
  if ((OptionsBytesStruct.SecureMode & OB_SECURE_SRAM1_DISABLE) != 0)
 80226c6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80226c8:	065a      	lsls	r2, r3, #25
 80226ca:	d508      	bpl.n	80226de <MBMUX_RetrieveSecureSramConfig+0x22>
    unsecure_sram1_end = SRAM1_BASE + SRAM1_SIZE;
 80226cc:	4a0a      	ldr	r2, [pc, #40]	; (80226f8 <MBMUX_RetrieveSecureSramConfig+0x3c>)
 80226ce:	490b      	ldr	r1, [pc, #44]	; (80226fc <MBMUX_RetrieveSecureSramConfig+0x40>)
 80226d0:	6011      	str	r1, [r2, #0]
  if ((OptionsBytesStruct.SecureMode & OB_SECURE_SRAM2_DISABLE) != 0)
 80226d2:	061b      	lsls	r3, r3, #24
 80226d4:	d508      	bpl.n	80226e8 <MBMUX_RetrieveSecureSramConfig+0x2c>
    unsecure_sram2_end = SRAM2_BASE + SRAM2_SIZE;
 80226d6:	4b0a      	ldr	r3, [pc, #40]	; (8022700 <MBMUX_RetrieveSecureSramConfig+0x44>)
 80226d8:	4a0a      	ldr	r2, [pc, #40]	; (8022704 <MBMUX_RetrieveSecureSramConfig+0x48>)
 80226da:	601a      	str	r2, [r3, #0]
}
 80226dc:	bd10      	pop	{r4, pc}
    unsecure_sram1_end = OptionsBytesStruct.SecureSRAM1StartAddr;
 80226de:	4a05      	ldr	r2, [pc, #20]	; (80226f4 <MBMUX_RetrieveSecureSramConfig+0x38>)
 80226e0:	6b91      	ldr	r1, [r2, #56]	; 0x38
 80226e2:	4a05      	ldr	r2, [pc, #20]	; (80226f8 <MBMUX_RetrieveSecureSramConfig+0x3c>)
 80226e4:	6011      	str	r1, [r2, #0]
 80226e6:	e7f4      	b.n	80226d2 <MBMUX_RetrieveSecureSramConfig+0x16>
    unsecure_sram2_end = OptionsBytesStruct.SecureSRAM2StartAddr;
 80226e8:	4b02      	ldr	r3, [pc, #8]	; (80226f4 <MBMUX_RetrieveSecureSramConfig+0x38>)
 80226ea:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80226ec:	4b04      	ldr	r3, [pc, #16]	; (8022700 <MBMUX_RetrieveSecureSramConfig+0x44>)
 80226ee:	601a      	str	r2, [r3, #0]
}
 80226f0:	e7f4      	b.n	80226dc <MBMUX_RetrieveSecureSramConfig+0x20>
 80226f2:	46c0      	nop			; (mov r8, r8)
 80226f4:	2000b254 	.word	0x2000b254
 80226f8:	2000b2b0 	.word	0x2000b2b0
 80226fc:	20008000 	.word	0x20008000
 8022700:	2000b2b4 	.word	0x2000b2b4
 8022704:	20010000 	.word	0x20010000

08022708 <MBMUX_RegisterFeatureCallback>:
{
 8022708:	b570      	push	{r4, r5, r6, lr}
 802270a:	000c      	movs	r4, r1
 802270c:	0015      	movs	r5, r2
  check_existing_feature_registration = MBMUX_GetFeatureChIdx(e_featID, ComType);
 802270e:	f7ff ff95 	bl	802263c <MBMUX_GetFeatureChIdx>
  if (check_existing_feature_registration != MB_CHANNEL_NOT_REGISTERED)
 8022712:	28ff      	cmp	r0, #255	; 0xff
 8022714:	d00b      	beq.n	802272e <MBMUX_RegisterFeatureCallback+0x26>
      if (ComType == MBMUX_CMD_RESP)
 8022716:	2c00      	cmp	r4, #0
 8022718:	d104      	bne.n	8022724 <MBMUX_RegisterFeatureCallback+0x1c>
        MBMUX_MsgCbPointersTabCm0.MBCmdRespCb[channel_idx].MsgCm0plusCb = MsgCb;
 802271a:	0083      	lsls	r3, r0, #2
 802271c:	4a05      	ldr	r2, [pc, #20]	; (8022734 <MBMUX_RegisterFeatureCallback+0x2c>)
 802271e:	509d      	str	r5, [r3, r2]
      ret = channel_idx;
 8022720:	b240      	sxtb	r0, r0
}
 8022722:	bd70      	pop	{r4, r5, r6, pc}
        MBMUX_MsgCbPointersTabCm0.MBNotifAckCb[channel_idx].MsgCm0plusCb = MsgCb;
 8022724:	1d83      	adds	r3, r0, #6
 8022726:	009b      	lsls	r3, r3, #2
 8022728:	4a02      	ldr	r2, [pc, #8]	; (8022734 <MBMUX_RegisterFeatureCallback+0x2c>)
 802272a:	509d      	str	r5, [r3, r2]
 802272c:	e7f8      	b.n	8022720 <MBMUX_RegisterFeatureCallback+0x18>
  int8_t ret = -1;
 802272e:	2001      	movs	r0, #1
 8022730:	4240      	negs	r0, r0
 8022732:	e7f6      	b.n	8022722 <MBMUX_RegisterFeatureCallback+0x1a>
 8022734:	2000b224 	.word	0x2000b224

08022738 <MBMUX_GetFeatureComPtr>:
{
 8022738:	b510      	push	{r4, lr}
 802273a:	000c      	movs	r4, r1
  channel_idx = MBMUX_GetFeatureChIdx(e_featID, ComType);
 802273c:	f7ff ff7e 	bl	802263c <MBMUX_GetFeatureChIdx>
  if (channel_idx < MBMUX_CHANNEL_NUMBER)
 8022740:	2805      	cmp	r0, #5
 8022742:	d810      	bhi.n	8022766 <MBMUX_GetFeatureComPtr+0x2e>
    if (ComType == MBMUX_CMD_RESP)  /* TX */
 8022744:	2c00      	cmp	r4, #0
 8022746:	d106      	bne.n	8022756 <MBMUX_GetFeatureComPtr+0x1e>
      com_param_ptr = (MBMUX_ComParam_t *) &p_MBMUX_ComTable->MBCmdRespParam[channel_idx];
 8022748:	4b08      	ldr	r3, [pc, #32]	; (802276c <MBMUX_GetFeatureComPtr+0x34>)
 802274a:	681b      	ldr	r3, [r3, #0]
 802274c:	0042      	lsls	r2, r0, #1
 802274e:	1810      	adds	r0, r2, r0
 8022750:	00c0      	lsls	r0, r0, #3
 8022752:	1818      	adds	r0, r3, r0
}
 8022754:	bd10      	pop	{r4, pc}
      com_param_ptr = (MBMUX_ComParam_t *) &p_MBMUX_ComTable->MBNotifAckParam[channel_idx];
 8022756:	4b05      	ldr	r3, [pc, #20]	; (802276c <MBMUX_GetFeatureComPtr+0x34>)
 8022758:	681b      	ldr	r3, [r3, #0]
 802275a:	0042      	lsls	r2, r0, #1
 802275c:	1810      	adds	r0, r2, r0
 802275e:	00c0      	lsls	r0, r0, #3
 8022760:	3090      	adds	r0, #144	; 0x90
 8022762:	1818      	adds	r0, r3, r0
 8022764:	e7f6      	b.n	8022754 <MBMUX_GetFeatureComPtr+0x1c>
  MBMUX_ComParam_t *com_param_ptr = NULL;
 8022766:	2000      	movs	r0, #0
  return com_param_ptr;
 8022768:	e7f4      	b.n	8022754 <MBMUX_GetFeatureComPtr+0x1c>
 802276a:	46c0      	nop			; (mov r8, r8)
 802276c:	2000b2ac 	.word	0x2000b2ac

08022770 <MBMUX_NotificationSnd>:
{
 8022770:	b510      	push	{r4, lr}
  mb_ch = MBMUX_GetFeatureChIdx(e_featID, MBMUX_NOTIF_ACK);
 8022772:	2101      	movs	r1, #1
 8022774:	f7ff ff62 	bl	802263c <MBMUX_GetFeatureChIdx>
 8022778:	0004      	movs	r4, r0
  if (p_MBMUX_ComTable->MBNotifAckParam[mb_ch].ParamCnt > p_MBMUX_ComTable->MBNotifAckParam[mb_ch].BufSize)
 802277a:	4b0a      	ldr	r3, [pc, #40]	; (80227a4 <MBMUX_NotificationSnd+0x34>)
 802277c:	681b      	ldr	r3, [r3, #0]
 802277e:	0042      	lsls	r2, r0, #1
 8022780:	1812      	adds	r2, r2, r0
 8022782:	00d2      	lsls	r2, r2, #3
 8022784:	189b      	adds	r3, r3, r2
 8022786:	001a      	movs	r2, r3
 8022788:	329e      	adds	r2, #158	; 0x9e
 802278a:	8812      	ldrh	r2, [r2, #0]
 802278c:	339c      	adds	r3, #156	; 0x9c
 802278e:	881b      	ldrh	r3, [r3, #0]
 8022790:	429a      	cmp	r2, r3
 8022792:	d803      	bhi.n	802279c <MBMUX_NotificationSnd+0x2c>
  return IPCC_IF_NotificationSnd(mb_ch);
 8022794:	0020      	movs	r0, r4
 8022796:	f7fe ff4d 	bl	8021634 <IPCC_IF_NotificationSnd>
}
 802279a:	bd10      	pop	{r4, pc}
    Error_Handler();
 802279c:	f7fe ff79 	bl	8021692 <Error_Handler>
 80227a0:	e7f8      	b.n	8022794 <MBMUX_NotificationSnd+0x24>
 80227a2:	46c0      	nop			; (mov r8, r8)
 80227a4:	2000b2ac 	.word	0x2000b2ac

080227a8 <MBMUX_ResponseSnd>:
{
 80227a8:	b510      	push	{r4, lr}
  mb_ch = MBMUX_GetFeatureChIdx(e_featID, MBMUX_CMD_RESP);
 80227aa:	2100      	movs	r1, #0
 80227ac:	f7ff ff46 	bl	802263c <MBMUX_GetFeatureChIdx>
  return IPCC_IF_ResponseSnd(mb_ch);
 80227b0:	f7fe ff50 	bl	8021654 <IPCC_IF_ResponseSnd>
}
 80227b4:	bd10      	pop	{r4, pc}

080227b6 <MBMUX_SEC_VerifySramBufferPtr>:
{
 80227b6:	b510      	push	{r4, lr}
  pbuf_validated = MBMUX_SEC_VerifySramBuffer(pBufferAddress, bufferSize);
 80227b8:	f7ff ff50 	bl	802265c <MBMUX_SEC_VerifySramBuffer>
}
 80227bc:	bd10      	pop	{r4, pc}
	...

080227c0 <MBMUX_Init>:
{
 80227c0:	b510      	push	{r4, lr}
 80227c2:	0004      	movs	r4, r0
  IPCC_IF_Init(MBMUX_IsrCommandRcvCb, MBMUX_IsrAcknowledgeRcvCb);
 80227c4:	4911      	ldr	r1, [pc, #68]	; (802280c <MBMUX_Init+0x4c>)
 80227c6:	4812      	ldr	r0, [pc, #72]	; (8022810 <MBMUX_Init+0x50>)
 80227c8:	f7fe fef4 	bl	80215b4 <IPCC_IF_Init>
  MBMUX_RetrieveSecureSramConfig();
 80227cc:	f7ff ff76 	bl	80226bc <MBMUX_RetrieveSecureSramConfig>
  p_MBMUX_ComTable = (MBMUX_ComTable_t *) MBMUX_SEC_VerifySramBufferPtr((uint32_t *) pMBMUX_ComTable, sizeof(MBMUX_ComTable_t));
 80227d0:	219e      	movs	r1, #158	; 0x9e
 80227d2:	0049      	lsls	r1, r1, #1
 80227d4:	0020      	movs	r0, r4
 80227d6:	f7ff ffee 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
 80227da:	4b0e      	ldr	r3, [pc, #56]	; (8022814 <MBMUX_Init+0x54>)
 80227dc:	6018      	str	r0, [r3, #0]
  for (i = 0; i < MBMUX_CHANNEL_NUMBER; i++)
 80227de:	2200      	movs	r2, #0
 80227e0:	e010      	b.n	8022804 <MBMUX_Init+0x44>
    MBMUX_MsgCbPointersTabCm0.MBCmdRespCb[i].MsgCm0plusCb = MBMUX_IsrNotRegistered;
 80227e2:	490d      	ldr	r1, [pc, #52]	; (8022818 <MBMUX_Init+0x58>)
 80227e4:	0093      	lsls	r3, r2, #2
 80227e6:	4c0d      	ldr	r4, [pc, #52]	; (802281c <MBMUX_Init+0x5c>)
 80227e8:	505c      	str	r4, [r3, r1]
    MBMUX_MsgCbPointersTabCm0.MBNotifAckCb[i].MsgCm0plusCb = MBMUX_IsrNotRegistered;
 80227ea:	1d93      	adds	r3, r2, #6
 80227ec:	009b      	lsls	r3, r3, #2
 80227ee:	505c      	str	r4, [r3, r1]
    p_MBMUX_ComTable->MBCmdRespParam[i].MsgCm0plusCb = MBMUX_IsrNotRegistered; /* not used anymore */
 80227f0:	0053      	lsls	r3, r2, #1
 80227f2:	1899      	adds	r1, r3, r2
 80227f4:	00c9      	lsls	r1, r1, #3
 80227f6:	1841      	adds	r1, r0, r1
 80227f8:	608c      	str	r4, [r1, #8]
    p_MBMUX_ComTable->MBNotifAckParam[i].MsgCm0plusCb = MBMUX_IsrNotRegistered; /* not used anymore */
 80227fa:	000b      	movs	r3, r1
 80227fc:	3398      	adds	r3, #152	; 0x98
 80227fe:	601c      	str	r4, [r3, #0]
  for (i = 0; i < MBMUX_CHANNEL_NUMBER; i++)
 8022800:	3201      	adds	r2, #1
 8022802:	b2d2      	uxtb	r2, r2
 8022804:	2a05      	cmp	r2, #5
 8022806:	d9ec      	bls.n	80227e2 <MBMUX_Init+0x22>
}
 8022808:	bd10      	pop	{r4, pc}
 802280a:	46c0      	nop			; (mov r8, r8)
 802280c:	08022615 	.word	0x08022615
 8022810:	080225f1 	.word	0x080225f1
 8022814:	2000b2ac 	.word	0x2000b2ac
 8022818:	2000b224 	.word	0x2000b224
 802281c:	08022655 	.word	0x08022655

08022820 <MBMUXIF_TaskLoraCmdRcv>:

  /* USER CODE END MBMUXIF_IsrLoraCmdRcvCb_Last */
}

static void MBMUXIF_TaskLoraCmdRcv(void)
{
 8022820:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MBMUXIF_TaskLoraCmdRcv_1 */

  /* USER CODE END MBMUXIF_TaskLoraCmdRcv_1 */
  Process_Lora_Cmd(LoraComObj);
 8022822:	4b02      	ldr	r3, [pc, #8]	; (802282c <MBMUXIF_TaskLoraCmdRcv+0xc>)
 8022824:	6818      	ldr	r0, [r3, #0]
 8022826:	f7ff fcff 	bl	8022228 <Process_Lora_Cmd>
  /* USER CODE BEGIN MBMUXIF_TaskLoraCmdRcv_Last */

  /* USER CODE END MBMUXIF_TaskLoraCmdRcv_Last */
}
 802282a:	bd10      	pop	{r4, pc}
 802282c:	2000b2b8 	.word	0x2000b2b8

08022830 <MBMUXIF_IsrLoraCmdRcvCb>:
{
 8022830:	b510      	push	{r4, lr}
  LoraComObj = (MBMUX_ComParam_t *) ComObj;
 8022832:	4b03      	ldr	r3, [pc, #12]	; (8022840 <MBMUXIF_IsrLoraCmdRcvCb+0x10>)
 8022834:	6018      	str	r0, [r3, #0]
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_MbLoRaCmdRcv), CFG_SEQ_Prio_0);
 8022836:	2100      	movs	r1, #0
 8022838:	2004      	movs	r0, #4
 802283a:	f011 fc45 	bl	80340c8 <UTIL_SEQ_SetTask>
}
 802283e:	bd10      	pop	{r4, pc}
 8022840:	2000b2b8 	.word	0x2000b2b8

08022844 <MBMUXIF_IsrLoraAckRcvCb>:
{
 8022844:	b510      	push	{r4, lr}
  UTIL_SEQ_SetEvt(1 << CFG_SEQ_Evt_MbLoraAckRcv);
 8022846:	2004      	movs	r0, #4
 8022848:	f011 fc52 	bl	80340f0 <UTIL_SEQ_SetEvt>
}
 802284c:	bd10      	pop	{r4, pc}
	...

08022850 <MBMUXIF_LoraInit>:
{
 8022850:	b510      	push	{r4, lr}
  ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_LORAWAN_ID, MBMUX_NOTIF_ACK, MBMUXIF_IsrLoraAckRcvCb);
 8022852:	4a0b      	ldr	r2, [pc, #44]	; (8022880 <MBMUXIF_LoraInit+0x30>)
 8022854:	2101      	movs	r1, #1
 8022856:	2008      	movs	r0, #8
 8022858:	f7ff ff56 	bl	8022708 <MBMUX_RegisterFeatureCallback>
  if (ret >= 0)
 802285c:	2800      	cmp	r0, #0
 802285e:	da02      	bge.n	8022866 <MBMUXIF_LoraInit+0x16>
  if (ret >= 0)
 8022860:	2800      	cmp	r0, #0
 8022862:	da06      	bge.n	8022872 <MBMUXIF_LoraInit+0x22>
}
 8022864:	bd10      	pop	{r4, pc}
    ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_LORAWAN_ID, MBMUX_CMD_RESP, MBMUXIF_IsrLoraCmdRcvCb);
 8022866:	4a07      	ldr	r2, [pc, #28]	; (8022884 <MBMUXIF_LoraInit+0x34>)
 8022868:	2100      	movs	r1, #0
 802286a:	2008      	movs	r0, #8
 802286c:	f7ff ff4c 	bl	8022708 <MBMUX_RegisterFeatureCallback>
 8022870:	e7f6      	b.n	8022860 <MBMUXIF_LoraInit+0x10>
    UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_MbLoRaCmdRcv), UTIL_SEQ_RFU, MBMUXIF_TaskLoraCmdRcv);
 8022872:	4a05      	ldr	r2, [pc, #20]	; (8022888 <MBMUXIF_LoraInit+0x38>)
 8022874:	2100      	movs	r1, #0
 8022876:	2004      	movs	r0, #4
 8022878:	f011 fd24 	bl	80342c4 <UTIL_SEQ_RegTask>
    ret = 0;
 802287c:	2000      	movs	r0, #0
 802287e:	e7f1      	b.n	8022864 <MBMUXIF_LoraInit+0x14>
 8022880:	08022845 	.word	0x08022845
 8022884:	08022831 	.word	0x08022831
 8022888:	08022821 	.word	0x08022821

0802288c <MBMUXIF_GetLoraFeatureNotifComPtr>:
{
 802288c:	b510      	push	{r4, lr}
  MBMUX_ComParam_t *com_param_ptr = MBMUX_GetFeatureComPtr(FEAT_INFO_LORAWAN_ID, MBMUX_NOTIF_ACK);
 802288e:	2101      	movs	r1, #1
 8022890:	2008      	movs	r0, #8
 8022892:	f7ff ff51 	bl	8022738 <MBMUX_GetFeatureComPtr>
 8022896:	1e04      	subs	r4, r0, #0
  if (com_param_ptr == NULL)
 8022898:	d001      	beq.n	802289e <MBMUXIF_GetLoraFeatureNotifComPtr+0x12>
}
 802289a:	0020      	movs	r0, r4
 802289c:	bd10      	pop	{r4, pc}
    Error_Handler(); /* feature isn't registered */
 802289e:	f7fe fef8 	bl	8021692 <Error_Handler>
  return com_param_ptr;
 80228a2:	e7fa      	b.n	802289a <MBMUXIF_GetLoraFeatureNotifComPtr+0xe>

080228a4 <MBMUXIF_LoraSendNotif>:
{
 80228a4:	b510      	push	{r4, lr}
  if (MBMUX_NotificationSnd(FEAT_INFO_LORAWAN_ID) == 0)
 80228a6:	2008      	movs	r0, #8
 80228a8:	f7ff ff62 	bl	8022770 <MBMUX_NotificationSnd>
 80228ac:	2800      	cmp	r0, #0
 80228ae:	d103      	bne.n	80228b8 <MBMUXIF_LoraSendNotif+0x14>
    UTIL_SEQ_WaitEvt(1 << CFG_SEQ_Evt_MbLoraAckRcv);
 80228b0:	3004      	adds	r0, #4
 80228b2:	f011 fcdd 	bl	8034270 <UTIL_SEQ_WaitEvt>
}
 80228b6:	bd10      	pop	{r4, pc}
    Error_Handler();
 80228b8:	f7fe feeb 	bl	8021692 <Error_Handler>
}
 80228bc:	e7fb      	b.n	80228b6 <MBMUXIF_LoraSendNotif+0x12>

080228be <MBMUXIF_TaskRadioNotifSnd>:

  /* USER CODE END MBMUXIF_TaskRadioCmdRcv_Last */
}

static void MBMUXIF_TaskRadioNotifSnd(void)
{
 80228be:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MBMUXIF_TaskRadioNotifSnd_1 */

  /* USER CODE END MBMUXIF_TaskRadioNotifSnd_1 */
  if (MBMUX_NotificationSnd(FEAT_INFO_RADIO_ID) == 0)
 80228c0:	2007      	movs	r0, #7
 80228c2:	f7ff ff55 	bl	8022770 <MBMUX_NotificationSnd>
 80228c6:	2800      	cmp	r0, #0
 80228c8:	d103      	bne.n	80228d2 <MBMUXIF_TaskRadioNotifSnd+0x14>
  {
    UTIL_SEQ_WaitEvt(1 << CFG_SEQ_Evt_MbRadioAckRcv);
 80228ca:	3008      	adds	r0, #8
 80228cc:	f011 fcd0 	bl	8034270 <UTIL_SEQ_WaitEvt>
    Error_Handler();
  }
  /* USER CODE BEGIN MBMUXIF_TaskRadioNotifSnd_Last */

  /* USER CODE END MBMUXIF_TaskRadioNotifSnd_Last */
}
 80228d0:	bd10      	pop	{r4, pc}
    Error_Handler();
 80228d2:	f7fe fede 	bl	8021692 <Error_Handler>
}
 80228d6:	e7fb      	b.n	80228d0 <MBMUXIF_TaskRadioNotifSnd+0x12>

080228d8 <MBMUXIF_TaskRadioCmdRcv>:
{
 80228d8:	b510      	push	{r4, lr}
  Process_Radio_Cmd(RadioComObj);
 80228da:	4b02      	ldr	r3, [pc, #8]	; (80228e4 <MBMUXIF_TaskRadioCmdRcv+0xc>)
 80228dc:	6818      	ldr	r0, [r3, #0]
 80228de:	f000 f9fb 	bl	8022cd8 <Process_Radio_Cmd>
}
 80228e2:	bd10      	pop	{r4, pc}
 80228e4:	2000b2bc 	.word	0x2000b2bc

080228e8 <MBMUXIF_IsrRadioCmdRcvCb>:
{
 80228e8:	b510      	push	{r4, lr}
  RadioComObj = (MBMUX_ComParam_t *) ComObj;
 80228ea:	4b03      	ldr	r3, [pc, #12]	; (80228f8 <MBMUXIF_IsrRadioCmdRcvCb+0x10>)
 80228ec:	6018      	str	r0, [r3, #0]
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_MbRadioCmdRcv), CFG_SEQ_Prio_0);
 80228ee:	2100      	movs	r1, #0
 80228f0:	2008      	movs	r0, #8
 80228f2:	f011 fbe9 	bl	80340c8 <UTIL_SEQ_SetTask>
}
 80228f6:	bd10      	pop	{r4, pc}
 80228f8:	2000b2bc 	.word	0x2000b2bc

080228fc <MBMUXIF_IsrRadioAckRcvCb>:
{
 80228fc:	b510      	push	{r4, lr}
  UTIL_SEQ_SetEvt(1 << CFG_SEQ_Evt_MbRadioAckRcv);
 80228fe:	2008      	movs	r0, #8
 8022900:	f011 fbf6 	bl	80340f0 <UTIL_SEQ_SetEvt>
}
 8022904:	bd10      	pop	{r4, pc}
	...

08022908 <MBMUXIF_RadioInit>:
{
 8022908:	b510      	push	{r4, lr}
  ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_RADIO_ID, MBMUX_NOTIF_ACK, MBMUXIF_IsrRadioAckRcvCb);
 802290a:	4a0e      	ldr	r2, [pc, #56]	; (8022944 <MBMUXIF_RadioInit+0x3c>)
 802290c:	2101      	movs	r1, #1
 802290e:	2007      	movs	r0, #7
 8022910:	f7ff fefa 	bl	8022708 <MBMUX_RegisterFeatureCallback>
  if (ret >= 0)
 8022914:	2800      	cmp	r0, #0
 8022916:	da02      	bge.n	802291e <MBMUXIF_RadioInit+0x16>
  if (ret >= 0)
 8022918:	2800      	cmp	r0, #0
 802291a:	da06      	bge.n	802292a <MBMUXIF_RadioInit+0x22>
}
 802291c:	bd10      	pop	{r4, pc}
    ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_RADIO_ID, MBMUX_CMD_RESP, MBMUXIF_IsrRadioCmdRcvCb);
 802291e:	4a0a      	ldr	r2, [pc, #40]	; (8022948 <MBMUXIF_RadioInit+0x40>)
 8022920:	2100      	movs	r1, #0
 8022922:	2007      	movs	r0, #7
 8022924:	f7ff fef0 	bl	8022708 <MBMUX_RegisterFeatureCallback>
 8022928:	e7f6      	b.n	8022918 <MBMUXIF_RadioInit+0x10>
    UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_MbRadioCmdRcv), UTIL_SEQ_RFU, MBMUXIF_TaskRadioCmdRcv);
 802292a:	4a08      	ldr	r2, [pc, #32]	; (802294c <MBMUXIF_RadioInit+0x44>)
 802292c:	2100      	movs	r1, #0
 802292e:	2008      	movs	r0, #8
 8022930:	f011 fcc8 	bl	80342c4 <UTIL_SEQ_RegTask>
    UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_MbRadioNotifSnd), UTIL_SEQ_RFU, MBMUXIF_TaskRadioNotifSnd);
 8022934:	4a06      	ldr	r2, [pc, #24]	; (8022950 <MBMUXIF_RadioInit+0x48>)
 8022936:	2100      	movs	r1, #0
 8022938:	2010      	movs	r0, #16
 802293a:	f011 fcc3 	bl	80342c4 <UTIL_SEQ_RegTask>
    ret = 0;
 802293e:	2000      	movs	r0, #0
 8022940:	e7ec      	b.n	802291c <MBMUXIF_RadioInit+0x14>
 8022942:	46c0      	nop			; (mov r8, r8)
 8022944:	080228fd 	.word	0x080228fd
 8022948:	080228e9 	.word	0x080228e9
 802294c:	080228d9 	.word	0x080228d9
 8022950:	080228bf 	.word	0x080228bf

08022954 <MBMUXIF_GetRadioFeatureNotifComPtr>:
{
 8022954:	b510      	push	{r4, lr}
  MBMUX_ComParam_t *com_param_ptr = MBMUX_GetFeatureComPtr(FEAT_INFO_RADIO_ID, MBMUX_NOTIF_ACK);
 8022956:	2101      	movs	r1, #1
 8022958:	2007      	movs	r0, #7
 802295a:	f7ff feed 	bl	8022738 <MBMUX_GetFeatureComPtr>
 802295e:	1e04      	subs	r4, r0, #0
  if (com_param_ptr == NULL)
 8022960:	d001      	beq.n	8022966 <MBMUXIF_GetRadioFeatureNotifComPtr+0x12>
}
 8022962:	0020      	movs	r0, r4
 8022964:	bd10      	pop	{r4, pc}
    Error_Handler(); /* feature isn't registered */
 8022966:	f7fe fe94 	bl	8021692 <Error_Handler>
  return com_param_ptr;
 802296a:	e7fa      	b.n	8022962 <MBMUXIF_GetRadioFeatureNotifComPtr+0xe>

0802296c <MBMUXIF_RadioSendNotif>:
{
 802296c:	b510      	push	{r4, lr}
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_MbRadioNotifSnd), CFG_SEQ_Prio_0);
 802296e:	2100      	movs	r1, #0
 8022970:	2010      	movs	r0, #16
 8022972:	f011 fba9 	bl	80340c8 <UTIL_SEQ_SetTask>
}
 8022976:	bd10      	pop	{r4, pc}

08022978 <MBMUXIF_IsrSystemPrioAAckRcvCb>:
static void MBMUXIF_IsrSystemPrioAAckRcvCb(void *ComObj)
{
  /* USER CODE BEGIN MBMUXIF_IsrSystemPrioAAckRcvCb */

  /* USER CODE END MBMUXIF_IsrSystemPrioAAckRcvCb */
}
 8022978:	4770      	bx	lr

0802297a <MBMUXIF_IsrSystemPrioACmdRcvCb>:
static void MBMUXIF_IsrSystemPrioACmdRcvCb(void *ComObj)
{
  /* USER CODE BEGIN MBMUXIF_IsrSystemPrioACmdRcvCb */

  /* USER CODE END MBMUXIF_IsrSystemPrioACmdRcvCb */
}
 802297a:	4770      	bx	lr

0802297c <MBMUXIF_IsrSystemPrioBAckRcvCb>:
static void MBMUXIF_IsrSystemPrioBAckRcvCb(void *ComObj)
{
  /* USER CODE BEGIN MBMUXIF_IsrSystemPrioBAckRcvCb */

  /* USER CODE END MBMUXIF_IsrSystemPrioBAckRcvCb */
}
 802297c:	4770      	bx	lr

0802297e <MBMUXIF_IsrSystemPrioBCmdRcvCb>:
static void MBMUXIF_IsrSystemPrioBCmdRcvCb(void *ComObj)
{
  /* USER CODE BEGIN MBMUXIF_IsrSystemPrioBCmdRcvCb */

  /* USER CODE END MBMUXIF_IsrSystemPrioBCmdRcvCb */
}
 802297e:	4770      	bx	lr

08022980 <MBMUXIF_FeatureCm0plusRegistrationCmd>:

static int8_t MBMUXIF_FeatureCm0plusRegistrationCmd(uint32_t *pBuf)
{
 8022980:	b510      	push	{r4, lr}

  /* USER CODE BEGIN MBMUXIF_FeatureCm0plusRegistrationCmd_1 */

  /* USER CODE END MBMUXIF_FeatureCm0plusRegistrationCmd_1 */

  switch (pBuf[0])
 8022982:	6803      	ldr	r3, [r0, #0]
 8022984:	2b09      	cmp	r3, #9
 8022986:	d842      	bhi.n	8022a0e <MBMUXIF_FeatureCm0plusRegistrationCmd+0x8e>
 8022988:	009b      	lsls	r3, r3, #2
 802298a:	4a22      	ldr	r2, [pc, #136]	; (8022a14 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x94>)
 802298c:	58d3      	ldr	r3, [r2, r3]
 802298e:	469f      	mov	pc, r3
  {
    case FEAT_INFO_SYSTEM_CMD_PRIO_A_ID:
      ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_CMD_PRIO_A_ID, MBMUX_CMD_RESP,
 8022990:	4a21      	ldr	r2, [pc, #132]	; (8022a18 <MBMUXIF_FeatureCm0plusRegistrationCmd+0x98>)
 8022992:	2100      	movs	r1, #0
 8022994:	2001      	movs	r0, #1
 8022996:	f7ff feb7 	bl	8022708 <MBMUX_RegisterFeatureCallback>
 802299a:	0004      	movs	r4, r0
  /* USER CODE BEGIN MBMUXIF_FeatureCm0plusRegistrationCmd_Last */

  /* USER CODE END MBMUXIF_FeatureCm0plusRegistrationCmd_Last */

  return ret;
}
 802299c:	0020      	movs	r0, r4
 802299e:	bd10      	pop	{r4, pc}
      ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_NOTIF_PRIO_A_ID, MBMUX_NOTIF_ACK,
 80229a0:	4a1e      	ldr	r2, [pc, #120]	; (8022a1c <MBMUXIF_FeatureCm0plusRegistrationCmd+0x9c>)
 80229a2:	2101      	movs	r1, #1
 80229a4:	2002      	movs	r0, #2
 80229a6:	f7ff feaf 	bl	8022708 <MBMUX_RegisterFeatureCallback>
 80229aa:	0004      	movs	r4, r0
      break;
 80229ac:	e7f6      	b.n	802299c <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_CMD_PRIO_B_ID, MBMUX_CMD_RESP,
 80229ae:	4a1c      	ldr	r2, [pc, #112]	; (8022a20 <MBMUXIF_FeatureCm0plusRegistrationCmd+0xa0>)
 80229b0:	2100      	movs	r1, #0
 80229b2:	2003      	movs	r0, #3
 80229b4:	f7ff fea8 	bl	8022708 <MBMUX_RegisterFeatureCallback>
 80229b8:	0004      	movs	r4, r0
      break;
 80229ba:	e7ef      	b.n	802299c <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_NOTIF_PRIO_B_ID, MBMUX_NOTIF_ACK,
 80229bc:	4a19      	ldr	r2, [pc, #100]	; (8022a24 <MBMUXIF_FeatureCm0plusRegistrationCmd+0xa4>)
 80229be:	2101      	movs	r1, #1
 80229c0:	2004      	movs	r0, #4
 80229c2:	f7ff fea1 	bl	8022708 <MBMUX_RegisterFeatureCallback>
 80229c6:	0004      	movs	r4, r0
      break;
 80229c8:	e7e8      	b.n	802299c <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      ret = MBMUXIF_TraceInit(VERBOSE_LEVEL);
 80229ca:	2002      	movs	r0, #2
 80229cc:	f000 f8e4 	bl	8022b98 <MBMUXIF_TraceInit>
 80229d0:	0004      	movs	r4, r0
      break;
 80229d2:	e7e3      	b.n	802299c <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      ret = MBMUXIF_RadioInit();
 80229d4:	f7ff ff98 	bl	8022908 <MBMUXIF_RadioInit>
 80229d8:	0004      	movs	r4, r0
      APP_LOG(TS_OFF, VLEVEL_L, "CM0PLUS : Radio registration done\r\n");
 80229da:	4b13      	ldr	r3, [pc, #76]	; (8022a28 <MBMUXIF_FeatureCm0plusRegistrationCmd+0xa8>)
 80229dc:	2200      	movs	r2, #0
 80229de:	2100      	movs	r1, #0
 80229e0:	2001      	movs	r0, #1
 80229e2:	f011 fa45 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
      break;
 80229e6:	e7d9      	b.n	802299c <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      ret = MBMUXIF_LoraInit();
 80229e8:	f7ff ff32 	bl	8022850 <MBMUXIF_LoraInit>
 80229ec:	0004      	movs	r4, r0
      APP_LOG(TS_OFF, VLEVEL_L, "CM0PLUS : Lora registration done\r\n");
 80229ee:	4b0f      	ldr	r3, [pc, #60]	; (8022a2c <MBMUXIF_FeatureCm0plusRegistrationCmd+0xac>)
 80229f0:	2200      	movs	r2, #0
 80229f2:	2100      	movs	r1, #0
 80229f4:	2001      	movs	r0, #1
 80229f6:	f011 fa3b 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
      break;
 80229fa:	e7cf      	b.n	802299c <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
      APP_LOG(TS_OFF, VLEVEL_L, "CM0PLUS : Sigfox not supported\r\n");
 80229fc:	4b0c      	ldr	r3, [pc, #48]	; (8022a30 <MBMUXIF_FeatureCm0plusRegistrationCmd+0xb0>)
 80229fe:	2200      	movs	r2, #0
 8022a00:	2100      	movs	r1, #0
 8022a02:	2001      	movs	r0, #1
 8022a04:	f011 fa34 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
  int8_t ret = -2; /* feature not supported */
 8022a08:	2402      	movs	r4, #2
 8022a0a:	4264      	negs	r4, r4
      break;
 8022a0c:	e7c6      	b.n	802299c <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
  switch (pBuf[0])
 8022a0e:	2402      	movs	r4, #2
 8022a10:	4264      	negs	r4, r4
 8022a12:	e7c3      	b.n	802299c <MBMUXIF_FeatureCm0plusRegistrationCmd+0x1c>
 8022a14:	08034f18 	.word	0x08034f18
 8022a18:	0802297b 	.word	0x0802297b
 8022a1c:	08022979 	.word	0x08022979
 8022a20:	0802297f 	.word	0x0802297f
 8022a24:	0802297d 	.word	0x0802297d
 8022a28:	08034eac 	.word	0x08034eac
 8022a2c:	08034ed0 	.word	0x08034ed0
 8022a30:	08034ef4 	.word	0x08034ef4

08022a34 <MBMUXIF_TaskSystemCmdRcv>:
{
 8022a34:	b510      	push	{r4, lr}
  uint32_t *com_buffer = MBMUX_SEC_VerifySramBufferPtr(SystemComObj->ParamBuf, SystemComObj->BufSize);
 8022a36:	4c0c      	ldr	r4, [pc, #48]	; (8022a68 <MBMUXIF_TaskSystemCmdRcv+0x34>)
 8022a38:	6823      	ldr	r3, [r4, #0]
 8022a3a:	8999      	ldrh	r1, [r3, #12]
 8022a3c:	6918      	ldr	r0, [r3, #16]
 8022a3e:	f7ff feba 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
 8022a42:	0003      	movs	r3, r0
  if (SystemComObj->MsgId == SYS_REGISTER_FEATURE_MSG_ID)
 8022a44:	6820      	ldr	r0, [r4, #0]
 8022a46:	6802      	ldr	r2, [r0, #0]
 8022a48:	2a01      	cmp	r2, #1
 8022a4a:	d002      	beq.n	8022a52 <MBMUXIF_TaskSystemCmdRcv+0x1e>
    Process_Sys_Cmd(SystemComObj);
 8022a4c:	f7ff f834 	bl	8021ab8 <Process_Sys_Cmd>
}
 8022a50:	bd10      	pop	{r4, pc}
    SystemComObj->ReturnVal = (uint32_t) MBMUXIF_FeatureCm0plusRegistrationCmd(com_buffer);
 8022a52:	0018      	movs	r0, r3
 8022a54:	f7ff ff94 	bl	8022980 <MBMUXIF_FeatureCm0plusRegistrationCmd>
 8022a58:	4b03      	ldr	r3, [pc, #12]	; (8022a68 <MBMUXIF_TaskSystemCmdRcv+0x34>)
 8022a5a:	681b      	ldr	r3, [r3, #0]
 8022a5c:	6158      	str	r0, [r3, #20]
    MBMUX_ResponseSnd(FEAT_INFO_SYSTEM_ID);
 8022a5e:	2000      	movs	r0, #0
 8022a60:	f7ff fea2 	bl	80227a8 <MBMUX_ResponseSnd>
 8022a64:	e7f4      	b.n	8022a50 <MBMUXIF_TaskSystemCmdRcv+0x1c>
 8022a66:	46c0      	nop			; (mov r8, r8)
 8022a68:	2000b2c0 	.word	0x2000b2c0

08022a6c <MBMUXIF_IsrSystemCmdRcvCb>:
{
 8022a6c:	b510      	push	{r4, lr}
  SystemComObj = (MBMUX_ComParam_t *) ComObj;
 8022a6e:	4b09      	ldr	r3, [pc, #36]	; (8022a94 <MBMUXIF_IsrSystemCmdRcvCb+0x28>)
 8022a70:	6018      	str	r0, [r3, #0]
  switch (SystemComObj->MsgId)
 8022a72:	6803      	ldr	r3, [r0, #0]
 8022a74:	2b00      	cmp	r3, #0
 8022a76:	d108      	bne.n	8022a8a <MBMUXIF_IsrSystemCmdRcvCb+0x1e>
      SystemComObj->ReturnVal = (uint32_t) FEAT_INFO_GetListPtr();
 8022a78:	f7ff fd7a 	bl	8022570 <FEAT_INFO_GetListPtr>
 8022a7c:	4b05      	ldr	r3, [pc, #20]	; (8022a94 <MBMUXIF_IsrSystemCmdRcvCb+0x28>)
 8022a7e:	681b      	ldr	r3, [r3, #0]
 8022a80:	6158      	str	r0, [r3, #20]
      MBMUX_ResponseSnd(FEAT_INFO_SYSTEM_ID);
 8022a82:	2000      	movs	r0, #0
 8022a84:	f7ff fe90 	bl	80227a8 <MBMUX_ResponseSnd>
}
 8022a88:	bd10      	pop	{r4, pc}
      UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_MbSystemCmdRcv), CFG_SEQ_Prio_0);
 8022a8a:	2100      	movs	r1, #0
 8022a8c:	2001      	movs	r0, #1
 8022a8e:	f011 fb1b 	bl	80340c8 <UTIL_SEQ_SetTask>
}
 8022a92:	e7f9      	b.n	8022a88 <MBMUXIF_IsrSystemCmdRcvCb+0x1c>
 8022a94:	2000b2c0 	.word	0x2000b2c0

08022a98 <MBMUXIF_IsrSystemAckRcvCb>:
{
 8022a98:	b510      	push	{r4, lr}
  UTIL_SEQ_SetEvt(1 << CFG_SEQ_Evt_MbSystemAckRcv);
 8022a9a:	2001      	movs	r0, #1
 8022a9c:	f011 fb28 	bl	80340f0 <UTIL_SEQ_SetEvt>
}
 8022aa0:	bd10      	pop	{r4, pc}
	...

08022aa4 <MBMUXIF_SystemInit>:
{
 8022aa4:	b500      	push	{lr}
 8022aa6:	b097      	sub	sp, #92	; 0x5c
  HAL_FLASHEx_OBGetConfig(&OptionsBytesStruct);
 8022aa8:	4668      	mov	r0, sp
 8022aaa:	f001 fcc7 	bl	802443c <HAL_FLASHEx_OBGetConfig>
  pMb_RefTable = (MBMUX_ComTable_t *) OptionsBytesStruct.IPCCdataBufAddr;
 8022aae:	9815      	ldr	r0, [sp, #84]	; 0x54
 8022ab0:	4b17      	ldr	r3, [pc, #92]	; (8022b10 <MBMUXIF_SystemInit+0x6c>)
 8022ab2:	6018      	str	r0, [r3, #0]
  while (pMb_RefTable->SynchronizeCpusAtBoot == CPUS_BOOT_SYNC_PREVENT_CPU2_TO_START);
 8022ab4:	239b      	movs	r3, #155	; 0x9b
 8022ab6:	005b      	lsls	r3, r3, #1
 8022ab8:	5ac3      	ldrh	r3, [r0, r3]
 8022aba:	b29b      	uxth	r3, r3
 8022abc:	4a15      	ldr	r2, [pc, #84]	; (8022b14 <MBMUXIF_SystemInit+0x70>)
 8022abe:	4293      	cmp	r3, r2
 8022ac0:	d0f8      	beq.n	8022ab4 <MBMUXIF_SystemInit+0x10>
  MBMUX_Init(pMb_RefTable);
 8022ac2:	f7ff fe7d 	bl	80227c0 <MBMUX_Init>
  ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_ID, MBMUX_NOTIF_ACK, MBMUXIF_IsrSystemAckRcvCb);
 8022ac6:	4a14      	ldr	r2, [pc, #80]	; (8022b18 <MBMUXIF_SystemInit+0x74>)
 8022ac8:	2101      	movs	r1, #1
 8022aca:	2000      	movs	r0, #0
 8022acc:	f7ff fe1c 	bl	8022708 <MBMUX_RegisterFeatureCallback>
  if (ret >= 0)
 8022ad0:	2800      	cmp	r0, #0
 8022ad2:	da03      	bge.n	8022adc <MBMUXIF_SystemInit+0x38>
  if (ret >= 0)
 8022ad4:	2800      	cmp	r0, #0
 8022ad6:	da07      	bge.n	8022ae8 <MBMUXIF_SystemInit+0x44>
}
 8022ad8:	b017      	add	sp, #92	; 0x5c
 8022ada:	bd00      	pop	{pc}
    ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_SYSTEM_ID, MBMUX_CMD_RESP, MBMUXIF_IsrSystemCmdRcvCb);
 8022adc:	4a0f      	ldr	r2, [pc, #60]	; (8022b1c <MBMUXIF_SystemInit+0x78>)
 8022ade:	2100      	movs	r1, #0
 8022ae0:	2000      	movs	r0, #0
 8022ae2:	f7ff fe11 	bl	8022708 <MBMUX_RegisterFeatureCallback>
 8022ae6:	e7f5      	b.n	8022ad4 <MBMUXIF_SystemInit+0x30>
    UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_MbSystemCmdRcv), UTIL_SEQ_RFU, MBMUXIF_TaskSystemCmdRcv);
 8022ae8:	4a0d      	ldr	r2, [pc, #52]	; (8022b20 <MBMUXIF_SystemInit+0x7c>)
 8022aea:	2100      	movs	r1, #0
 8022aec:	2001      	movs	r0, #1
 8022aee:	f011 fbe9 	bl	80342c4 <UTIL_SEQ_RegTask>
    while (pMb_RefTable->SynchronizeCpusAtBoot != CPUS_BOOT_SYNC_ALLOW_CPU2_TO_START);
 8022af2:	4b07      	ldr	r3, [pc, #28]	; (8022b10 <MBMUXIF_SystemInit+0x6c>)
 8022af4:	681a      	ldr	r2, [r3, #0]
 8022af6:	239b      	movs	r3, #155	; 0x9b
 8022af8:	005b      	lsls	r3, r3, #1
 8022afa:	5ad3      	ldrh	r3, [r2, r3]
 8022afc:	b29b      	uxth	r3, r3
 8022afe:	4909      	ldr	r1, [pc, #36]	; (8022b24 <MBMUXIF_SystemInit+0x80>)
 8022b00:	428b      	cmp	r3, r1
 8022b02:	d1f6      	bne.n	8022af2 <MBMUXIF_SystemInit+0x4e>
    pMb_RefTable->SynchronizeCpusAtBoot = CPUS_BOOT_SYNC_CPU2_INIT_COMPLETED;
 8022b04:	239b      	movs	r3, #155	; 0x9b
 8022b06:	005b      	lsls	r3, r3, #1
 8022b08:	4907      	ldr	r1, [pc, #28]	; (8022b28 <MBMUXIF_SystemInit+0x84>)
 8022b0a:	52d1      	strh	r1, [r2, r3]
 8022b0c:	2000      	movs	r0, #0
 8022b0e:	e7e3      	b.n	8022ad8 <MBMUXIF_SystemInit+0x34>
 8022b10:	2000b2c4 	.word	0x2000b2c4
 8022b14:	0000ffff 	.word	0x0000ffff
 8022b18:	08022a99 	.word	0x08022a99
 8022b1c:	08022a6d 	.word	0x08022a6d
 8022b20:	08022a35 	.word	0x08022a35
 8022b24:	00005555 	.word	0x00005555
 8022b28:	ffffaaaa 	.word	0xffffaaaa

08022b2c <MBMUXIF_GetCpusSynchroFlag>:
  return pMb_RefTable->SynchronizeCpusAtBoot;
 8022b2c:	4b03      	ldr	r3, [pc, #12]	; (8022b3c <MBMUXIF_GetCpusSynchroFlag+0x10>)
 8022b2e:	681a      	ldr	r2, [r3, #0]
 8022b30:	239b      	movs	r3, #155	; 0x9b
 8022b32:	005b      	lsls	r3, r3, #1
 8022b34:	5ad0      	ldrh	r0, [r2, r3]
 8022b36:	b280      	uxth	r0, r0
}
 8022b38:	4770      	bx	lr
 8022b3a:	46c0      	nop			; (mov r8, r8)
 8022b3c:	2000b2c4 	.word	0x2000b2c4

08022b40 <MBMUXIF_GetSystemFeatureNotifComPtr>:
{
 8022b40:	b510      	push	{r4, lr}
  MBMUX_ComParam_t *com_param_ptr = MBMUX_GetFeatureComPtr(SystemPrioFeat, MBMUX_NOTIF_ACK);
 8022b42:	2101      	movs	r1, #1
 8022b44:	f7ff fdf8 	bl	8022738 <MBMUX_GetFeatureComPtr>
 8022b48:	1e04      	subs	r4, r0, #0
  if (com_param_ptr == NULL)
 8022b4a:	d001      	beq.n	8022b50 <MBMUXIF_GetSystemFeatureNotifComPtr+0x10>
}
 8022b4c:	0020      	movs	r0, r4
 8022b4e:	bd10      	pop	{r4, pc}
    Error_Handler(); /* feature isn't registered */
 8022b50:	f7fe fd9f 	bl	8021692 <Error_Handler>
  return com_param_ptr;
 8022b54:	e7fa      	b.n	8022b4c <MBMUXIF_GetSystemFeatureNotifComPtr+0xc>

08022b56 <MBMUXIF_SystemSendNotif_NoWait>:
{
 8022b56:	b510      	push	{r4, lr}
  if (MBMUX_NotificationSnd(SystemPrioFeat) != 0)
 8022b58:	f7ff fe0a 	bl	8022770 <MBMUX_NotificationSnd>
 8022b5c:	2800      	cmp	r0, #0
 8022b5e:	d100      	bne.n	8022b62 <MBMUXIF_SystemSendNotif_NoWait+0xc>
}
 8022b60:	bd10      	pop	{r4, pc}
    Error_Handler();
 8022b62:	f7fe fd96 	bl	8021692 <Error_Handler>
}
 8022b66:	e7fb      	b.n	8022b60 <MBMUXIF_SystemSendNotif_NoWait+0xa>

08022b68 <MBMUXIF_TraceBufferInit>:
static UTIL_ADV_TRACE_Status_t MBMUXIF_TraceBufferInit(void (*cb)(void *))
{
  /* USER CODE BEGIN MBMUXIF_TraceBufferInit_1 */

  /* USER CODE END MBMUXIF_TraceBufferInit_1 */
  TraceUtilCpltCallback = cb;
 8022b68:	4b01      	ldr	r3, [pc, #4]	; (8022b70 <MBMUXIF_TraceBufferInit+0x8>)
 8022b6a:	6018      	str	r0, [r3, #0]
  return UTIL_ADV_TRACE_OK;
  /* USER CODE BEGIN MBMUXIF_TraceBufferInit_Last */

  /* USER CODE END MBMUXIF_TraceBufferInit_Last */
}
 8022b6c:	2000      	movs	r0, #0
 8022b6e:	4770      	bx	lr
 8022b70:	2000b2c8 	.word	0x2000b2c8

08022b74 <MBMUXIF_TaskTraceAckRcv>:

  /* USER CODE END MBMUXIF_IsrTraceAckRcvCb_Last */
}

static void MBMUXIF_TaskTraceAckRcv(void)
{
 8022b74:	b510      	push	{r4, lr}
  /* USER CODE BEGIN MBMUXIF_TaskTraceAckRcv_1 */

  /* USER CODE END MBMUXIF_TaskTraceAckRcv_1 */
  TraceUtilCpltCallback(NULL);
 8022b76:	4b02      	ldr	r3, [pc, #8]	; (8022b80 <MBMUXIF_TaskTraceAckRcv+0xc>)
 8022b78:	681b      	ldr	r3, [r3, #0]
 8022b7a:	2000      	movs	r0, #0
 8022b7c:	4798      	blx	r3
  /* USER CODE BEGIN MBMUXIF_TaskTraceAckRcv_Last */

  /* USER CODE END MBMUXIF_TaskTraceAckRcv_Last */
}
 8022b7e:	bd10      	pop	{r4, pc}
 8022b80:	2000b2c8 	.word	0x2000b2c8

08022b84 <MBMUXIF_IsrTraceAckRcvCb>:
{
 8022b84:	b510      	push	{r4, lr}
  UTIL_SEQ_SetEvt(1 << CFG_SEQ_Evt_MbTraceAckRcv); /* not necessary */
 8022b86:	2002      	movs	r0, #2
 8022b88:	f011 fab2 	bl	80340f0 <UTIL_SEQ_SetEvt>
  UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_MbTraceAckRcv), CFG_SEQ_Prio_0);
 8022b8c:	2100      	movs	r1, #0
 8022b8e:	2002      	movs	r0, #2
 8022b90:	f011 fa9a 	bl	80340c8 <UTIL_SEQ_SetTask>
}
 8022b94:	bd10      	pop	{r4, pc}
	...

08022b98 <MBMUXIF_TraceInit>:
{
 8022b98:	b510      	push	{r4, lr}
 8022b9a:	0004      	movs	r4, r0
  ret = MBMUX_RegisterFeatureCallback(FEAT_INFO_TRACE_ID, MBMUX_NOTIF_ACK, MBMUXIF_IsrTraceAckRcvCb);
 8022b9c:	4a0b      	ldr	r2, [pc, #44]	; (8022bcc <MBMUXIF_TraceInit+0x34>)
 8022b9e:	2101      	movs	r1, #1
 8022ba0:	2006      	movs	r0, #6
 8022ba2:	f7ff fdb1 	bl	8022708 <MBMUX_RegisterFeatureCallback>
  if (ret >= 0)
 8022ba6:	2800      	cmp	r0, #0
 8022ba8:	da00      	bge.n	8022bac <MBMUXIF_TraceInit+0x14>
}
 8022baa:	bd10      	pop	{r4, pc}
    UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_MbTraceAckRcv), UTIL_SEQ_RFU, MBMUXIF_TaskTraceAckRcv);
 8022bac:	4a08      	ldr	r2, [pc, #32]	; (8022bd0 <MBMUXIF_TraceInit+0x38>)
 8022bae:	2100      	movs	r1, #0
 8022bb0:	2002      	movs	r0, #2
 8022bb2:	f011 fb87 	bl	80342c4 <UTIL_SEQ_RegTask>
    UTIL_ADV_TRACE_Init();
 8022bb6:	f011 f8e5 	bl	8033d84 <UTIL_ADV_TRACE_Init>
    UTIL_ADV_TRACE_RegisterTimeStampFunction(TimestampNow);
 8022bba:	4806      	ldr	r0, [pc, #24]	; (8022bd4 <MBMUXIF_TraceInit+0x3c>)
 8022bbc:	f011 f8fc 	bl	8033db8 <UTIL_ADV_TRACE_RegisterTimeStampFunction>
    UTIL_ADV_TRACE_SetVerboseLevel(verboseLevel);
 8022bc0:	0020      	movs	r0, r4
 8022bc2:	f011 f8ff 	bl	8033dc4 <UTIL_ADV_TRACE_SetVerboseLevel>
    ret = 0;
 8022bc6:	2000      	movs	r0, #0
 8022bc8:	e7ef      	b.n	8022baa <MBMUXIF_TraceInit+0x12>
 8022bca:	46c0      	nop			; (mov r8, r8)
 8022bcc:	08022b85 	.word	0x08022b85
 8022bd0:	08022b75 	.word	0x08022b75
 8022bd4:	08021a85 	.word	0x08021a85

08022bd8 <MBMUXIF_GetTraceFeatureNotifComPtr>:
{
 8022bd8:	b510      	push	{r4, lr}
  MBMUX_ComParam_t *com_param_ptr = MBMUX_GetFeatureComPtr(FEAT_INFO_TRACE_ID, MBMUX_NOTIF_ACK);
 8022bda:	2101      	movs	r1, #1
 8022bdc:	2006      	movs	r0, #6
 8022bde:	f7ff fdab 	bl	8022738 <MBMUX_GetFeatureComPtr>
 8022be2:	1e04      	subs	r4, r0, #0
  if (com_param_ptr == NULL)
 8022be4:	d001      	beq.n	8022bea <MBMUXIF_GetTraceFeatureNotifComPtr+0x12>
}
 8022be6:	0020      	movs	r0, r4
 8022be8:	bd10      	pop	{r4, pc}
    Error_Handler(); /* feature isn't registered */
 8022bea:	f7fe fd52 	bl	8021692 <Error_Handler>
  return com_param_ptr;
 8022bee:	e7fa      	b.n	8022be6 <MBMUXIF_GetTraceFeatureNotifComPtr+0xe>

08022bf0 <MBMUXIF_TraceSendNotif_NoWait>:
{
 8022bf0:	b510      	push	{r4, lr}
  if (MBMUX_NotificationSnd(FEAT_INFO_TRACE_ID) != 0)
 8022bf2:	2006      	movs	r0, #6
 8022bf4:	f7ff fdbc 	bl	8022770 <MBMUX_NotificationSnd>
 8022bf8:	2800      	cmp	r0, #0
 8022bfa:	d100      	bne.n	8022bfe <MBMUXIF_TraceSendNotif_NoWait+0xe>
}
 8022bfc:	bd10      	pop	{r4, pc}
    Error_Handler();
 8022bfe:	f7fe fd48 	bl	8021692 <Error_Handler>
}
 8022c02:	e7fb      	b.n	8022bfc <MBMUXIF_TraceSendNotif_NoWait+0xc>

08022c04 <MBMUXIF_TraceBufferSend>:
{
 8022c04:	b570      	push	{r4, r5, r6, lr}
 8022c06:	0006      	movs	r6, r0
 8022c08:	000d      	movs	r5, r1
  com_obj = MBMUXIF_GetTraceFeatureNotifComPtr();
 8022c0a:	f7ff ffe5 	bl	8022bd8 <MBMUXIF_GetTraceFeatureNotifComPtr>
 8022c0e:	1e04      	subs	r4, r0, #0
  if (com_obj != NULL)
 8022c10:	d00b      	beq.n	8022c2a <MBMUXIF_TraceBufferSend+0x26>
    pbuf_validated = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8022c12:	8981      	ldrh	r1, [r0, #12]
 8022c14:	6900      	ldr	r0, [r0, #16]
 8022c16:	f7ff fdce 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
    com_obj->MsgId = TRACE_SEND_MSG_ID;
 8022c1a:	2300      	movs	r3, #0
 8022c1c:	6023      	str	r3, [r4, #0]
    pbuf_validated[0] = (uint32_t) buf;
 8022c1e:	6006      	str	r6, [r0, #0]
    pbuf_validated[1] = (uint32_t) bufSize;
 8022c20:	6045      	str	r5, [r0, #4]
    com_obj->ParamCnt = 2;
 8022c22:	3302      	adds	r3, #2
 8022c24:	81e3      	strh	r3, [r4, #14]
    MBMUXIF_TraceSendNotif_NoWait();
 8022c26:	f7ff ffe3 	bl	8022bf0 <MBMUXIF_TraceSendNotif_NoWait>
}
 8022c2a:	2000      	movs	r0, #0
 8022c2c:	bd70      	pop	{r4, r5, r6, pc}

08022c2e <RadioRxError_mbwrapper>:

  /* USER CODE END RadioRxTimeout_mbwrapper_2 */
}

static void RadioRxError_mbwrapper(void)
{
 8022c2e:	b510      	push	{r4, lr}
  /* USER CODE BEGIN RadioRxError_mbwrapper_1 */

  /* USER CODE END RadioRxError_mbwrapper_1 */
  MBMUX_ComParam_t *com_obj;

  com_obj = MBMUXIF_GetRadioFeatureNotifComPtr();
 8022c30:	f7ff fe90 	bl	8022954 <MBMUXIF_GetRadioFeatureNotifComPtr>
  com_obj->MsgId = RADIO_RX_ERROR_CB_ID;
 8022c34:	2323      	movs	r3, #35	; 0x23
 8022c36:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8022c38:	2300      	movs	r3, #0
 8022c3a:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendNotif();
 8022c3c:	f7ff fe96 	bl	802296c <MBMUXIF_RadioSendNotif>
  /* once event is received and semaphore released: */
  return;
  /* USER CODE BEGIN RadioRxError_mbwrapper_2 */

  /* USER CODE END RadioRxError_mbwrapper_2 */
}
 8022c40:	bd10      	pop	{r4, pc}

08022c42 <RadioRxTimeout_mbwrapper>:
{
 8022c42:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetRadioFeatureNotifComPtr();
 8022c44:	f7ff fe86 	bl	8022954 <MBMUXIF_GetRadioFeatureNotifComPtr>
  com_obj->MsgId = RADIO_RX_TIMEOUT_CB_ID;
 8022c48:	2322      	movs	r3, #34	; 0x22
 8022c4a:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8022c4c:	2300      	movs	r3, #0
 8022c4e:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendNotif();
 8022c50:	f7ff fe8c 	bl	802296c <MBMUXIF_RadioSendNotif>
}
 8022c54:	bd10      	pop	{r4, pc}

08022c56 <RadioTxTimeout_mbwrapper>:
{
 8022c56:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetRadioFeatureNotifComPtr();
 8022c58:	f7ff fe7c 	bl	8022954 <MBMUXIF_GetRadioFeatureNotifComPtr>
  com_obj->MsgId = RADIO_TX_TIMEOUT_CB_ID;
 8022c5c:	2320      	movs	r3, #32
 8022c5e:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8022c60:	2300      	movs	r3, #0
 8022c62:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendNotif();
 8022c64:	f7ff fe82 	bl	802296c <MBMUXIF_RadioSendNotif>
}
 8022c68:	bd10      	pop	{r4, pc}

08022c6a <RadioTxDone_mbwrapper>:
{
 8022c6a:	b510      	push	{r4, lr}
  com_obj = MBMUXIF_GetRadioFeatureNotifComPtr();
 8022c6c:	f7ff fe72 	bl	8022954 <MBMUXIF_GetRadioFeatureNotifComPtr>
  com_obj->MsgId = RADIO_TX_DONE_CB_ID;
 8022c70:	231f      	movs	r3, #31
 8022c72:	6003      	str	r3, [r0, #0]
  com_obj->ParamCnt = 0;
 8022c74:	2300      	movs	r3, #0
 8022c76:	81c3      	strh	r3, [r0, #14]
  MBMUXIF_RadioSendNotif();
 8022c78:	f7ff fe78 	bl	802296c <MBMUXIF_RadioSendNotif>
}
 8022c7c:	bd10      	pop	{r4, pc}
	...

08022c80 <RadioRxDone_mbwrapper>:
{
 8022c80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8022c82:	46c6      	mov	lr, r8
 8022c84:	b500      	push	{lr}
 8022c86:	0005      	movs	r5, r0
 8022c88:	000e      	movs	r6, r1
 8022c8a:	4690      	mov	r8, r2
 8022c8c:	001f      	movs	r7, r3
  if (payload != NULL)
 8022c8e:	2800      	cmp	r0, #0
 8022c90:	d004      	beq.n	8022c9c <RadioRxDone_mbwrapper+0x1c>
    UTIL_MEM_cpy_8(aRadioMbWrapRxBuffer, payload, size);
 8022c92:	000a      	movs	r2, r1
 8022c94:	0001      	movs	r1, r0
 8022c96:	480f      	ldr	r0, [pc, #60]	; (8022cd4 <RadioRxDone_mbwrapper+0x54>)
 8022c98:	f011 fa02 	bl	80340a0 <UTIL_MEM_cpy_8>
  com_obj = MBMUXIF_GetRadioFeatureNotifComPtr();
 8022c9c:	f7ff fe5a 	bl	8022954 <MBMUXIF_GetRadioFeatureNotifComPtr>
 8022ca0:	0004      	movs	r4, r0
  com_obj->MsgId = RADIO_RX_DONE_CB_ID;
 8022ca2:	2321      	movs	r3, #33	; 0x21
 8022ca4:	6003      	str	r3, [r0, #0]
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(com_obj->ParamBuf, com_obj->BufSize);
 8022ca6:	8981      	ldrh	r1, [r0, #12]
 8022ca8:	6900      	ldr	r0, [r0, #16]
 8022caa:	f7ff fd84 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
  if (payload == NULL)
 8022cae:	2d00      	cmp	r5, #0
 8022cb0:	d00c      	beq.n	8022ccc <RadioRxDone_mbwrapper+0x4c>
    com_buffer[i++] = (uint32_t) aRadioMbWrapRxBuffer;
 8022cb2:	4b08      	ldr	r3, [pc, #32]	; (8022cd4 <RadioRxDone_mbwrapper+0x54>)
 8022cb4:	6003      	str	r3, [r0, #0]
  com_buffer[i++] = (uint32_t) size;
 8022cb6:	6046      	str	r6, [r0, #4]
  com_buffer[i++] = (uint32_t) rssi;
 8022cb8:	4643      	mov	r3, r8
 8022cba:	6083      	str	r3, [r0, #8]
  com_buffer[i++] = (uint32_t) snr;
 8022cbc:	60c7      	str	r7, [r0, #12]
  com_obj->ParamCnt = i;
 8022cbe:	2304      	movs	r3, #4
 8022cc0:	81e3      	strh	r3, [r4, #14]
  MBMUXIF_RadioSendNotif();
 8022cc2:	f7ff fe53 	bl	802296c <MBMUXIF_RadioSendNotif>
}
 8022cc6:	bc80      	pop	{r7}
 8022cc8:	46b8      	mov	r8, r7
 8022cca:	bdf0      	pop	{r4, r5, r6, r7, pc}
    com_buffer[i++] = (uint32_t)NULL;
 8022ccc:	2300      	movs	r3, #0
 8022cce:	6003      	str	r3, [r0, #0]
 8022cd0:	e7f1      	b.n	8022cb6 <RadioRxDone_mbwrapper+0x36>
 8022cd2:	46c0      	nop			; (mov r8, r8)
 8022cd4:	200091a0 	.word	0x200091a0

08022cd8 <Process_Radio_Cmd>:
{
 8022cd8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8022cda:	46de      	mov	lr, fp
 8022cdc:	4657      	mov	r7, sl
 8022cde:	464e      	mov	r6, r9
 8022ce0:	4645      	mov	r5, r8
 8022ce2:	b5e0      	push	{r5, r6, r7, lr}
 8022ce4:	b08f      	sub	sp, #60	; 0x3c
 8022ce6:	0004      	movs	r4, r0
  APP_LOG(TS_ON, VLEVEL_H, ">CM0PLUS(Radio)\r\n");
 8022ce8:	4bdb      	ldr	r3, [pc, #876]	; (8023058 <Process_Radio_Cmd+0x380>)
 8022cea:	2201      	movs	r2, #1
 8022cec:	2100      	movs	r1, #0
 8022cee:	2003      	movs	r0, #3
 8022cf0:	f011 f8be 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
  com_buffer = MBMUX_SEC_VerifySramBufferPtr(ComObj->ParamBuf, ComObj->BufSize);
 8022cf4:	89a1      	ldrh	r1, [r4, #12]
 8022cf6:	6920      	ldr	r0, [r4, #16]
 8022cf8:	f7ff fd5d 	bl	80227b6 <MBMUX_SEC_VerifySramBufferPtr>
  switch (ComObj->MsgId)
 8022cfc:	6823      	ldr	r3, [r4, #0]
 8022cfe:	2b1e      	cmp	r3, #30
 8022d00:	d814      	bhi.n	8022d2c <Process_Radio_Cmd+0x54>
 8022d02:	009b      	lsls	r3, r3, #2
 8022d04:	4ad5      	ldr	r2, [pc, #852]	; (802305c <Process_Radio_Cmd+0x384>)
 8022d06:	58d3      	ldr	r3, [r2, r3]
 8022d08:	469f      	mov	pc, r3
      radioevents_mbwrapper.TxDone = &RadioTxDone_mbwrapper;
 8022d0a:	48d5      	ldr	r0, [pc, #852]	; (8023060 <Process_Radio_Cmd+0x388>)
 8022d0c:	4bd5      	ldr	r3, [pc, #852]	; (8023064 <Process_Radio_Cmd+0x38c>)
 8022d0e:	6003      	str	r3, [r0, #0]
      radioevents_mbwrapper.TxTimeout = &RadioTxTimeout_mbwrapper;
 8022d10:	4bd5      	ldr	r3, [pc, #852]	; (8023068 <Process_Radio_Cmd+0x390>)
 8022d12:	6043      	str	r3, [r0, #4]
      radioevents_mbwrapper.RxDone = &RadioRxDone_mbwrapper;
 8022d14:	4bd5      	ldr	r3, [pc, #852]	; (802306c <Process_Radio_Cmd+0x394>)
 8022d16:	6083      	str	r3, [r0, #8]
      radioevents_mbwrapper.RxTimeout = &RadioRxTimeout_mbwrapper;
 8022d18:	4bd5      	ldr	r3, [pc, #852]	; (8023070 <Process_Radio_Cmd+0x398>)
 8022d1a:	60c3      	str	r3, [r0, #12]
      radioevents_mbwrapper.RxError = &RadioRxError_mbwrapper;
 8022d1c:	4bd5      	ldr	r3, [pc, #852]	; (8023074 <Process_Radio_Cmd+0x39c>)
 8022d1e:	6103      	str	r3, [r0, #16]
      Radio.Init(&radioevents_mbwrapper);
 8022d20:	4bd5      	ldr	r3, [pc, #852]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022d22:	681b      	ldr	r3, [r3, #0]
 8022d24:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022d26:	2300      	movs	r3, #0
 8022d28:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022d2a:	6163      	str	r3, [r4, #20]
  APP_LOG(TS_ON, VLEVEL_H, "<CM0PLUS(Radio)\r\n");
 8022d2c:	4bd3      	ldr	r3, [pc, #844]	; (802307c <Process_Radio_Cmd+0x3a4>)
 8022d2e:	2201      	movs	r2, #1
 8022d30:	2100      	movs	r1, #0
 8022d32:	2003      	movs	r0, #3
 8022d34:	f011 f89c 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
  MBMUX_ResponseSnd(FEAT_INFO_RADIO_ID);
 8022d38:	2007      	movs	r0, #7
 8022d3a:	f7ff fd35 	bl	80227a8 <MBMUX_ResponseSnd>
}
 8022d3e:	b00f      	add	sp, #60	; 0x3c
 8022d40:	bcf0      	pop	{r4, r5, r6, r7}
 8022d42:	46bb      	mov	fp, r7
 8022d44:	46b2      	mov	sl, r6
 8022d46:	46a9      	mov	r9, r5
 8022d48:	46a0      	mov	r8, r4
 8022d4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      state = Radio.GetStatus();
 8022d4c:	4bca      	ldr	r3, [pc, #808]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022d4e:	685b      	ldr	r3, [r3, #4]
 8022d50:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022d52:	2300      	movs	r3, #0
 8022d54:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) state; /* */
 8022d56:	6160      	str	r0, [r4, #20]
      break;
 8022d58:	e7e8      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.SetModem((RadioModems_t) com_buffer[0]);
 8022d5a:	4bc7      	ldr	r3, [pc, #796]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022d5c:	689b      	ldr	r3, [r3, #8]
 8022d5e:	7800      	ldrb	r0, [r0, #0]
 8022d60:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022d62:	2300      	movs	r3, #0
 8022d64:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022d66:	6163      	str	r3, [r4, #20]
      break;
 8022d68:	e7e0      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.SetChannel((uint32_t) com_buffer[0]);
 8022d6a:	4bc3      	ldr	r3, [pc, #780]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022d6c:	68db      	ldr	r3, [r3, #12]
 8022d6e:	6800      	ldr	r0, [r0, #0]
 8022d70:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022d72:	2300      	movs	r3, #0
 8022d74:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022d76:	6163      	str	r3, [r4, #20]
      break;
 8022d78:	e7d8      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      ret_uint = Radio.IsChannelFree(com_buffer[0], com_buffer[1], (int16_t) com_buffer[2], com_buffer[3]);
 8022d7a:	4bbf      	ldr	r3, [pc, #764]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022d7c:	691d      	ldr	r5, [r3, #16]
 8022d7e:	68c3      	ldr	r3, [r0, #12]
 8022d80:	2108      	movs	r1, #8
 8022d82:	5e42      	ldrsh	r2, [r0, r1]
 8022d84:	6841      	ldr	r1, [r0, #4]
 8022d86:	6800      	ldr	r0, [r0, #0]
 8022d88:	47a8      	blx	r5
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022d8a:	2300      	movs	r3, #0
 8022d8c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8022d8e:	6160      	str	r0, [r4, #20]
      break;
 8022d90:	e7cc      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      ret_uint = Radio.Random();
 8022d92:	4bb9      	ldr	r3, [pc, #740]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022d94:	695b      	ldr	r3, [r3, #20]
 8022d96:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022d98:	2300      	movs	r3, #0
 8022d9a:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8022d9c:	6160      	str	r0, [r4, #20]
      break;
 8022d9e:	e7c5      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.SetRxConfig((RadioModems_t) com_buffer[0],  com_buffer[1],
 8022da0:	4bb5      	ldr	r3, [pc, #724]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022da2:	699b      	ldr	r3, [r3, #24]
 8022da4:	4698      	mov	r8, r3
                        com_buffer[4], (uint16_t) com_buffer[5],
 8022da6:	6943      	ldr	r3, [r0, #20]
 8022da8:	930a      	str	r3, [sp, #40]	; 0x28
                        (uint16_t) com_buffer[6], (bool) com_buffer[7],
 8022daa:	6982      	ldr	r2, [r0, #24]
 8022dac:	920b      	str	r2, [sp, #44]	; 0x2c
 8022dae:	69c3      	ldr	r3, [r0, #28]
 8022db0:	469b      	mov	fp, r3
                        (uint8_t) com_buffer[8],
 8022db2:	6a01      	ldr	r1, [r0, #32]
 8022db4:	910c      	str	r1, [sp, #48]	; 0x30
                        (bool) com_buffer[9], (bool) com_buffer[10], (uint8_t) com_buffer[11],
 8022db6:	6a46      	ldr	r6, [r0, #36]	; 0x24
 8022db8:	6a87      	ldr	r7, [r0, #40]	; 0x28
 8022dba:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8022dbc:	930d      	str	r3, [sp, #52]	; 0x34
                        (bool) com_buffer[12], (bool) com_buffer[13]);
 8022dbe:	6b03      	ldr	r3, [r0, #48]	; 0x30
      Radio.SetRxConfig((RadioModems_t) com_buffer[0],  com_buffer[1],
 8022dc0:	7b02      	ldrb	r2, [r0, #12]
 8022dc2:	4692      	mov	sl, r2
 8022dc4:	6882      	ldr	r2, [r0, #8]
 8022dc6:	4691      	mov	r9, r2
 8022dc8:	6841      	ldr	r1, [r0, #4]
 8022dca:	7802      	ldrb	r2, [r0, #0]
 8022dcc:	4694      	mov	ip, r2
 8022dce:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8022dd0:	1e55      	subs	r5, r2, #1
 8022dd2:	41aa      	sbcs	r2, r5
 8022dd4:	9209      	str	r2, [sp, #36]	; 0x24
 8022dd6:	1e5a      	subs	r2, r3, #1
 8022dd8:	4193      	sbcs	r3, r2
 8022dda:	9308      	str	r3, [sp, #32]
 8022ddc:	466b      	mov	r3, sp
 8022dde:	2234      	movs	r2, #52	; 0x34
 8022de0:	189b      	adds	r3, r3, r2
 8022de2:	781b      	ldrb	r3, [r3, #0]
 8022de4:	9307      	str	r3, [sp, #28]
 8022de6:	1e7b      	subs	r3, r7, #1
 8022de8:	419f      	sbcs	r7, r3
 8022dea:	9706      	str	r7, [sp, #24]
 8022dec:	1e73      	subs	r3, r6, #1
 8022dee:	419e      	sbcs	r6, r3
 8022df0:	9605      	str	r6, [sp, #20]
 8022df2:	466b      	mov	r3, sp
 8022df4:	3a04      	subs	r2, #4
 8022df6:	189b      	adds	r3, r3, r2
 8022df8:	781b      	ldrb	r3, [r3, #0]
 8022dfa:	9304      	str	r3, [sp, #16]
 8022dfc:	465d      	mov	r5, fp
 8022dfe:	1e6b      	subs	r3, r5, #1
 8022e00:	419d      	sbcs	r5, r3
 8022e02:	9503      	str	r5, [sp, #12]
 8022e04:	466b      	mov	r3, sp
 8022e06:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8022e08:	9302      	str	r3, [sp, #8]
 8022e0a:	466b      	mov	r3, sp
 8022e0c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8022e0e:	9301      	str	r3, [sp, #4]
 8022e10:	6903      	ldr	r3, [r0, #16]
 8022e12:	9300      	str	r3, [sp, #0]
 8022e14:	4653      	mov	r3, sl
 8022e16:	464a      	mov	r2, r9
 8022e18:	4660      	mov	r0, ip
 8022e1a:	47c0      	blx	r8
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022e1c:	2300      	movs	r3, #0
 8022e1e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022e20:	6163      	str	r3, [r4, #20]
      break;
 8022e22:	e783      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.SetTxConfig((RadioModems_t) com_buffer[0], (int8_t) com_buffer[1],
 8022e24:	4b94      	ldr	r3, [pc, #592]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022e26:	69db      	ldr	r3, [r3, #28]
 8022e28:	4698      	mov	r8, r3
                        (uint8_t) com_buffer[5], (uint16_t) com_buffer[6],
 8022e2a:	6943      	ldr	r3, [r0, #20]
 8022e2c:	930a      	str	r3, [sp, #40]	; 0x28
 8022e2e:	6982      	ldr	r2, [r0, #24]
 8022e30:	920b      	str	r2, [sp, #44]	; 0x2c
                        (bool) com_buffer[7], (bool) com_buffer[8], (bool) com_buffer[9],
 8022e32:	69c5      	ldr	r5, [r0, #28]
 8022e34:	6a06      	ldr	r6, [r0, #32]
 8022e36:	6a47      	ldr	r7, [r0, #36]	; 0x24
                        (uint8_t) com_buffer[10], (bool) com_buffer[11],  com_buffer[12]);
 8022e38:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8022e3a:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
      Radio.SetTxConfig((RadioModems_t) com_buffer[0], (int8_t) com_buffer[1],
 8022e3c:	68c1      	ldr	r1, [r0, #12]
 8022e3e:	468a      	mov	sl, r1
 8022e40:	6881      	ldr	r1, [r0, #8]
 8022e42:	4689      	mov	r9, r1
 8022e44:	2104      	movs	r1, #4
 8022e46:	5641      	ldrsb	r1, [r0, r1]
 8022e48:	468b      	mov	fp, r1
 8022e4a:	7801      	ldrb	r1, [r0, #0]
 8022e4c:	468c      	mov	ip, r1
 8022e4e:	6b01      	ldr	r1, [r0, #48]	; 0x30
 8022e50:	9108      	str	r1, [sp, #32]
 8022e52:	1e51      	subs	r1, r2, #1
 8022e54:	418a      	sbcs	r2, r1
 8022e56:	9207      	str	r2, [sp, #28]
 8022e58:	b2db      	uxtb	r3, r3
 8022e5a:	9306      	str	r3, [sp, #24]
 8022e5c:	1e7b      	subs	r3, r7, #1
 8022e5e:	419f      	sbcs	r7, r3
 8022e60:	9705      	str	r7, [sp, #20]
 8022e62:	1e73      	subs	r3, r6, #1
 8022e64:	419e      	sbcs	r6, r3
 8022e66:	9604      	str	r6, [sp, #16]
 8022e68:	1e6b      	subs	r3, r5, #1
 8022e6a:	419d      	sbcs	r5, r3
 8022e6c:	9503      	str	r5, [sp, #12]
 8022e6e:	466b      	mov	r3, sp
 8022e70:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 8022e72:	9302      	str	r3, [sp, #8]
 8022e74:	466b      	mov	r3, sp
 8022e76:	2228      	movs	r2, #40	; 0x28
 8022e78:	189b      	adds	r3, r3, r2
 8022e7a:	781b      	ldrb	r3, [r3, #0]
 8022e7c:	9301      	str	r3, [sp, #4]
 8022e7e:	6903      	ldr	r3, [r0, #16]
 8022e80:	9300      	str	r3, [sp, #0]
 8022e82:	4653      	mov	r3, sl
 8022e84:	464a      	mov	r2, r9
 8022e86:	4659      	mov	r1, fp
 8022e88:	4660      	mov	r0, ip
 8022e8a:	47c0      	blx	r8
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022e8c:	2300      	movs	r3, #0
 8022e8e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022e90:	6163      	str	r3, [r4, #20]
      break;
 8022e92:	e74b      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      ret_uint = Radio.CheckRfFrequency(com_buffer[0]);
 8022e94:	4b78      	ldr	r3, [pc, #480]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022e96:	6a1b      	ldr	r3, [r3, #32]
 8022e98:	6800      	ldr	r0, [r0, #0]
 8022e9a:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022e9c:	2300      	movs	r3, #0
 8022e9e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8022ea0:	6160      	str	r0, [r4, #20]
      break;
 8022ea2:	e743      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      ret_uint = Radio.TimeOnAir((RadioModems_t) com_buffer[0], (uint32_t) com_buffer[1],
 8022ea4:	4b74      	ldr	r3, [pc, #464]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022ea6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8022ea8:	4698      	mov	r8, r3
                                 (uint16_t) com_buffer[4], (bool) com_buffer[5],
 8022eaa:	6905      	ldr	r5, [r0, #16]
 8022eac:	6946      	ldr	r6, [r0, #20]
                                 (uint8_t) com_buffer[6], (bool) com_buffer[7]);
 8022eae:	6987      	ldr	r7, [r0, #24]
 8022eb0:	69c3      	ldr	r3, [r0, #28]
 8022eb2:	469c      	mov	ip, r3
      ret_uint = Radio.TimeOnAir((RadioModems_t) com_buffer[0], (uint32_t) com_buffer[1],
 8022eb4:	7b03      	ldrb	r3, [r0, #12]
 8022eb6:	4699      	mov	r9, r3
 8022eb8:	6883      	ldr	r3, [r0, #8]
 8022eba:	469a      	mov	sl, r3
 8022ebc:	6841      	ldr	r1, [r0, #4]
 8022ebe:	7800      	ldrb	r0, [r0, #0]
 8022ec0:	4663      	mov	r3, ip
 8022ec2:	1e5a      	subs	r2, r3, #1
 8022ec4:	4193      	sbcs	r3, r2
 8022ec6:	9303      	str	r3, [sp, #12]
 8022ec8:	b2ff      	uxtb	r7, r7
 8022eca:	9702      	str	r7, [sp, #8]
 8022ecc:	1e77      	subs	r7, r6, #1
 8022ece:	41be      	sbcs	r6, r7
 8022ed0:	9601      	str	r6, [sp, #4]
 8022ed2:	b2ad      	uxth	r5, r5
 8022ed4:	9500      	str	r5, [sp, #0]
 8022ed6:	464b      	mov	r3, r9
 8022ed8:	4652      	mov	r2, sl
 8022eda:	47c0      	blx	r8
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022edc:	2300      	movs	r3, #0
 8022ede:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8022ee0:	6160      	str	r0, [r4, #20]
      break;
 8022ee2:	e723      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      ret_status = Radio.Send((uint8_t *) com_buffer[0], (uint8_t) com_buffer[1]);
 8022ee4:	4b64      	ldr	r3, [pc, #400]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022ee6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8022ee8:	6802      	ldr	r2, [r0, #0]
 8022eea:	7901      	ldrb	r1, [r0, #4]
 8022eec:	0010      	movs	r0, r2
 8022eee:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022ef0:	2300      	movs	r3, #0
 8022ef2:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_status; /* */
 8022ef4:	6160      	str	r0, [r4, #20]
      break;
 8022ef6:	e719      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.Sleep();
 8022ef8:	4b5f      	ldr	r3, [pc, #380]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022efa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8022efc:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022efe:	2300      	movs	r3, #0
 8022f00:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022f02:	6163      	str	r3, [r4, #20]
      break;
 8022f04:	e712      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.Standby();
 8022f06:	4b5c      	ldr	r3, [pc, #368]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022f08:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8022f0a:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022f0c:	2300      	movs	r3, #0
 8022f0e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022f10:	6163      	str	r3, [r4, #20]
      break;
 8022f12:	e70b      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.Rx(com_buffer[0]);
 8022f14:	4b58      	ldr	r3, [pc, #352]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022f16:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8022f18:	6800      	ldr	r0, [r0, #0]
 8022f1a:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022f1c:	2300      	movs	r3, #0
 8022f1e:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022f20:	6163      	str	r3, [r4, #20]
      break;
 8022f22:	e703      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.StartCad();
 8022f24:	4b54      	ldr	r3, [pc, #336]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022f26:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8022f28:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022f2a:	2300      	movs	r3, #0
 8022f2c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022f2e:	6163      	str	r3, [r4, #20]
      break;
 8022f30:	e6fc      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.SetTxContinuousWave(com_buffer[0], (int8_t) com_buffer[1], (uint16_t) com_buffer[2]);
 8022f32:	4b51      	ldr	r3, [pc, #324]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022f34:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8022f36:	8902      	ldrh	r2, [r0, #8]
 8022f38:	2104      	movs	r1, #4
 8022f3a:	5641      	ldrsb	r1, [r0, r1]
 8022f3c:	6800      	ldr	r0, [r0, #0]
 8022f3e:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022f40:	2300      	movs	r3, #0
 8022f42:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022f44:	6163      	str	r3, [r4, #20]
      break;
 8022f46:	e6f1      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      ret_int =  Radio.Rssi((RadioModems_t) com_buffer[0]);
 8022f48:	4b4b      	ldr	r3, [pc, #300]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022f4a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8022f4c:	7800      	ldrb	r0, [r0, #0]
 8022f4e:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022f50:	2300      	movs	r3, #0
 8022f52:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_int; /* */
 8022f54:	6160      	str	r0, [r4, #20]
      break;
 8022f56:	e6e9      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.Write((uint16_t) com_buffer[0], (uint8_t) com_buffer[1]);
 8022f58:	4b47      	ldr	r3, [pc, #284]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022f5a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8022f5c:	7901      	ldrb	r1, [r0, #4]
 8022f5e:	8800      	ldrh	r0, [r0, #0]
 8022f60:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022f62:	2300      	movs	r3, #0
 8022f64:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022f66:	6163      	str	r3, [r4, #20]
      break;
 8022f68:	e6e0      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      ret_uint = Radio.Read((uint16_t) com_buffer[0]);
 8022f6a:	4b43      	ldr	r3, [pc, #268]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022f6c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8022f6e:	8800      	ldrh	r0, [r0, #0]
 8022f70:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022f72:	2300      	movs	r3, #0
 8022f74:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8022f76:	6160      	str	r0, [r4, #20]
      break;
 8022f78:	e6d8      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.WriteRegisters((uint16_t) com_buffer[0], (uint8_t *) com_buffer[1], (uint8_t) com_buffer[2]);
 8022f7a:	4b3f      	ldr	r3, [pc, #252]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022f7c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8022f7e:	6841      	ldr	r1, [r0, #4]
 8022f80:	7a02      	ldrb	r2, [r0, #8]
 8022f82:	8800      	ldrh	r0, [r0, #0]
 8022f84:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022f86:	2300      	movs	r3, #0
 8022f88:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022f8a:	6163      	str	r3, [r4, #20]
      break;
 8022f8c:	e6ce      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.ReadRegisters((uint16_t) com_buffer[0], (uint8_t *) com_buffer[1], (uint8_t) com_buffer[2]);
 8022f8e:	4b3a      	ldr	r3, [pc, #232]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022f90:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8022f92:	6841      	ldr	r1, [r0, #4]
 8022f94:	7a02      	ldrb	r2, [r0, #8]
 8022f96:	8800      	ldrh	r0, [r0, #0]
 8022f98:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022f9a:	2300      	movs	r3, #0
 8022f9c:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022f9e:	6163      	str	r3, [r4, #20]
      break;
 8022fa0:	e6c4      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.SetMaxPayloadLength((RadioModems_t) com_buffer[0], (uint8_t) com_buffer[1]);
 8022fa2:	4b35      	ldr	r3, [pc, #212]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022fa4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8022fa6:	7901      	ldrb	r1, [r0, #4]
 8022fa8:	7800      	ldrb	r0, [r0, #0]
 8022faa:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022fac:	2300      	movs	r3, #0
 8022fae:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022fb0:	6163      	str	r3, [r4, #20]
      break;
 8022fb2:	e6bb      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.SetPublicNetwork((bool) com_buffer[0]);
 8022fb4:	4b30      	ldr	r3, [pc, #192]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022fb6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8022fb8:	6800      	ldr	r0, [r0, #0]
 8022fba:	1e42      	subs	r2, r0, #1
 8022fbc:	4190      	sbcs	r0, r2
 8022fbe:	b2c0      	uxtb	r0, r0
 8022fc0:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022fc2:	2300      	movs	r3, #0
 8022fc4:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022fc6:	6163      	str	r3, [r4, #20]
      break;
 8022fc8:	e6b0      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      ret_uint = Radio.GetWakeupTime();
 8022fca:	4b2b      	ldr	r3, [pc, #172]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022fcc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8022fce:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022fd0:	2300      	movs	r3, #0
 8022fd2:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8022fd4:	6160      	str	r0, [r4, #20]
      break;
 8022fd6:	e6a9      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.IrqProcess();
 8022fd8:	4b27      	ldr	r3, [pc, #156]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022fda:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8022fdc:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022fde:	2300      	movs	r3, #0
 8022fe0:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022fe2:	6163      	str	r3, [r4, #20]
      break;
 8022fe4:	e6a2      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.RxBoosted(com_buffer[0]);
 8022fe6:	4b24      	ldr	r3, [pc, #144]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022fe8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8022fea:	6800      	ldr	r0, [r0, #0]
 8022fec:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8022fee:	2300      	movs	r3, #0
 8022ff0:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8022ff2:	6163      	str	r3, [r4, #20]
      break;
 8022ff4:	e69a      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.SetRxDutyCycle(com_buffer[0], com_buffer[1]);
 8022ff6:	4b20      	ldr	r3, [pc, #128]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8022ff8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8022ffa:	6841      	ldr	r1, [r0, #4]
 8022ffc:	6800      	ldr	r0, [r0, #0]
 8022ffe:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8023000:	2300      	movs	r3, #0
 8023002:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8023004:	6163      	str	r3, [r4, #20]
      break;
 8023006:	e691      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.TxCw((int8_t)com_buffer[0]);
 8023008:	4b1b      	ldr	r3, [pc, #108]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 802300a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 802300c:	7800      	ldrb	r0, [r0, #0]
 802300e:	b240      	sxtb	r0, r0
 8023010:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8023012:	2300      	movs	r3, #0
 8023014:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8023016:	6163      	str	r3, [r4, #20]
      break;
 8023018:	e688      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      Radio.TxPrbs();
 802301a:	4b17      	ldr	r3, [pc, #92]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 802301c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 802301e:	4798      	blx	r3
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8023020:	2300      	movs	r3, #0
 8023022:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = 0; /* */
 8023024:	6163      	str	r3, [r4, #20]
      break;
 8023026:	e681      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      ret_uint = Radio.RadioSetRxGenericConfig((GenericModems_t) com_buffer[0], (RxConfigGeneric_t *)com_buffer[1], com_buffer[2], com_buffer[3]);
 8023028:	4b13      	ldr	r3, [pc, #76]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 802302a:	6f5d      	ldr	r5, [r3, #116]	; 0x74
 802302c:	6841      	ldr	r1, [r0, #4]
 802302e:	68c3      	ldr	r3, [r0, #12]
 8023030:	6882      	ldr	r2, [r0, #8]
 8023032:	7800      	ldrb	r0, [r0, #0]
 8023034:	47a8      	blx	r5
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 8023036:	2300      	movs	r3, #0
 8023038:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 802303a:	6160      	str	r0, [r4, #20]
      break;
 802303c:	e676      	b.n	8022d2c <Process_Radio_Cmd+0x54>
      ret_uint = Radio.RadioSetTxGenericConfig((GenericModems_t) com_buffer[0], (TxConfigGeneric_t *)com_buffer[1], (int8_t) com_buffer[2], (uint32_t) com_buffer[3]);
 802303e:	4b0e      	ldr	r3, [pc, #56]	; (8023078 <Process_Radio_Cmd+0x3a0>)
 8023040:	6f9d      	ldr	r5, [r3, #120]	; 0x78
 8023042:	6841      	ldr	r1, [r0, #4]
 8023044:	68c3      	ldr	r3, [r0, #12]
 8023046:	2208      	movs	r2, #8
 8023048:	5682      	ldrsb	r2, [r0, r2]
 802304a:	7800      	ldrb	r0, [r0, #0]
 802304c:	47a8      	blx	r5
      ComObj->ParamCnt = 0; /* reset ParamCnt */
 802304e:	2300      	movs	r3, #0
 8023050:	81e3      	strh	r3, [r4, #14]
      ComObj->ReturnVal = (uint32_t) ret_uint; /* */
 8023052:	6160      	str	r0, [r4, #20]
      break;
 8023054:	e66a      	b.n	8022d2c <Process_Radio_Cmd+0x54>
 8023056:	46c0      	nop			; (mov r8, r8)
 8023058:	08034f50 	.word	0x08034f50
 802305c:	08034f78 	.word	0x08034f78
 8023060:	2000b2cc 	.word	0x2000b2cc
 8023064:	08022c6b 	.word	0x08022c6b
 8023068:	08022c57 	.word	0x08022c57
 802306c:	08022c81 	.word	0x08022c81
 8023070:	08022c43 	.word	0x08022c43
 8023074:	08022c2f 	.word	0x08022c2f
 8023078:	08035d8c 	.word	0x08035d8c
 802307c:	08034f64 	.word	0x08034f64

08023080 <CopyDataInit>:
  bl LoopCopyDataInit
.endm

.section  .text.data_initializers
CopyDataInit:
  ldr r4, [r2, r3]
 8023080:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8023082:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8023084:	3304      	adds	r3, #4

08023086 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8023086:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8023088:	428c      	cmp	r4, r1
  bcc  CopyDataInit
 802308a:	d3f9      	bcc.n	8023080 <CopyDataInit>
  bx lr
 802308c:	4770      	bx	lr

0802308e <FillZerobss>:

FillZerobss:
  str  r3, [r0]
 802308e:	6003      	str	r3, [r0, #0]
  adds r0, r0, #4
 8023090:	3004      	adds	r0, #4

08023092 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r0, r1
 8023092:	4288      	cmp	r0, r1
  bcc FillZerobss
 8023094:	d3fb      	bcc.n	802308e <FillZerobss>
  bx lr
 8023096:	4770      	bx	lr

08023098 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8023098:	4811      	ldr	r0, [pc, #68]	; (80230e0 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 802309a:	4685      	mov	sp, r0

/* Zero fill the bss segments. */
  INIT_BSS _sbss, _ebss
 802309c:	4811      	ldr	r0, [pc, #68]	; (80230e4 <LoopForever+0x6>)
 802309e:	4912      	ldr	r1, [pc, #72]	; (80230e8 <LoopForever+0xa>)
 80230a0:	2300      	movs	r3, #0
 80230a2:	f7ff fff6 	bl	8023092 <LoopFillZerobss>

/* Zero fill the MB_MEM2 segments. */
  INIT_BSS _sMB_MEM2, _eMB_MEM2
 80230a6:	4811      	ldr	r0, [pc, #68]	; (80230ec <LoopForever+0xe>)
 80230a8:	4911      	ldr	r1, [pc, #68]	; (80230f0 <LoopForever+0x12>)
 80230aa:	2300      	movs	r3, #0
 80230ac:	f7ff fff1 	bl	8023092 <LoopFillZerobss>

/* Zero fill the MB_MEM2 segments. */
  INIT_BSS _sMB_MEM3, _eMB_MEM3
 80230b0:	4810      	ldr	r0, [pc, #64]	; (80230f4 <LoopForever+0x16>)
 80230b2:	4911      	ldr	r1, [pc, #68]	; (80230f8 <LoopForever+0x1a>)
 80230b4:	2300      	movs	r3, #0
 80230b6:	f7ff ffec 	bl	8023092 <LoopFillZerobss>

/* Copy the data segment initializers from flash to SRAM */
  INIT_DATA _sdata, _edata, _sidata
 80230ba:	4810      	ldr	r0, [pc, #64]	; (80230fc <LoopForever+0x1e>)
 80230bc:	4910      	ldr	r1, [pc, #64]	; (8023100 <LoopForever+0x22>)
 80230be:	4a11      	ldr	r2, [pc, #68]	; (8023104 <LoopForever+0x26>)
 80230c0:	2300      	movs	r3, #0
 80230c2:	f7ff ffe0 	bl	8023086 <LoopCopyDataInit>

/* Copy the MB_MEM2 segment initializers from flash to SRAM */
  INIT_DATA _sMB_MEM2, _eMB_MEM2, _siMB_MEM2
 80230c6:	4809      	ldr	r0, [pc, #36]	; (80230ec <LoopForever+0xe>)
 80230c8:	4909      	ldr	r1, [pc, #36]	; (80230f0 <LoopForever+0x12>)
 80230ca:	4a0f      	ldr	r2, [pc, #60]	; (8023108 <LoopForever+0x2a>)
 80230cc:	2300      	movs	r3, #0
 80230ce:	f7ff ffda 	bl	8023086 <LoopCopyDataInit>

/* Call the clock system initialization function.*/
  bl  SystemInit
 80230d2:	f000 f8b9 	bl	8023248 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 80230d6:	f011 fcf3 	bl	8034ac0 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80230da:	f7fe face 	bl	802167a <main>

080230de <LoopForever>:

LoopForever:
    b LoopForever
 80230de:	e7fe      	b.n	80230de <LoopForever>
  ldr   r0, =_estack
 80230e0:	20010000 	.word	0x20010000
  INIT_BSS _sbss, _ebss
 80230e4:	2000b178 	.word	0x2000b178
 80230e8:	2000c960 	.word	0x2000c960
  INIT_BSS _sMB_MEM2, _eMB_MEM2
 80230ec:	20009000 	.word	0x20009000
 80230f0:	20009058 	.word	0x20009058
  INIT_BSS _sMB_MEM3, _eMB_MEM3
 80230f4:	20009058 	.word	0x20009058
 80230f8:	200096a0 	.word	0x200096a0
  INIT_DATA _sdata, _edata, _sidata
 80230fc:	2000b000 	.word	0x2000b000
 8023100:	2000b178 	.word	0x2000b178
 8023104:	08035fd0 	.word	0x08035fd0
  INIT_DATA _sMB_MEM2, _eMB_MEM2, _siMB_MEM2
 8023108:	08036148 	.word	0x08036148

0802310c <ADC_COMP_DAC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 802310c:	e7fe      	b.n	802310c <ADC_COMP_DAC_IRQHandler>
	...

08023110 <BSP_RADIO_Init>:
/**
  * @brief  Init Radio Switch 
  * @retval BSP status
  */
int32_t BSP_RADIO_Init(void)
{
 8023110:	b510      	push	{r4, lr}
 8023112:	b086      	sub	sp, #24
  GPIO_InitTypeDef  gpio_init_structure = {0};
 8023114:	2214      	movs	r2, #20
 8023116:	2100      	movs	r1, #0
 8023118:	a801      	add	r0, sp, #4
 802311a:	f011 fd0c 	bl	8034b36 <memset>
  SET_BIT(RCC->C2AHB2ENR, Periphs);
 802311e:	21b0      	movs	r1, #176	; 0xb0
 8023120:	05c9      	lsls	r1, r1, #23
 8023122:	22a6      	movs	r2, #166	; 0xa6
 8023124:	0052      	lsls	r2, r2, #1
 8023126:	5888      	ldr	r0, [r1, r2]
 8023128:	2304      	movs	r3, #4
 802312a:	4318      	orrs	r0, r3
 802312c:	5088      	str	r0, [r1, r2]
  tmpreg = READ_BIT(RCC->C2AHB2ENR, Periphs);
 802312e:	588a      	ldr	r2, [r1, r2]
 8023130:	4013      	ands	r3, r2
 8023132:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 8023134:	9b00      	ldr	r3, [sp, #0]
  
  /* Enable the Radio Switch Clock */
  RF_SW_CTRL3_GPIO_CLK_ENABLE();
  
  /* Configure the Radio Switch pin */
  gpio_init_structure.Pin   = RF_SW_CTRL1_PIN;
 8023136:	2310      	movs	r3, #16
 8023138:	9301      	str	r3, [sp, #4]
  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
 802313a:	3b0f      	subs	r3, #15
 802313c:	9302      	str	r3, [sp, #8]
  gpio_init_structure.Pull  = GPIO_NOPULL;
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802313e:	3302      	adds	r3, #2
 8023140:	9304      	str	r3, [sp, #16]
  
  HAL_GPIO_Init(RF_SW_CTRL1_GPIO_PORT, &gpio_init_structure);
 8023142:	4c11      	ldr	r4, [pc, #68]	; (8023188 <BSP_RADIO_Init+0x78>)
 8023144:	a901      	add	r1, sp, #4
 8023146:	0020      	movs	r0, r4
 8023148:	f001 fa12 	bl	8024570 <HAL_GPIO_Init>
  
  gpio_init_structure.Pin = RF_SW_CTRL2_PIN;
 802314c:	2320      	movs	r3, #32
 802314e:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL2_GPIO_PORT, &gpio_init_structure);
 8023150:	a901      	add	r1, sp, #4
 8023152:	0020      	movs	r0, r4
 8023154:	f001 fa0c 	bl	8024570 <HAL_GPIO_Init>
  
  gpio_init_structure.Pin = RF_SW_CTRL3_PIN;
 8023158:	2308      	movs	r3, #8
 802315a:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(RF_SW_CTRL3_GPIO_PORT, &gpio_init_structure);
 802315c:	a901      	add	r1, sp, #4
 802315e:	0020      	movs	r0, r4
 8023160:	f001 fa06 	bl	8024570 <HAL_GPIO_Init>

  HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET); 
 8023164:	2200      	movs	r2, #0
 8023166:	2120      	movs	r1, #32
 8023168:	0020      	movs	r0, r4
 802316a:	f001 fab7 	bl	80246dc <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 802316e:	2200      	movs	r2, #0
 8023170:	2110      	movs	r1, #16
 8023172:	0020      	movs	r0, r4
 8023174:	f001 fab2 	bl	80246dc <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_RESET); 
 8023178:	2200      	movs	r2, #0
 802317a:	2108      	movs	r1, #8
 802317c:	0020      	movs	r0, r4
 802317e:	f001 faad 	bl	80246dc <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
}
 8023182:	2000      	movs	r0, #0
 8023184:	b006      	add	sp, #24
 8023186:	bd10      	pop	{r4, pc}
 8023188:	48000800 	.word	0x48000800

0802318c <BSP_RADIO_ConfigRFSwitch>:
  *           @arg RADIO_SWITCH_RFO_LP
  *           @arg RADIO_SWITCH_RFO_HP
  * @retval BSP status
  */
int32_t BSP_RADIO_ConfigRFSwitch(BSP_RADIO_Switch_TypeDef Config)
{
 802318c:	b510      	push	{r4, lr}
  switch (Config)
 802318e:	2802      	cmp	r0, #2
 8023190:	d03a      	beq.n	8023208 <BSP_RADIO_ConfigRFSwitch+0x7c>
 8023192:	d814      	bhi.n	80231be <BSP_RADIO_ConfigRFSwitch+0x32>
 8023194:	2800      	cmp	r0, #0
 8023196:	d025      	beq.n	80231e4 <BSP_RADIO_ConfigRFSwitch+0x58>
 8023198:	2801      	cmp	r0, #1
 802319a:	d133      	bne.n	8023204 <BSP_RADIO_ConfigRFSwitch+0x78>
      break;      
    }
    case RADIO_SWITCH_RX:
    {
      /*Turns On in Rx Mode the RF Switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 802319c:	4c23      	ldr	r4, [pc, #140]	; (802322c <BSP_RADIO_ConfigRFSwitch+0xa0>)
 802319e:	2201      	movs	r2, #1
 80231a0:	2108      	movs	r1, #8
 80231a2:	0020      	movs	r0, r4
 80231a4:	f001 fa9a 	bl	80246dc <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 80231a8:	2201      	movs	r2, #1
 80231aa:	2110      	movs	r1, #16
 80231ac:	0020      	movs	r0, r4
 80231ae:	f001 fa95 	bl	80246dc <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET); 
 80231b2:	2200      	movs	r2, #0
 80231b4:	2120      	movs	r1, #32
 80231b6:	0020      	movs	r0, r4
 80231b8:	f001 fa90 	bl	80246dc <HAL_GPIO_WritePin>
      break;
 80231bc:	e022      	b.n	8023204 <BSP_RADIO_ConfigRFSwitch+0x78>
  switch (Config)
 80231be:	2803      	cmp	r0, #3
 80231c0:	d120      	bne.n	8023204 <BSP_RADIO_ConfigRFSwitch+0x78>
      break;
    }
    case RADIO_SWITCH_RFO_HP:
    {
      /*Turns On in Tx High Power the RF Switch */
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 80231c2:	4c1a      	ldr	r4, [pc, #104]	; (802322c <BSP_RADIO_ConfigRFSwitch+0xa0>)
 80231c4:	2201      	movs	r2, #1
 80231c6:	2108      	movs	r1, #8
 80231c8:	0020      	movs	r0, r4
 80231ca:	f001 fa87 	bl	80246dc <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET); 
 80231ce:	2200      	movs	r2, #0
 80231d0:	2110      	movs	r1, #16
 80231d2:	0020      	movs	r0, r4
 80231d4:	f001 fa82 	bl	80246dc <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_SET); 
 80231d8:	2201      	movs	r2, #1
 80231da:	2120      	movs	r1, #32
 80231dc:	0020      	movs	r0, r4
 80231de:	f001 fa7d 	bl	80246dc <HAL_GPIO_WritePin>
      break;
 80231e2:	e00f      	b.n	8023204 <BSP_RADIO_ConfigRFSwitch+0x78>
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_RESET);
 80231e4:	4c11      	ldr	r4, [pc, #68]	; (802322c <BSP_RADIO_ConfigRFSwitch+0xa0>)
 80231e6:	2200      	movs	r2, #0
 80231e8:	2108      	movs	r1, #8
 80231ea:	0020      	movs	r0, r4
 80231ec:	f001 fa76 	bl	80246dc <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_RESET);
 80231f0:	2200      	movs	r2, #0
 80231f2:	2110      	movs	r1, #16
 80231f4:	0020      	movs	r0, r4
 80231f6:	f001 fa71 	bl	80246dc <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_RESET);
 80231fa:	2200      	movs	r2, #0
 80231fc:	2120      	movs	r1, #32
 80231fe:	0020      	movs	r0, r4
 8023200:	f001 fa6c 	bl	80246dc <HAL_GPIO_WritePin>
    default:
      break;    
  }  

  return BSP_ERROR_NONE;
}
 8023204:	2000      	movs	r0, #0
 8023206:	bd10      	pop	{r4, pc}
      HAL_GPIO_WritePin(RF_SW_CTRL3_GPIO_PORT, RF_SW_CTRL3_PIN, GPIO_PIN_SET);
 8023208:	4c08      	ldr	r4, [pc, #32]	; (802322c <BSP_RADIO_ConfigRFSwitch+0xa0>)
 802320a:	2201      	movs	r2, #1
 802320c:	2108      	movs	r1, #8
 802320e:	0020      	movs	r0, r4
 8023210:	f001 fa64 	bl	80246dc <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL1_GPIO_PORT, RF_SW_CTRL1_PIN, GPIO_PIN_SET); 
 8023214:	2201      	movs	r2, #1
 8023216:	2110      	movs	r1, #16
 8023218:	0020      	movs	r0, r4
 802321a:	f001 fa5f 	bl	80246dc <HAL_GPIO_WritePin>
      HAL_GPIO_WritePin(RF_SW_CTRL2_GPIO_PORT, RF_SW_CTRL2_PIN, GPIO_PIN_SET); 
 802321e:	2201      	movs	r2, #1
 8023220:	2120      	movs	r1, #32
 8023222:	0020      	movs	r0, r4
 8023224:	f001 fa5a 	bl	80246dc <HAL_GPIO_WritePin>
      break;
 8023228:	e7ec      	b.n	8023204 <BSP_RADIO_ConfigRFSwitch+0x78>
 802322a:	46c0      	nop			; (mov r8, r8)
 802322c:	48000800 	.word	0x48000800

08023230 <BSP_RADIO_GetTxConfig>:
  *  RADIO_CONF_RFO_HP
  */
int32_t BSP_RADIO_GetTxConfig(void)
{
  return RADIO_CONF_RFO_LP_HP;
}
 8023230:	2000      	movs	r0, #0
 8023232:	4770      	bx	lr

08023234 <BSP_RADIO_IsTCXO>:
  *  RADIO_CONF_TCXO_SUPPORTED
  */
int32_t BSP_RADIO_IsTCXO(void)
{
  return RADIO_CONF_TCXO_SUPPORTED;
}
 8023234:	2001      	movs	r0, #1
 8023236:	4770      	bx	lr

08023238 <BSP_RADIO_IsDCDC>:
  *  RADIO_CONF_DCDC_SUPPORTED  
  */
int32_t BSP_RADIO_IsDCDC(void)
{
  return RADIO_CONF_DCDC_SUPPORTED;
}
 8023238:	2001      	movs	r0, #1
 802323a:	4770      	bx	lr

0802323c <BSP_RADIO_GetRFOMaxPowerConfig>:
  */
int32_t BSP_RADIO_GetRFOMaxPowerConfig(BSP_RADIO_RFOMaxPowerConfig_TypeDef Config)
{
  int32_t ret;

  if(Config == RADIO_RFO_LP_MAXPOWER)
 802323c:	2800      	cmp	r0, #0
 802323e:	d101      	bne.n	8023244 <BSP_RADIO_GetRFOMaxPowerConfig+0x8>
  {
    ret = RADIO_CONF_RFO_LP_MAX_15_dBm;
 8023240:	300f      	adds	r0, #15
  {
    ret = RADIO_CONF_RFO_HP_MAX_22_dBm;
  }

  return ret;
}
 8023242:	4770      	bx	lr
    ret = RADIO_CONF_RFO_HP_MAX_22_dBm;
 8023244:	2016      	movs	r0, #22
  return ret;
 8023246:	e7fc      	b.n	8023242 <BSP_RADIO_GetRFOMaxPowerConfig+0x6>

08023248 <SystemInit>:

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
#endif
}
 8023248:	4770      	bx	lr
	...

0802324c <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 802324c:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
#endif

  /* Update the SystemCoreClock global variable */
#if defined(DUAL_CORE) && defined(CORE_CM0PLUS)
  SystemCoreClock = HAL_RCC_GetHCLK2Freq();
 802324e:	f001 fc5f 	bl	8024b10 <HAL_RCC_GetHCLK2Freq>
 8023252:	4b06      	ldr	r3, [pc, #24]	; (802326c <HAL_Init+0x20>)
 8023254:	6018      	str	r0, [r3, #0]
#else
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
#endif

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8023256:	2003      	movs	r0, #3
 8023258:	f7fe fca4 	bl	8021ba4 <HAL_InitTick>
 802325c:	1e04      	subs	r4, r0, #0
 802325e:	d002      	beq.n	8023266 <HAL_Init+0x1a>
  {
    status = HAL_ERROR;
 8023260:	2401      	movs	r4, #1
    HAL_MspInit();
  }

  /* Return function status */
  return status;
}
 8023262:	0020      	movs	r0, r4
 8023264:	bd10      	pop	{r4, pc}
    HAL_MspInit();
 8023266:	f7fe fb69 	bl	802193c <HAL_MspInit>
 802326a:	e7fa      	b.n	8023262 <HAL_Init+0x16>
 802326c:	2000b04c 	.word	0x2000b04c

08023270 <HAL_SuspendTick>:
  * @retval None
  */
__weak void HAL_SuspendTick(void)
{
  /* Disable SysTick Interrupt */
  CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 8023270:	4a02      	ldr	r2, [pc, #8]	; (802327c <HAL_SuspendTick+0xc>)
 8023272:	6813      	ldr	r3, [r2, #0]
 8023274:	2102      	movs	r1, #2
 8023276:	438b      	bics	r3, r1
 8023278:	6013      	str	r3, [r2, #0]
}
 802327a:	4770      	bx	lr
 802327c:	e000e010 	.word	0xe000e010

08023280 <HAL_ResumeTick>:
  * @retval None
  */
__weak void HAL_ResumeTick(void)
{
  /* Enable SysTick Interrupt */
  SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
 8023280:	4a02      	ldr	r2, [pc, #8]	; (802328c <HAL_ResumeTick+0xc>)
 8023282:	6813      	ldr	r3, [r2, #0]
 8023284:	2102      	movs	r1, #2
 8023286:	430b      	orrs	r3, r1
 8023288:	6013      	str	r3, [r2, #0]
}
 802328a:	4770      	bx	lr
 802328c:	e000e010 	.word	0xe000e010

08023290 <HAL_GetUIDw0>:
  * @brief  Return the first word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw0(void)
{
  return (READ_REG(*((uint32_t *)UID_BASE)));
 8023290:	4b01      	ldr	r3, [pc, #4]	; (8023298 <HAL_GetUIDw0+0x8>)
 8023292:	6818      	ldr	r0, [r3, #0]
}
 8023294:	4770      	bx	lr
 8023296:	46c0      	nop			; (mov r8, r8)
 8023298:	1fff7590 	.word	0x1fff7590

0802329c <HAL_GetUIDw1>:
  * @brief  Return the second word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw1(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 4U))));
 802329c:	4b01      	ldr	r3, [pc, #4]	; (80232a4 <HAL_GetUIDw1+0x8>)
 802329e:	6818      	ldr	r0, [r3, #0]
}
 80232a0:	4770      	bx	lr
 80232a2:	46c0      	nop			; (mov r8, r8)
 80232a4:	1fff7594 	.word	0x1fff7594

080232a8 <HAL_GetUIDw2>:
  * @brief  Return the third word of the unique device identifier (UID based on 96 bits)
  * @retval Device identifier
  */
uint32_t HAL_GetUIDw2(void)
{
  return (READ_REG(*((uint32_t *)(UID_BASE + 8U))));
 80232a8:	4b01      	ldr	r3, [pc, #4]	; (80232b0 <HAL_GetUIDw2+0x8>)
 80232aa:	6818      	ldr	r0, [r3, #0]
}
 80232ac:	4770      	bx	lr
 80232ae:	46c0      	nop			; (mov r8, r8)
 80232b0:	1fff7598 	.word	0x1fff7598

080232b4 <HAL_NVIC_SetPriority>:
  *         with stm32wlxx devices, this parameter is a dummy value and it is ignored, because
  *         no subpriority supported in Cortex M0+ based products.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80232b4:	b570      	push	{r4, r5, r6, lr}
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 80232b6:	2800      	cmp	r0, #0
 80232b8:	db11      	blt.n	80232de <HAL_NVIC_SetPriority+0x2a>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80232ba:	0883      	lsrs	r3, r0, #2
 80232bc:	4e13      	ldr	r6, [pc, #76]	; (802330c <HAL_NVIC_SetPriority+0x58>)
 80232be:	33c0      	adds	r3, #192	; 0xc0
 80232c0:	009b      	lsls	r3, r3, #2
 80232c2:	599d      	ldr	r5, [r3, r6]
 80232c4:	2403      	movs	r4, #3
 80232c6:	4020      	ands	r0, r4
 80232c8:	00c0      	lsls	r0, r0, #3
 80232ca:	22ff      	movs	r2, #255	; 0xff
 80232cc:	0014      	movs	r4, r2
 80232ce:	4084      	lsls	r4, r0
 80232d0:	43a5      	bics	r5, r4
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 80232d2:	0189      	lsls	r1, r1, #6
 80232d4:	400a      	ands	r2, r1
 80232d6:	4082      	lsls	r2, r0
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80232d8:	432a      	orrs	r2, r5
 80232da:	519a      	str	r2, [r3, r6]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn, PreemptPriority);
}
 80232dc:	bd70      	pop	{r4, r5, r6, pc}
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 80232de:	230f      	movs	r3, #15
 80232e0:	4003      	ands	r3, r0
 80232e2:	3b08      	subs	r3, #8
 80232e4:	089b      	lsrs	r3, r3, #2
 80232e6:	3306      	adds	r3, #6
 80232e8:	009b      	lsls	r3, r3, #2
 80232ea:	4a09      	ldr	r2, [pc, #36]	; (8023310 <HAL_NVIC_SetPriority+0x5c>)
 80232ec:	4694      	mov	ip, r2
 80232ee:	4463      	add	r3, ip
 80232f0:	685c      	ldr	r4, [r3, #4]
 80232f2:	2203      	movs	r2, #3
 80232f4:	4010      	ands	r0, r2
 80232f6:	00c0      	lsls	r0, r0, #3
 80232f8:	32fc      	adds	r2, #252	; 0xfc
 80232fa:	0015      	movs	r5, r2
 80232fc:	4085      	lsls	r5, r0
 80232fe:	43ac      	bics	r4, r5
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8023300:	0189      	lsls	r1, r1, #6
 8023302:	400a      	ands	r2, r1
 8023304:	4082      	lsls	r2, r0
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8023306:	4322      	orrs	r2, r4
 8023308:	605a      	str	r2, [r3, #4]
 802330a:	e7e7      	b.n	80232dc <HAL_NVIC_SetPriority+0x28>
 802330c:	e000e100 	.word	0xe000e100
 8023310:	e000ed00 	.word	0xe000ed00

08023314 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8023314:	2800      	cmp	r0, #0
 8023316:	db05      	blt.n	8023324 <HAL_NVIC_EnableIRQ+0x10>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8023318:	231f      	movs	r3, #31
 802331a:	4018      	ands	r0, r3
 802331c:	3b1e      	subs	r3, #30
 802331e:	4083      	lsls	r3, r0
 8023320:	4a01      	ldr	r2, [pc, #4]	; (8023328 <HAL_NVIC_EnableIRQ+0x14>)
 8023322:	6013      	str	r3, [r2, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8023324:	4770      	bx	lr
 8023326:	46c0      	nop			; (mov r8, r8)
 8023328:	e000e100 	.word	0xe000e100

0802332c <CRYP_SetKey>:
  *         occurs when the key is written out of HAL scope.
  * @retval None
  */
static void CRYP_SetKey(CRYP_HandleTypeDef *hcryp, uint32_t KeySize)
{
  if (hcryp->Init.pKey != NULL)
 802332c:	68c3      	ldr	r3, [r0, #12]
 802332e:	2b00      	cmp	r3, #0
 8023330:	d024      	beq.n	802337c <CRYP_SetKey+0x50>
  {
    switch (KeySize)
 8023332:	2900      	cmp	r1, #0
 8023334:	d023      	beq.n	802337e <CRYP_SetKey+0x52>
 8023336:	2280      	movs	r2, #128	; 0x80
 8023338:	02d2      	lsls	r2, r2, #11
 802333a:	4291      	cmp	r1, r2
 802333c:	d11e      	bne.n	802337c <CRYP_SetKey+0x50>
    {
      case CRYP_KEYSIZE_256B:
        hcryp->Instance->KEYR7 = *(uint32_t *)(hcryp->Init.pKey);
 802333e:	6802      	ldr	r2, [r0, #0]
 8023340:	681b      	ldr	r3, [r3, #0]
 8023342:	63d3      	str	r3, [r2, #60]	; 0x3c
        hcryp->Instance->KEYR6 = *(uint32_t *)(hcryp->Init.pKey + 1U);
 8023344:	68c2      	ldr	r2, [r0, #12]
 8023346:	6803      	ldr	r3, [r0, #0]
 8023348:	6852      	ldr	r2, [r2, #4]
 802334a:	639a      	str	r2, [r3, #56]	; 0x38
        hcryp->Instance->KEYR5 = *(uint32_t *)(hcryp->Init.pKey + 2U);
 802334c:	68c2      	ldr	r2, [r0, #12]
 802334e:	6803      	ldr	r3, [r0, #0]
 8023350:	6892      	ldr	r2, [r2, #8]
 8023352:	635a      	str	r2, [r3, #52]	; 0x34
        hcryp->Instance->KEYR4 = *(uint32_t *)(hcryp->Init.pKey + 3U);
 8023354:	68c2      	ldr	r2, [r0, #12]
 8023356:	6803      	ldr	r3, [r0, #0]
 8023358:	68d2      	ldr	r2, [r2, #12]
 802335a:	631a      	str	r2, [r3, #48]	; 0x30
        hcryp->Instance->KEYR3 = *(uint32_t *)(hcryp->Init.pKey + 4U);
 802335c:	68c2      	ldr	r2, [r0, #12]
 802335e:	6803      	ldr	r3, [r0, #0]
 8023360:	6912      	ldr	r2, [r2, #16]
 8023362:	61da      	str	r2, [r3, #28]
        hcryp->Instance->KEYR2 = *(uint32_t *)(hcryp->Init.pKey + 5U);
 8023364:	68c2      	ldr	r2, [r0, #12]
 8023366:	6803      	ldr	r3, [r0, #0]
 8023368:	6952      	ldr	r2, [r2, #20]
 802336a:	619a      	str	r2, [r3, #24]
        hcryp->Instance->KEYR1 = *(uint32_t *)(hcryp->Init.pKey + 6U);
 802336c:	68c2      	ldr	r2, [r0, #12]
 802336e:	6803      	ldr	r3, [r0, #0]
 8023370:	6992      	ldr	r2, [r2, #24]
 8023372:	615a      	str	r2, [r3, #20]
        hcryp->Instance->KEYR0 = *(uint32_t *)(hcryp->Init.pKey + 7U);
 8023374:	68c2      	ldr	r2, [r0, #12]
 8023376:	6803      	ldr	r3, [r0, #0]
 8023378:	69d2      	ldr	r2, [r2, #28]
 802337a:	611a      	str	r2, [r3, #16]
        break;
      default:
        break;
    }
  }
}
 802337c:	4770      	bx	lr
        hcryp->Instance->KEYR3 = *(uint32_t *)(hcryp->Init.pKey);
 802337e:	6802      	ldr	r2, [r0, #0]
 8023380:	681b      	ldr	r3, [r3, #0]
 8023382:	61d3      	str	r3, [r2, #28]
        hcryp->Instance->KEYR2 = *(uint32_t *)(hcryp->Init.pKey + 1U);
 8023384:	68c2      	ldr	r2, [r0, #12]
 8023386:	6803      	ldr	r3, [r0, #0]
 8023388:	6852      	ldr	r2, [r2, #4]
 802338a:	619a      	str	r2, [r3, #24]
        hcryp->Instance->KEYR1 = *(uint32_t *)(hcryp->Init.pKey + 2U);
 802338c:	68c2      	ldr	r2, [r0, #12]
 802338e:	6803      	ldr	r3, [r0, #0]
 8023390:	6892      	ldr	r2, [r2, #8]
 8023392:	615a      	str	r2, [r3, #20]
        hcryp->Instance->KEYR0 = *(uint32_t *)(hcryp->Init.pKey + 3U);
 8023394:	68c2      	ldr	r2, [r0, #12]
 8023396:	6803      	ldr	r3, [r0, #0]
 8023398:	68d2      	ldr	r2, [r2, #12]
 802339a:	611a      	str	r2, [r3, #16]
}
 802339c:	e7ee      	b.n	802337c <CRYP_SetKey+0x50>

0802339e <CRYP_WaitOnCCFlag>:
  * @param  Timeout Timeout duration.
  * @note   This function can only be used in thread mode.
  * @retval HAL status
  */
static HAL_StatusTypeDef CRYP_WaitOnCCFlag(CRYP_HandleTypeDef *hcryp, uint32_t Timeout)
{
 802339e:	b570      	push	{r4, r5, r6, lr}
 80233a0:	0005      	movs	r5, r0
 80233a2:	000c      	movs	r4, r1
  uint32_t tickstart;

  /* Get timeout */
  tickstart = HAL_GetTick();
 80233a4:	f7fe fc00 	bl	8021ba8 <HAL_GetTick>
 80233a8:	0006      	movs	r6, r0

  while (HAL_IS_BIT_CLR(hcryp->Instance->SR, AES_SR_CCF))
 80233aa:	682b      	ldr	r3, [r5, #0]
 80233ac:	685b      	ldr	r3, [r3, #4]
 80233ae:	07db      	lsls	r3, r3, #31
 80233b0:	d40a      	bmi.n	80233c8 <CRYP_WaitOnCCFlag+0x2a>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 80233b2:	1c63      	adds	r3, r4, #1
 80233b4:	d0f9      	beq.n	80233aa <CRYP_WaitOnCCFlag+0xc>
    {
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 80233b6:	f7fe fbf7 	bl	8021ba8 <HAL_GetTick>
 80233ba:	1b80      	subs	r0, r0, r6
 80233bc:	42a0      	cmp	r0, r4
 80233be:	d805      	bhi.n	80233cc <CRYP_WaitOnCCFlag+0x2e>
 80233c0:	2c00      	cmp	r4, #0
 80233c2:	d1f2      	bne.n	80233aa <CRYP_WaitOnCCFlag+0xc>
      {
        return HAL_ERROR;
 80233c4:	2001      	movs	r0, #1
 80233c6:	e000      	b.n	80233ca <CRYP_WaitOnCCFlag+0x2c>
      }
    }
  }
  return HAL_OK;
 80233c8:	2000      	movs	r0, #0
}
 80233ca:	bd70      	pop	{r4, r5, r6, pc}
        return HAL_ERROR;
 80233cc:	2001      	movs	r0, #1
 80233ce:	e7fc      	b.n	80233ca <CRYP_WaitOnCCFlag+0x2c>

080233d0 <CRYP_GCMCCM_SetHeaderPhase>:
{
 80233d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80233d2:	b08d      	sub	sp, #52	; 0x34
 80233d4:	0004      	movs	r4, r0
 80233d6:	000d      	movs	r5, r1
  uint32_t mask[12] = {0x0U, 0xFF000000U, 0xFFFF0000U, 0xFFFFFF00U,  /* 32-bit data type */
 80233d8:	4669      	mov	r1, sp
 80233da:	4b8f      	ldr	r3, [pc, #572]	; (8023618 <CRYP_GCMCCM_SetHeaderPhase+0x248>)
 80233dc:	000a      	movs	r2, r1
 80233de:	cb43      	ldmia	r3!, {r0, r1, r6}
 80233e0:	c243      	stmia	r2!, {r0, r1, r6}
 80233e2:	cb43      	ldmia	r3!, {r0, r1, r6}
 80233e4:	c243      	stmia	r2!, {r0, r1, r6}
 80233e6:	cb43      	ldmia	r3!, {r0, r1, r6}
 80233e8:	c243      	stmia	r2!, {r0, r1, r6}
 80233ea:	cb43      	ldmia	r3!, {r0, r1, r6}
 80233ec:	c243      	stmia	r2!, {r0, r1, r6}
  if (hcryp->Init.HeaderWidthUnit == CRYP_HEADERWIDTHUNIT_WORD)
 80233ee:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80233f0:	2b00      	cmp	r3, #0
 80233f2:	d118      	bne.n	8023426 <CRYP_GCMCCM_SetHeaderPhase+0x56>
    size_in_bytes = hcryp->Init.HeaderSize * 4U;
 80233f4:	69e3      	ldr	r3, [r4, #28]
 80233f6:	009e      	lsls	r6, r3, #2
  if ((size_in_bytes != 0U))
 80233f8:	2e00      	cmp	r6, #0
 80233fa:	d100      	bne.n	80233fe <CRYP_GCMCCM_SetHeaderPhase+0x2e>
 80233fc:	e0f5      	b.n	80235ea <CRYP_GCMCCM_SetHeaderPhase+0x21a>
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_HEADER);
 80233fe:	6821      	ldr	r1, [r4, #0]
 8023400:	680b      	ldr	r3, [r1, #0]
 8023402:	4a86      	ldr	r2, [pc, #536]	; (802361c <CRYP_GCMCCM_SetHeaderPhase+0x24c>)
 8023404:	401a      	ands	r2, r3
 8023406:	2380      	movs	r3, #128	; 0x80
 8023408:	019b      	lsls	r3, r3, #6
 802340a:	4313      	orrs	r3, r2
 802340c:	600b      	str	r3, [r1, #0]
    __HAL_CRYP_ENABLE(hcryp);
 802340e:	6822      	ldr	r2, [r4, #0]
 8023410:	6813      	ldr	r3, [r2, #0]
 8023412:	2101      	movs	r1, #1
 8023414:	430b      	orrs	r3, r1
 8023416:	6013      	str	r3, [r2, #0]
    if ((size_in_bytes % 16U) == 0U)
 8023418:	230f      	movs	r3, #15
 802341a:	001f      	movs	r7, r3
 802341c:	4037      	ands	r7, r6
 802341e:	4233      	tst	r3, r6
 8023420:	d009      	beq.n	8023436 <CRYP_GCMCCM_SetHeaderPhase+0x66>
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 16U) * 4U)); loopcounter += 4U)
 8023422:	2700      	movs	r7, #0
 8023424:	e050      	b.n	80234c8 <CRYP_GCMCCM_SetHeaderPhase+0xf8>
    size_in_bytes = hcryp->Init.HeaderSize;
 8023426:	69e6      	ldr	r6, [r4, #28]
 8023428:	e7e6      	b.n	80233f8 <CRYP_GCMCCM_SetHeaderPhase+0x28>
        __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 802342a:	6822      	ldr	r2, [r4, #0]
 802342c:	6813      	ldr	r3, [r2, #0]
 802342e:	2180      	movs	r1, #128	; 0x80
 8023430:	430b      	orrs	r3, r1
 8023432:	6013      	str	r3, [r2, #0]
      for (loopcounter = 0U; (loopcounter < (size_in_bytes / 4U)); loopcounter += 4U)
 8023434:	3704      	adds	r7, #4
 8023436:	08b3      	lsrs	r3, r6, #2
 8023438:	42bb      	cmp	r3, r7
 802343a:	d93d      	bls.n	80234b8 <CRYP_GCMCCM_SetHeaderPhase+0xe8>
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 802343c:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 802343e:	009b      	lsls	r3, r3, #2
 8023440:	6822      	ldr	r2, [r4, #0]
 8023442:	69a1      	ldr	r1, [r4, #24]
 8023444:	58cb      	ldr	r3, [r1, r3]
 8023446:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 8023448:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 802344a:	3301      	adds	r3, #1
 802344c:	b29b      	uxth	r3, r3
 802344e:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 8023450:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8023452:	009b      	lsls	r3, r3, #2
 8023454:	6822      	ldr	r2, [r4, #0]
 8023456:	69a1      	ldr	r1, [r4, #24]
 8023458:	58cb      	ldr	r3, [r1, r3]
 802345a:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 802345c:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 802345e:	3301      	adds	r3, #1
 8023460:	b29b      	uxth	r3, r3
 8023462:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR  = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 8023464:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8023466:	009b      	lsls	r3, r3, #2
 8023468:	6822      	ldr	r2, [r4, #0]
 802346a:	69a1      	ldr	r1, [r4, #24]
 802346c:	58cb      	ldr	r3, [r1, r3]
 802346e:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 8023470:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8023472:	3301      	adds	r3, #1
 8023474:	b29b      	uxth	r3, r3
 8023476:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 8023478:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 802347a:	009b      	lsls	r3, r3, #2
 802347c:	6822      	ldr	r2, [r4, #0]
 802347e:	69a1      	ldr	r1, [r4, #24]
 8023480:	58cb      	ldr	r3, [r1, r3]
 8023482:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 8023484:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8023486:	3301      	adds	r3, #1
 8023488:	b29b      	uxth	r3, r3
 802348a:	87a3      	strh	r3, [r4, #60]	; 0x3c
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 802348c:	0029      	movs	r1, r5
 802348e:	0020      	movs	r0, r4
 8023490:	f7ff ff85 	bl	802339e <CRYP_WaitOnCCFlag>
 8023494:	2800      	cmp	r0, #0
 8023496:	d0c8      	beq.n	802342a <CRYP_GCMCCM_SetHeaderPhase+0x5a>
          __HAL_CRYP_DISABLE(hcryp);
 8023498:	6821      	ldr	r1, [r4, #0]
 802349a:	680b      	ldr	r3, [r1, #0]
 802349c:	2201      	movs	r2, #1
 802349e:	4393      	bics	r3, r2
 80234a0:	600b      	str	r3, [r1, #0]
          hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 80234a2:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80234a4:	2110      	movs	r1, #16
 80234a6:	430b      	orrs	r3, r1
 80234a8:	6563      	str	r3, [r4, #84]	; 0x54
          hcryp->State = HAL_CRYP_STATE_READY;
 80234aa:	2351      	movs	r3, #81	; 0x51
 80234ac:	54e2      	strb	r2, [r4, r3]
          __HAL_UNLOCK(hcryp);
 80234ae:	3b01      	subs	r3, #1
 80234b0:	2200      	movs	r2, #0
 80234b2:	54e2      	strb	r2, [r4, r3]
          return HAL_ERROR;
 80234b4:	2001      	movs	r0, #1
 80234b6:	e0ad      	b.n	8023614 <CRYP_GCMCCM_SetHeaderPhase+0x244>
  return HAL_OK;
 80234b8:	2000      	movs	r0, #0
 80234ba:	e0ab      	b.n	8023614 <CRYP_GCMCCM_SetHeaderPhase+0x244>
        __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 80234bc:	6822      	ldr	r2, [r4, #0]
 80234be:	6813      	ldr	r3, [r2, #0]
 80234c0:	2180      	movs	r1, #128	; 0x80
 80234c2:	430b      	orrs	r3, r1
 80234c4:	6013      	str	r3, [r2, #0]
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 16U) * 4U)); loopcounter += 4U)
 80234c6:	3704      	adds	r7, #4
 80234c8:	0933      	lsrs	r3, r6, #4
 80234ca:	009b      	lsls	r3, r3, #2
 80234cc:	42bb      	cmp	r3, r7
 80234ce:	d93d      	bls.n	802354c <CRYP_GCMCCM_SetHeaderPhase+0x17c>
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 80234d0:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 80234d2:	009b      	lsls	r3, r3, #2
 80234d4:	6822      	ldr	r2, [r4, #0]
 80234d6:	69a1      	ldr	r1, [r4, #24]
 80234d8:	58cb      	ldr	r3, [r1, r3]
 80234da:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 80234dc:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 80234de:	3301      	adds	r3, #1
 80234e0:	b29b      	uxth	r3, r3
 80234e2:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 80234e4:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 80234e6:	009b      	lsls	r3, r3, #2
 80234e8:	6822      	ldr	r2, [r4, #0]
 80234ea:	69a1      	ldr	r1, [r4, #24]
 80234ec:	58cb      	ldr	r3, [r1, r3]
 80234ee:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 80234f0:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 80234f2:	3301      	adds	r3, #1
 80234f4:	b29b      	uxth	r3, r3
 80234f6:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR  = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 80234f8:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 80234fa:	009b      	lsls	r3, r3, #2
 80234fc:	6822      	ldr	r2, [r4, #0]
 80234fe:	69a1      	ldr	r1, [r4, #24]
 8023500:	58cb      	ldr	r3, [r1, r3]
 8023502:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 8023504:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8023506:	3301      	adds	r3, #1
 8023508:	b29b      	uxth	r3, r3
 802350a:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 802350c:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 802350e:	009b      	lsls	r3, r3, #2
 8023510:	6822      	ldr	r2, [r4, #0]
 8023512:	69a1      	ldr	r1, [r4, #24]
 8023514:	58cb      	ldr	r3, [r1, r3]
 8023516:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 8023518:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 802351a:	3301      	adds	r3, #1
 802351c:	b29b      	uxth	r3, r3
 802351e:	87a3      	strh	r3, [r4, #60]	; 0x3c
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 8023520:	0029      	movs	r1, r5
 8023522:	0020      	movs	r0, r4
 8023524:	f7ff ff3b 	bl	802339e <CRYP_WaitOnCCFlag>
 8023528:	2800      	cmp	r0, #0
 802352a:	d0c7      	beq.n	80234bc <CRYP_GCMCCM_SetHeaderPhase+0xec>
          __HAL_CRYP_DISABLE(hcryp);
 802352c:	6821      	ldr	r1, [r4, #0]
 802352e:	680b      	ldr	r3, [r1, #0]
 8023530:	2201      	movs	r2, #1
 8023532:	4393      	bics	r3, r2
 8023534:	600b      	str	r3, [r1, #0]
          hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8023536:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023538:	2110      	movs	r1, #16
 802353a:	430b      	orrs	r3, r1
 802353c:	6563      	str	r3, [r4, #84]	; 0x54
          hcryp->State = HAL_CRYP_STATE_READY;
 802353e:	2351      	movs	r3, #81	; 0x51
 8023540:	54e2      	strb	r2, [r4, r3]
          __HAL_UNLOCK(hcryp);
 8023542:	3b01      	subs	r3, #1
 8023544:	2200      	movs	r2, #0
 8023546:	54e2      	strb	r2, [r4, r3]
          return HAL_ERROR;
 8023548:	2001      	movs	r0, #1
 802354a:	e063      	b.n	8023614 <CRYP_GCMCCM_SetHeaderPhase+0x244>
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 4U) % 4U)); loopcounter++)
 802354c:	2200      	movs	r2, #0
 802354e:	08b1      	lsrs	r1, r6, #2
 8023550:	2303      	movs	r3, #3
 8023552:	400b      	ands	r3, r1
 8023554:	4293      	cmp	r3, r2
 8023556:	d90b      	bls.n	8023570 <CRYP_GCMCCM_SetHeaderPhase+0x1a0>
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 8023558:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 802355a:	009b      	lsls	r3, r3, #2
 802355c:	6821      	ldr	r1, [r4, #0]
 802355e:	69a0      	ldr	r0, [r4, #24]
 8023560:	58c3      	ldr	r3, [r0, r3]
 8023562:	608b      	str	r3, [r1, #8]
        hcryp->CrypHeaderCount++ ;
 8023564:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8023566:	3301      	adds	r3, #1
 8023568:	b29b      	uxth	r3, r3
 802356a:	87a3      	strh	r3, [r4, #60]	; 0x3c
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 4U) % 4U)); loopcounter++)
 802356c:	3201      	adds	r2, #1
 802356e:	e7ee      	b.n	802354e <CRYP_GCMCCM_SetHeaderPhase+0x17e>
      if ((size_in_bytes % 4U) == 0U)
 8023570:	2103      	movs	r1, #3
 8023572:	000b      	movs	r3, r1
 8023574:	4033      	ands	r3, r6
 8023576:	4231      	tst	r1, r6
 8023578:	d012      	beq.n	80235a0 <CRYP_GCMCCM_SetHeaderPhase+0x1d0>
         tmp =  *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 802357a:	8fa1      	ldrh	r1, [r4, #60]	; 0x3c
 802357c:	0089      	lsls	r1, r1, #2
 802357e:	69a0      	ldr	r0, [r4, #24]
 8023580:	5841      	ldr	r1, [r0, r1]
         tmp &= mask[(hcryp->Init.DataType * 2U) + (size_in_bytes % 4U)];
 8023582:	6860      	ldr	r0, [r4, #4]
 8023584:	0040      	lsls	r0, r0, #1
 8023586:	181b      	adds	r3, r3, r0
 8023588:	009b      	lsls	r3, r3, #2
 802358a:	4668      	mov	r0, sp
 802358c:	581b      	ldr	r3, [r3, r0]
 802358e:	400b      	ands	r3, r1
         hcryp->Instance->DINR = tmp;
 8023590:	6821      	ldr	r1, [r4, #0]
 8023592:	608b      	str	r3, [r1, #8]
         loopcounter++;
 8023594:	3201      	adds	r2, #1
         while (loopcounter < 4U)
 8023596:	e015      	b.n	80235c4 <CRYP_GCMCCM_SetHeaderPhase+0x1f4>
          hcryp->Instance->DINR = 0x0U;
 8023598:	6823      	ldr	r3, [r4, #0]
 802359a:	2100      	movs	r1, #0
 802359c:	6099      	str	r1, [r3, #8]
          loopcounter++;
 802359e:	3201      	adds	r2, #1
        while (loopcounter < 4U)
 80235a0:	2a03      	cmp	r2, #3
 80235a2:	d9f9      	bls.n	8023598 <CRYP_GCMCCM_SetHeaderPhase+0x1c8>
      if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 80235a4:	0029      	movs	r1, r5
 80235a6:	0020      	movs	r0, r4
 80235a8:	f7ff fef9 	bl	802339e <CRYP_WaitOnCCFlag>
 80235ac:	2800      	cmp	r0, #0
 80235ae:	d10c      	bne.n	80235ca <CRYP_GCMCCM_SetHeaderPhase+0x1fa>
      __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 80235b0:	6822      	ldr	r2, [r4, #0]
 80235b2:	6813      	ldr	r3, [r2, #0]
 80235b4:	2180      	movs	r1, #128	; 0x80
 80235b6:	430b      	orrs	r3, r1
 80235b8:	6013      	str	r3, [r2, #0]
 80235ba:	e02b      	b.n	8023614 <CRYP_GCMCCM_SetHeaderPhase+0x244>
           hcryp->Instance->DINR = 0x0U;
 80235bc:	6823      	ldr	r3, [r4, #0]
 80235be:	2100      	movs	r1, #0
 80235c0:	6099      	str	r1, [r3, #8]
           loopcounter++;
 80235c2:	3201      	adds	r2, #1
         while (loopcounter < 4U)
 80235c4:	2a03      	cmp	r2, #3
 80235c6:	d9f9      	bls.n	80235bc <CRYP_GCMCCM_SetHeaderPhase+0x1ec>
 80235c8:	e7ec      	b.n	80235a4 <CRYP_GCMCCM_SetHeaderPhase+0x1d4>
        __HAL_CRYP_DISABLE(hcryp);
 80235ca:	6821      	ldr	r1, [r4, #0]
 80235cc:	680b      	ldr	r3, [r1, #0]
 80235ce:	2201      	movs	r2, #1
 80235d0:	4393      	bics	r3, r2
 80235d2:	600b      	str	r3, [r1, #0]
        hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 80235d4:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80235d6:	2110      	movs	r1, #16
 80235d8:	430b      	orrs	r3, r1
 80235da:	6563      	str	r3, [r4, #84]	; 0x54
        hcryp->State = HAL_CRYP_STATE_READY;
 80235dc:	2351      	movs	r3, #81	; 0x51
 80235de:	54e2      	strb	r2, [r4, r3]
        __HAL_UNLOCK(hcryp);
 80235e0:	3b01      	subs	r3, #1
 80235e2:	2200      	movs	r2, #0
 80235e4:	54e2      	strb	r2, [r4, r3]
        return HAL_ERROR;
 80235e6:	2001      	movs	r0, #1
 80235e8:	e014      	b.n	8023614 <CRYP_GCMCCM_SetHeaderPhase+0x244>
    MODIFY_REG(hcryp->Instance->CR, AES_CR_DATATYPE, hcryp->Init.DataType);
 80235ea:	6822      	ldr	r2, [r4, #0]
 80235ec:	6813      	ldr	r3, [r2, #0]
 80235ee:	2106      	movs	r1, #6
 80235f0:	438b      	bics	r3, r1
 80235f2:	6861      	ldr	r1, [r4, #4]
 80235f4:	430b      	orrs	r3, r1
 80235f6:	6013      	str	r3, [r2, #0]
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_HEADER);
 80235f8:	6821      	ldr	r1, [r4, #0]
 80235fa:	680b      	ldr	r3, [r1, #0]
 80235fc:	4a07      	ldr	r2, [pc, #28]	; (802361c <CRYP_GCMCCM_SetHeaderPhase+0x24c>)
 80235fe:	401a      	ands	r2, r3
 8023600:	2380      	movs	r3, #128	; 0x80
 8023602:	019b      	lsls	r3, r3, #6
 8023604:	4313      	orrs	r3, r2
 8023606:	600b      	str	r3, [r1, #0]
    __HAL_CRYP_ENABLE(hcryp);
 8023608:	6822      	ldr	r2, [r4, #0]
 802360a:	6813      	ldr	r3, [r2, #0]
 802360c:	2101      	movs	r1, #1
 802360e:	430b      	orrs	r3, r1
 8023610:	6013      	str	r3, [r2, #0]
  return HAL_OK;
 8023612:	2000      	movs	r0, #0
}
 8023614:	b00d      	add	sp, #52	; 0x34
 8023616:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8023618:	08034c90 	.word	0x08034c90
 802361c:	ffff9fff 	.word	0xffff9fff

08023620 <HAL_CRYP_Init>:
{
 8023620:	b510      	push	{r4, lr}
 8023622:	1e04      	subs	r4, r0, #0
  if (hcryp == NULL)
 8023624:	d01d      	beq.n	8023662 <HAL_CRYP_Init+0x42>
  if (hcryp->State == HAL_CRYP_STATE_RESET)
 8023626:	2351      	movs	r3, #81	; 0x51
 8023628:	5cc3      	ldrb	r3, [r0, r3]
 802362a:	2b00      	cmp	r3, #0
 802362c:	d013      	beq.n	8023656 <HAL_CRYP_Init+0x36>
  MODIFY_REG(hcryp->Instance->CR, AES_CR_DATATYPE | AES_CR_KEYSIZE | AES_CR_CHMOD, hcryp->Init.DataType | hcryp->Init.KeySize | hcryp->Init.Algorithm);
 802362e:	6821      	ldr	r1, [r4, #0]
 8023630:	680b      	ldr	r3, [r1, #0]
 8023632:	4a0d      	ldr	r2, [pc, #52]	; (8023668 <HAL_CRYP_Init+0x48>)
 8023634:	4013      	ands	r3, r2
 8023636:	6862      	ldr	r2, [r4, #4]
 8023638:	68a0      	ldr	r0, [r4, #8]
 802363a:	4302      	orrs	r2, r0
 802363c:	6960      	ldr	r0, [r4, #20]
 802363e:	4302      	orrs	r2, r0
 8023640:	4313      	orrs	r3, r2
 8023642:	600b      	str	r3, [r1, #0]
  hcryp->ErrorCode = HAL_CRYP_ERROR_NONE;
 8023644:	2300      	movs	r3, #0
 8023646:	6563      	str	r3, [r4, #84]	; 0x54
  hcryp->KeyIVConfig = 0U;
 8023648:	65a3      	str	r3, [r4, #88]	; 0x58
  hcryp->State = HAL_CRYP_STATE_READY;
 802364a:	3301      	adds	r3, #1
 802364c:	2251      	movs	r2, #81	; 0x51
 802364e:	54a3      	strb	r3, [r4, r2]
  hcryp->Phase = CRYP_PHASE_READY;
 8023650:	6463      	str	r3, [r4, #68]	; 0x44
  return HAL_OK;
 8023652:	2000      	movs	r0, #0
}
 8023654:	bd10      	pop	{r4, pc}
    hcryp->Lock = HAL_UNLOCKED;
 8023656:	3350      	adds	r3, #80	; 0x50
 8023658:	2200      	movs	r2, #0
 802365a:	54c2      	strb	r2, [r0, r3]
    HAL_CRYP_MspInit(hcryp);
 802365c:	f7fd ff0a 	bl	8021474 <HAL_CRYP_MspInit>
 8023660:	e7e5      	b.n	802362e <HAL_CRYP_Init+0xe>
    return HAL_ERROR;
 8023662:	2001      	movs	r0, #1
 8023664:	e7f6      	b.n	8023654 <HAL_CRYP_Init+0x34>
 8023666:	46c0      	nop			; (mov r8, r8)
 8023668:	fffaff99 	.word	0xfffaff99

0802366c <HAL_CRYP_DeInit>:
{
 802366c:	b570      	push	{r4, r5, r6, lr}
 802366e:	1e04      	subs	r4, r0, #0
  if (hcryp == NULL)
 8023670:	d013      	beq.n	802369a <HAL_CRYP_DeInit+0x2e>
  hcryp->Phase = CRYP_PHASE_READY;
 8023672:	2101      	movs	r1, #1
 8023674:	6441      	str	r1, [r0, #68]	; 0x44
  hcryp->CrypInCount = 0;
 8023676:	2300      	movs	r3, #0
 8023678:	2500      	movs	r5, #0
 802367a:	87c3      	strh	r3, [r0, #62]	; 0x3e
  hcryp->CrypOutCount = 0;
 802367c:	2240      	movs	r2, #64	; 0x40
 802367e:	5283      	strh	r3, [r0, r2]
  hcryp->CrypHeaderCount = 0;
 8023680:	8783      	strh	r3, [r0, #60]	; 0x3c
  __HAL_CRYP_DISABLE(hcryp);
 8023682:	6802      	ldr	r2, [r0, #0]
 8023684:	6813      	ldr	r3, [r2, #0]
 8023686:	438b      	bics	r3, r1
 8023688:	6013      	str	r3, [r2, #0]
  HAL_CRYP_MspDeInit(hcryp);
 802368a:	f7fd ff11 	bl	80214b0 <HAL_CRYP_MspDeInit>
  hcryp->State = HAL_CRYP_STATE_RESET;
 802368e:	2351      	movs	r3, #81	; 0x51
 8023690:	54e5      	strb	r5, [r4, r3]
  __HAL_UNLOCK(hcryp);
 8023692:	3b01      	subs	r3, #1
 8023694:	54e5      	strb	r5, [r4, r3]
  return HAL_OK;
 8023696:	2000      	movs	r0, #0
}
 8023698:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 802369a:	2001      	movs	r0, #1
 802369c:	e7fc      	b.n	8023698 <HAL_CRYP_DeInit+0x2c>

0802369e <HAL_CRYP_ErrorCallback>:
}
 802369e:	4770      	bx	lr

080236a0 <CRYP_AES_ProcessData>:
{
 80236a0:	b530      	push	{r4, r5, lr}
 80236a2:	b085      	sub	sp, #20
 80236a4:	0004      	movs	r4, r0
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 80236a6:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 80236a8:	009b      	lsls	r3, r3, #2
 80236aa:	6802      	ldr	r2, [r0, #0]
 80236ac:	6b40      	ldr	r0, [r0, #52]	; 0x34
 80236ae:	58c3      	ldr	r3, [r0, r3]
 80236b0:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 80236b2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80236b4:	3301      	adds	r3, #1
 80236b6:	b29b      	uxth	r3, r3
 80236b8:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 80236ba:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80236bc:	009b      	lsls	r3, r3, #2
 80236be:	6822      	ldr	r2, [r4, #0]
 80236c0:	6b60      	ldr	r0, [r4, #52]	; 0x34
 80236c2:	58c3      	ldr	r3, [r0, r3]
 80236c4:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 80236c6:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80236c8:	3301      	adds	r3, #1
 80236ca:	b29b      	uxth	r3, r3
 80236cc:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 80236ce:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80236d0:	009b      	lsls	r3, r3, #2
 80236d2:	6822      	ldr	r2, [r4, #0]
 80236d4:	6b60      	ldr	r0, [r4, #52]	; 0x34
 80236d6:	58c3      	ldr	r3, [r0, r3]
 80236d8:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 80236da:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80236dc:	3301      	adds	r3, #1
 80236de:	b29b      	uxth	r3, r3
 80236e0:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 80236e2:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80236e4:	009b      	lsls	r3, r3, #2
 80236e6:	6822      	ldr	r2, [r4, #0]
 80236e8:	6b60      	ldr	r0, [r4, #52]	; 0x34
 80236ea:	58c3      	ldr	r3, [r0, r3]
 80236ec:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 80236ee:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80236f0:	3301      	adds	r3, #1
 80236f2:	b29b      	uxth	r3, r3
 80236f4:	87e3      	strh	r3, [r4, #62]	; 0x3e
  if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 80236f6:	0020      	movs	r0, r4
 80236f8:	f7ff fe51 	bl	802339e <CRYP_WaitOnCCFlag>
 80236fc:	2800      	cmp	r0, #0
 80236fe:	d106      	bne.n	802370e <CRYP_AES_ProcessData+0x6e>
  __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8023700:	6822      	ldr	r2, [r4, #0]
 8023702:	6813      	ldr	r3, [r2, #0]
 8023704:	2180      	movs	r1, #128	; 0x80
 8023706:	430b      	orrs	r3, r1
 8023708:	6013      	str	r3, [r2, #0]
  for (i = 0U; i < 4U; i++)
 802370a:	2300      	movs	r3, #0
 802370c:	e017      	b.n	802373e <CRYP_AES_ProcessData+0x9e>
    __HAL_CRYP_DISABLE(hcryp);
 802370e:	6821      	ldr	r1, [r4, #0]
 8023710:	680b      	ldr	r3, [r1, #0]
 8023712:	2201      	movs	r2, #1
 8023714:	4393      	bics	r3, r2
 8023716:	600b      	str	r3, [r1, #0]
    hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8023718:	6d63      	ldr	r3, [r4, #84]	; 0x54
 802371a:	2110      	movs	r1, #16
 802371c:	430b      	orrs	r3, r1
 802371e:	6563      	str	r3, [r4, #84]	; 0x54
    hcryp->State = HAL_CRYP_STATE_READY;
 8023720:	2351      	movs	r3, #81	; 0x51
 8023722:	54e2      	strb	r2, [r4, r3]
    __HAL_UNLOCK(hcryp);
 8023724:	3b01      	subs	r3, #1
 8023726:	2200      	movs	r2, #0
 8023728:	54e2      	strb	r2, [r4, r3]
    HAL_CRYP_ErrorCallback(hcryp);
 802372a:	0020      	movs	r0, r4
 802372c:	f7ff ffb7 	bl	802369e <HAL_CRYP_ErrorCallback>
 8023730:	e7e6      	b.n	8023700 <CRYP_AES_ProcessData+0x60>
    temp[i] = hcryp->Instance->DOUTR;
 8023732:	6822      	ldr	r2, [r4, #0]
 8023734:	68d1      	ldr	r1, [r2, #12]
 8023736:	009a      	lsls	r2, r3, #2
 8023738:	4668      	mov	r0, sp
 802373a:	5011      	str	r1, [r2, r0]
  for (i = 0U; i < 4U; i++)
 802373c:	3301      	adds	r3, #1
 802373e:	2b03      	cmp	r3, #3
 8023740:	d9f7      	bls.n	8023732 <CRYP_AES_ProcessData+0x92>
  i= 0U;
 8023742:	2100      	movs	r1, #0
 8023744:	e00c      	b.n	8023760 <CRYP_AES_ProcessData+0xc0>
    *(uint32_t *)(hcryp->pCrypOutBuffPtr + hcryp->CrypOutCount) = temp[i];
 8023746:	2240      	movs	r2, #64	; 0x40
 8023748:	5aa3      	ldrh	r3, [r4, r2]
 802374a:	009b      	lsls	r3, r3, #2
 802374c:	0088      	lsls	r0, r1, #2
 802374e:	466d      	mov	r5, sp
 8023750:	5940      	ldr	r0, [r0, r5]
 8023752:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8023754:	50e8      	str	r0, [r5, r3]
    hcryp->CrypOutCount++;
 8023756:	5aa3      	ldrh	r3, [r4, r2]
 8023758:	3301      	adds	r3, #1
 802375a:	b29b      	uxth	r3, r3
 802375c:	52a3      	strh	r3, [r4, r2]
    i++;
 802375e:	3101      	adds	r1, #1
  while((hcryp->CrypOutCount < ((hcryp->Size + 3U)/4U)) && (i<4U))
 8023760:	2340      	movs	r3, #64	; 0x40
 8023762:	5ae2      	ldrh	r2, [r4, r3]
 8023764:	b292      	uxth	r2, r2
 8023766:	3302      	adds	r3, #2
 8023768:	5ae3      	ldrh	r3, [r4, r3]
 802376a:	3303      	adds	r3, #3
 802376c:	089b      	lsrs	r3, r3, #2
 802376e:	429a      	cmp	r2, r3
 8023770:	d201      	bcs.n	8023776 <CRYP_AES_ProcessData+0xd6>
 8023772:	2903      	cmp	r1, #3
 8023774:	d9e7      	bls.n	8023746 <CRYP_AES_ProcessData+0xa6>
}
 8023776:	b005      	add	sp, #20
 8023778:	bd30      	pop	{r4, r5, pc}

0802377a <CRYP_AES_Encrypt>:
{
 802377a:	b570      	push	{r4, r5, r6, lr}
 802377c:	0004      	movs	r4, r0
 802377e:	000d      	movs	r5, r1
  if ((hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)|| (hcryp->Init.KeyIVConfigSkip == CRYP_IVCONFIG_ONCE))
 8023780:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8023782:	2b01      	cmp	r3, #1
 8023784:	d025      	beq.n	80237d2 <CRYP_AES_Encrypt+0x58>
 8023786:	2b04      	cmp	r3, #4
 8023788:	d023      	beq.n	80237d2 <CRYP_AES_Encrypt+0x58>
    CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 802378a:	68a1      	ldr	r1, [r4, #8]
 802378c:	0020      	movs	r0, r4
 802378e:	f7ff fdcd 	bl	802332c <CRYP_SetKey>
    if (hcryp->Init.Algorithm != CRYP_AES_ECB)
 8023792:	6963      	ldr	r3, [r4, #20]
 8023794:	2b00      	cmp	r3, #0
 8023796:	d00f      	beq.n	80237b8 <CRYP_AES_Encrypt+0x3e>
      hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.pInitVect);
 8023798:	6922      	ldr	r2, [r4, #16]
 802379a:	6823      	ldr	r3, [r4, #0]
 802379c:	6812      	ldr	r2, [r2, #0]
 802379e:	62da      	str	r2, [r3, #44]	; 0x2c
      hcryp->Instance->IVR2 = *(uint32_t *)(hcryp->Init.pInitVect + 1U);
 80237a0:	6922      	ldr	r2, [r4, #16]
 80237a2:	6823      	ldr	r3, [r4, #0]
 80237a4:	6852      	ldr	r2, [r2, #4]
 80237a6:	629a      	str	r2, [r3, #40]	; 0x28
      hcryp->Instance->IVR1 = *(uint32_t *)(hcryp->Init.pInitVect + 2U);
 80237a8:	6922      	ldr	r2, [r4, #16]
 80237aa:	6823      	ldr	r3, [r4, #0]
 80237ac:	6892      	ldr	r2, [r2, #8]
 80237ae:	625a      	str	r2, [r3, #36]	; 0x24
      hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.pInitVect + 3U);
 80237b0:	6922      	ldr	r2, [r4, #16]
 80237b2:	6823      	ldr	r3, [r4, #0]
 80237b4:	68d2      	ldr	r2, [r2, #12]
 80237b6:	621a      	str	r2, [r3, #32]
  hcryp->Phase = CRYP_PHASE_PROCESS;
 80237b8:	2302      	movs	r3, #2
 80237ba:	6463      	str	r3, [r4, #68]	; 0x44
  __HAL_CRYP_ENABLE(hcryp);
 80237bc:	6822      	ldr	r2, [r4, #0]
 80237be:	6813      	ldr	r3, [r2, #0]
 80237c0:	2101      	movs	r1, #1
 80237c2:	430b      	orrs	r3, r1
 80237c4:	6013      	str	r3, [r2, #0]
  incount = hcryp->CrypInCount;
 80237c6:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 80237c8:	b292      	uxth	r2, r2
  outcount = hcryp->CrypOutCount;
 80237ca:	2340      	movs	r3, #64	; 0x40
 80237cc:	5ae0      	ldrh	r0, [r4, r3]
 80237ce:	b280      	uxth	r0, r0
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 80237d0:	e015      	b.n	80237fe <CRYP_AES_Encrypt+0x84>
    if (hcryp->KeyIVConfig == 1U)
 80237d2:	6da2      	ldr	r2, [r4, #88]	; 0x58
 80237d4:	2a01      	cmp	r2, #1
 80237d6:	d002      	beq.n	80237de <CRYP_AES_Encrypt+0x64>
      hcryp->KeyIVConfig = 1U;
 80237d8:	2301      	movs	r3, #1
 80237da:	65a3      	str	r3, [r4, #88]	; 0x58
  if (DoKeyIVConfig == 1U)
 80237dc:	e7d5      	b.n	802378a <CRYP_AES_Encrypt+0x10>
    if (hcryp->Init.KeyIVConfigSkip == CRYP_IVCONFIG_ONCE)
 80237de:	2b04      	cmp	r3, #4
 80237e0:	d1ea      	bne.n	80237b8 <CRYP_AES_Encrypt+0x3e>
      CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 80237e2:	68a1      	ldr	r1, [r4, #8]
 80237e4:	0020      	movs	r0, r4
 80237e6:	f7ff fda1 	bl	802332c <CRYP_SetKey>
 80237ea:	e7e5      	b.n	80237b8 <CRYP_AES_Encrypt+0x3e>
    CRYP_AES_ProcessData(hcryp, Timeout);
 80237ec:	0029      	movs	r1, r5
 80237ee:	0020      	movs	r0, r4
 80237f0:	f7ff ff56 	bl	80236a0 <CRYP_AES_ProcessData>
    incount = hcryp->CrypInCount;
 80237f4:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 80237f6:	b292      	uxth	r2, r2
    outcount = hcryp->CrypOutCount;
 80237f8:	2340      	movs	r3, #64	; 0x40
 80237fa:	5ae0      	ldrh	r0, [r4, r3]
 80237fc:	b280      	uxth	r0, r0
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 80237fe:	2342      	movs	r3, #66	; 0x42
 8023800:	5ae3      	ldrh	r3, [r4, r3]
 8023802:	089b      	lsrs	r3, r3, #2
 8023804:	4293      	cmp	r3, r2
 8023806:	d901      	bls.n	802380c <CRYP_AES_Encrypt+0x92>
 8023808:	4283      	cmp	r3, r0
 802380a:	d8ef      	bhi.n	80237ec <CRYP_AES_Encrypt+0x72>
  __HAL_CRYP_DISABLE(hcryp);
 802380c:	6821      	ldr	r1, [r4, #0]
 802380e:	680b      	ldr	r3, [r1, #0]
 8023810:	2201      	movs	r2, #1
 8023812:	4393      	bics	r3, r2
 8023814:	600b      	str	r3, [r1, #0]
  hcryp->State = HAL_CRYP_STATE_READY;
 8023816:	2351      	movs	r3, #81	; 0x51
 8023818:	54e2      	strb	r2, [r4, r3]
}
 802381a:	2000      	movs	r0, #0
 802381c:	bd70      	pop	{r4, r5, r6, pc}
	...

08023820 <CRYP_AESCCM_Process>:
{
 8023820:	b5f0      	push	{r4, r5, r6, r7, lr}
 8023822:	b085      	sub	sp, #20
 8023824:	0004      	movs	r4, r0
 8023826:	000d      	movs	r5, r1
  uint32_t wordsize = ((uint32_t)hcryp->Size / 4U) ;
 8023828:	2342      	movs	r3, #66	; 0x42
 802382a:	5ac3      	ldrh	r3, [r0, r3]
 802382c:	089e      	lsrs	r6, r3, #2
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 802382e:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8023830:	2a01      	cmp	r2, #1
 8023832:	d033      	beq.n	802389c <CRYP_AESCCM_Process+0x7c>
    hcryp->SizesSum = hcryp->Size;
 8023834:	65c3      	str	r3, [r0, #92]	; 0x5c
    hcryp->CrypHeaderCount = 0U;
 8023836:	2300      	movs	r3, #0
 8023838:	87a3      	strh	r3, [r4, #60]	; 0x3c
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 802383a:	6822      	ldr	r2, [r4, #0]
 802383c:	6813      	ldr	r3, [r2, #0]
 802383e:	497b      	ldr	r1, [pc, #492]	; (8023a2c <CRYP_AESCCM_Process+0x20c>)
 8023840:	400b      	ands	r3, r1
 8023842:	6013      	str	r3, [r2, #0]
    CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 8023844:	68a1      	ldr	r1, [r4, #8]
 8023846:	0020      	movs	r0, r4
 8023848:	f7ff fd70 	bl	802332c <CRYP_SetKey>
    hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.B0);
 802384c:	6a22      	ldr	r2, [r4, #32]
 802384e:	6823      	ldr	r3, [r4, #0]
 8023850:	6812      	ldr	r2, [r2, #0]
 8023852:	62da      	str	r2, [r3, #44]	; 0x2c
    hcryp->Instance->IVR2 = *(uint32_t *)(hcryp->Init.B0 + 1U);
 8023854:	6a22      	ldr	r2, [r4, #32]
 8023856:	6823      	ldr	r3, [r4, #0]
 8023858:	6852      	ldr	r2, [r2, #4]
 802385a:	629a      	str	r2, [r3, #40]	; 0x28
    hcryp->Instance->IVR1 = *(uint32_t *)(hcryp->Init.B0 + 2U);
 802385c:	6a22      	ldr	r2, [r4, #32]
 802385e:	6823      	ldr	r3, [r4, #0]
 8023860:	6892      	ldr	r2, [r2, #8]
 8023862:	625a      	str	r2, [r3, #36]	; 0x24
    hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.B0 + 3U);
 8023864:	6a22      	ldr	r2, [r4, #32]
 8023866:	6823      	ldr	r3, [r4, #0]
 8023868:	68d2      	ldr	r2, [r2, #12]
 802386a:	621a      	str	r2, [r3, #32]
    __HAL_CRYP_ENABLE(hcryp);
 802386c:	6822      	ldr	r2, [r4, #0]
 802386e:	6813      	ldr	r3, [r2, #0]
 8023870:	2101      	movs	r1, #1
 8023872:	430b      	orrs	r3, r1
 8023874:	6013      	str	r3, [r2, #0]
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 8023876:	0029      	movs	r1, r5
 8023878:	0020      	movs	r0, r4
 802387a:	f7ff fd90 	bl	802339e <CRYP_WaitOnCCFlag>
 802387e:	2800      	cmp	r0, #0
 8023880:	d018      	beq.n	80238b4 <CRYP_AESCCM_Process+0x94>
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8023882:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023884:	2210      	movs	r2, #16
 8023886:	4313      	orrs	r3, r2
 8023888:	6563      	str	r3, [r4, #84]	; 0x54
      hcryp->State = HAL_CRYP_STATE_READY;
 802388a:	2351      	movs	r3, #81	; 0x51
 802388c:	3a0f      	subs	r2, #15
 802388e:	54e2      	strb	r2, [r4, r3]
      __HAL_UNLOCK(hcryp);
 8023890:	3b01      	subs	r3, #1
 8023892:	2200      	movs	r2, #0
 8023894:	54e2      	strb	r2, [r4, r3]
      return HAL_ERROR;
 8023896:	2001      	movs	r0, #1
}
 8023898:	b005      	add	sp, #20
 802389a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (hcryp->KeyIVConfig == 1U)
 802389c:	6d82      	ldr	r2, [r0, #88]	; 0x58
 802389e:	2a01      	cmp	r2, #1
 80238a0:	d003      	beq.n	80238aa <CRYP_AESCCM_Process+0x8a>
      hcryp->KeyIVConfig = 1U;
 80238a2:	2201      	movs	r2, #1
 80238a4:	6582      	str	r2, [r0, #88]	; 0x58
      hcryp->SizesSum = hcryp->Size; /* Merely store payload length */
 80238a6:	65c3      	str	r3, [r0, #92]	; 0x5c
  if (DoKeyIVConfig == 1U)
 80238a8:	e7c5      	b.n	8023836 <CRYP_AESCCM_Process+0x16>
      hcryp->SizesSum += hcryp->Size; /* Compute message total payload length */
 80238aa:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 80238ac:	4694      	mov	ip, r2
 80238ae:	4463      	add	r3, ip
 80238b0:	65c3      	str	r3, [r0, #92]	; 0x5c
  if (DoKeyIVConfig == 1U)
 80238b2:	e01a      	b.n	80238ea <CRYP_AESCCM_Process+0xca>
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 80238b4:	6822      	ldr	r2, [r4, #0]
 80238b6:	6813      	ldr	r3, [r2, #0]
 80238b8:	2180      	movs	r1, #128	; 0x80
 80238ba:	430b      	orrs	r3, r1
 80238bc:	6013      	str	r3, [r2, #0]
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 80238be:	0029      	movs	r1, r5
 80238c0:	0020      	movs	r0, r4
 80238c2:	f7ff fd85 	bl	80233d0 <CRYP_GCMCCM_SetHeaderPhase>
 80238c6:	2800      	cmp	r0, #0
 80238c8:	d000      	beq.n	80238cc <CRYP_AESCCM_Process+0xac>
 80238ca:	e0ab      	b.n	8023a24 <CRYP_AESCCM_Process+0x204>
    hcryp->Phase = CRYP_PHASE_PROCESS;
 80238cc:	2302      	movs	r3, #2
 80238ce:	6463      	str	r3, [r4, #68]	; 0x44
    MODIFY_REG(hcryp->Instance->CR, AES_CR_GCMPH, CRYP_PHASE_PAYLOAD);
 80238d0:	6821      	ldr	r1, [r4, #0]
 80238d2:	680b      	ldr	r3, [r1, #0]
 80238d4:	4a55      	ldr	r2, [pc, #340]	; (8023a2c <CRYP_AESCCM_Process+0x20c>)
 80238d6:	401a      	ands	r2, r3
 80238d8:	2380      	movs	r3, #128	; 0x80
 80238da:	01db      	lsls	r3, r3, #7
 80238dc:	4313      	orrs	r3, r2
 80238de:	600b      	str	r3, [r1, #0]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, 0U);
 80238e0:	6822      	ldr	r2, [r4, #0]
 80238e2:	6813      	ldr	r3, [r2, #0]
 80238e4:	4952      	ldr	r1, [pc, #328]	; (8023a30 <CRYP_AESCCM_Process+0x210>)
 80238e6:	400b      	ands	r3, r1
 80238e8:	6013      	str	r3, [r2, #0]
  if ((hcryp->Size % 16U) != 0U)
 80238ea:	2342      	movs	r3, #66	; 0x42
 80238ec:	5ae3      	ldrh	r3, [r4, r3]
 80238ee:	071b      	lsls	r3, r3, #28
 80238f0:	d001      	beq.n	80238f6 <CRYP_AESCCM_Process+0xd6>
    wordsize = ((wordsize / 4U) * 4U) ;
 80238f2:	2303      	movs	r3, #3
 80238f4:	439e      	bics	r6, r3
  tickstart = HAL_GetTick();
 80238f6:	f7fe f957 	bl	8021ba8 <HAL_GetTick>
 80238fa:	0007      	movs	r7, r0
  incount = hcryp->CrypInCount;
 80238fc:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 80238fe:	b29b      	uxth	r3, r3
  outcount = hcryp->CrypOutCount;
 8023900:	2240      	movs	r2, #64	; 0x40
 8023902:	5aa2      	ldrh	r2, [r4, r2]
 8023904:	b292      	uxth	r2, r2
  while ((incount < wordsize) && (outcount < wordsize))
 8023906:	e004      	b.n	8023912 <CRYP_AESCCM_Process+0xf2>
    incount = hcryp->CrypInCount;
 8023908:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 802390a:	b29b      	uxth	r3, r3
    outcount = hcryp->CrypOutCount;
 802390c:	2240      	movs	r2, #64	; 0x40
 802390e:	5aa2      	ldrh	r2, [r4, r2]
 8023910:	b292      	uxth	r2, r2
  while ((incount < wordsize) && (outcount < wordsize))
 8023912:	429e      	cmp	r6, r3
 8023914:	d91e      	bls.n	8023954 <CRYP_AESCCM_Process+0x134>
 8023916:	4296      	cmp	r6, r2
 8023918:	d91c      	bls.n	8023954 <CRYP_AESCCM_Process+0x134>
    CRYP_AES_ProcessData(hcryp, Timeout);
 802391a:	0029      	movs	r1, r5
 802391c:	0020      	movs	r0, r4
 802391e:	f7ff febf 	bl	80236a0 <CRYP_AES_ProcessData>
    if (Timeout != HAL_MAX_DELAY)
 8023922:	1c6b      	adds	r3, r5, #1
 8023924:	d0f0      	beq.n	8023908 <CRYP_AESCCM_Process+0xe8>
      if (((HAL_GetTick() - tickstart) > Timeout) ||(Timeout == 0U))
 8023926:	f7fe f93f 	bl	8021ba8 <HAL_GetTick>
 802392a:	1bc0      	subs	r0, r0, r7
 802392c:	42a8      	cmp	r0, r5
 802392e:	d801      	bhi.n	8023934 <CRYP_AESCCM_Process+0x114>
 8023930:	2d00      	cmp	r5, #0
 8023932:	d1e9      	bne.n	8023908 <CRYP_AESCCM_Process+0xe8>
        __HAL_CRYP_DISABLE(hcryp);
 8023934:	6821      	ldr	r1, [r4, #0]
 8023936:	680b      	ldr	r3, [r1, #0]
 8023938:	2201      	movs	r2, #1
 802393a:	4393      	bics	r3, r2
 802393c:	600b      	str	r3, [r1, #0]
        hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 802393e:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023940:	2110      	movs	r1, #16
 8023942:	430b      	orrs	r3, r1
 8023944:	6563      	str	r3, [r4, #84]	; 0x54
        hcryp->State = HAL_CRYP_STATE_READY;
 8023946:	2351      	movs	r3, #81	; 0x51
 8023948:	54e2      	strb	r2, [r4, r3]
        __HAL_UNLOCK(hcryp);
 802394a:	3b01      	subs	r3, #1
 802394c:	2200      	movs	r2, #0
 802394e:	54e2      	strb	r2, [r4, r3]
        return HAL_ERROR;
 8023950:	2001      	movs	r0, #1
 8023952:	e7a1      	b.n	8023898 <CRYP_AESCCM_Process+0x78>
  if ((hcryp->Size % 16U) != 0U)
 8023954:	2342      	movs	r3, #66	; 0x42
 8023956:	5ae3      	ldrh	r3, [r4, r3]
 8023958:	071a      	lsls	r2, r3, #28
 802395a:	d065      	beq.n	8023a28 <CRYP_AESCCM_Process+0x208>
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 802395c:	091e      	lsrs	r6, r3, #4
 802395e:	3601      	adds	r6, #1
 8023960:	0136      	lsls	r6, r6, #4
 8023962:	1af7      	subs	r7, r6, r3
    if ((hcryp->Instance->CR & AES_CR_MODE) == CRYP_OPERATINGMODE_DECRYPT)
 8023964:	6820      	ldr	r0, [r4, #0]
 8023966:	6801      	ldr	r1, [r0, #0]
 8023968:	2218      	movs	r2, #24
 802396a:	400a      	ands	r2, r1
 802396c:	2a10      	cmp	r2, #16
 802396e:	d013      	beq.n	8023998 <CRYP_AESCCM_Process+0x178>
    if ((npblb % 4U) == 0U)
 8023970:	07ba      	lsls	r2, r7, #30
 8023972:	d118      	bne.n	80239a6 <CRYP_AESCCM_Process+0x186>
      lastwordsize = (16U - npblb) / 4U;
 8023974:	1b9e      	subs	r6, r3, r6
 8023976:	3610      	adds	r6, #16
 8023978:	08b6      	lsrs	r6, r6, #2
    for (loopcounter = 0U; loopcounter < lastwordsize; loopcounter ++)
 802397a:	2200      	movs	r2, #0
 802397c:	42b2      	cmp	r2, r6
 802397e:	d217      	bcs.n	80239b0 <CRYP_AESCCM_Process+0x190>
      hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 8023980:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8023982:	009b      	lsls	r3, r3, #2
 8023984:	6821      	ldr	r1, [r4, #0]
 8023986:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8023988:	58c3      	ldr	r3, [r0, r3]
 802398a:	608b      	str	r3, [r1, #8]
      hcryp->CrypInCount++;
 802398c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 802398e:	3301      	adds	r3, #1
 8023990:	b29b      	uxth	r3, r3
 8023992:	87e3      	strh	r3, [r4, #62]	; 0x3e
    for (loopcounter = 0U; loopcounter < lastwordsize; loopcounter ++)
 8023994:	3201      	adds	r2, #1
 8023996:	e7f1      	b.n	802397c <CRYP_AESCCM_Process+0x15c>
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20);
 8023998:	6802      	ldr	r2, [r0, #0]
 802399a:	4925      	ldr	r1, [pc, #148]	; (8023a30 <CRYP_AESCCM_Process+0x210>)
 802399c:	400a      	ands	r2, r1
 802399e:	0539      	lsls	r1, r7, #20
 80239a0:	430a      	orrs	r2, r1
 80239a2:	6002      	str	r2, [r0, #0]
 80239a4:	e7e4      	b.n	8023970 <CRYP_AESCCM_Process+0x150>
      lastwordsize = ((16U - npblb) / 4U) + 1U;
 80239a6:	1b9e      	subs	r6, r3, r6
 80239a8:	3610      	adds	r6, #16
 80239aa:	08b6      	lsrs	r6, r6, #2
 80239ac:	3601      	adds	r6, #1
 80239ae:	e7e4      	b.n	802397a <CRYP_AESCCM_Process+0x15a>
    while (loopcounter < 4U)
 80239b0:	2a03      	cmp	r2, #3
 80239b2:	d804      	bhi.n	80239be <CRYP_AESCCM_Process+0x19e>
      hcryp->Instance->DINR  = 0U;
 80239b4:	6823      	ldr	r3, [r4, #0]
 80239b6:	2100      	movs	r1, #0
 80239b8:	6099      	str	r1, [r3, #8]
      loopcounter++;
 80239ba:	3201      	adds	r2, #1
 80239bc:	e7f8      	b.n	80239b0 <CRYP_AESCCM_Process+0x190>
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 80239be:	0029      	movs	r1, r5
 80239c0:	0020      	movs	r0, r4
 80239c2:	f7ff fcec 	bl	802339e <CRYP_WaitOnCCFlag>
 80239c6:	2800      	cmp	r0, #0
 80239c8:	d106      	bne.n	80239d8 <CRYP_AESCCM_Process+0x1b8>
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 80239ca:	6822      	ldr	r2, [r4, #0]
 80239cc:	6813      	ldr	r3, [r2, #0]
 80239ce:	2180      	movs	r1, #128	; 0x80
 80239d0:	430b      	orrs	r3, r1
 80239d2:	6013      	str	r3, [r2, #0]
    for (loopcounter = 0U; loopcounter < 4U; loopcounter++)
 80239d4:	2300      	movs	r3, #0
 80239d6:	e011      	b.n	80239fc <CRYP_AESCCM_Process+0x1dc>
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 80239d8:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80239da:	2210      	movs	r2, #16
 80239dc:	4313      	orrs	r3, r2
 80239de:	6563      	str	r3, [r4, #84]	; 0x54
      hcryp->State = HAL_CRYP_STATE_READY;
 80239e0:	2351      	movs	r3, #81	; 0x51
 80239e2:	3a0f      	subs	r2, #15
 80239e4:	54e2      	strb	r2, [r4, r3]
      __HAL_UNLOCK(hcryp);
 80239e6:	3b01      	subs	r3, #1
 80239e8:	2200      	movs	r2, #0
 80239ea:	54e2      	strb	r2, [r4, r3]
      return HAL_ERROR;
 80239ec:	2001      	movs	r0, #1
 80239ee:	e753      	b.n	8023898 <CRYP_AESCCM_Process+0x78>
      temp[loopcounter] = hcryp->Instance->DOUTR;
 80239f0:	6822      	ldr	r2, [r4, #0]
 80239f2:	68d1      	ldr	r1, [r2, #12]
 80239f4:	009a      	lsls	r2, r3, #2
 80239f6:	466d      	mov	r5, sp
 80239f8:	5151      	str	r1, [r2, r5]
    for (loopcounter = 0U; loopcounter < 4U; loopcounter++)
 80239fa:	3301      	adds	r3, #1
 80239fc:	2b03      	cmp	r3, #3
 80239fe:	d9f7      	bls.n	80239f0 <CRYP_AESCCM_Process+0x1d0>
    for (loopcounter = 0U; loopcounter<lastwordsize; loopcounter++)
 8023a00:	2200      	movs	r2, #0
 8023a02:	e00c      	b.n	8023a1e <CRYP_AESCCM_Process+0x1fe>
      *(uint32_t *)(hcryp->pCrypOutBuffPtr + hcryp->CrypOutCount) = temp[loopcounter];
 8023a04:	2140      	movs	r1, #64	; 0x40
 8023a06:	5a63      	ldrh	r3, [r4, r1]
 8023a08:	009b      	lsls	r3, r3, #2
 8023a0a:	0095      	lsls	r5, r2, #2
 8023a0c:	466f      	mov	r7, sp
 8023a0e:	59ed      	ldr	r5, [r5, r7]
 8023a10:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 8023a12:	50fd      	str	r5, [r7, r3]
      hcryp->CrypOutCount++;
 8023a14:	5a63      	ldrh	r3, [r4, r1]
 8023a16:	3301      	adds	r3, #1
 8023a18:	b29b      	uxth	r3, r3
 8023a1a:	5263      	strh	r3, [r4, r1]
    for (loopcounter = 0U; loopcounter<lastwordsize; loopcounter++)
 8023a1c:	3201      	adds	r2, #1
 8023a1e:	42b2      	cmp	r2, r6
 8023a20:	d3f0      	bcc.n	8023a04 <CRYP_AESCCM_Process+0x1e4>
 8023a22:	e739      	b.n	8023898 <CRYP_AESCCM_Process+0x78>
      return HAL_ERROR;
 8023a24:	2001      	movs	r0, #1
 8023a26:	e737      	b.n	8023898 <CRYP_AESCCM_Process+0x78>
  return HAL_OK;
 8023a28:	2000      	movs	r0, #0
 8023a2a:	e735      	b.n	8023898 <CRYP_AESCCM_Process+0x78>
 8023a2c:	ffff9fff 	.word	0xffff9fff
 8023a30:	ff0fffff 	.word	0xff0fffff

08023a34 <CRYP_AES_Decrypt>:
{
 8023a34:	b570      	push	{r4, r5, r6, lr}
 8023a36:	0004      	movs	r4, r0
 8023a38:	000d      	movs	r5, r1
  if ((hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE) || (hcryp->Init.KeyIVConfigSkip == CRYP_IVCONFIG_ONCE))
 8023a3a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8023a3c:	2b01      	cmp	r3, #1
 8023a3e:	d02c      	beq.n	8023a9a <CRYP_AES_Decrypt+0x66>
 8023a40:	2b04      	cmp	r3, #4
 8023a42:	d02a      	beq.n	8023a9a <CRYP_AES_Decrypt+0x66>
    if (hcryp->Init.Algorithm != CRYP_AES_CTR)   /*ECB or CBC*/
 8023a44:	6963      	ldr	r3, [r4, #20]
 8023a46:	2b40      	cmp	r3, #64	; 0x40
 8023a48:	d100      	bne.n	8023a4c <CRYP_AES_Decrypt+0x18>
 8023a4a:	e092      	b.n	8023b72 <CRYP_AES_Decrypt+0x13e>
      if (hcryp->AutoKeyDerivation == DISABLE)/*Mode 2 Key preparation*/
 8023a4c:	2330      	movs	r3, #48	; 0x30
 8023a4e:	5ce3      	ldrb	r3, [r4, r3]
 8023a50:	2b00      	cmp	r3, #0
 8023a52:	d165      	bne.n	8023b20 <CRYP_AES_Decrypt+0xec>
        MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_KEYDERIVATION);
 8023a54:	6822      	ldr	r2, [r4, #0]
 8023a56:	6813      	ldr	r3, [r2, #0]
 8023a58:	2118      	movs	r1, #24
 8023a5a:	438b      	bics	r3, r1
 8023a5c:	3910      	subs	r1, #16
 8023a5e:	430b      	orrs	r3, r1
 8023a60:	6013      	str	r3, [r2, #0]
        CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 8023a62:	68a1      	ldr	r1, [r4, #8]
 8023a64:	0020      	movs	r0, r4
 8023a66:	f7ff fc61 	bl	802332c <CRYP_SetKey>
        __HAL_CRYP_ENABLE(hcryp);
 8023a6a:	6822      	ldr	r2, [r4, #0]
 8023a6c:	6813      	ldr	r3, [r2, #0]
 8023a6e:	2101      	movs	r1, #1
 8023a70:	430b      	orrs	r3, r1
 8023a72:	6013      	str	r3, [r2, #0]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 8023a74:	0029      	movs	r1, r5
 8023a76:	0020      	movs	r0, r4
 8023a78:	f7ff fc91 	bl	802339e <CRYP_WaitOnCCFlag>
 8023a7c:	2800      	cmp	r0, #0
 8023a7e:	d13f      	bne.n	8023b00 <CRYP_AES_Decrypt+0xcc>
        __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8023a80:	6822      	ldr	r2, [r4, #0]
 8023a82:	6813      	ldr	r3, [r2, #0]
 8023a84:	2180      	movs	r1, #128	; 0x80
 8023a86:	430b      	orrs	r3, r1
 8023a88:	6013      	str	r3, [r2, #0]
        MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_DECRYPT);
 8023a8a:	6822      	ldr	r2, [r4, #0]
 8023a8c:	6813      	ldr	r3, [r2, #0]
 8023a8e:	3968      	subs	r1, #104	; 0x68
 8023a90:	438b      	bics	r3, r1
 8023a92:	3908      	subs	r1, #8
 8023a94:	430b      	orrs	r3, r1
 8023a96:	6013      	str	r3, [r2, #0]
 8023a98:	e04b      	b.n	8023b32 <CRYP_AES_Decrypt+0xfe>
    if (hcryp->KeyIVConfig == 1U)
 8023a9a:	6da2      	ldr	r2, [r4, #88]	; 0x58
 8023a9c:	2a01      	cmp	r2, #1
 8023a9e:	d002      	beq.n	8023aa6 <CRYP_AES_Decrypt+0x72>
      hcryp->KeyIVConfig = 1U;
 8023aa0:	2301      	movs	r3, #1
 8023aa2:	65a3      	str	r3, [r4, #88]	; 0x58
  if (DoKeyIVConfig == 1U)
 8023aa4:	e7ce      	b.n	8023a44 <CRYP_AES_Decrypt+0x10>
    if (hcryp->Init.KeyIVConfigSkip == CRYP_IVCONFIG_ONCE)
 8023aa6:	2b04      	cmp	r3, #4
 8023aa8:	d156      	bne.n	8023b58 <CRYP_AES_Decrypt+0x124>
      if (hcryp->Init.Algorithm != CRYP_AES_CTR)   /*ECB or CBC*/
 8023aaa:	6963      	ldr	r3, [r4, #20]
 8023aac:	2b40      	cmp	r3, #64	; 0x40
 8023aae:	d100      	bne.n	8023ab2 <CRYP_AES_Decrypt+0x7e>
 8023ab0:	e07e      	b.n	8023bb0 <CRYP_AES_Decrypt+0x17c>
        if (hcryp->AutoKeyDerivation == DISABLE)/*Mode 2 Key preparation*/
 8023ab2:	2330      	movs	r3, #48	; 0x30
 8023ab4:	5ce3      	ldrb	r3, [r4, r3]
 8023ab6:	2b00      	cmp	r3, #0
 8023ab8:	d170      	bne.n	8023b9c <CRYP_AES_Decrypt+0x168>
          MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_KEYDERIVATION);
 8023aba:	6822      	ldr	r2, [r4, #0]
 8023abc:	6813      	ldr	r3, [r2, #0]
 8023abe:	2118      	movs	r1, #24
 8023ac0:	438b      	bics	r3, r1
 8023ac2:	3910      	subs	r1, #16
 8023ac4:	430b      	orrs	r3, r1
 8023ac6:	6013      	str	r3, [r2, #0]
          CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 8023ac8:	68a1      	ldr	r1, [r4, #8]
 8023aca:	0020      	movs	r0, r4
 8023acc:	f7ff fc2e 	bl	802332c <CRYP_SetKey>
          __HAL_CRYP_ENABLE(hcryp);
 8023ad0:	6822      	ldr	r2, [r4, #0]
 8023ad2:	6813      	ldr	r3, [r2, #0]
 8023ad4:	2101      	movs	r1, #1
 8023ad6:	430b      	orrs	r3, r1
 8023ad8:	6013      	str	r3, [r2, #0]
          if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 8023ada:	0029      	movs	r1, r5
 8023adc:	0020      	movs	r0, r4
 8023ade:	f7ff fc5e 	bl	802339e <CRYP_WaitOnCCFlag>
 8023ae2:	2800      	cmp	r0, #0
 8023ae4:	d14a      	bne.n	8023b7c <CRYP_AES_Decrypt+0x148>
          __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8023ae6:	6822      	ldr	r2, [r4, #0]
 8023ae8:	6813      	ldr	r3, [r2, #0]
 8023aea:	2180      	movs	r1, #128	; 0x80
 8023aec:	430b      	orrs	r3, r1
 8023aee:	6013      	str	r3, [r2, #0]
          MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_DECRYPT);
 8023af0:	6822      	ldr	r2, [r4, #0]
 8023af2:	6813      	ldr	r3, [r2, #0]
 8023af4:	3968      	subs	r1, #104	; 0x68
 8023af6:	438b      	bics	r3, r1
 8023af8:	3908      	subs	r1, #8
 8023afa:	430b      	orrs	r3, r1
 8023afc:	6013      	str	r3, [r2, #0]
 8023afe:	e02b      	b.n	8023b58 <CRYP_AES_Decrypt+0x124>
          __HAL_CRYP_DISABLE(hcryp);
 8023b00:	6821      	ldr	r1, [r4, #0]
 8023b02:	680b      	ldr	r3, [r1, #0]
 8023b04:	2201      	movs	r2, #1
 8023b06:	4393      	bics	r3, r2
 8023b08:	600b      	str	r3, [r1, #0]
          hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8023b0a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023b0c:	2110      	movs	r1, #16
 8023b0e:	430b      	orrs	r3, r1
 8023b10:	6563      	str	r3, [r4, #84]	; 0x54
          hcryp->State = HAL_CRYP_STATE_READY;
 8023b12:	2351      	movs	r3, #81	; 0x51
 8023b14:	54e2      	strb	r2, [r4, r3]
          __HAL_UNLOCK(hcryp);
 8023b16:	3b01      	subs	r3, #1
 8023b18:	2200      	movs	r2, #0
 8023b1a:	54e2      	strb	r2, [r4, r3]
          return HAL_ERROR;
 8023b1c:	2001      	movs	r0, #1
 8023b1e:	e064      	b.n	8023bea <CRYP_AES_Decrypt+0x1b6>
        CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 8023b20:	68a1      	ldr	r1, [r4, #8]
 8023b22:	0020      	movs	r0, r4
 8023b24:	f7ff fc02 	bl	802332c <CRYP_SetKey>
        MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_KEYDERIVATION_DECRYPT);
 8023b28:	6822      	ldr	r2, [r4, #0]
 8023b2a:	6813      	ldr	r3, [r2, #0]
 8023b2c:	2118      	movs	r1, #24
 8023b2e:	430b      	orrs	r3, r1
 8023b30:	6013      	str	r3, [r2, #0]
    if (hcryp->Init.Algorithm != CRYP_AES_ECB)
 8023b32:	6963      	ldr	r3, [r4, #20]
 8023b34:	2b00      	cmp	r3, #0
 8023b36:	d00f      	beq.n	8023b58 <CRYP_AES_Decrypt+0x124>
      hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.pInitVect);
 8023b38:	6922      	ldr	r2, [r4, #16]
 8023b3a:	6823      	ldr	r3, [r4, #0]
 8023b3c:	6812      	ldr	r2, [r2, #0]
 8023b3e:	62da      	str	r2, [r3, #44]	; 0x2c
      hcryp->Instance->IVR2 = *(uint32_t *)(hcryp->Init.pInitVect + 1U);
 8023b40:	6922      	ldr	r2, [r4, #16]
 8023b42:	6823      	ldr	r3, [r4, #0]
 8023b44:	6852      	ldr	r2, [r2, #4]
 8023b46:	629a      	str	r2, [r3, #40]	; 0x28
      hcryp->Instance->IVR1 = *(uint32_t *)(hcryp->Init.pInitVect + 2U);
 8023b48:	6922      	ldr	r2, [r4, #16]
 8023b4a:	6823      	ldr	r3, [r4, #0]
 8023b4c:	6892      	ldr	r2, [r2, #8]
 8023b4e:	625a      	str	r2, [r3, #36]	; 0x24
      hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.pInitVect + 3U);
 8023b50:	6922      	ldr	r2, [r4, #16]
 8023b52:	6823      	ldr	r3, [r4, #0]
 8023b54:	68d2      	ldr	r2, [r2, #12]
 8023b56:	621a      	str	r2, [r3, #32]
  hcryp->Phase = CRYP_PHASE_PROCESS;
 8023b58:	2302      	movs	r3, #2
 8023b5a:	6463      	str	r3, [r4, #68]	; 0x44
  __HAL_CRYP_ENABLE(hcryp);
 8023b5c:	6822      	ldr	r2, [r4, #0]
 8023b5e:	6813      	ldr	r3, [r2, #0]
 8023b60:	2101      	movs	r1, #1
 8023b62:	430b      	orrs	r3, r1
 8023b64:	6013      	str	r3, [r2, #0]
  incount = hcryp->CrypInCount;
 8023b66:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8023b68:	b292      	uxth	r2, r2
  outcount = hcryp->CrypOutCount;
 8023b6a:	2340      	movs	r3, #64	; 0x40
 8023b6c:	5ae0      	ldrh	r0, [r4, r3]
 8023b6e:	b280      	uxth	r0, r0
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 8023b70:	e02c      	b.n	8023bcc <CRYP_AES_Decrypt+0x198>
      CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 8023b72:	68a1      	ldr	r1, [r4, #8]
 8023b74:	0020      	movs	r0, r4
 8023b76:	f7ff fbd9 	bl	802332c <CRYP_SetKey>
 8023b7a:	e7da      	b.n	8023b32 <CRYP_AES_Decrypt+0xfe>
            __HAL_CRYP_DISABLE(hcryp);
 8023b7c:	6821      	ldr	r1, [r4, #0]
 8023b7e:	680b      	ldr	r3, [r1, #0]
 8023b80:	2201      	movs	r2, #1
 8023b82:	4393      	bics	r3, r2
 8023b84:	600b      	str	r3, [r1, #0]
            hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8023b86:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023b88:	2110      	movs	r1, #16
 8023b8a:	430b      	orrs	r3, r1
 8023b8c:	6563      	str	r3, [r4, #84]	; 0x54
            hcryp->State = HAL_CRYP_STATE_READY;
 8023b8e:	2351      	movs	r3, #81	; 0x51
 8023b90:	54e2      	strb	r2, [r4, r3]
            __HAL_UNLOCK(hcryp);
 8023b92:	3b01      	subs	r3, #1
 8023b94:	2200      	movs	r2, #0
 8023b96:	54e2      	strb	r2, [r4, r3]
            return HAL_ERROR;
 8023b98:	2001      	movs	r0, #1
 8023b9a:	e026      	b.n	8023bea <CRYP_AES_Decrypt+0x1b6>
          CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 8023b9c:	68a1      	ldr	r1, [r4, #8]
 8023b9e:	0020      	movs	r0, r4
 8023ba0:	f7ff fbc4 	bl	802332c <CRYP_SetKey>
          MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_KEYDERIVATION_DECRYPT);
 8023ba4:	6822      	ldr	r2, [r4, #0]
 8023ba6:	6813      	ldr	r3, [r2, #0]
 8023ba8:	2118      	movs	r1, #24
 8023baa:	430b      	orrs	r3, r1
 8023bac:	6013      	str	r3, [r2, #0]
 8023bae:	e7d3      	b.n	8023b58 <CRYP_AES_Decrypt+0x124>
        CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 8023bb0:	68a1      	ldr	r1, [r4, #8]
 8023bb2:	0020      	movs	r0, r4
 8023bb4:	f7ff fbba 	bl	802332c <CRYP_SetKey>
 8023bb8:	e7ce      	b.n	8023b58 <CRYP_AES_Decrypt+0x124>
    CRYP_AES_ProcessData(hcryp, Timeout);
 8023bba:	0029      	movs	r1, r5
 8023bbc:	0020      	movs	r0, r4
 8023bbe:	f7ff fd6f 	bl	80236a0 <CRYP_AES_ProcessData>
    incount = hcryp->CrypInCount;
 8023bc2:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8023bc4:	b292      	uxth	r2, r2
    outcount = hcryp->CrypOutCount;
 8023bc6:	2340      	movs	r3, #64	; 0x40
 8023bc8:	5ae0      	ldrh	r0, [r4, r3]
 8023bca:	b280      	uxth	r0, r0
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 8023bcc:	2342      	movs	r3, #66	; 0x42
 8023bce:	5ae3      	ldrh	r3, [r4, r3]
 8023bd0:	089b      	lsrs	r3, r3, #2
 8023bd2:	4293      	cmp	r3, r2
 8023bd4:	d901      	bls.n	8023bda <CRYP_AES_Decrypt+0x1a6>
 8023bd6:	4283      	cmp	r3, r0
 8023bd8:	d8ef      	bhi.n	8023bba <CRYP_AES_Decrypt+0x186>
  __HAL_CRYP_DISABLE(hcryp);
 8023bda:	6821      	ldr	r1, [r4, #0]
 8023bdc:	680b      	ldr	r3, [r1, #0]
 8023bde:	2201      	movs	r2, #1
 8023be0:	4393      	bics	r3, r2
 8023be2:	600b      	str	r3, [r1, #0]
  hcryp->State = HAL_CRYP_STATE_READY;
 8023be4:	2351      	movs	r3, #81	; 0x51
 8023be6:	54e2      	strb	r2, [r4, r3]
  return HAL_OK;
 8023be8:	2000      	movs	r0, #0
}
 8023bea:	bd70      	pop	{r4, r5, r6, pc}

08023bec <CRYP_AESGCM_Process>:
{
 8023bec:	b5f0      	push	{r4, r5, r6, r7, lr}
 8023bee:	b085      	sub	sp, #20
 8023bf0:	0004      	movs	r4, r0
 8023bf2:	000d      	movs	r5, r1
  uint32_t wordsize = ((uint32_t)hcryp->Size / 4U) ;
 8023bf4:	2342      	movs	r3, #66	; 0x42
 8023bf6:	5ac3      	ldrh	r3, [r0, r3]
 8023bf8:	089e      	lsrs	r6, r3, #2
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 8023bfa:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8023bfc:	2a01      	cmp	r2, #1
 8023bfe:	d033      	beq.n	8023c68 <CRYP_AESGCM_Process+0x7c>
    hcryp->SizesSum = hcryp->Size;
 8023c00:	65c3      	str	r3, [r0, #92]	; 0x5c
    hcryp->CrypHeaderCount = 0U;
 8023c02:	2300      	movs	r3, #0
 8023c04:	87a3      	strh	r3, [r4, #60]	; 0x3c
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 8023c06:	6822      	ldr	r2, [r4, #0]
 8023c08:	6813      	ldr	r3, [r2, #0]
 8023c0a:	497a      	ldr	r1, [pc, #488]	; (8023df4 <CRYP_AESGCM_Process+0x208>)
 8023c0c:	400b      	ands	r3, r1
 8023c0e:	6013      	str	r3, [r2, #0]
    CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 8023c10:	68a1      	ldr	r1, [r4, #8]
 8023c12:	0020      	movs	r0, r4
 8023c14:	f7ff fb8a 	bl	802332c <CRYP_SetKey>
    hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.pInitVect);
 8023c18:	6922      	ldr	r2, [r4, #16]
 8023c1a:	6823      	ldr	r3, [r4, #0]
 8023c1c:	6812      	ldr	r2, [r2, #0]
 8023c1e:	62da      	str	r2, [r3, #44]	; 0x2c
    hcryp->Instance->IVR2 = *(uint32_t *)(hcryp->Init.pInitVect + 1U);
 8023c20:	6922      	ldr	r2, [r4, #16]
 8023c22:	6823      	ldr	r3, [r4, #0]
 8023c24:	6852      	ldr	r2, [r2, #4]
 8023c26:	629a      	str	r2, [r3, #40]	; 0x28
    hcryp->Instance->IVR1 = *(uint32_t *)(hcryp->Init.pInitVect + 2U);
 8023c28:	6922      	ldr	r2, [r4, #16]
 8023c2a:	6823      	ldr	r3, [r4, #0]
 8023c2c:	6892      	ldr	r2, [r2, #8]
 8023c2e:	625a      	str	r2, [r3, #36]	; 0x24
    hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.pInitVect + 3U);
 8023c30:	6922      	ldr	r2, [r4, #16]
 8023c32:	6823      	ldr	r3, [r4, #0]
 8023c34:	68d2      	ldr	r2, [r2, #12]
 8023c36:	621a      	str	r2, [r3, #32]
    __HAL_CRYP_ENABLE(hcryp);
 8023c38:	6822      	ldr	r2, [r4, #0]
 8023c3a:	6813      	ldr	r3, [r2, #0]
 8023c3c:	2101      	movs	r1, #1
 8023c3e:	430b      	orrs	r3, r1
 8023c40:	6013      	str	r3, [r2, #0]
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 8023c42:	0029      	movs	r1, r5
 8023c44:	0020      	movs	r0, r4
 8023c46:	f7ff fbaa 	bl	802339e <CRYP_WaitOnCCFlag>
 8023c4a:	2800      	cmp	r0, #0
 8023c4c:	d018      	beq.n	8023c80 <CRYP_AESGCM_Process+0x94>
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8023c4e:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023c50:	2210      	movs	r2, #16
 8023c52:	4313      	orrs	r3, r2
 8023c54:	6563      	str	r3, [r4, #84]	; 0x54
      hcryp->State = HAL_CRYP_STATE_READY;
 8023c56:	2351      	movs	r3, #81	; 0x51
 8023c58:	3a0f      	subs	r2, #15
 8023c5a:	54e2      	strb	r2, [r4, r3]
      __HAL_UNLOCK(hcryp);
 8023c5c:	3b01      	subs	r3, #1
 8023c5e:	2200      	movs	r2, #0
 8023c60:	54e2      	strb	r2, [r4, r3]
      return HAL_ERROR;
 8023c62:	2001      	movs	r0, #1
}
 8023c64:	b005      	add	sp, #20
 8023c66:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (hcryp->KeyIVConfig == 1U)
 8023c68:	6d82      	ldr	r2, [r0, #88]	; 0x58
 8023c6a:	2a01      	cmp	r2, #1
 8023c6c:	d003      	beq.n	8023c76 <CRYP_AESGCM_Process+0x8a>
      hcryp->KeyIVConfig = 1U;
 8023c6e:	2201      	movs	r2, #1
 8023c70:	6582      	str	r2, [r0, #88]	; 0x58
      hcryp->SizesSum = hcryp->Size; /* Merely store payload length */
 8023c72:	65c3      	str	r3, [r0, #92]	; 0x5c
  if (DoKeyIVConfig == 1U)
 8023c74:	e7c5      	b.n	8023c02 <CRYP_AESGCM_Process+0x16>
      hcryp->SizesSum += hcryp->Size; /* Compute message total payload length */
 8023c76:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 8023c78:	4694      	mov	ip, r2
 8023c7a:	4463      	add	r3, ip
 8023c7c:	65c3      	str	r3, [r0, #92]	; 0x5c
  if (DoKeyIVConfig == 1U)
 8023c7e:	e01a      	b.n	8023cb6 <CRYP_AESGCM_Process+0xca>
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8023c80:	6822      	ldr	r2, [r4, #0]
 8023c82:	6813      	ldr	r3, [r2, #0]
 8023c84:	2180      	movs	r1, #128	; 0x80
 8023c86:	430b      	orrs	r3, r1
 8023c88:	6013      	str	r3, [r2, #0]
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 8023c8a:	0029      	movs	r1, r5
 8023c8c:	0020      	movs	r0, r4
 8023c8e:	f7ff fb9f 	bl	80233d0 <CRYP_GCMCCM_SetHeaderPhase>
 8023c92:	2800      	cmp	r0, #0
 8023c94:	d000      	beq.n	8023c98 <CRYP_AESGCM_Process+0xac>
 8023c96:	e0a8      	b.n	8023dea <CRYP_AESGCM_Process+0x1fe>
    hcryp->Phase = CRYP_PHASE_PROCESS;
 8023c98:	2302      	movs	r3, #2
 8023c9a:	6463      	str	r3, [r4, #68]	; 0x44
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_PAYLOAD);
 8023c9c:	6821      	ldr	r1, [r4, #0]
 8023c9e:	680b      	ldr	r3, [r1, #0]
 8023ca0:	4a54      	ldr	r2, [pc, #336]	; (8023df4 <CRYP_AESGCM_Process+0x208>)
 8023ca2:	401a      	ands	r2, r3
 8023ca4:	2380      	movs	r3, #128	; 0x80
 8023ca6:	01db      	lsls	r3, r3, #7
 8023ca8:	4313      	orrs	r3, r2
 8023caa:	600b      	str	r3, [r1, #0]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, 0U);
 8023cac:	6822      	ldr	r2, [r4, #0]
 8023cae:	6813      	ldr	r3, [r2, #0]
 8023cb0:	4951      	ldr	r1, [pc, #324]	; (8023df8 <CRYP_AESGCM_Process+0x20c>)
 8023cb2:	400b      	ands	r3, r1
 8023cb4:	6013      	str	r3, [r2, #0]
  if ((hcryp->Size % 16U) != 0U)
 8023cb6:	2342      	movs	r3, #66	; 0x42
 8023cb8:	5ae3      	ldrh	r3, [r4, r3]
 8023cba:	071b      	lsls	r3, r3, #28
 8023cbc:	d001      	beq.n	8023cc2 <CRYP_AESGCM_Process+0xd6>
    wordsize = ((wordsize / 4U) * 4U) ;
 8023cbe:	2303      	movs	r3, #3
 8023cc0:	439e      	bics	r6, r3
  tickstart = HAL_GetTick();
 8023cc2:	f7fd ff71 	bl	8021ba8 <HAL_GetTick>
 8023cc6:	0007      	movs	r7, r0
  incount = hcryp->CrypInCount;
 8023cc8:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8023cca:	b29b      	uxth	r3, r3
  outcount = hcryp->CrypOutCount;
 8023ccc:	2240      	movs	r2, #64	; 0x40
 8023cce:	5aa2      	ldrh	r2, [r4, r2]
 8023cd0:	b292      	uxth	r2, r2
  while ((incount < wordsize) && (outcount < wordsize))
 8023cd2:	e004      	b.n	8023cde <CRYP_AESGCM_Process+0xf2>
    incount = hcryp->CrypInCount;
 8023cd4:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8023cd6:	b29b      	uxth	r3, r3
    outcount = hcryp->CrypOutCount;
 8023cd8:	2240      	movs	r2, #64	; 0x40
 8023cda:	5aa2      	ldrh	r2, [r4, r2]
 8023cdc:	b292      	uxth	r2, r2
  while ((incount < wordsize) && (outcount < wordsize))
 8023cde:	429e      	cmp	r6, r3
 8023ce0:	d91e      	bls.n	8023d20 <CRYP_AESGCM_Process+0x134>
 8023ce2:	4296      	cmp	r6, r2
 8023ce4:	d91c      	bls.n	8023d20 <CRYP_AESGCM_Process+0x134>
    CRYP_AES_ProcessData(hcryp, Timeout);
 8023ce6:	0029      	movs	r1, r5
 8023ce8:	0020      	movs	r0, r4
 8023cea:	f7ff fcd9 	bl	80236a0 <CRYP_AES_ProcessData>
    if (Timeout != HAL_MAX_DELAY)
 8023cee:	1c6b      	adds	r3, r5, #1
 8023cf0:	d0f0      	beq.n	8023cd4 <CRYP_AESGCM_Process+0xe8>
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8023cf2:	f7fd ff59 	bl	8021ba8 <HAL_GetTick>
 8023cf6:	1bc0      	subs	r0, r0, r7
 8023cf8:	42a8      	cmp	r0, r5
 8023cfa:	d801      	bhi.n	8023d00 <CRYP_AESGCM_Process+0x114>
 8023cfc:	2d00      	cmp	r5, #0
 8023cfe:	d1e9      	bne.n	8023cd4 <CRYP_AESGCM_Process+0xe8>
        __HAL_CRYP_DISABLE(hcryp);
 8023d00:	6821      	ldr	r1, [r4, #0]
 8023d02:	680b      	ldr	r3, [r1, #0]
 8023d04:	2201      	movs	r2, #1
 8023d06:	4393      	bics	r3, r2
 8023d08:	600b      	str	r3, [r1, #0]
        hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8023d0a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023d0c:	2110      	movs	r1, #16
 8023d0e:	430b      	orrs	r3, r1
 8023d10:	6563      	str	r3, [r4, #84]	; 0x54
        hcryp->State = HAL_CRYP_STATE_READY;
 8023d12:	2351      	movs	r3, #81	; 0x51
 8023d14:	54e2      	strb	r2, [r4, r3]
        __HAL_UNLOCK(hcryp);
 8023d16:	3b01      	subs	r3, #1
 8023d18:	2200      	movs	r2, #0
 8023d1a:	54e2      	strb	r2, [r4, r3]
        return HAL_ERROR;
 8023d1c:	2001      	movs	r0, #1
 8023d1e:	e7a1      	b.n	8023c64 <CRYP_AESGCM_Process+0x78>
  if ((hcryp->Size % 16U) != 0U)
 8023d20:	2342      	movs	r3, #66	; 0x42
 8023d22:	5ae3      	ldrh	r3, [r4, r3]
 8023d24:	071a      	lsls	r2, r3, #28
 8023d26:	d062      	beq.n	8023dee <CRYP_AESGCM_Process+0x202>
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 8023d28:	091e      	lsrs	r6, r3, #4
 8023d2a:	3601      	adds	r6, #1
 8023d2c:	0136      	lsls	r6, r6, #4
 8023d2e:	1af0      	subs	r0, r6, r3
    if ((hcryp->Instance->CR & AES_CR_MODE) == CRYP_OPERATINGMODE_ENCRYPT)
 8023d30:	6822      	ldr	r2, [r4, #0]
 8023d32:	6811      	ldr	r1, [r2, #0]
 8023d34:	2718      	movs	r7, #24
 8023d36:	420f      	tst	r7, r1
 8023d38:	d105      	bne.n	8023d46 <CRYP_AESGCM_Process+0x15a>
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20U);
 8023d3a:	6811      	ldr	r1, [r2, #0]
 8023d3c:	4f2e      	ldr	r7, [pc, #184]	; (8023df8 <CRYP_AESGCM_Process+0x20c>)
 8023d3e:	4039      	ands	r1, r7
 8023d40:	0507      	lsls	r7, r0, #20
 8023d42:	4339      	orrs	r1, r7
 8023d44:	6011      	str	r1, [r2, #0]
    if ((npblb % 4U) == 0U)
 8023d46:	0782      	lsls	r2, r0, #30
 8023d48:	d104      	bne.n	8023d54 <CRYP_AESGCM_Process+0x168>
      lastwordsize = (16U - npblb) / 4U;
 8023d4a:	1b9e      	subs	r6, r3, r6
 8023d4c:	3610      	adds	r6, #16
 8023d4e:	08b6      	lsrs	r6, r6, #2
    for (index = 0U; index < lastwordsize; index ++)
 8023d50:	2200      	movs	r2, #0
 8023d52:	e00f      	b.n	8023d74 <CRYP_AESGCM_Process+0x188>
      lastwordsize = ((16U - npblb) / 4U) + 1U;
 8023d54:	1b9e      	subs	r6, r3, r6
 8023d56:	3610      	adds	r6, #16
 8023d58:	08b6      	lsrs	r6, r6, #2
 8023d5a:	3601      	adds	r6, #1
 8023d5c:	e7f8      	b.n	8023d50 <CRYP_AESGCM_Process+0x164>
      hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 8023d5e:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8023d60:	009b      	lsls	r3, r3, #2
 8023d62:	6821      	ldr	r1, [r4, #0]
 8023d64:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8023d66:	58c3      	ldr	r3, [r0, r3]
 8023d68:	608b      	str	r3, [r1, #8]
      hcryp->CrypInCount++;
 8023d6a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8023d6c:	3301      	adds	r3, #1
 8023d6e:	b29b      	uxth	r3, r3
 8023d70:	87e3      	strh	r3, [r4, #62]	; 0x3e
    for (index = 0U; index < lastwordsize; index ++)
 8023d72:	3201      	adds	r2, #1
 8023d74:	42b2      	cmp	r2, r6
 8023d76:	d3f2      	bcc.n	8023d5e <CRYP_AESGCM_Process+0x172>
 8023d78:	e003      	b.n	8023d82 <CRYP_AESGCM_Process+0x196>
      hcryp->Instance->DINR  = 0U;
 8023d7a:	6823      	ldr	r3, [r4, #0]
 8023d7c:	2100      	movs	r1, #0
 8023d7e:	6099      	str	r1, [r3, #8]
      index++;
 8023d80:	3201      	adds	r2, #1
    while (index < 4U)
 8023d82:	2a03      	cmp	r2, #3
 8023d84:	d9f9      	bls.n	8023d7a <CRYP_AESGCM_Process+0x18e>
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 8023d86:	0029      	movs	r1, r5
 8023d88:	0020      	movs	r0, r4
 8023d8a:	f7ff fb08 	bl	802339e <CRYP_WaitOnCCFlag>
 8023d8e:	2800      	cmp	r0, #0
 8023d90:	d10e      	bne.n	8023db0 <CRYP_AESGCM_Process+0x1c4>
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 8023d92:	6822      	ldr	r2, [r4, #0]
 8023d94:	6813      	ldr	r3, [r2, #0]
 8023d96:	2180      	movs	r1, #128	; 0x80
 8023d98:	430b      	orrs	r3, r1
 8023d9a:	6013      	str	r3, [r2, #0]
    for (index = 0U; index < 4U; index++)
 8023d9c:	2300      	movs	r3, #0
 8023d9e:	2b03      	cmp	r3, #3
 8023da0:	d810      	bhi.n	8023dc4 <CRYP_AESGCM_Process+0x1d8>
      temp[index] = hcryp->Instance->DOUTR;
 8023da2:	6822      	ldr	r2, [r4, #0]
 8023da4:	68d1      	ldr	r1, [r2, #12]
 8023da6:	009a      	lsls	r2, r3, #2
 8023da8:	4668      	mov	r0, sp
 8023daa:	5011      	str	r1, [r2, r0]
    for (index = 0U; index < 4U; index++)
 8023dac:	3301      	adds	r3, #1
 8023dae:	e7f6      	b.n	8023d9e <CRYP_AESGCM_Process+0x1b2>
      hcryp->State = HAL_CRYP_STATE_READY;
 8023db0:	2351      	movs	r3, #81	; 0x51
 8023db2:	2201      	movs	r2, #1
 8023db4:	54e2      	strb	r2, [r4, r3]
      __HAL_UNLOCK(hcryp);
 8023db6:	3b01      	subs	r3, #1
 8023db8:	2200      	movs	r2, #0
 8023dba:	54e2      	strb	r2, [r4, r3]
      HAL_CRYP_ErrorCallback(hcryp);
 8023dbc:	0020      	movs	r0, r4
 8023dbe:	f7ff fc6e 	bl	802369e <HAL_CRYP_ErrorCallback>
 8023dc2:	e7e6      	b.n	8023d92 <CRYP_AESGCM_Process+0x1a6>
    for (index = 0U; index < lastwordsize; index++)
 8023dc4:	2200      	movs	r2, #0
 8023dc6:	42b2      	cmp	r2, r6
 8023dc8:	d20d      	bcs.n	8023de6 <CRYP_AESGCM_Process+0x1fa>
      *(uint32_t *)(hcryp->pCrypOutBuffPtr + (hcryp->CrypOutCount)) = temp[index];
 8023dca:	2140      	movs	r1, #64	; 0x40
 8023dcc:	5a63      	ldrh	r3, [r4, r1]
 8023dce:	009b      	lsls	r3, r3, #2
 8023dd0:	0090      	lsls	r0, r2, #2
 8023dd2:	466d      	mov	r5, sp
 8023dd4:	5940      	ldr	r0, [r0, r5]
 8023dd6:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8023dd8:	50e8      	str	r0, [r5, r3]
      hcryp->CrypOutCount++;
 8023dda:	5a63      	ldrh	r3, [r4, r1]
 8023ddc:	3301      	adds	r3, #1
 8023dde:	b29b      	uxth	r3, r3
 8023de0:	5263      	strh	r3, [r4, r1]
    for (index = 0U; index < lastwordsize; index++)
 8023de2:	3201      	adds	r2, #1
 8023de4:	e7ef      	b.n	8023dc6 <CRYP_AESGCM_Process+0x1da>
  return HAL_OK;
 8023de6:	2000      	movs	r0, #0
 8023de8:	e73c      	b.n	8023c64 <CRYP_AESGCM_Process+0x78>
      return HAL_ERROR;
 8023dea:	2001      	movs	r0, #1
 8023dec:	e73a      	b.n	8023c64 <CRYP_AESGCM_Process+0x78>
  return HAL_OK;
 8023dee:	2000      	movs	r0, #0
 8023df0:	e738      	b.n	8023c64 <CRYP_AESGCM_Process+0x78>
 8023df2:	46c0      	nop			; (mov r8, r8)
 8023df4:	ffff9fff 	.word	0xffff9fff
 8023df8:	ff0fffff 	.word	0xff0fffff

08023dfc <HAL_CRYP_Encrypt>:
{
 8023dfc:	b570      	push	{r4, r5, r6, lr}
 8023dfe:	0004      	movs	r4, r0
  if (hcryp->State == HAL_CRYP_STATE_READY)
 8023e00:	2051      	movs	r0, #81	; 0x51
 8023e02:	5c25      	ldrb	r5, [r4, r0]
 8023e04:	b2e8      	uxtb	r0, r5
 8023e06:	2d01      	cmp	r5, #1
 8023e08:	d005      	beq.n	8023e16 <HAL_CRYP_Encrypt+0x1a>
    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;
 8023e0a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023e0c:	2208      	movs	r2, #8
 8023e0e:	4313      	orrs	r3, r2
 8023e10:	6563      	str	r3, [r4, #84]	; 0x54
    status = HAL_ERROR;
 8023e12:	2001      	movs	r0, #1
}
 8023e14:	bd70      	pop	{r4, r5, r6, pc}
    hcryp->State = HAL_CRYP_STATE_BUSY;
 8023e16:	3550      	adds	r5, #80	; 0x50
 8023e18:	2602      	movs	r6, #2
 8023e1a:	5566      	strb	r6, [r4, r5]
    __HAL_LOCK(hcryp);
 8023e1c:	3d01      	subs	r5, #1
 8023e1e:	5d65      	ldrb	r5, [r4, r5]
 8023e20:	2d01      	cmp	r5, #1
 8023e22:	d043      	beq.n	8023eac <HAL_CRYP_Encrypt+0xb0>
 8023e24:	2550      	movs	r5, #80	; 0x50
 8023e26:	3e01      	subs	r6, #1
 8023e28:	5566      	strb	r6, [r4, r5]
    hcryp->CrypInCount = 0U;
 8023e2a:	2500      	movs	r5, #0
 8023e2c:	87e5      	strh	r5, [r4, #62]	; 0x3e
    hcryp->CrypOutCount = 0U;
 8023e2e:	363f      	adds	r6, #63	; 0x3f
 8023e30:	53a5      	strh	r5, [r4, r6]
    hcryp->pCrypInBuffPtr = Input;
 8023e32:	6361      	str	r1, [r4, #52]	; 0x34
    hcryp->pCrypOutBuffPtr = Output;
 8023e34:	63a3      	str	r3, [r4, #56]	; 0x38
    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)
 8023e36:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8023e38:	2b00      	cmp	r3, #0
 8023e3a:	d11f      	bne.n	8023e7c <HAL_CRYP_Encrypt+0x80>
      hcryp->Size = Size * 4U;
 8023e3c:	0092      	lsls	r2, r2, #2
 8023e3e:	3342      	adds	r3, #66	; 0x42
 8023e40:	52e2      	strh	r2, [r4, r3]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_ENCRYPT);
 8023e42:	6822      	ldr	r2, [r4, #0]
 8023e44:	6813      	ldr	r3, [r2, #0]
 8023e46:	2118      	movs	r1, #24
 8023e48:	438b      	bics	r3, r1
 8023e4a:	6013      	str	r3, [r2, #0]
    algo = hcryp->Instance->CR & AES_CR_CHMOD;
 8023e4c:	6823      	ldr	r3, [r4, #0]
 8023e4e:	681b      	ldr	r3, [r3, #0]
 8023e50:	4a17      	ldr	r2, [pc, #92]	; (8023eb0 <HAL_CRYP_Encrypt+0xb4>)
 8023e52:	4013      	ands	r3, r2
    switch (algo)
 8023e54:	2b60      	cmp	r3, #96	; 0x60
 8023e56:	d024      	beq.n	8023ea2 <HAL_CRYP_Encrypt+0xa6>
 8023e58:	d81a      	bhi.n	8023e90 <HAL_CRYP_Encrypt+0x94>
 8023e5a:	2b20      	cmp	r3, #32
 8023e5c:	d001      	beq.n	8023e62 <HAL_CRYP_Encrypt+0x66>
 8023e5e:	2b40      	cmp	r3, #64	; 0x40
 8023e60:	d10f      	bne.n	8023e82 <HAL_CRYP_Encrypt+0x86>
        status = CRYP_AES_Encrypt(hcryp, Timeout);
 8023e62:	9904      	ldr	r1, [sp, #16]
 8023e64:	0020      	movs	r0, r4
 8023e66:	f7ff fc88 	bl	802377a <CRYP_AES_Encrypt>
    if (status == HAL_OK)
 8023e6a:	2800      	cmp	r0, #0
 8023e6c:	d1d2      	bne.n	8023e14 <HAL_CRYP_Encrypt+0x18>
      hcryp->State = HAL_CRYP_STATE_READY;
 8023e6e:	2351      	movs	r3, #81	; 0x51
 8023e70:	2201      	movs	r2, #1
 8023e72:	54e2      	strb	r2, [r4, r3]
      __HAL_UNLOCK(hcryp);
 8023e74:	3b01      	subs	r3, #1
 8023e76:	2200      	movs	r2, #0
 8023e78:	54e2      	strb	r2, [r4, r3]
 8023e7a:	e7cb      	b.n	8023e14 <HAL_CRYP_Encrypt+0x18>
      hcryp->Size = Size;
 8023e7c:	2342      	movs	r3, #66	; 0x42
 8023e7e:	52e2      	strh	r2, [r4, r3]
 8023e80:	e7df      	b.n	8023e42 <HAL_CRYP_Encrypt+0x46>
    switch (algo)
 8023e82:	2b00      	cmp	r3, #0
 8023e84:	d0ed      	beq.n	8023e62 <HAL_CRYP_Encrypt+0x66>
        hcryp->ErrorCode |= HAL_CRYP_ERROR_NOT_SUPPORTED;
 8023e86:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023e88:	2220      	movs	r2, #32
 8023e8a:	4313      	orrs	r3, r2
 8023e8c:	6563      	str	r3, [r4, #84]	; 0x54
    if (status == HAL_OK)
 8023e8e:	e7c1      	b.n	8023e14 <HAL_CRYP_Encrypt+0x18>
    switch (algo)
 8023e90:	2280      	movs	r2, #128	; 0x80
 8023e92:	0252      	lsls	r2, r2, #9
 8023e94:	4293      	cmp	r3, r2
 8023e96:	d1f6      	bne.n	8023e86 <HAL_CRYP_Encrypt+0x8a>
        status = CRYP_AESCCM_Process(hcryp, Timeout);
 8023e98:	9904      	ldr	r1, [sp, #16]
 8023e9a:	0020      	movs	r0, r4
 8023e9c:	f7ff fcc0 	bl	8023820 <CRYP_AESCCM_Process>
        break;
 8023ea0:	e7e3      	b.n	8023e6a <HAL_CRYP_Encrypt+0x6e>
        status = CRYP_AESGCM_Process(hcryp, Timeout) ;
 8023ea2:	9904      	ldr	r1, [sp, #16]
 8023ea4:	0020      	movs	r0, r4
 8023ea6:	f7ff fea1 	bl	8023bec <CRYP_AESGCM_Process>
        break;
 8023eaa:	e7de      	b.n	8023e6a <HAL_CRYP_Encrypt+0x6e>
    __HAL_LOCK(hcryp);
 8023eac:	2002      	movs	r0, #2
 8023eae:	e7b1      	b.n	8023e14 <HAL_CRYP_Encrypt+0x18>
 8023eb0:	00010060 	.word	0x00010060

08023eb4 <HAL_CRYP_Decrypt>:
{
 8023eb4:	b570      	push	{r4, r5, r6, lr}
 8023eb6:	0004      	movs	r4, r0
  if (hcryp->State == HAL_CRYP_STATE_READY)
 8023eb8:	2051      	movs	r0, #81	; 0x51
 8023eba:	5c25      	ldrb	r5, [r4, r0]
 8023ebc:	b2e8      	uxtb	r0, r5
 8023ebe:	2d01      	cmp	r5, #1
 8023ec0:	d005      	beq.n	8023ece <HAL_CRYP_Decrypt+0x1a>
    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;
 8023ec2:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023ec4:	2208      	movs	r2, #8
 8023ec6:	4313      	orrs	r3, r2
 8023ec8:	6563      	str	r3, [r4, #84]	; 0x54
    status = HAL_ERROR;
 8023eca:	2001      	movs	r0, #1
}
 8023ecc:	bd70      	pop	{r4, r5, r6, pc}
    hcryp->State = HAL_CRYP_STATE_BUSY;
 8023ece:	3550      	adds	r5, #80	; 0x50
 8023ed0:	2602      	movs	r6, #2
 8023ed2:	5566      	strb	r6, [r4, r5]
    __HAL_LOCK(hcryp);
 8023ed4:	3d01      	subs	r5, #1
 8023ed6:	5d65      	ldrb	r5, [r4, r5]
 8023ed8:	2d01      	cmp	r5, #1
 8023eda:	d045      	beq.n	8023f68 <HAL_CRYP_Decrypt+0xb4>
 8023edc:	2550      	movs	r5, #80	; 0x50
 8023ede:	3e01      	subs	r6, #1
 8023ee0:	5566      	strb	r6, [r4, r5]
    hcryp->CrypInCount = 0U;
 8023ee2:	2500      	movs	r5, #0
 8023ee4:	87e5      	strh	r5, [r4, #62]	; 0x3e
    hcryp->CrypOutCount = 0U;
 8023ee6:	363f      	adds	r6, #63	; 0x3f
 8023ee8:	53a5      	strh	r5, [r4, r6]
    hcryp->pCrypInBuffPtr = Input;
 8023eea:	6361      	str	r1, [r4, #52]	; 0x34
    hcryp->pCrypOutBuffPtr = Output;
 8023eec:	63a3      	str	r3, [r4, #56]	; 0x38
    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)
 8023eee:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8023ef0:	2b00      	cmp	r3, #0
 8023ef2:	d121      	bne.n	8023f38 <HAL_CRYP_Decrypt+0x84>
      hcryp->Size = Size * 4U;
 8023ef4:	0092      	lsls	r2, r2, #2
 8023ef6:	3342      	adds	r3, #66	; 0x42
 8023ef8:	52e2      	strh	r2, [r4, r3]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_DECRYPT);
 8023efa:	6822      	ldr	r2, [r4, #0]
 8023efc:	6813      	ldr	r3, [r2, #0]
 8023efe:	2118      	movs	r1, #24
 8023f00:	438b      	bics	r3, r1
 8023f02:	3908      	subs	r1, #8
 8023f04:	430b      	orrs	r3, r1
 8023f06:	6013      	str	r3, [r2, #0]
    algo = hcryp->Instance->CR & AES_CR_CHMOD;
 8023f08:	6823      	ldr	r3, [r4, #0]
 8023f0a:	681b      	ldr	r3, [r3, #0]
 8023f0c:	4a17      	ldr	r2, [pc, #92]	; (8023f6c <HAL_CRYP_Decrypt+0xb8>)
 8023f0e:	4013      	ands	r3, r2
    switch (algo)
 8023f10:	2b60      	cmp	r3, #96	; 0x60
 8023f12:	d024      	beq.n	8023f5e <HAL_CRYP_Decrypt+0xaa>
 8023f14:	d81a      	bhi.n	8023f4c <HAL_CRYP_Decrypt+0x98>
 8023f16:	2b20      	cmp	r3, #32
 8023f18:	d001      	beq.n	8023f1e <HAL_CRYP_Decrypt+0x6a>
 8023f1a:	2b40      	cmp	r3, #64	; 0x40
 8023f1c:	d10f      	bne.n	8023f3e <HAL_CRYP_Decrypt+0x8a>
        status = CRYP_AES_Decrypt(hcryp, Timeout);
 8023f1e:	9904      	ldr	r1, [sp, #16]
 8023f20:	0020      	movs	r0, r4
 8023f22:	f7ff fd87 	bl	8023a34 <CRYP_AES_Decrypt>
    if (status == HAL_OK)
 8023f26:	2800      	cmp	r0, #0
 8023f28:	d1d0      	bne.n	8023ecc <HAL_CRYP_Decrypt+0x18>
      hcryp->State = HAL_CRYP_STATE_READY;
 8023f2a:	2351      	movs	r3, #81	; 0x51
 8023f2c:	2201      	movs	r2, #1
 8023f2e:	54e2      	strb	r2, [r4, r3]
      __HAL_UNLOCK(hcryp);
 8023f30:	3b01      	subs	r3, #1
 8023f32:	2200      	movs	r2, #0
 8023f34:	54e2      	strb	r2, [r4, r3]
 8023f36:	e7c9      	b.n	8023ecc <HAL_CRYP_Decrypt+0x18>
      hcryp->Size = Size;
 8023f38:	2342      	movs	r3, #66	; 0x42
 8023f3a:	52e2      	strh	r2, [r4, r3]
 8023f3c:	e7dd      	b.n	8023efa <HAL_CRYP_Decrypt+0x46>
    switch (algo)
 8023f3e:	2b00      	cmp	r3, #0
 8023f40:	d0ed      	beq.n	8023f1e <HAL_CRYP_Decrypt+0x6a>
        hcryp->ErrorCode |= HAL_CRYP_ERROR_NOT_SUPPORTED;
 8023f42:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023f44:	2220      	movs	r2, #32
 8023f46:	4313      	orrs	r3, r2
 8023f48:	6563      	str	r3, [r4, #84]	; 0x54
    if (status == HAL_OK)
 8023f4a:	e7bf      	b.n	8023ecc <HAL_CRYP_Decrypt+0x18>
    switch (algo)
 8023f4c:	2280      	movs	r2, #128	; 0x80
 8023f4e:	0252      	lsls	r2, r2, #9
 8023f50:	4293      	cmp	r3, r2
 8023f52:	d1f6      	bne.n	8023f42 <HAL_CRYP_Decrypt+0x8e>
        status = CRYP_AESCCM_Process(hcryp, Timeout);
 8023f54:	9904      	ldr	r1, [sp, #16]
 8023f56:	0020      	movs	r0, r4
 8023f58:	f7ff fc62 	bl	8023820 <CRYP_AESCCM_Process>
        break;
 8023f5c:	e7e3      	b.n	8023f26 <HAL_CRYP_Decrypt+0x72>
        status = CRYP_AESGCM_Process(hcryp, Timeout) ;
 8023f5e:	9904      	ldr	r1, [sp, #16]
 8023f60:	0020      	movs	r0, r4
 8023f62:	f7ff fe43 	bl	8023bec <CRYP_AESGCM_Process>
        break;
 8023f66:	e7de      	b.n	8023f26 <HAL_CRYP_Decrypt+0x72>
    __HAL_LOCK(hcryp);
 8023f68:	2002      	movs	r0, #2
 8023f6a:	e7af      	b.n	8023ecc <HAL_CRYP_Decrypt+0x18>
 8023f6c:	00010060 	.word	0x00010060

08023f70 <HAL_CRYPEx_AESGCM_GenerateAuthTAG>:
  * @param  AuthTag Pointer to the authentication buffer
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRYPEx_AESGCM_GenerateAuthTAG(CRYP_HandleTypeDef *hcryp, uint32_t *AuthTag, uint32_t Timeout)
{
 8023f70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8023f72:	46ce      	mov	lr, r9
 8023f74:	4647      	mov	r7, r8
 8023f76:	b580      	push	{r7, lr}
 8023f78:	0004      	movs	r4, r0
 8023f7a:	000e      	movs	r6, r1
 8023f7c:	0015      	movs	r5, r2
  uint32_t tickstart;
  /* Assume first Init.HeaderSize is in words */
  uint64_t headerlength = (uint64_t)hcryp->Init.HeaderSize * 32U; /* Header length in bits */
 8023f7e:	69c3      	ldr	r3, [r0, #28]
 8023f80:	0eda      	lsrs	r2, r3, #27
 8023f82:	0159      	lsls	r1, r3, #5
  uint64_t inputlength = (uint64_t)hcryp->SizesSum * 8U; /* Input length in bits */
 8023f84:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 8023f86:	00db      	lsls	r3, r3, #3
  uint32_t tagaddr = (uint32_t)AuthTag;

  /* Correct headerlength if Init.HeaderSize is actually in bytes */
  if (hcryp->Init.HeaderWidthUnit == CRYP_HEADERWIDTHUNIT_BYTE)
 8023f88:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8023f8a:	2801      	cmp	r0, #1
 8023f8c:	d021      	beq.n	8023fd2 <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x62>
  {
    headerlength /= 4U;
  }

  if (hcryp->State == HAL_CRYP_STATE_READY)
 8023f8e:	2251      	movs	r2, #81	; 0x51
 8023f90:	5ca2      	ldrb	r2, [r4, r2]
 8023f92:	b2d7      	uxtb	r7, r2
 8023f94:	2a01      	cmp	r2, #1
 8023f96:	d17b      	bne.n	8024090 <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x120>
  {
    /* Process locked */
    __HAL_LOCK(hcryp);
 8023f98:	324f      	adds	r2, #79	; 0x4f
 8023f9a:	5ca2      	ldrb	r2, [r4, r2]
 8023f9c:	2a01      	cmp	r2, #1
 8023f9e:	d100      	bne.n	8023fa2 <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x32>
 8023fa0:	e080      	b.n	80240a4 <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x134>
 8023fa2:	2250      	movs	r2, #80	; 0x50
 8023fa4:	2001      	movs	r0, #1
 8023fa6:	54a0      	strb	r0, [r4, r2]

    /* Change the CRYP peripheral state */
    hcryp->State = HAL_CRYP_STATE_BUSY;
 8023fa8:	3201      	adds	r2, #1
 8023faa:	3001      	adds	r0, #1
 8023fac:	54a0      	strb	r0, [r4, r2]

    /* Check if initialization phase has already been performed */
    if (hcryp->Phase == CRYPEx_PHASE_PROCESS)
 8023fae:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8023fb0:	2a02      	cmp	r2, #2
 8023fb2:	d012      	beq.n	8023fda <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x6a>
      hcryp->Phase = CRYPEx_PHASE_FINAL;
    }
    else /* Initialization phase has not been performed*/
    {
      /* Disable the Peripheral */
      __HAL_CRYP_DISABLE(hcryp);
 8023fb4:	6821      	ldr	r1, [r4, #0]
 8023fb6:	680b      	ldr	r3, [r1, #0]
 8023fb8:	2201      	movs	r2, #1
 8023fba:	4393      	bics	r3, r2
 8023fbc:	600b      	str	r3, [r1, #0]

      /* Sequence error code field */
      hcryp->ErrorCode |= HAL_CRYP_ERROR_AUTH_TAG_SEQUENCE;
 8023fbe:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8023fc0:	2140      	movs	r1, #64	; 0x40
 8023fc2:	430b      	orrs	r3, r1
 8023fc4:	6563      	str	r3, [r4, #84]	; 0x54

      /* Change the CRYP peripheral state */
      hcryp->State = HAL_CRYP_STATE_READY;
 8023fc6:	2351      	movs	r3, #81	; 0x51
 8023fc8:	54e2      	strb	r2, [r4, r3]

      /* Process unlocked */
      __HAL_UNLOCK(hcryp);
 8023fca:	3b01      	subs	r3, #1
 8023fcc:	2200      	movs	r2, #0
 8023fce:	54e2      	strb	r2, [r4, r3]
      return HAL_ERROR;
 8023fd0:	e063      	b.n	802409a <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x12a>
    headerlength /= 4U;
 8023fd2:	0792      	lsls	r2, r2, #30
 8023fd4:	0889      	lsrs	r1, r1, #2
 8023fd6:	4311      	orrs	r1, r2
 8023fd8:	e7d9      	b.n	8023f8e <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x1e>
      hcryp->Phase = CRYPEx_PHASE_FINAL;
 8023fda:	3201      	adds	r2, #1
 8023fdc:	6462      	str	r2, [r4, #68]	; 0x44
    }

    /* Select final phase */
    MODIFY_REG(hcryp->Instance->CR, AES_CR_GCMPH, CRYP_PHASE_FINAL);
 8023fde:	6822      	ldr	r2, [r4, #0]
 8023fe0:	4690      	mov	r8, r2
 8023fe2:	6812      	ldr	r2, [r2, #0]
 8023fe4:	4694      	mov	ip, r2
 8023fe6:	22c0      	movs	r2, #192	; 0xc0
 8023fe8:	01d2      	lsls	r2, r2, #7
 8023fea:	4660      	mov	r0, ip
 8023fec:	4302      	orrs	r2, r0
 8023fee:	4640      	mov	r0, r8
 8023ff0:	6002      	str	r2, [r0, #0]

    /* Set the encrypt operating mode*/
    MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_ENCRYPT);
 8023ff2:	6822      	ldr	r2, [r4, #0]
 8023ff4:	4691      	mov	r9, r2
 8023ff6:	6812      	ldr	r2, [r2, #0]
 8023ff8:	4690      	mov	r8, r2
 8023ffa:	2218      	movs	r2, #24
 8023ffc:	4640      	mov	r0, r8
 8023ffe:	4390      	bics	r0, r2
 8024000:	0002      	movs	r2, r0
 8024002:	4648      	mov	r0, r9
 8024004:	6002      	str	r2, [r0, #0]

    /*TinyAES peripheral from V3.1.1 : data has to be inserted normally (no swapping)*/
    /* Write into the AES_DINR register the number of bits in header (64 bits)
    followed by the number of bits in the payload */

    hcryp->Instance->DINR = 0U;
 8024006:	6820      	ldr	r0, [r4, #0]
 8024008:	2200      	movs	r2, #0
 802400a:	6082      	str	r2, [r0, #8]
    hcryp->Instance->DINR = (uint32_t)(headerlength);
 802400c:	6820      	ldr	r0, [r4, #0]
 802400e:	6081      	str	r1, [r0, #8]
    hcryp->Instance->DINR = 0U;
 8024010:	6821      	ldr	r1, [r4, #0]
 8024012:	608a      	str	r2, [r1, #8]
    hcryp->Instance->DINR = (uint32_t)(inputlength);
 8024014:	6822      	ldr	r2, [r4, #0]
 8024016:	6093      	str	r3, [r2, #8]

    /* Wait for CCF flag to be raised */
    tickstart = HAL_GetTick();
 8024018:	f7fd fdc6 	bl	8021ba8 <HAL_GetTick>
 802401c:	4680      	mov	r8, r0
    while (HAL_IS_BIT_CLR(hcryp->Instance->SR, AES_SR_CCF))
 802401e:	6823      	ldr	r3, [r4, #0]
 8024020:	685a      	ldr	r2, [r3, #4]
 8024022:	07d2      	lsls	r2, r2, #31
 8024024:	d418      	bmi.n	8024058 <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0xe8>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 8024026:	1c6b      	adds	r3, r5, #1
 8024028:	d0f9      	beq.n	802401e <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0xae>
      {
        if (((HAL_GetTick() - tickstart) > Timeout)||(Timeout == 0U))
 802402a:	f7fd fdbd 	bl	8021ba8 <HAL_GetTick>
 802402e:	4643      	mov	r3, r8
 8024030:	1ac0      	subs	r0, r0, r3
 8024032:	42a8      	cmp	r0, r5
 8024034:	d801      	bhi.n	802403a <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0xca>
 8024036:	2d00      	cmp	r5, #0
 8024038:	d1f1      	bne.n	802401e <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0xae>
        {
          /* Disable the CRYP peripheral clock */
          __HAL_CRYP_DISABLE(hcryp);
 802403a:	6821      	ldr	r1, [r4, #0]
 802403c:	680b      	ldr	r3, [r1, #0]
 802403e:	2201      	movs	r2, #1
 8024040:	4393      	bics	r3, r2
 8024042:	600b      	str	r3, [r1, #0]

          /* Change state */
          hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 8024044:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8024046:	2110      	movs	r1, #16
 8024048:	430b      	orrs	r3, r1
 802404a:	6563      	str	r3, [r4, #84]	; 0x54
          hcryp->State = HAL_CRYP_STATE_READY;
 802404c:	2351      	movs	r3, #81	; 0x51
 802404e:	54e2      	strb	r2, [r4, r3]

          /* Process unlocked */
          __HAL_UNLOCK(hcryp);
 8024050:	3b01      	subs	r3, #1
 8024052:	2200      	movs	r2, #0
 8024054:	54e2      	strb	r2, [r4, r3]
          return HAL_ERROR;
 8024056:	e020      	b.n	802409a <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x12a>
        }
      }
    }

    /* Read the authentication TAG in the output FIFO */
    *(uint32_t *)(tagaddr) = hcryp->Instance->DOUTR;
 8024058:	68db      	ldr	r3, [r3, #12]
 802405a:	6033      	str	r3, [r6, #0]
    tagaddr += 4U;
    *(uint32_t *)(tagaddr) = hcryp->Instance->DOUTR;
 802405c:	6823      	ldr	r3, [r4, #0]
 802405e:	68db      	ldr	r3, [r3, #12]
 8024060:	6073      	str	r3, [r6, #4]
    tagaddr += 4U;
    *(uint32_t *)(tagaddr) = hcryp->Instance->DOUTR;
 8024062:	6823      	ldr	r3, [r4, #0]
 8024064:	68db      	ldr	r3, [r3, #12]
 8024066:	60b3      	str	r3, [r6, #8]
    tagaddr += 4U;
    *(uint32_t *)(tagaddr) = hcryp->Instance->DOUTR;
 8024068:	6823      	ldr	r3, [r4, #0]
 802406a:	68db      	ldr	r3, [r3, #12]
 802406c:	60f3      	str	r3, [r6, #12]

    /* Clear CCF flag */
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 802406e:	6822      	ldr	r2, [r4, #0]
 8024070:	6813      	ldr	r3, [r2, #0]
 8024072:	2180      	movs	r1, #128	; 0x80
 8024074:	430b      	orrs	r3, r1
 8024076:	6013      	str	r3, [r2, #0]

    /* Disable the peripheral */
    __HAL_CRYP_DISABLE(hcryp);
 8024078:	6821      	ldr	r1, [r4, #0]
 802407a:	680b      	ldr	r3, [r1, #0]
 802407c:	2201      	movs	r2, #1
 802407e:	4393      	bics	r3, r2
 8024080:	600b      	str	r3, [r1, #0]

    /* Change the CRYP peripheral state */
    hcryp->State = HAL_CRYP_STATE_READY;
 8024082:	2351      	movs	r3, #81	; 0x51
 8024084:	54e2      	strb	r2, [r4, r3]

    /* Process unlocked */
    __HAL_UNLOCK(hcryp);
 8024086:	3b01      	subs	r3, #1
 8024088:	2200      	movs	r2, #0
 802408a:	54e2      	strb	r2, [r4, r3]
    /* Busy error code field */
    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;
    return HAL_ERROR;
  }
  /* Return function status */
  return HAL_OK;
 802408c:	2700      	movs	r7, #0
 802408e:	e004      	b.n	802409a <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x12a>
    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;
 8024090:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8024092:	2208      	movs	r2, #8
 8024094:	4313      	orrs	r3, r2
 8024096:	6563      	str	r3, [r4, #84]	; 0x54
    return HAL_ERROR;
 8024098:	2701      	movs	r7, #1
}
 802409a:	0038      	movs	r0, r7
 802409c:	bcc0      	pop	{r6, r7}
 802409e:	46b9      	mov	r9, r7
 80240a0:	46b0      	mov	r8, r6
 80240a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_LOCK(hcryp);
 80240a4:	2702      	movs	r7, #2
 80240a6:	e7f8      	b.n	802409a <HAL_CRYPEx_AESGCM_GenerateAuthTAG+0x12a>

080240a8 <FLASH_Program_DoubleWord>:
  * @param  Address Specifies the address to be programmed.
  * @param  Data Specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
{
 80240a8:	b530      	push	{r4, r5, lr}
#ifdef CORE_CM0PLUS
  /* Set PG bit */
  SET_BIT(FLASH->C2CR, FLASH_CR_PG);
 80240aa:	4c05      	ldr	r4, [pc, #20]	; (80240c0 <FLASH_Program_DoubleWord+0x18>)
 80240ac:	6e61      	ldr	r1, [r4, #100]	; 0x64
 80240ae:	2501      	movs	r5, #1
 80240b0:	4329      	orrs	r1, r5
 80240b2:	6661      	str	r1, [r4, #100]	; 0x64
  /* Set PG bit */
  SET_BIT(FLASH->CR, FLASH_CR_PG);
#endif

  /* Program first word */
  *(uint32_t *)Address = (uint32_t)Data;
 80240b4:	6002      	str	r2, [r0, #0]
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__STATIC_FORCEINLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 80240b6:	f3bf 8f6f 	isb	sy
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(uint32_t *)(Address + 4U) = (uint32_t)(Data >> 32U);
 80240ba:	6043      	str	r3, [r0, #4]
}
 80240bc:	bd30      	pop	{r4, r5, pc}
 80240be:	46c0      	nop			; (mov r8, r8)
 80240c0:	58004000 	.word	0x58004000

080240c4 <HAL_FLASH_Unlock>:
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 80240c4:	4b08      	ldr	r3, [pc, #32]	; (80240e8 <HAL_FLASH_Unlock+0x24>)
 80240c6:	695b      	ldr	r3, [r3, #20]
 80240c8:	2b00      	cmp	r3, #0
 80240ca:	db01      	blt.n	80240d0 <HAL_FLASH_Unlock+0xc>
  HAL_StatusTypeDef status = HAL_OK;
 80240cc:	2000      	movs	r0, #0
}
 80240ce:	4770      	bx	lr
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 80240d0:	4b05      	ldr	r3, [pc, #20]	; (80240e8 <HAL_FLASH_Unlock+0x24>)
 80240d2:	4a06      	ldr	r2, [pc, #24]	; (80240ec <HAL_FLASH_Unlock+0x28>)
 80240d4:	609a      	str	r2, [r3, #8]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 80240d6:	4a06      	ldr	r2, [pc, #24]	; (80240f0 <HAL_FLASH_Unlock+0x2c>)
 80240d8:	609a      	str	r2, [r3, #8]
    if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 80240da:	695b      	ldr	r3, [r3, #20]
 80240dc:	2b00      	cmp	r3, #0
 80240de:	db01      	blt.n	80240e4 <HAL_FLASH_Unlock+0x20>
  HAL_StatusTypeDef status = HAL_OK;
 80240e0:	2000      	movs	r0, #0
 80240e2:	e7f4      	b.n	80240ce <HAL_FLASH_Unlock+0xa>
      status = HAL_ERROR;
 80240e4:	2001      	movs	r0, #1
 80240e6:	e7f2      	b.n	80240ce <HAL_FLASH_Unlock+0xa>
 80240e8:	58004000 	.word	0x58004000
 80240ec:	45670123 	.word	0x45670123
 80240f0:	cdef89ab 	.word	0xcdef89ab

080240f4 <HAL_FLASH_Lock>:
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 80240f4:	4b06      	ldr	r3, [pc, #24]	; (8024110 <HAL_FLASH_Lock+0x1c>)
 80240f6:	6959      	ldr	r1, [r3, #20]
 80240f8:	2280      	movs	r2, #128	; 0x80
 80240fa:	0612      	lsls	r2, r2, #24
 80240fc:	430a      	orrs	r2, r1
 80240fe:	615a      	str	r2, [r3, #20]
  if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) == 0U)
 8024100:	695b      	ldr	r3, [r3, #20]
 8024102:	2b00      	cmp	r3, #0
 8024104:	db01      	blt.n	802410a <HAL_FLASH_Lock+0x16>
    status = HAL_ERROR;
 8024106:	2001      	movs	r0, #1
}
 8024108:	4770      	bx	lr
  HAL_StatusTypeDef status = HAL_OK;
 802410a:	2000      	movs	r0, #0
 802410c:	e7fc      	b.n	8024108 <HAL_FLASH_Lock+0x14>
 802410e:	46c0      	nop			; (mov r8, r8)
 8024110:	58004000 	.word	0x58004000

08024114 <FLASH_WaitForLastOperation>:
{
 8024114:	b570      	push	{r4, r5, r6, lr}
 8024116:	0005      	movs	r5, r0
  uint32_t tickstart = HAL_GetTick();
 8024118:	f7fd fd46 	bl	8021ba8 <HAL_GetTick>
 802411c:	0004      	movs	r4, r0
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 802411e:	4b19      	ldr	r3, [pc, #100]	; (8024184 <FLASH_WaitForLastOperation+0x70>)
 8024120:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8024122:	03db      	lsls	r3, r3, #15
 8024124:	d506      	bpl.n	8024134 <FLASH_WaitForLastOperation+0x20>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 8024126:	f7fd fd3f 	bl	8021ba8 <HAL_GetTick>
 802412a:	1b00      	subs	r0, r0, r4
 802412c:	42a8      	cmp	r0, r5
 802412e:	d3f6      	bcc.n	802411e <FLASH_WaitForLastOperation+0xa>
      return HAL_TIMEOUT;
 8024130:	2003      	movs	r0, #3
}
 8024132:	bd70      	pop	{r4, r5, r6, pc}
  error = FLASH->C2SR;
 8024134:	4b13      	ldr	r3, [pc, #76]	; (8024184 <FLASH_WaitForLastOperation+0x70>)
 8024136:	6e1a      	ldr	r2, [r3, #96]	; 0x60
  if ((error & FLASH_FLAG_EOP) != 0U)
 8024138:	07d3      	lsls	r3, r2, #31
 802413a:	d502      	bpl.n	8024142 <FLASH_WaitForLastOperation+0x2e>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 802413c:	4b11      	ldr	r3, [pc, #68]	; (8024184 <FLASH_WaitForLastOperation+0x70>)
 802413e:	2101      	movs	r1, #1
 8024140:	6619      	str	r1, [r3, #96]	; 0x60
  error &= FLASH_FLAG_SR_ERRORS;
 8024142:	4b11      	ldr	r3, [pc, #68]	; (8024188 <FLASH_WaitForLastOperation+0x74>)
 8024144:	4013      	ands	r3, r2
  __HAL_FLASH_CLEAR_FLAG(error);
 8024146:	0412      	lsls	r2, r2, #16
 8024148:	d505      	bpl.n	8024156 <FLASH_WaitForLastOperation+0x42>
 802414a:	490e      	ldr	r1, [pc, #56]	; (8024184 <FLASH_WaitForLastOperation+0x70>)
 802414c:	6908      	ldr	r0, [r1, #16]
 802414e:	2280      	movs	r2, #128	; 0x80
 8024150:	0212      	lsls	r2, r2, #8
 8024152:	4302      	orrs	r2, r0
 8024154:	610a      	str	r2, [r1, #16]
 8024156:	2b00      	cmp	r3, #0
 8024158:	d001      	beq.n	802415e <FLASH_WaitForLastOperation+0x4a>
 802415a:	4a0a      	ldr	r2, [pc, #40]	; (8024184 <FLASH_WaitForLastOperation+0x70>)
 802415c:	6613      	str	r3, [r2, #96]	; 0x60
  if (error != 0U)
 802415e:	2b00      	cmp	r3, #0
 8024160:	d10a      	bne.n	8024178 <FLASH_WaitForLastOperation+0x64>
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_CFGBSY))
 8024162:	4b08      	ldr	r3, [pc, #32]	; (8024184 <FLASH_WaitForLastOperation+0x70>)
 8024164:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8024166:	035b      	lsls	r3, r3, #13
 8024168:	d50a      	bpl.n	8024180 <FLASH_WaitForLastOperation+0x6c>
    if ((HAL_GetTick() - tickstart) >= Timeout)
 802416a:	f7fd fd1d 	bl	8021ba8 <HAL_GetTick>
 802416e:	1b00      	subs	r0, r0, r4
 8024170:	42a8      	cmp	r0, r5
 8024172:	d3f6      	bcc.n	8024162 <FLASH_WaitForLastOperation+0x4e>
      return HAL_TIMEOUT;
 8024174:	2003      	movs	r0, #3
 8024176:	e7dc      	b.n	8024132 <FLASH_WaitForLastOperation+0x1e>
    pFlash.ErrorCode = error;
 8024178:	4a04      	ldr	r2, [pc, #16]	; (802418c <FLASH_WaitForLastOperation+0x78>)
 802417a:	6053      	str	r3, [r2, #4]
    return HAL_ERROR;
 802417c:	2001      	movs	r0, #1
 802417e:	e7d8      	b.n	8024132 <FLASH_WaitForLastOperation+0x1e>
  return HAL_OK;
 8024180:	2000      	movs	r0, #0
 8024182:	e7d6      	b.n	8024132 <FLASH_WaitForLastOperation+0x1e>
 8024184:	58004000 	.word	0x58004000
 8024188:	0000c3fa 	.word	0x0000c3fa
 802418c:	2000b2e8 	.word	0x2000b2e8

08024190 <HAL_FLASH_Program>:
{
 8024190:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8024192:	0007      	movs	r7, r0
 8024194:	000c      	movs	r4, r1
 8024196:	0015      	movs	r5, r2
 8024198:	001e      	movs	r6, r3
  __HAL_LOCK(&pFlash);
 802419a:	4b14      	ldr	r3, [pc, #80]	; (80241ec <HAL_FLASH_Program+0x5c>)
 802419c:	781b      	ldrb	r3, [r3, #0]
 802419e:	2b01      	cmp	r3, #1
 80241a0:	d022      	beq.n	80241e8 <HAL_FLASH_Program+0x58>
 80241a2:	4b12      	ldr	r3, [pc, #72]	; (80241ec <HAL_FLASH_Program+0x5c>)
 80241a4:	2201      	movs	r2, #1
 80241a6:	701a      	strb	r2, [r3, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 80241a8:	2200      	movs	r2, #0
 80241aa:	605a      	str	r2, [r3, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 80241ac:	20fa      	movs	r0, #250	; 0xfa
 80241ae:	0080      	lsls	r0, r0, #2
 80241b0:	f7ff ffb0 	bl	8024114 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 80241b4:	2800      	cmp	r0, #0
 80241b6:	d10d      	bne.n	80241d4 <HAL_FLASH_Program+0x44>
    if (TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
 80241b8:	2f01      	cmp	r7, #1
 80241ba:	d00f      	beq.n	80241dc <HAL_FLASH_Program+0x4c>
      FLASH_Program_Fast(Address, (uint32_t)Data);
 80241bc:	0029      	movs	r1, r5
 80241be:	0020      	movs	r0, r4
 80241c0:	f010 fd5a 	bl	8034c78 <__FLASH_Program_Fast_veneer>
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 80241c4:	20fa      	movs	r0, #250	; 0xfa
 80241c6:	0080      	lsls	r0, r0, #2
 80241c8:	f7ff ffa4 	bl	8024114 <FLASH_WaitForLastOperation>
    CLEAR_BIT(FLASH->C2CR, TypeProgram);
 80241cc:	4a08      	ldr	r2, [pc, #32]	; (80241f0 <HAL_FLASH_Program+0x60>)
 80241ce:	6e53      	ldr	r3, [r2, #100]	; 0x64
 80241d0:	43bb      	bics	r3, r7
 80241d2:	6653      	str	r3, [r2, #100]	; 0x64
  __HAL_UNLOCK(&pFlash);
 80241d4:	4b05      	ldr	r3, [pc, #20]	; (80241ec <HAL_FLASH_Program+0x5c>)
 80241d6:	2200      	movs	r2, #0
 80241d8:	701a      	strb	r2, [r3, #0]
}
 80241da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      FLASH_Program_DoubleWord(Address, Data);
 80241dc:	002a      	movs	r2, r5
 80241de:	0033      	movs	r3, r6
 80241e0:	0020      	movs	r0, r4
 80241e2:	f7ff ff61 	bl	80240a8 <FLASH_Program_DoubleWord>
 80241e6:	e7ed      	b.n	80241c4 <HAL_FLASH_Program+0x34>
  __HAL_LOCK(&pFlash);
 80241e8:	2002      	movs	r0, #2
 80241ea:	e7f6      	b.n	80241da <HAL_FLASH_Program+0x4a>
 80241ec:	2000b2e8 	.word	0x2000b2e8
 80241f0:	58004000 	.word	0x58004000

080241f4 <FLASH_MassErase>:
  */
static void FLASH_MassErase(void)
{
  /* Set the Mass Erase Bit and start bit */
#ifdef CORE_CM0PLUS
  SET_BIT(FLASH->C2CR, (FLASH_CR_MER | FLASH_CR_STRT));
 80241f4:	4a02      	ldr	r2, [pc, #8]	; (8024200 <FLASH_MassErase+0xc>)
 80241f6:	6e51      	ldr	r1, [r2, #100]	; 0x64
 80241f8:	4b02      	ldr	r3, [pc, #8]	; (8024204 <FLASH_MassErase+0x10>)
 80241fa:	430b      	orrs	r3, r1
 80241fc:	6653      	str	r3, [r2, #100]	; 0x64
#else
  SET_BIT(FLASH->CR, (FLASH_CR_MER | FLASH_CR_STRT));
#endif
}
 80241fe:	4770      	bx	lr
 8024200:	58004000 	.word	0x58004000
 8024204:	00010004 	.word	0x00010004

08024208 <FLASH_FlushCaches>:
  * @retval None
  */
void FLASH_FlushCaches(void)
{
  /* Flush instruction cache  */
  if (READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) == 1U)
 8024208:	4b0d      	ldr	r3, [pc, #52]	; (8024240 <FLASH_FlushCaches+0x38>)
 802420a:	681b      	ldr	r3, [r3, #0]
 802420c:	2280      	movs	r2, #128	; 0x80
 802420e:	0092      	lsls	r2, r2, #2
 8024210:	4013      	ands	r3, r2
 8024212:	2b01      	cmp	r3, #1
 8024214:	d000      	beq.n	8024218 <FLASH_FlushCaches+0x10>
    __HAL_FLASH_DATA_CACHE_RESET();
    /* Enable data cache */
    __HAL_FLASH_DATA_CACHE_ENABLE();
  }
#endif
}
 8024216:	4770      	bx	lr
    __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 8024218:	4b09      	ldr	r3, [pc, #36]	; (8024240 <FLASH_FlushCaches+0x38>)
 802421a:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 802421c:	4909      	ldr	r1, [pc, #36]	; (8024244 <FLASH_FlushCaches+0x3c>)
 802421e:	400a      	ands	r2, r1
 8024220:	65da      	str	r2, [r3, #92]	; 0x5c
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
 8024222:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 8024224:	2280      	movs	r2, #128	; 0x80
 8024226:	0112      	lsls	r2, r2, #4
 8024228:	430a      	orrs	r2, r1
 802422a:	65da      	str	r2, [r3, #92]	; 0x5c
 802422c:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 802422e:	4906      	ldr	r1, [pc, #24]	; (8024248 <FLASH_FlushCaches+0x40>)
 8024230:	400a      	ands	r2, r1
 8024232:	65da      	str	r2, [r3, #92]	; 0x5c
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8024234:	6dd9      	ldr	r1, [r3, #92]	; 0x5c
 8024236:	2280      	movs	r2, #128	; 0x80
 8024238:	0092      	lsls	r2, r2, #2
 802423a:	430a      	orrs	r2, r1
 802423c:	65da      	str	r2, [r3, #92]	; 0x5c
}
 802423e:	e7ea      	b.n	8024216 <FLASH_FlushCaches+0xe>
 8024240:	58004000 	.word	0x58004000
 8024244:	fffffdff 	.word	0xfffffdff
 8024248:	fffff7ff 	.word	0xfffff7ff

0802424c <FLASH_AcknowledgePageErase>:
  * @retval None
  */
static void FLASH_AcknowledgePageErase(void)
{
#ifdef CORE_CM0PLUS
  CLEAR_BIT(FLASH->C2CR, (FLASH_CR_PER | FLASH_CR_PNB));
 802424c:	4a02      	ldr	r2, [pc, #8]	; (8024258 <FLASH_AcknowledgePageErase+0xc>)
 802424e:	6e53      	ldr	r3, [r2, #100]	; 0x64
 8024250:	4902      	ldr	r1, [pc, #8]	; (802425c <FLASH_AcknowledgePageErase+0x10>)
 8024252:	400b      	ands	r3, r1
 8024254:	6653      	str	r3, [r2, #100]	; 0x64
#else
  CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
#endif
}
 8024256:	4770      	bx	lr
 8024258:	58004000 	.word	0x58004000
 802425c:	fffffc05 	.word	0xfffffc05

08024260 <FLASH_OB_GetWRP>:
  * @param[out]  WRDPEndOffset Specifies the address where to copied the end page of
  *                            the write protected area
  * @retval None
  */
static void FLASH_OB_GetWRP(uint32_t WRPArea, uint32_t *WRPStartOffset, uint32_t *WRDPEndOffset)
{
 8024260:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_OB_WRPAREA(WRPArea));

  /* Get the configuration of the write protected area */
  if (WRPArea == OB_WRPAREA_BANK1_AREAA)
 8024262:	2800      	cmp	r0, #0
 8024264:	d109      	bne.n	802427a <FLASH_OB_GetWRP+0x1a>
  {
    *WRPStartOffset = READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_STRT);
 8024266:	4c0a      	ldr	r4, [pc, #40]	; (8024290 <FLASH_OB_GetWRP+0x30>)
 8024268:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 802426a:	237f      	movs	r3, #127	; 0x7f
 802426c:	4018      	ands	r0, r3
 802426e:	6008      	str	r0, [r1, #0]
    *WRDPEndOffset = (READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_END) >> FLASH_WRP1AR_WRP1A_END_Pos);
 8024270:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8024272:	0c09      	lsrs	r1, r1, #16
 8024274:	400b      	ands	r3, r1
 8024276:	6013      	str	r3, [r2, #0]
  else /* OB_WRPAREA_BANK1_AREAB */
  {
    *WRPStartOffset = READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_STRT);
    *WRDPEndOffset = (READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_END) >> FLASH_WRP1BR_WRP1B_END_Pos);
  }
}
 8024278:	bd10      	pop	{r4, pc}
    *WRPStartOffset = READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_STRT);
 802427a:	4c05      	ldr	r4, [pc, #20]	; (8024290 <FLASH_OB_GetWRP+0x30>)
 802427c:	6b20      	ldr	r0, [r4, #48]	; 0x30
 802427e:	237f      	movs	r3, #127	; 0x7f
 8024280:	4018      	ands	r0, r3
 8024282:	6008      	str	r0, [r1, #0]
    *WRDPEndOffset = (READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_END) >> FLASH_WRP1BR_WRP1B_END_Pos);
 8024284:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8024286:	0c09      	lsrs	r1, r1, #16
 8024288:	400b      	ands	r3, r1
 802428a:	6013      	str	r3, [r2, #0]
}
 802428c:	e7f4      	b.n	8024278 <FLASH_OB_GetWRP+0x18>
 802428e:	46c0      	nop			; (mov r8, r8)
 8024290:	58004000 	.word	0x58004000

08024294 <FLASH_OB_GetRDP>:
  *            @arg @ref OB_RDP_LEVEL_1 Read protection of the memory
  *            @arg @ref OB_RDP_LEVEL_2 Full chip protection
  */
static uint32_t FLASH_OB_GetRDP(void)
{
  uint32_t rdplvl = READ_BIT(FLASH->OPTR, FLASH_OPTR_RDP);
 8024294:	4b04      	ldr	r3, [pc, #16]	; (80242a8 <FLASH_OB_GetRDP+0x14>)
 8024296:	6a1b      	ldr	r3, [r3, #32]
 8024298:	20ff      	movs	r0, #255	; 0xff
 802429a:	4018      	ands	r0, r3

  if ((rdplvl != OB_RDP_LEVEL_0) && (rdplvl != OB_RDP_LEVEL_2))
 802429c:	28aa      	cmp	r0, #170	; 0xaa
 802429e:	d002      	beq.n	80242a6 <FLASH_OB_GetRDP+0x12>
 80242a0:	28cc      	cmp	r0, #204	; 0xcc
 80242a2:	d000      	beq.n	80242a6 <FLASH_OB_GetRDP+0x12>
  {
    return (OB_RDP_LEVEL_1);
 80242a4:	20bb      	movs	r0, #187	; 0xbb
  }
  else
  {
    return rdplvl;
  }
}
 80242a6:	4770      	bx	lr
 80242a8:	58004000 	.word	0x58004000

080242ac <FLASH_OB_GetUser>:
  *         @arg @ref OB_BOOT_LOCK_DISABLE or @ref OB_BOOT_LOCK_ENABLE
  */
#endif
static uint32_t FLASH_OB_GetUser(void)
{
  uint32_t user_config = (READ_REG(FLASH->OPTR) & OB_USER_ALL);
 80242ac:	4b02      	ldr	r3, [pc, #8]	; (80242b8 <FLASH_OB_GetUser+0xc>)
 80242ae:	6a18      	ldr	r0, [r3, #32]
 80242b0:	4b02      	ldr	r3, [pc, #8]	; (80242bc <FLASH_OB_GetUser+0x10>)
 80242b2:	4018      	ands	r0, r3
  CLEAR_BIT(user_config, (FLASH_OPTR_RDP | FLASH_OPTR_ESE));

  return user_config;
}
 80242b4:	4770      	bx	lr
 80242b6:	46c0      	nop			; (mov r8, r8)
 80242b8:	58004000 	.word	0x58004000
 80242bc:	cf8f7e00 	.word	0xcf8f7e00

080242c0 <FLASH_OB_GetPCROP>:
  * @param PCROP1BEndAddr [out] Specifies the address where to copied the end address of
  *                       the Zone 1B Proprietary code readout protection
  * @retval None
  */
static void FLASH_OB_GetPCROP(uint32_t *PCROPConfig, uint32_t *PCROP1AStartAddr, uint32_t *PCROP1AEndAddr, uint32_t *PCROP1BStartAddr, uint32_t *PCROP1BEndAddr)
{
 80242c0:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t pcrop;

  pcrop             = (READ_BIT(FLASH->PCROP1BSR, FLASH_PCROP1BSR_PCROP1B_STRT));
 80242c2:	4d10      	ldr	r5, [pc, #64]	; (8024304 <FLASH_OB_GetPCROP+0x44>)
 80242c4:	6b6c      	ldr	r4, [r5, #52]	; 0x34
  *PCROP1BStartAddr = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 80242c6:	02a4      	lsls	r4, r4, #10
 80242c8:	26ff      	movs	r6, #255	; 0xff
 80242ca:	02b6      	lsls	r6, r6, #10
 80242cc:	4034      	ands	r4, r6
 80242ce:	2780      	movs	r7, #128	; 0x80
 80242d0:	053f      	lsls	r7, r7, #20
 80242d2:	46bc      	mov	ip, r7
 80242d4:	4464      	add	r4, ip
 80242d6:	601c      	str	r4, [r3, #0]

  pcrop             = (READ_BIT(FLASH->PCROP1BER, FLASH_PCROP1BER_PCROP1B_END));
 80242d8:	6bac      	ldr	r4, [r5, #56]	; 0x38
  *PCROP1BEndAddr   = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 80242da:	02a4      	lsls	r4, r4, #10
 80242dc:	4034      	ands	r4, r6
 80242de:	4464      	add	r4, ip
 80242e0:	9b05      	ldr	r3, [sp, #20]
 80242e2:	601c      	str	r4, [r3, #0]

  pcrop             = (READ_BIT(FLASH->PCROP1ASR, FLASH_PCROP1ASR_PCROP1A_STRT));
 80242e4:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  *PCROP1AStartAddr = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 80242e6:	02a4      	lsls	r4, r4, #10
 80242e8:	4034      	ands	r4, r6
 80242ea:	4464      	add	r4, ip
 80242ec:	600c      	str	r4, [r1, #0]

  pcrop             = (READ_BIT(FLASH->PCROP1AER, FLASH_PCROP1AER_PCROP1A_END));
 80242ee:	6aab      	ldr	r3, [r5, #40]	; 0x28
  *PCROP1AEndAddr   = ((pcrop << FLASH_PCROP_GRANULARITY_OFFSET) + FLASH_BASE);
 80242f0:	029b      	lsls	r3, r3, #10
 80242f2:	4033      	ands	r3, r6
 80242f4:	4463      	add	r3, ip
 80242f6:	6013      	str	r3, [r2, #0]

  *PCROPConfig      = (READ_REG(FLASH->PCROP1AER) & FLASH_PCROP1AER_PCROP_RDP);
 80242f8:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80242fa:	0fdb      	lsrs	r3, r3, #31
 80242fc:	07db      	lsls	r3, r3, #31
 80242fe:	6003      	str	r3, [r0, #0]
}
 8024300:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8024302:	46c0      	nop			; (mov r8, r8)
 8024304:	58004000 	.word	0x58004000

08024308 <FLASH_OB_GetIPCCBufferAddr>:
  *           This value correspond to the first double-word of the IPCC mailbox data buffer area
  *           in SRAM starting from 0x20000000 (SRAM1 start address to SRAM2 end address).
  */
static uint32_t FLASH_OB_GetIPCCBufferAddr(void)
{
  return (uint32_t)((READ_BIT(FLASH->IPCCBR, FLASH_IPCCBR_IPCCDBA) << 4) + SRAM1_BASE);
 8024308:	4b04      	ldr	r3, [pc, #16]	; (802431c <FLASH_OB_GetIPCCBufferAddr+0x14>)
 802430a:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 802430c:	0100      	lsls	r0, r0, #4
 802430e:	4b04      	ldr	r3, [pc, #16]	; (8024320 <FLASH_OB_GetIPCCBufferAddr+0x18>)
 8024310:	4018      	ands	r0, r3
 8024312:	2380      	movs	r3, #128	; 0x80
 8024314:	059b      	lsls	r3, r3, #22
 8024316:	469c      	mov	ip, r3
 8024318:	4460      	add	r0, ip
}
 802431a:	4770      	bx	lr
 802431c:	58004000 	.word	0x58004000
 8024320:	0003fff0 	.word	0x0003fff0

08024324 <FLASH_OB_GetC2BootResetConfig>:
  * @param  C2BootResetRegion   Specifies the Secure Boot reset memory region
  * @retval None
  */
static void FLASH_OB_GetC2BootResetConfig(uint32_t *C2BootResetVectAddr, uint32_t *C2BootResetRegion)
{
  *C2BootResetRegion = (READ_BIT(FLASH->SRRVR, FLASH_SRRVR_C2OPT));
 8024324:	4a0e      	ldr	r2, [pc, #56]	; (8024360 <FLASH_OB_GetC2BootResetConfig+0x3c>)
 8024326:	2384      	movs	r3, #132	; 0x84
 8024328:	58d3      	ldr	r3, [r2, r3]
 802432a:	0fdb      	lsrs	r3, r3, #31
 802432c:	07db      	lsls	r3, r3, #31
 802432e:	600b      	str	r3, [r1, #0]

  if (*C2BootResetRegion == OB_C2_BOOT_FROM_FLASH)
 8024330:	d10b      	bne.n	802434a <FLASH_OB_GetC2BootResetConfig+0x26>
  {
    *C2BootResetVectAddr = (uint32_t)((READ_BIT(FLASH->SRRVR, FLASH_SRRVR_SBRV) << 2) + FLASH_BASE);
  }
  else
  {
    *C2BootResetVectAddr = (uint32_t)((READ_BIT(FLASH->SRRVR, FLASH_SRRVR_SBRV) << 2) + SRAM1_BASE);
 8024332:	4a0b      	ldr	r2, [pc, #44]	; (8024360 <FLASH_OB_GetC2BootResetConfig+0x3c>)
 8024334:	2384      	movs	r3, #132	; 0x84
 8024336:	58d3      	ldr	r3, [r2, r3]
 8024338:	009b      	lsls	r3, r3, #2
 802433a:	4a0a      	ldr	r2, [pc, #40]	; (8024364 <FLASH_OB_GetC2BootResetConfig+0x40>)
 802433c:	4013      	ands	r3, r2
 802433e:	2280      	movs	r2, #128	; 0x80
 8024340:	0592      	lsls	r2, r2, #22
 8024342:	4694      	mov	ip, r2
 8024344:	4463      	add	r3, ip
 8024346:	6003      	str	r3, [r0, #0]
  }
}
 8024348:	4770      	bx	lr
    *C2BootResetVectAddr = (uint32_t)((READ_BIT(FLASH->SRRVR, FLASH_SRRVR_SBRV) << 2) + FLASH_BASE);
 802434a:	2384      	movs	r3, #132	; 0x84
 802434c:	58d3      	ldr	r3, [r2, r3]
 802434e:	009b      	lsls	r3, r3, #2
 8024350:	4a04      	ldr	r2, [pc, #16]	; (8024364 <FLASH_OB_GetC2BootResetConfig+0x40>)
 8024352:	4013      	ands	r3, r2
 8024354:	2280      	movs	r2, #128	; 0x80
 8024356:	0512      	lsls	r2, r2, #20
 8024358:	4694      	mov	ip, r2
 802435a:	4463      	add	r3, ip
 802435c:	6003      	str	r3, [r0, #0]
 802435e:	e7f3      	b.n	8024348 <FLASH_OB_GetC2BootResetConfig+0x24>
 8024360:	58004000 	.word	0x58004000
 8024364:	0003fffc 	.word	0x0003fffc

08024368 <FLASH_OB_GetSUBGHZSPISecureAccess>:
  *           @arg @ref OB_SUBGHZSPI_SECURE_ACCESS_DISABLE : Sub-GHz radio SPI Secure access disabled
  *           @arg @ref OB_SUBGHZSPI_SECURE_ACCESS_ENABLE : Sub-GHz radio SPI Secure access enabled
  */
static uint32_t FLASH_OB_GetSUBGHZSPISecureAccess(void)
{
  return (READ_BIT(FLASH->SFR, FLASH_SFR_SUBGHZSPISD));
 8024368:	4a02      	ldr	r2, [pc, #8]	; (8024374 <FLASH_OB_GetSUBGHZSPISecureAccess+0xc>)
 802436a:	2380      	movs	r3, #128	; 0x80
 802436c:	58d0      	ldr	r0, [r2, r3]
 802436e:	0fc0      	lsrs	r0, r0, #31
 8024370:	07c0      	lsls	r0, r0, #31
}
 8024372:	4770      	bx	lr
 8024374:	58004000 	.word	0x58004000

08024378 <FLASH_OB_GetC2DebugAccessMode>:
  *           @arg @ref OB_C2_DEBUG_ACCESS_DISABLE : CPU2 debug access disabled
  *           @arg @ref OB_C2_DEBUG_ACCESS_ENABLE : CPU2 debug access enabled
  */
static uint32_t FLASH_OB_GetC2DebugAccessMode(void)
{
  return (READ_BIT(FLASH->SFR, FLASH_SFR_DDS));
 8024378:	4a03      	ldr	r2, [pc, #12]	; (8024388 <FLASH_OB_GetC2DebugAccessMode+0x10>)
 802437a:	2380      	movs	r3, #128	; 0x80
 802437c:	58d0      	ldr	r0, [r2, r3]
 802437e:	2380      	movs	r3, #128	; 0x80
 8024380:	015b      	lsls	r3, r3, #5
 8024382:	4018      	ands	r0, r3
}
 8024384:	4770      	bx	lr
 8024386:	46c0      	nop			; (mov r8, r8)
 8024388:	58004000 	.word	0x58004000

0802438c <FLASH_OB_GetSecureMode>:
  *                               Null
  */
static uint32_t FLASH_OB_GetSecureMode(uint32_t Reg, uint32_t Bit, uint32_t ValueEnable, uint32_t ValueDisable)
{
  /* Return status of bit (set as enable, set as disable) */
  if (READ_BIT(Reg, Bit) == 0U)
 802438c:	4201      	tst	r1, r0
 802438e:	d100      	bne.n	8024392 <FLASH_OB_GetSecureMode+0x6>
  {
    return ValueEnable;
 8024390:	0013      	movs	r3, r2
  }
  else
  {
    return ValueDisable;
  }
}
 8024392:	0018      	movs	r0, r3
 8024394:	4770      	bx	lr
	...

08024398 <FLASH_OB_GetSecureMemoryConfig>:
{
 8024398:	b5f0      	push	{r4, r5, r6, r7, lr}
 802439a:	46c6      	mov	lr, r8
 802439c:	b500      	push	{lr}
 802439e:	4698      	mov	r8, r3
  uint32_t sfr_reg_val = READ_REG(FLASH->SFR);
 80243a0:	4c24      	ldr	r4, [pc, #144]	; (8024434 <FLASH_OB_GetSecureMemoryConfig+0x9c>)
 80243a2:	2580      	movs	r5, #128	; 0x80
 80243a4:	5966      	ldr	r6, [r4, r5]
  uint32_t srrvr_reg_val = READ_REG(FLASH->SRRVR);
 80243a6:	3504      	adds	r5, #4
 80243a8:	5965      	ldr	r5, [r4, r5]
  uint32_t user_config = (READ_BIT(sfr_reg_val, FLASH_SFR_SFSA) >> FLASH_SFR_SFSA_Pos);
 80243aa:	247f      	movs	r4, #127	; 0x7f
 80243ac:	0027      	movs	r7, r4
 80243ae:	4037      	ands	r7, r6
  *SecureFlashStartAddr = ((user_config * FLASH_PAGE_SIZE) + FLASH_BASE);
 80243b0:	2380      	movs	r3, #128	; 0x80
 80243b2:	025b      	lsls	r3, r3, #9
 80243b4:	469c      	mov	ip, r3
 80243b6:	4467      	add	r7, ip
 80243b8:	02ff      	lsls	r7, r7, #11
 80243ba:	6007      	str	r7, [r0, #0]
  user_config = (READ_BIT(sfr_reg_val, FLASH_SFR_HDPSA) >> FLASH_SFR_HDPSA_Pos);
 80243bc:	0c30      	lsrs	r0, r6, #16
 80243be:	4004      	ands	r4, r0
  *HideProtectionStartAddr = ((user_config * FLASH_PAGE_SIZE) + FLASH_BASE);
 80243c0:	4464      	add	r4, ip
 80243c2:	02e4      	lsls	r4, r4, #11
 80243c4:	600c      	str	r4, [r1, #0]
  user_config = (READ_BIT(srrvr_reg_val, FLASH_SRRVR_SBRSA) >> FLASH_SRRVR_SBRSA_Pos);
 80243c6:	0ca9      	lsrs	r1, r5, #18
  *SecureSRAM2StartAddr = ((user_config << SRAM_SECURE_PAGE_GRANULARITY_OFFSET) + SRAM2_BASE);
 80243c8:	0289      	lsls	r1, r1, #10
 80243ca:	20f8      	movs	r0, #248	; 0xf8
 80243cc:	01c0      	lsls	r0, r0, #7
 80243ce:	4001      	ands	r1, r0
 80243d0:	4b19      	ldr	r3, [pc, #100]	; (8024438 <FLASH_OB_GetSecureMemoryConfig+0xa0>)
 80243d2:	469c      	mov	ip, r3
 80243d4:	4461      	add	r1, ip
 80243d6:	6011      	str	r1, [r2, #0]
  user_config = (READ_BIT(srrvr_reg_val, FLASH_SRRVR_SNBRSA) >> FLASH_SRRVR_SNBRSA_Pos);
 80243d8:	0e6a      	lsrs	r2, r5, #25
  *SecureSRAM1StartAddr = ((user_config << SRAM_SECURE_PAGE_GRANULARITY_OFFSET) + SRAM1_BASE);
 80243da:	0292      	lsls	r2, r2, #10
 80243dc:	4002      	ands	r2, r0
 80243de:	2380      	movs	r3, #128	; 0x80
 80243e0:	059b      	lsls	r3, r3, #22
 80243e2:	469c      	mov	ip, r3
 80243e4:	4462      	add	r2, ip
 80243e6:	4643      	mov	r3, r8
 80243e8:	601a      	str	r2, [r3, #0]
  *SecureMode = (FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_FSD, OB_SECURE_SYSTEM_AND_FLASH_ENABLE, OB_SECURE_SYSTEM_AND_FLASH_DISABLE) | \
 80243ea:	2310      	movs	r3, #16
 80243ec:	2201      	movs	r2, #1
 80243ee:	2180      	movs	r1, #128	; 0x80
 80243f0:	0030      	movs	r0, r6
 80243f2:	f7ff ffcb 	bl	802438c <FLASH_OB_GetSecureMode>
 80243f6:	0004      	movs	r4, r0
                 FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_HDPAD, OB_SECURE_HIDE_PROTECTION_ENABLE, OB_SECURE_HIDE_PROTECTION_DISABLE) | \
 80243f8:	2780      	movs	r7, #128	; 0x80
 80243fa:	043f      	lsls	r7, r7, #16
 80243fc:	2320      	movs	r3, #32
 80243fe:	2202      	movs	r2, #2
 8024400:	0039      	movs	r1, r7
 8024402:	0030      	movs	r0, r6
 8024404:	f7ff ffc2 	bl	802438c <FLASH_OB_GetSecureMode>
  *SecureMode = (FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_FSD, OB_SECURE_SYSTEM_AND_FLASH_ENABLE, OB_SECURE_SYSTEM_AND_FLASH_DISABLE) | \
 8024408:	4304      	orrs	r4, r0
                 FLASH_OB_GetSecureMode(srrvr_reg_val, FLASH_SRRVR_NBRSD, OB_SECURE_SRAM1_ENABLE, OB_SECURE_SRAM1_DISABLE)                 | \
 802440a:	2180      	movs	r1, #128	; 0x80
 802440c:	2340      	movs	r3, #64	; 0x40
 802440e:	2204      	movs	r2, #4
 8024410:	05c9      	lsls	r1, r1, #23
 8024412:	0028      	movs	r0, r5
 8024414:	f7ff ffba 	bl	802438c <FLASH_OB_GetSecureMode>
                 FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_HDPAD, OB_SECURE_HIDE_PROTECTION_ENABLE, OB_SECURE_HIDE_PROTECTION_DISABLE) | \
 8024418:	4304      	orrs	r4, r0
                 FLASH_OB_GetSecureMode(srrvr_reg_val, FLASH_SRRVR_BRSD, OB_SECURE_SRAM2_ENABLE, OB_SECURE_SRAM2_DISABLE));
 802441a:	2380      	movs	r3, #128	; 0x80
 802441c:	2208      	movs	r2, #8
 802441e:	0039      	movs	r1, r7
 8024420:	0028      	movs	r0, r5
 8024422:	f7ff ffb3 	bl	802438c <FLASH_OB_GetSecureMode>
                 FLASH_OB_GetSecureMode(srrvr_reg_val, FLASH_SRRVR_NBRSD, OB_SECURE_SRAM1_ENABLE, OB_SECURE_SRAM1_DISABLE)                 | \
 8024426:	4304      	orrs	r4, r0
  *SecureMode = (FLASH_OB_GetSecureMode(sfr_reg_val, FLASH_SFR_FSD, OB_SECURE_SYSTEM_AND_FLASH_ENABLE, OB_SECURE_SYSTEM_AND_FLASH_DISABLE) | \
 8024428:	9b06      	ldr	r3, [sp, #24]
 802442a:	601c      	str	r4, [r3, #0]
}
 802442c:	bc80      	pop	{r7}
 802442e:	46b8      	mov	r8, r7
 8024430:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8024432:	46c0      	nop			; (mov r8, r8)
 8024434:	58004000 	.word	0x58004000
 8024438:	20008000 	.word	0x20008000

0802443c <HAL_FLASHEx_OBGetConfig>:
{
 802443c:	b530      	push	{r4, r5, lr}
 802443e:	b083      	sub	sp, #12
 8024440:	0004      	movs	r4, r0
  pOBInit->OptionType = OPTIONBYTE_ALL;
 8024442:	4b21      	ldr	r3, [pc, #132]	; (80244c8 <HAL_FLASHEx_OBGetConfig+0x8c>)
 8024444:	6003      	str	r3, [r0, #0]
  if ((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB))
 8024446:	6840      	ldr	r0, [r0, #4]
 8024448:	2801      	cmp	r0, #1
 802444a:	d935      	bls.n	80244b8 <HAL_FLASHEx_OBGetConfig+0x7c>
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
 802444c:	f7ff ff22 	bl	8024294 <FLASH_OB_GetRDP>
 8024450:	6120      	str	r0, [r4, #16]
  pOBInit->UserConfig = FLASH_OB_GetUser();
 8024452:	f7ff ff2b 	bl	80242ac <FLASH_OB_GetUser>
 8024456:	61a0      	str	r0, [r4, #24]
  pOBInit->UserType = OB_USER_ALL;
 8024458:	4b1c      	ldr	r3, [pc, #112]	; (80244cc <HAL_FLASHEx_OBGetConfig+0x90>)
 802445a:	6163      	str	r3, [r4, #20]
  FLASH_OB_GetPCROP(&(pOBInit->PCROPConfig), &(pOBInit->PCROP1AStartAddr), &(pOBInit->PCROP1AEndAddr), &(pOBInit->PCROP1BStartAddr), &(pOBInit->PCROP1BEndAddr));
 802445c:	0023      	movs	r3, r4
 802445e:	3328      	adds	r3, #40	; 0x28
 8024460:	0022      	movs	r2, r4
 8024462:	3224      	adds	r2, #36	; 0x24
 8024464:	0021      	movs	r1, r4
 8024466:	3120      	adds	r1, #32
 8024468:	0020      	movs	r0, r4
 802446a:	301c      	adds	r0, #28
 802446c:	0025      	movs	r5, r4
 802446e:	352c      	adds	r5, #44	; 0x2c
 8024470:	9500      	str	r5, [sp, #0]
 8024472:	f7ff ff25 	bl	80242c0 <FLASH_OB_GetPCROP>
  pOBInit->PCROPConfig |= (OB_PCROP_ZONE_A | OB_PCROP_ZONE_B);
 8024476:	2303      	movs	r3, #3
 8024478:	69e2      	ldr	r2, [r4, #28]
 802447a:	4313      	orrs	r3, r2
 802447c:	61e3      	str	r3, [r4, #28]
  pOBInit->IPCCdataBufAddr = FLASH_OB_GetIPCCBufferAddr();
 802447e:	f7ff ff43 	bl	8024308 <FLASH_OB_GetIPCCBufferAddr>
 8024482:	6560      	str	r0, [r4, #84]	; 0x54
  FLASH_OB_GetSecureMemoryConfig(&(pOBInit->SecureFlashStartAddr), &(pOBInit->HideProtectionStartAddr), &(pOBInit->SecureSRAM2StartAddr), &(pOBInit->SecureSRAM1StartAddr), &(pOBInit->SecureMode));
 8024484:	0023      	movs	r3, r4
 8024486:	3338      	adds	r3, #56	; 0x38
 8024488:	0022      	movs	r2, r4
 802448a:	3234      	adds	r2, #52	; 0x34
 802448c:	0021      	movs	r1, r4
 802448e:	313c      	adds	r1, #60	; 0x3c
 8024490:	0020      	movs	r0, r4
 8024492:	3030      	adds	r0, #48	; 0x30
 8024494:	3514      	adds	r5, #20
 8024496:	9500      	str	r5, [sp, #0]
 8024498:	f7ff ff7e 	bl	8024398 <FLASH_OB_GetSecureMemoryConfig>
  FLASH_OB_GetC2BootResetConfig(&(pOBInit->C2SecureBootVectAddr), &(pOBInit->C2BootRegion));
 802449c:	0021      	movs	r1, r4
 802449e:	314c      	adds	r1, #76	; 0x4c
 80244a0:	0020      	movs	r0, r4
 80244a2:	3050      	adds	r0, #80	; 0x50
 80244a4:	f7ff ff3e 	bl	8024324 <FLASH_OB_GetC2BootResetConfig>
  pOBInit->SUBGHZSPISecureAccess = FLASH_OB_GetSUBGHZSPISecureAccess();
 80244a8:	f7ff ff5e 	bl	8024368 <FLASH_OB_GetSUBGHZSPISecureAccess>
 80244ac:	6460      	str	r0, [r4, #68]	; 0x44
  pOBInit->C2DebugAccessMode = FLASH_OB_GetC2DebugAccessMode();
 80244ae:	f7ff ff63 	bl	8024378 <FLASH_OB_GetC2DebugAccessMode>
 80244b2:	64a0      	str	r0, [r4, #72]	; 0x48
}
 80244b4:	b003      	add	sp, #12
 80244b6:	bd30      	pop	{r4, r5, pc}
    FLASH_OB_GetWRP(pOBInit->WRPArea, &(pOBInit->WRPStartOffset), &(pOBInit->WRPEndOffset));
 80244b8:	0022      	movs	r2, r4
 80244ba:	320c      	adds	r2, #12
 80244bc:	0021      	movs	r1, r4
 80244be:	3108      	adds	r1, #8
 80244c0:	f7ff fece 	bl	8024260 <FLASH_OB_GetWRP>
 80244c4:	e7c2      	b.n	802444c <HAL_FLASHEx_OBGetConfig+0x10>
 80244c6:	46c0      	nop			; (mov r8, r8)
 80244c8:	00000f1f 	.word	0x00000f1f
 80244cc:	cf8f7e00 	.word	0xcf8f7e00

080244d0 <FLASH_PageErase>:
  MODIFY_REG(FLASH->C2CR, FLASH_CR_PNB, ((Page << FLASH_CR_PNB_Pos) | FLASH_CR_PER | FLASH_CR_STRT));
 80244d0:	4a04      	ldr	r2, [pc, #16]	; (80244e4 <FLASH_PageErase+0x14>)
 80244d2:	6e53      	ldr	r3, [r2, #100]	; 0x64
 80244d4:	4904      	ldr	r1, [pc, #16]	; (80244e8 <FLASH_PageErase+0x18>)
 80244d6:	400b      	ands	r3, r1
 80244d8:	00c0      	lsls	r0, r0, #3
 80244da:	4303      	orrs	r3, r0
 80244dc:	4803      	ldr	r0, [pc, #12]	; (80244ec <FLASH_PageErase+0x1c>)
 80244de:	4303      	orrs	r3, r0
 80244e0:	6653      	str	r3, [r2, #100]	; 0x64
}
 80244e2:	4770      	bx	lr
 80244e4:	58004000 	.word	0x58004000
 80244e8:	fffffc07 	.word	0xfffffc07
 80244ec:	00010002 	.word	0x00010002

080244f0 <HAL_FLASHEx_Erase>:
{
 80244f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80244f2:	0006      	movs	r6, r0
 80244f4:	000f      	movs	r7, r1
  __HAL_LOCK(&pFlash);
 80244f6:	4b1d      	ldr	r3, [pc, #116]	; (802456c <HAL_FLASHEx_Erase+0x7c>)
 80244f8:	781b      	ldrb	r3, [r3, #0]
 80244fa:	2b01      	cmp	r3, #1
 80244fc:	d034      	beq.n	8024568 <HAL_FLASHEx_Erase+0x78>
 80244fe:	4b1b      	ldr	r3, [pc, #108]	; (802456c <HAL_FLASHEx_Erase+0x7c>)
 8024500:	2201      	movs	r2, #1
 8024502:	701a      	strb	r2, [r3, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8024504:	2200      	movs	r2, #0
 8024506:	605a      	str	r2, [r3, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8024508:	20fa      	movs	r0, #250	; 0xfa
 802450a:	0080      	lsls	r0, r0, #2
 802450c:	f7ff fe02 	bl	8024114 <FLASH_WaitForLastOperation>
 8024510:	1e04      	subs	r4, r0, #0
  if (status == HAL_OK)
 8024512:	d124      	bne.n	802455e <HAL_FLASHEx_Erase+0x6e>
    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 8024514:	6833      	ldr	r3, [r6, #0]
 8024516:	2b04      	cmp	r3, #4
 8024518:	d014      	beq.n	8024544 <HAL_FLASHEx_Erase+0x54>
      *PageError = 0xFFFFFFFFU;
 802451a:	2301      	movs	r3, #1
 802451c:	425b      	negs	r3, r3
 802451e:	603b      	str	r3, [r7, #0]
      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 8024520:	6875      	ldr	r5, [r6, #4]
 8024522:	6873      	ldr	r3, [r6, #4]
 8024524:	68b2      	ldr	r2, [r6, #8]
 8024526:	4694      	mov	ip, r2
 8024528:	4463      	add	r3, ip
 802452a:	42ab      	cmp	r3, r5
 802452c:	d913      	bls.n	8024556 <HAL_FLASHEx_Erase+0x66>
        FLASH_PageErase(index);
 802452e:	0028      	movs	r0, r5
 8024530:	f7ff ffce 	bl	80244d0 <FLASH_PageErase>
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8024534:	20fa      	movs	r0, #250	; 0xfa
 8024536:	0080      	lsls	r0, r0, #2
 8024538:	f7ff fdec 	bl	8024114 <FLASH_WaitForLastOperation>
 802453c:	1e04      	subs	r4, r0, #0
        if (status != HAL_OK)
 802453e:	d109      	bne.n	8024554 <HAL_FLASHEx_Erase+0x64>
      for (index = pEraseInit->Page; index < (pEraseInit->Page + pEraseInit->NbPages); index++)
 8024540:	3501      	adds	r5, #1
 8024542:	e7ee      	b.n	8024522 <HAL_FLASHEx_Erase+0x32>
      FLASH_MassErase();
 8024544:	f7ff fe56 	bl	80241f4 <FLASH_MassErase>
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8024548:	20fa      	movs	r0, #250	; 0xfa
 802454a:	0080      	lsls	r0, r0, #2
 802454c:	f7ff fde2 	bl	8024114 <FLASH_WaitForLastOperation>
 8024550:	0004      	movs	r4, r0
 8024552:	e002      	b.n	802455a <HAL_FLASHEx_Erase+0x6a>
          *PageError = index;
 8024554:	603d      	str	r5, [r7, #0]
      FLASH_AcknowledgePageErase();
 8024556:	f7ff fe79 	bl	802424c <FLASH_AcknowledgePageErase>
    FLASH_FlushCaches();
 802455a:	f7ff fe55 	bl	8024208 <FLASH_FlushCaches>
  __HAL_UNLOCK(&pFlash);
 802455e:	4b03      	ldr	r3, [pc, #12]	; (802456c <HAL_FLASHEx_Erase+0x7c>)
 8024560:	2200      	movs	r2, #0
 8024562:	701a      	strb	r2, [r3, #0]
}
 8024564:	0020      	movs	r0, r4
 8024566:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(&pFlash);
 8024568:	2402      	movs	r4, #2
 802456a:	e7fb      	b.n	8024564 <HAL_FLASHEx_Erase+0x74>
 802456c:	2000b2e8 	.word	0x2000b2e8

08024570 <HAL_GPIO_Init>:
  * @param GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8024570:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t position = 0x00u;
 8024572:	2300      	movs	r3, #0
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8024574:	e05b      	b.n	802462e <HAL_GPIO_Init+0xbe>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8024576:	6884      	ldr	r4, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8024578:	005f      	lsls	r7, r3, #1
 802457a:	2603      	movs	r6, #3
 802457c:	40be      	lsls	r6, r7
 802457e:	43b4      	bics	r4, r6
 8024580:	0026      	movs	r6, r4
        temp |= (GPIO_Init->Speed << (position * 2U));
 8024582:	68cc      	ldr	r4, [r1, #12]
 8024584:	40bc      	lsls	r4, r7
 8024586:	4334      	orrs	r4, r6
        GPIOx->OSPEEDR = temp;
 8024588:	6084      	str	r4, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 802458a:	6844      	ldr	r4, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 802458c:	4394      	bics	r4, r2
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 802458e:	684a      	ldr	r2, [r1, #4]
 8024590:	0916      	lsrs	r6, r2, #4
 8024592:	2201      	movs	r2, #1
 8024594:	4032      	ands	r2, r6
 8024596:	409a      	lsls	r2, r3
 8024598:	4322      	orrs	r2, r4
        GPIOx->OTYPER = temp;
 802459a:	6042      	str	r2, [r0, #4]
 802459c:	e057      	b.n	802464e <HAL_GPIO_Init+0xde>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 802459e:	08dc      	lsrs	r4, r3, #3
 80245a0:	3408      	adds	r4, #8
 80245a2:	00a4      	lsls	r4, r4, #2
 80245a4:	5826      	ldr	r6, [r4, r0]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 80245a6:	3205      	adds	r2, #5
 80245a8:	401a      	ands	r2, r3
 80245aa:	0092      	lsls	r2, r2, #2
 80245ac:	270f      	movs	r7, #15
 80245ae:	4097      	lsls	r7, r2
 80245b0:	43be      	bics	r6, r7
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 80245b2:	690f      	ldr	r7, [r1, #16]
 80245b4:	4097      	lsls	r7, r2
 80245b6:	003a      	movs	r2, r7
 80245b8:	4332      	orrs	r2, r6
        GPIOx->AFR[position >> 3u] = temp;
 80245ba:	5022      	str	r2, [r4, r0]
 80245bc:	e05b      	b.n	8024676 <HAL_GPIO_Init+0x106>
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
      {
        temp = SYSCFG->EXTICR[position >> 2u];
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80245be:	2602      	movs	r6, #2
 80245c0:	e000      	b.n	80245c4 <HAL_GPIO_Init+0x54>
 80245c2:	2600      	movs	r6, #0
 80245c4:	40a6      	lsls	r6, r4
 80245c6:	0034      	movs	r4, r6
 80245c8:	433c      	orrs	r4, r7
        SYSCFG->EXTICR[position >> 2u] = temp;
 80245ca:	3202      	adds	r2, #2
 80245cc:	0092      	lsls	r2, r2, #2
 80245ce:	4e3f      	ldr	r6, [pc, #252]	; (80246cc <HAL_GPIO_Init+0x15c>)
 80245d0:	5194      	str	r4, [r2, r6]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 80245d2:	4a3f      	ldr	r2, [pc, #252]	; (80246d0 <HAL_GPIO_Init+0x160>)
 80245d4:	6814      	ldr	r4, [r2, #0]
        temp &= ~(iocurrent);
 80245d6:	43ea      	mvns	r2, r5
 80245d8:	0026      	movs	r6, r4
 80245da:	43ae      	bics	r6, r5
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00u)
 80245dc:	684f      	ldr	r7, [r1, #4]
 80245de:	02ff      	lsls	r7, r7, #11
 80245e0:	d501      	bpl.n	80245e6 <HAL_GPIO_Init+0x76>
        {
          temp |= iocurrent;
 80245e2:	432c      	orrs	r4, r5
 80245e4:	0026      	movs	r6, r4
        }
        EXTI->RTSR1 = temp;
 80245e6:	4c3a      	ldr	r4, [pc, #232]	; (80246d0 <HAL_GPIO_Init+0x160>)
 80245e8:	6026      	str	r6, [r4, #0]

        temp = EXTI->FTSR1;
 80245ea:	6864      	ldr	r4, [r4, #4]
        temp &= ~(iocurrent);
 80245ec:	0026      	movs	r6, r4
 80245ee:	4016      	ands	r6, r2
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00u)
 80245f0:	684f      	ldr	r7, [r1, #4]
 80245f2:	02bf      	lsls	r7, r7, #10
 80245f4:	d501      	bpl.n	80245fa <HAL_GPIO_Init+0x8a>
        {
          temp |= iocurrent;
 80245f6:	432c      	orrs	r4, r5
 80245f8:	0026      	movs	r6, r4
        }
        EXTI->FTSR1 = temp;
 80245fa:	4c35      	ldr	r4, [pc, #212]	; (80246d0 <HAL_GPIO_Init+0x160>)
 80245fc:	6066      	str	r6, [r4, #4]

        /* Clear EXTI line configuration */
#ifdef CORE_CM0PLUS
        temp = EXTI->C2IMR1;
 80245fe:	26c0      	movs	r6, #192	; 0xc0
 8024600:	59a4      	ldr	r4, [r4, r6]
#else
        temp = EXTI->IMR1;
#endif /* CORE_CM0PLUS */
        temp &= ~(iocurrent);
 8024602:	0026      	movs	r6, r4
 8024604:	4016      	ands	r6, r2
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00u)
 8024606:	684f      	ldr	r7, [r1, #4]
 8024608:	03ff      	lsls	r7, r7, #15
 802460a:	d501      	bpl.n	8024610 <HAL_GPIO_Init+0xa0>
        {
          temp |= iocurrent;
 802460c:	432c      	orrs	r4, r5
 802460e:	0026      	movs	r6, r4
        }
#ifdef CORE_CM0PLUS
        EXTI->C2IMR1 = temp;
 8024610:	4c2f      	ldr	r4, [pc, #188]	; (80246d0 <HAL_GPIO_Init+0x160>)
 8024612:	27c0      	movs	r7, #192	; 0xc0
 8024614:	51e6      	str	r6, [r4, r7]
#else
        EXTI->IMR1 = temp;
#endif /* CORE_CM0PLUS */

#ifdef CORE_CM0PLUS
        temp = EXTI->C2EMR1;
 8024616:	26c4      	movs	r6, #196	; 0xc4
 8024618:	59a4      	ldr	r4, [r4, r6]
#else
        temp = EXTI->EMR1;
#endif /* CORE_CM0PLUS */
        temp &= ~(iocurrent);
 802461a:	4022      	ands	r2, r4
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00u)
 802461c:	684e      	ldr	r6, [r1, #4]
 802461e:	03b6      	lsls	r6, r6, #14
 8024620:	d501      	bpl.n	8024626 <HAL_GPIO_Init+0xb6>
        {
          temp |= iocurrent;
 8024622:	002a      	movs	r2, r5
 8024624:	4322      	orrs	r2, r4
        }
#ifdef CORE_CM0PLUS
        EXTI->C2EMR1 = temp;
 8024626:	4d2a      	ldr	r5, [pc, #168]	; (80246d0 <HAL_GPIO_Init+0x160>)
 8024628:	24c4      	movs	r4, #196	; 0xc4
 802462a:	512a      	str	r2, [r5, r4]
        EXTI->EMR1 = temp;
#endif /* CORE_CM0PLUS */
      }
    }

    position++;
 802462c:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 802462e:	680c      	ldr	r4, [r1, #0]
 8024630:	0022      	movs	r2, r4
 8024632:	40da      	lsrs	r2, r3
 8024634:	d049      	beq.n	80246ca <HAL_GPIO_Init+0x15a>
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8024636:	2201      	movs	r2, #1
 8024638:	409a      	lsls	r2, r3
 802463a:	0025      	movs	r5, r4
 802463c:	4015      	ands	r5, r2
    if (iocurrent != 0x00u)
 802463e:	4214      	tst	r4, r2
 8024640:	d0f4      	beq.n	802462c <HAL_GPIO_Init+0xbc>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8024642:	2403      	movs	r4, #3
 8024644:	684e      	ldr	r6, [r1, #4]
 8024646:	4034      	ands	r4, r6
 8024648:	3c01      	subs	r4, #1
 802464a:	2c01      	cmp	r4, #1
 802464c:	d993      	bls.n	8024576 <HAL_GPIO_Init+0x6>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 802464e:	2203      	movs	r2, #3
 8024650:	684c      	ldr	r4, [r1, #4]
 8024652:	4022      	ands	r2, r4
 8024654:	2a03      	cmp	r2, #3
 8024656:	d009      	beq.n	802466c <HAL_GPIO_Init+0xfc>
        temp = GPIOx->PUPDR;
 8024658:	68c2      	ldr	r2, [r0, #12]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 802465a:	005e      	lsls	r6, r3, #1
 802465c:	2403      	movs	r4, #3
 802465e:	40b4      	lsls	r4, r6
 8024660:	43a2      	bics	r2, r4
 8024662:	0014      	movs	r4, r2
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8024664:	688a      	ldr	r2, [r1, #8]
 8024666:	40b2      	lsls	r2, r6
 8024668:	4322      	orrs	r2, r4
        GPIOx->PUPDR = temp;
 802466a:	60c2      	str	r2, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 802466c:	2203      	movs	r2, #3
 802466e:	684c      	ldr	r4, [r1, #4]
 8024670:	4022      	ands	r2, r4
 8024672:	2a02      	cmp	r2, #2
 8024674:	d093      	beq.n	802459e <HAL_GPIO_Init+0x2e>
      temp = GPIOx->MODER;
 8024676:	6804      	ldr	r4, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8024678:	005e      	lsls	r6, r3, #1
 802467a:	2203      	movs	r2, #3
 802467c:	0017      	movs	r7, r2
 802467e:	40b7      	lsls	r7, r6
 8024680:	43bc      	bics	r4, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8024682:	684f      	ldr	r7, [r1, #4]
 8024684:	403a      	ands	r2, r7
 8024686:	40b2      	lsls	r2, r6
 8024688:	4322      	orrs	r2, r4
      GPIOx->MODER = temp;
 802468a:	6002      	str	r2, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00u)
 802468c:	22c0      	movs	r2, #192	; 0xc0
 802468e:	0292      	lsls	r2, r2, #10
 8024690:	684c      	ldr	r4, [r1, #4]
 8024692:	4214      	tst	r4, r2
 8024694:	d0ca      	beq.n	802462c <HAL_GPIO_Init+0xbc>
        temp = SYSCFG->EXTICR[position >> 2u];
 8024696:	089a      	lsrs	r2, r3, #2
 8024698:	1c94      	adds	r4, r2, #2
 802469a:	00a4      	lsls	r4, r4, #2
 802469c:	4e0b      	ldr	r6, [pc, #44]	; (80246cc <HAL_GPIO_Init+0x15c>)
 802469e:	59a7      	ldr	r7, [r4, r6]
        temp &= ~(0x07uL << (4U * (position & 0x03U)));
 80246a0:	2403      	movs	r4, #3
 80246a2:	401c      	ands	r4, r3
 80246a4:	00a4      	lsls	r4, r4, #2
 80246a6:	2607      	movs	r6, #7
 80246a8:	40a6      	lsls	r6, r4
 80246aa:	43b7      	bics	r7, r6
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80246ac:	2690      	movs	r6, #144	; 0x90
 80246ae:	05f6      	lsls	r6, r6, #23
 80246b0:	42b0      	cmp	r0, r6
 80246b2:	d086      	beq.n	80245c2 <HAL_GPIO_Init+0x52>
 80246b4:	4e07      	ldr	r6, [pc, #28]	; (80246d4 <HAL_GPIO_Init+0x164>)
 80246b6:	42b0      	cmp	r0, r6
 80246b8:	d005      	beq.n	80246c6 <HAL_GPIO_Init+0x156>
 80246ba:	4e07      	ldr	r6, [pc, #28]	; (80246d8 <HAL_GPIO_Init+0x168>)
 80246bc:	42b0      	cmp	r0, r6
 80246be:	d100      	bne.n	80246c2 <HAL_GPIO_Init+0x152>
 80246c0:	e77d      	b.n	80245be <HAL_GPIO_Init+0x4e>
 80246c2:	2607      	movs	r6, #7
 80246c4:	e77e      	b.n	80245c4 <HAL_GPIO_Init+0x54>
 80246c6:	2601      	movs	r6, #1
 80246c8:	e77c      	b.n	80245c4 <HAL_GPIO_Init+0x54>
  }
}
 80246ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80246cc:	40010000 	.word	0x40010000
 80246d0:	58000800 	.word	0x58000800
 80246d4:	48000400 	.word	0x48000400
 80246d8:	48000800 	.word	0x48000800

080246dc <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 80246dc:	2a00      	cmp	r2, #0
 80246de:	d001      	beq.n	80246e4 <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 80246e0:	6181      	str	r1, [r0, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 80246e2:	4770      	bx	lr
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 80246e4:	6281      	str	r1, [r0, #40]	; 0x28
}
 80246e6:	e7fc      	b.n	80246e2 <HAL_GPIO_WritePin+0x6>

080246e8 <HAL_IPCC_RxCallback>:
  UNUSED(ChannelDir);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_IPCC_RxCallback can be implemented in the user file
   */
}
 80246e8:	4770      	bx	lr

080246ea <HAL_IPCC_TxCallback>:
  UNUSED(ChannelDir);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_IPCC_TxCallback can be implemented in the user file
   */
}
 80246ea:	4770      	bx	lr

080246ec <HAL_IPCC_TX_IRQHandler>:
{
 80246ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80246ee:	0007      	movs	r7, r0
  irqmask = ~(currentInstance->MR) & IPCC_ALL_TX_BUF;
 80246f0:	4b12      	ldr	r3, [pc, #72]	; (802473c <HAL_IPCC_TX_IRQHandler+0x50>)
 80246f2:	685a      	ldr	r2, [r3, #4]
 80246f4:	26fc      	movs	r6, #252	; 0xfc
 80246f6:	03b6      	lsls	r6, r6, #14
 80246f8:	4396      	bics	r6, r2
  irqmask = irqmask & ~(currentInstance->SR << IPCC_MR_CH1FM_Pos);
 80246fa:	68db      	ldr	r3, [r3, #12]
 80246fc:	041b      	lsls	r3, r3, #16
 80246fe:	439e      	bics	r6, r3
  uint32_t ch_count = 0U;
 8024700:	2500      	movs	r5, #0
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 8024702:	e005      	b.n	8024710 <HAL_IPCC_TX_IRQHandler+0x24>
        hipcc->ChannelCallbackTx[ch_count](hipcc, ch_count, IPCC_CHANNEL_DIR_TX);
 8024704:	2200      	movs	r2, #0
 8024706:	0029      	movs	r1, r5
 8024708:	0038      	movs	r0, r7
 802470a:	4798      	blx	r3
      irqmask =  irqmask & ~(bit_pos);
 802470c:	43a6      	bics	r6, r4
    ch_count++;
 802470e:	3501      	adds	r5, #1
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 8024710:	2e00      	cmp	r6, #0
 8024712:	d011      	beq.n	8024738 <HAL_IPCC_TX_IRQHandler+0x4c>
    bit_pos = 1UL << (IPCC_MR_CH1FM_Pos + (ch_count & CHANNEL_INDEX_Msk));
 8024714:	230f      	movs	r3, #15
 8024716:	402b      	ands	r3, r5
 8024718:	3310      	adds	r3, #16
 802471a:	2401      	movs	r4, #1
 802471c:	409c      	lsls	r4, r3
    if ((irqmask & bit_pos) != 0U)
 802471e:	4234      	tst	r4, r6
 8024720:	d0f5      	beq.n	802470e <HAL_IPCC_TX_IRQHandler+0x22>
      currentInstance->MR |= bit_pos;
 8024722:	4a06      	ldr	r2, [pc, #24]	; (802473c <HAL_IPCC_TX_IRQHandler+0x50>)
 8024724:	6853      	ldr	r3, [r2, #4]
 8024726:	4323      	orrs	r3, r4
 8024728:	6053      	str	r3, [r2, #4]
      if (hipcc->ChannelCallbackTx[ch_count] != NULL)
 802472a:	1dab      	adds	r3, r5, #6
 802472c:	009b      	lsls	r3, r3, #2
 802472e:	18fb      	adds	r3, r7, r3
 8024730:	685b      	ldr	r3, [r3, #4]
 8024732:	2b00      	cmp	r3, #0
 8024734:	d1e6      	bne.n	8024704 <HAL_IPCC_TX_IRQHandler+0x18>
 8024736:	e7e9      	b.n	802470c <HAL_IPCC_TX_IRQHandler+0x20>
}
 8024738:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802473a:	46c0      	nop			; (mov r8, r8)
 802473c:	58000c10 	.word	0x58000c10

08024740 <HAL_IPCC_RX_IRQHandler>:
{
 8024740:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8024742:	0007      	movs	r7, r0
  irqmask = ~(currentInstance->MR) & IPCC_ALL_RX_BUF;
 8024744:	4b10      	ldr	r3, [pc, #64]	; (8024788 <HAL_IPCC_RX_IRQHandler+0x48>)
 8024746:	685b      	ldr	r3, [r3, #4]
 8024748:	263f      	movs	r6, #63	; 0x3f
 802474a:	439e      	bics	r6, r3
  irqmask = irqmask & otherInstance->SR;
 802474c:	4b0f      	ldr	r3, [pc, #60]	; (802478c <HAL_IPCC_RX_IRQHandler+0x4c>)
 802474e:	68db      	ldr	r3, [r3, #12]
 8024750:	401e      	ands	r6, r3
  uint32_t ch_count = 0U;
 8024752:	2500      	movs	r5, #0
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 8024754:	e005      	b.n	8024762 <HAL_IPCC_RX_IRQHandler+0x22>
        hipcc->ChannelCallbackRx[ch_count](hipcc, ch_count, IPCC_CHANNEL_DIR_RX);
 8024756:	2201      	movs	r2, #1
 8024758:	0029      	movs	r1, r5
 802475a:	0038      	movs	r0, r7
 802475c:	4798      	blx	r3
      irqmask = irqmask & ~(bit_pos);
 802475e:	43a6      	bics	r6, r4
    ch_count++;
 8024760:	3501      	adds	r5, #1
  while (irqmask != 0UL)  /* if several bits are set, it loops to serve all of them */
 8024762:	2e00      	cmp	r6, #0
 8024764:	d00f      	beq.n	8024786 <HAL_IPCC_RX_IRQHandler+0x46>
    bit_pos = 1UL << (ch_count & CHANNEL_INDEX_Msk);
 8024766:	230f      	movs	r3, #15
 8024768:	402b      	ands	r3, r5
 802476a:	2401      	movs	r4, #1
 802476c:	409c      	lsls	r4, r3
    if ((irqmask & bit_pos) != 0U)
 802476e:	4234      	tst	r4, r6
 8024770:	d0f6      	beq.n	8024760 <HAL_IPCC_RX_IRQHandler+0x20>
      currentInstance->MR |= bit_pos;
 8024772:	4a05      	ldr	r2, [pc, #20]	; (8024788 <HAL_IPCC_RX_IRQHandler+0x48>)
 8024774:	6853      	ldr	r3, [r2, #4]
 8024776:	4323      	orrs	r3, r4
 8024778:	6053      	str	r3, [r2, #4]
      if (hipcc->ChannelCallbackRx[ch_count] != NULL)
 802477a:	00ab      	lsls	r3, r5, #2
 802477c:	18fb      	adds	r3, r7, r3
 802477e:	685b      	ldr	r3, [r3, #4]
 8024780:	2b00      	cmp	r3, #0
 8024782:	d1e8      	bne.n	8024756 <HAL_IPCC_RX_IRQHandler+0x16>
 8024784:	e7eb      	b.n	802475e <HAL_IPCC_RX_IRQHandler+0x1e>
}
 8024786:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8024788:	58000c10 	.word	0x58000c10
 802478c:	58000c00 	.word	0x58000c00

08024790 <IPCC_UnmaskInterrupt>:
#if defined(CORE_CM0PLUS)
  IPCC_CommonTypeDef *currentInstance = IPCC_C2;
#else
  IPCC_CommonTypeDef *currentInstance = IPCC_C1;
#endif
  if (ChannelDir == IPCC_CHANNEL_DIR_TX)
 8024790:	2900      	cmp	r1, #0
 8024792:	d109      	bne.n	80247a8 <IPCC_UnmaskInterrupt+0x18>
  {
    /* Unmask interrupt */
    currentInstance->MR &= ~(IPCC_MR_CH1FM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
 8024794:	4909      	ldr	r1, [pc, #36]	; (80247bc <IPCC_UnmaskInterrupt+0x2c>)
 8024796:	684b      	ldr	r3, [r1, #4]
 8024798:	220f      	movs	r2, #15
 802479a:	4010      	ands	r0, r2
 802479c:	2280      	movs	r2, #128	; 0x80
 802479e:	0252      	lsls	r2, r2, #9
 80247a0:	4082      	lsls	r2, r0
 80247a2:	4393      	bics	r3, r2
 80247a4:	604b      	str	r3, [r1, #4]
  else
  {
    /* Unmask interrupt */
    currentInstance->MR &= ~(IPCC_MR_CH1OM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
  }
}
 80247a6:	4770      	bx	lr
    currentInstance->MR &= ~(IPCC_MR_CH1OM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
 80247a8:	4904      	ldr	r1, [pc, #16]	; (80247bc <IPCC_UnmaskInterrupt+0x2c>)
 80247aa:	684b      	ldr	r3, [r1, #4]
 80247ac:	220f      	movs	r2, #15
 80247ae:	4010      	ands	r0, r2
 80247b0:	3a0e      	subs	r2, #14
 80247b2:	4082      	lsls	r2, r0
 80247b4:	4393      	bics	r3, r2
 80247b6:	604b      	str	r3, [r1, #4]
}
 80247b8:	e7f5      	b.n	80247a6 <IPCC_UnmaskInterrupt+0x16>
 80247ba:	46c0      	nop			; (mov r8, r8)
 80247bc:	58000c10 	.word	0x58000c10

080247c0 <HAL_IPCC_ActivateNotification>:
{
 80247c0:	b510      	push	{r4, lr}
 80247c2:	000c      	movs	r4, r1
  if (hipcc != NULL)
 80247c4:	2800      	cmp	r0, #0
 80247c6:	d028      	beq.n	802481a <HAL_IPCC_ActivateNotification+0x5a>
    if (hipcc->State == HAL_IPCC_STATE_READY)
 80247c8:	2138      	movs	r1, #56	; 0x38
 80247ca:	5c41      	ldrb	r1, [r0, r1]
 80247cc:	2901      	cmp	r1, #1
 80247ce:	d001      	beq.n	80247d4 <HAL_IPCC_ActivateNotification+0x14>
      err = HAL_ERROR;
 80247d0:	2001      	movs	r0, #1
}
 80247d2:	bd10      	pop	{r4, pc}
      if (ChannelDir == IPCC_CHANNEL_DIR_TX)
 80247d4:	2a00      	cmp	r2, #0
 80247d6:	d10f      	bne.n	80247f8 <HAL_IPCC_ActivateNotification+0x38>
        hipcc->ChannelCallbackTx[ChannelIndex] = cb;
 80247d8:	1da1      	adds	r1, r4, #6
 80247da:	0089      	lsls	r1, r1, #2
 80247dc:	1841      	adds	r1, r0, r1
 80247de:	604b      	str	r3, [r1, #4]
        hipcc->callbackRequest |= (IPCC_MR_CH1FM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
 80247e0:	210f      	movs	r1, #15
 80247e2:	4021      	ands	r1, r4
 80247e4:	2380      	movs	r3, #128	; 0x80
 80247e6:	025b      	lsls	r3, r3, #9
 80247e8:	408b      	lsls	r3, r1
 80247ea:	6b41      	ldr	r1, [r0, #52]	; 0x34
 80247ec:	430b      	orrs	r3, r1
 80247ee:	6343      	str	r3, [r0, #52]	; 0x34
      if (ChannelDir == IPCC_CHANNEL_DIR_RX)
 80247f0:	2a01      	cmp	r2, #1
 80247f2:	d00c      	beq.n	802480e <HAL_IPCC_ActivateNotification+0x4e>
  HAL_StatusTypeDef err = HAL_OK;
 80247f4:	2000      	movs	r0, #0
 80247f6:	e7ec      	b.n	80247d2 <HAL_IPCC_ActivateNotification+0x12>
        hipcc->ChannelCallbackRx[ChannelIndex] = cb;
 80247f8:	00a1      	lsls	r1, r4, #2
 80247fa:	1841      	adds	r1, r0, r1
 80247fc:	604b      	str	r3, [r1, #4]
        hipcc->callbackRequest |= (IPCC_MR_CH1OM_Msk << (ChannelIndex & CHANNEL_INDEX_Msk));
 80247fe:	210f      	movs	r1, #15
 8024800:	4021      	ands	r1, r4
 8024802:	2301      	movs	r3, #1
 8024804:	408b      	lsls	r3, r1
 8024806:	6b41      	ldr	r1, [r0, #52]	; 0x34
 8024808:	430b      	orrs	r3, r1
 802480a:	6343      	str	r3, [r0, #52]	; 0x34
 802480c:	e7f0      	b.n	80247f0 <HAL_IPCC_ActivateNotification+0x30>
        IPCC_UnmaskInterrupt(ChannelIndex, ChannelDir);
 802480e:	0011      	movs	r1, r2
 8024810:	0020      	movs	r0, r4
 8024812:	f7ff ffbd 	bl	8024790 <IPCC_UnmaskInterrupt>
  HAL_StatusTypeDef err = HAL_OK;
 8024816:	2000      	movs	r0, #0
 8024818:	e7db      	b.n	80247d2 <HAL_IPCC_ActivateNotification+0x12>
    err = HAL_ERROR;
 802481a:	2001      	movs	r0, #1
 802481c:	e7d9      	b.n	80247d2 <HAL_IPCC_ActivateNotification+0x12>
	...

08024820 <HAL_IPCC_NotifyCPU>:
{
 8024820:	b570      	push	{r4, r5, r6, lr}
 8024822:	000b      	movs	r3, r1
  if (hipcc->State == HAL_IPCC_STATE_READY)
 8024824:	2438      	movs	r4, #56	; 0x38
 8024826:	5d04      	ldrb	r4, [r0, r4]
 8024828:	2c01      	cmp	r4, #1
 802482a:	d001      	beq.n	8024830 <HAL_IPCC_NotifyCPU+0x10>
    err = HAL_ERROR;
 802482c:	2001      	movs	r0, #1
}
 802482e:	bd70      	pop	{r4, r5, r6, pc}
    currentInstance->SCR |= ((ChannelDir == IPCC_CHANNEL_DIR_TX) ? IPCC_SCR_CH1S : IPCC_SCR_CH1C) << (ChannelIndex & CHANNEL_INDEX_Msk) ;
 8024830:	490c      	ldr	r1, [pc, #48]	; (8024864 <HAL_IPCC_NotifyCPU+0x44>)
 8024832:	6889      	ldr	r1, [r1, #8]
 8024834:	2a00      	cmp	r2, #0
 8024836:	d10d      	bne.n	8024854 <HAL_IPCC_NotifyCPU+0x34>
 8024838:	2480      	movs	r4, #128	; 0x80
 802483a:	0264      	lsls	r4, r4, #9
 802483c:	250f      	movs	r5, #15
 802483e:	401d      	ands	r5, r3
 8024840:	40ac      	lsls	r4, r5
 8024842:	4321      	orrs	r1, r4
 8024844:	4d07      	ldr	r5, [pc, #28]	; (8024864 <HAL_IPCC_NotifyCPU+0x44>)
 8024846:	60a9      	str	r1, [r5, #8]
    if ((hipcc->callbackRequest & mask) == mask)
 8024848:	6b41      	ldr	r1, [r0, #52]	; 0x34
 802484a:	4021      	ands	r1, r4
 802484c:	428c      	cmp	r4, r1
 802484e:	d003      	beq.n	8024858 <HAL_IPCC_NotifyCPU+0x38>
  HAL_StatusTypeDef err = HAL_OK;
 8024850:	2000      	movs	r0, #0
 8024852:	e7ec      	b.n	802482e <HAL_IPCC_NotifyCPU+0xe>
    currentInstance->SCR |= ((ChannelDir == IPCC_CHANNEL_DIR_TX) ? IPCC_SCR_CH1S : IPCC_SCR_CH1C) << (ChannelIndex & CHANNEL_INDEX_Msk) ;
 8024854:	2401      	movs	r4, #1
 8024856:	e7f1      	b.n	802483c <HAL_IPCC_NotifyCPU+0x1c>
      IPCC_UnmaskInterrupt(ChannelIndex, ChannelDir);
 8024858:	0011      	movs	r1, r2
 802485a:	0018      	movs	r0, r3
 802485c:	f7ff ff98 	bl	8024790 <IPCC_UnmaskInterrupt>
  HAL_StatusTypeDef err = HAL_OK;
 8024860:	2000      	movs	r0, #0
 8024862:	e7e4      	b.n	802482e <HAL_IPCC_NotifyCPU+0xe>
 8024864:	58000c10 	.word	0x58000c10

08024868 <IPCC_SetDefaultCallbacks>:
  */
void IPCC_SetDefaultCallbacks(IPCC_HandleTypeDef *hipcc)
{
  uint32_t i;
  /* Set all callbacks to default */
  for (i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 8024868:	2200      	movs	r2, #0
 802486a:	e009      	b.n	8024880 <IPCC_SetDefaultCallbacks+0x18>
  {
    hipcc->ChannelCallbackRx[i] = HAL_IPCC_RxCallback;
 802486c:	0093      	lsls	r3, r2, #2
 802486e:	18c3      	adds	r3, r0, r3
 8024870:	4905      	ldr	r1, [pc, #20]	; (8024888 <IPCC_SetDefaultCallbacks+0x20>)
 8024872:	6059      	str	r1, [r3, #4]
    hipcc->ChannelCallbackTx[i] = HAL_IPCC_TxCallback;
 8024874:	1d93      	adds	r3, r2, #6
 8024876:	009b      	lsls	r3, r3, #2
 8024878:	18c3      	adds	r3, r0, r3
 802487a:	4904      	ldr	r1, [pc, #16]	; (802488c <IPCC_SetDefaultCallbacks+0x24>)
 802487c:	6059      	str	r1, [r3, #4]
  for (i = 0; i < IPCC_CHANNEL_NUMBER; i++)
 802487e:	3201      	adds	r2, #1
 8024880:	2a05      	cmp	r2, #5
 8024882:	d9f3      	bls.n	802486c <IPCC_SetDefaultCallbacks+0x4>
  }
}
 8024884:	4770      	bx	lr
 8024886:	46c0      	nop			; (mov r8, r8)
 8024888:	080246e9 	.word	0x080246e9
 802488c:	080246eb 	.word	0x080246eb

08024890 <IPCC_Reset_Register>:
  * @param  Instance pointer to register
  */
void IPCC_Reset_Register(IPCC_CommonTypeDef *Instance)
{
  /* Disable RX and TX interrupts */
  Instance->CR  = 0x00000000U;
 8024890:	2300      	movs	r3, #0
 8024892:	6003      	str	r3, [r0, #0]

  /* Mask RX and TX interrupts */
  Instance->MR  = (IPCC_ALL_TX_BUF | IPCC_ALL_RX_BUF);
 8024894:	4b02      	ldr	r3, [pc, #8]	; (80248a0 <IPCC_Reset_Register+0x10>)
 8024896:	6043      	str	r3, [r0, #4]

  /* Clear RX status */
  Instance->SCR = IPCC_ALL_RX_BUF;
 8024898:	233f      	movs	r3, #63	; 0x3f
 802489a:	6083      	str	r3, [r0, #8]
}
 802489c:	4770      	bx	lr
 802489e:	46c0      	nop			; (mov r8, r8)
 80248a0:	003f003f 	.word	0x003f003f

080248a4 <HAL_IPCC_Init>:
{
 80248a4:	b570      	push	{r4, r5, r6, lr}
 80248a6:	1e04      	subs	r4, r0, #0
  if (hipcc != NULL)
 80248a8:	d018      	beq.n	80248dc <HAL_IPCC_Init+0x38>
    if (hipcc->State == HAL_IPCC_STATE_RESET)
 80248aa:	2338      	movs	r3, #56	; 0x38
 80248ac:	5cc3      	ldrb	r3, [r0, r3]
 80248ae:	2b00      	cmp	r3, #0
 80248b0:	d011      	beq.n	80248d6 <HAL_IPCC_Init+0x32>
    IPCC_Reset_Register(currentInstance);
 80248b2:	4d0b      	ldr	r5, [pc, #44]	; (80248e0 <HAL_IPCC_Init+0x3c>)
 80248b4:	0028      	movs	r0, r5
 80248b6:	f7ff ffeb 	bl	8024890 <IPCC_Reset_Register>
    currentInstance->CR |= (IPCC_CR_RXOIE | IPCC_CR_TXFIE);
 80248ba:	682a      	ldr	r2, [r5, #0]
 80248bc:	4b09      	ldr	r3, [pc, #36]	; (80248e4 <HAL_IPCC_Init+0x40>)
 80248be:	4313      	orrs	r3, r2
 80248c0:	602b      	str	r3, [r5, #0]
    IPCC_SetDefaultCallbacks(hipcc);
 80248c2:	0020      	movs	r0, r4
 80248c4:	f7ff ffd0 	bl	8024868 <IPCC_SetDefaultCallbacks>
    hipcc->callbackRequest = 0;
 80248c8:	2300      	movs	r3, #0
 80248ca:	6363      	str	r3, [r4, #52]	; 0x34
    hipcc->State = HAL_IPCC_STATE_READY;
 80248cc:	3338      	adds	r3, #56	; 0x38
 80248ce:	2201      	movs	r2, #1
 80248d0:	54e2      	strb	r2, [r4, r3]
  HAL_StatusTypeDef err = HAL_OK;
 80248d2:	2000      	movs	r0, #0
}
 80248d4:	bd70      	pop	{r4, r5, r6, pc}
      HAL_IPCC_MspInit(hipcc);
 80248d6:	f7fc fe3d 	bl	8021554 <HAL_IPCC_MspInit>
 80248da:	e7ea      	b.n	80248b2 <HAL_IPCC_Init+0xe>
    err = HAL_ERROR;
 80248dc:	2001      	movs	r0, #1
 80248de:	e7f9      	b.n	80248d4 <HAL_IPCC_Init+0x30>
 80248e0:	58000c10 	.word	0x58000c10
 80248e4:	00010001 	.word	0x00010001

080248e8 <HAL_PWR_EnableBkUpAccess>:
  *         backup domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80248e8:	4a03      	ldr	r2, [pc, #12]	; (80248f8 <HAL_PWR_EnableBkUpAccess+0x10>)
 80248ea:	6811      	ldr	r1, [r2, #0]
 80248ec:	2380      	movs	r3, #128	; 0x80
 80248ee:	005b      	lsls	r3, r3, #1
 80248f0:	430b      	orrs	r3, r1
 80248f2:	6013      	str	r3, [r2, #0]
}
 80248f4:	4770      	bx	lr
 80248f6:	46c0      	nop			; (mov r8, r8)
 80248f8:	58000400 	.word	0x58000400

080248fc <HAL_PWR_EnterSLEEPMode>:
  * @note  When WFI entry is used, tick interrupt have to be disabled if not desired as
  *        the interrupt wake up source.
  * @retval None
  */
void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
{
 80248fc:	b510      	push	{r4, lr}
 80248fe:	000c      	movs	r4, r1
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(Regulator));
  assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));

  /* Set Regulator parameter */
  if (Regulator == PWR_MAINREGULATOR_ON)
 8024900:	2800      	cmp	r0, #0
 8024902:	d113      	bne.n	802492c <HAL_PWR_EnterSLEEPMode+0x30>
  {
    /* If in low-power run mode at this point, exit it */
    if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 8024904:	4b0e      	ldr	r3, [pc, #56]	; (8024940 <HAL_PWR_EnterSLEEPMode+0x44>)
 8024906:	695b      	ldr	r3, [r3, #20]
 8024908:	059b      	lsls	r3, r3, #22
 802490a:	d40a      	bmi.n	8024922 <HAL_PWR_EnterSLEEPMode+0x26>
      HAL_PWREx_EnableLowPowerRunMode();
    }
  }

  /* Clear SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 802490c:	4a0d      	ldr	r2, [pc, #52]	; (8024944 <HAL_PWR_EnterSLEEPMode+0x48>)
 802490e:	6913      	ldr	r3, [r2, #16]
 8024910:	2104      	movs	r1, #4
 8024912:	438b      	bics	r3, r1
 8024914:	6113      	str	r3, [r2, #16]

  /* Select SLEEP mode entry -------------------------------------------------*/
  if (SLEEPEntry == PWR_SLEEPENTRY_WFI)
 8024916:	2c01      	cmp	r4, #1
 8024918:	d00f      	beq.n	802493a <HAL_PWR_EnterSLEEPMode+0x3e>
    __WFI();
  }
  else
  {
    /* Request Wait For Event */
    __SEV();
 802491a:	bf40      	sev
    __WFE();
 802491c:	bf20      	wfe
    __WFE();
 802491e:	bf20      	wfe
  }
}
 8024920:	bd10      	pop	{r4, pc}
      if (HAL_PWREx_DisableLowPowerRunMode() != HAL_OK)
 8024922:	f000 f81b 	bl	802495c <HAL_PWREx_DisableLowPowerRunMode>
 8024926:	2800      	cmp	r0, #0
 8024928:	d0f0      	beq.n	802490c <HAL_PWR_EnterSLEEPMode+0x10>
 802492a:	e7f9      	b.n	8024920 <HAL_PWR_EnterSLEEPMode+0x24>
    if (HAL_IS_BIT_CLR(PWR->SR2, (PWR_SR2_REGLPF)))
 802492c:	4b04      	ldr	r3, [pc, #16]	; (8024940 <HAL_PWR_EnterSLEEPMode+0x44>)
 802492e:	695b      	ldr	r3, [r3, #20]
 8024930:	059b      	lsls	r3, r3, #22
 8024932:	d4eb      	bmi.n	802490c <HAL_PWR_EnterSLEEPMode+0x10>
      HAL_PWREx_EnableLowPowerRunMode();
 8024934:	f000 f808 	bl	8024948 <HAL_PWREx_EnableLowPowerRunMode>
 8024938:	e7e8      	b.n	802490c <HAL_PWR_EnterSLEEPMode+0x10>
    __WFI();
 802493a:	bf30      	wfi
 802493c:	e7f0      	b.n	8024920 <HAL_PWR_EnterSLEEPMode+0x24>
 802493e:	46c0      	nop			; (mov r8, r8)
 8024940:	58000400 	.word	0x58000400
 8024944:	e000ed00 	.word	0xe000ed00

08024948 <HAL_PWREx_EnableLowPowerRunMode>:
  * @retval None
  */
void HAL_PWREx_EnableLowPowerRunMode(void)
{
  /* Set Regulator parameter */
  SET_BIT(PWR->CR1, PWR_CR1_LPR);
 8024948:	4a03      	ldr	r2, [pc, #12]	; (8024958 <HAL_PWREx_EnableLowPowerRunMode+0x10>)
 802494a:	6811      	ldr	r1, [r2, #0]
 802494c:	2380      	movs	r3, #128	; 0x80
 802494e:	01db      	lsls	r3, r3, #7
 8024950:	430b      	orrs	r3, r1
 8024952:	6013      	str	r3, [r2, #0]
}
 8024954:	4770      	bx	lr
 8024956:	46c0      	nop			; (mov r8, r8)
 8024958:	58000400 	.word	0x58000400

0802495c <HAL_PWREx_DisableLowPowerRunMode>:
  *        returns HAL_TIMEOUT status). The system clock frequency can then be
  *        increased above 2 MHz.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_DisableLowPowerRunMode(void)
{
 802495c:	b510      	push	{r4, lr}
  uint32_t wait_loop_index;

  /* Clear LPR bit */
  CLEAR_BIT(PWR->CR1, PWR_CR1_LPR);
 802495e:	4a0e      	ldr	r2, [pc, #56]	; (8024998 <HAL_PWREx_DisableLowPowerRunMode+0x3c>)
 8024960:	6813      	ldr	r3, [r2, #0]
 8024962:	490e      	ldr	r1, [pc, #56]	; (802499c <HAL_PWREx_DisableLowPowerRunMode+0x40>)
 8024964:	400b      	ands	r3, r1
 8024966:	6013      	str	r3, [r2, #0]

  /* Wait until REGLPF is reset */
  wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000UL);
 8024968:	4b0d      	ldr	r3, [pc, #52]	; (80249a0 <HAL_PWREx_DisableLowPowerRunMode+0x44>)
 802496a:	6818      	ldr	r0, [r3, #0]
 802496c:	2332      	movs	r3, #50	; 0x32
 802496e:	4358      	muls	r0, r3
 8024970:	490c      	ldr	r1, [pc, #48]	; (80249a4 <HAL_PWREx_DisableLowPowerRunMode+0x48>)
 8024972:	f7fb fbd1 	bl	8020118 <__udivsi3>
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
 8024976:	e000      	b.n	802497a <HAL_PWREx_DisableLowPowerRunMode+0x1e>
  {
    wait_loop_index--;
 8024978:	3801      	subs	r0, #1
  while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_REGLPF)) && (wait_loop_index != 0U))
 802497a:	4b07      	ldr	r3, [pc, #28]	; (8024998 <HAL_PWREx_DisableLowPowerRunMode+0x3c>)
 802497c:	695b      	ldr	r3, [r3, #20]
 802497e:	059b      	lsls	r3, r3, #22
 8024980:	d501      	bpl.n	8024986 <HAL_PWREx_DisableLowPowerRunMode+0x2a>
 8024982:	2800      	cmp	r0, #0
 8024984:	d1f8      	bne.n	8024978 <HAL_PWREx_DisableLowPowerRunMode+0x1c>
  }
  if (HAL_IS_BIT_SET(PWR->SR2, (PWR_SR2_REGLPF)))
 8024986:	4b04      	ldr	r3, [pc, #16]	; (8024998 <HAL_PWREx_DisableLowPowerRunMode+0x3c>)
 8024988:	695b      	ldr	r3, [r3, #20]
 802498a:	059b      	lsls	r3, r3, #22
 802498c:	d401      	bmi.n	8024992 <HAL_PWREx_DisableLowPowerRunMode+0x36>
  {
    return HAL_TIMEOUT;
  }

  return HAL_OK;
 802498e:	2000      	movs	r0, #0
}
 8024990:	bd10      	pop	{r4, pc}
    return HAL_TIMEOUT;
 8024992:	2003      	movs	r0, #3
 8024994:	e7fc      	b.n	8024990 <HAL_PWREx_DisableLowPowerRunMode+0x34>
 8024996:	46c0      	nop			; (mov r8, r8)
 8024998:	58000400 	.word	0x58000400
 802499c:	ffffbfff 	.word	0xffffbfff
 80249a0:	2000b04c 	.word	0x2000b04c
 80249a4:	000f4240 	.word	0x000f4240

080249a8 <HAL_PWREx_EnterSTOP2Mode>:
  *            @arg @ref PWR_STOPENTRY_WFI  Enter Stop mode with WFI instruction
  *            @arg @ref PWR_STOPENTRY_WFE  Enter Stop mode with WFE instruction
  * @retval None
  */
void HAL_PWREx_EnterSTOP2Mode(uint8_t STOPEntry)
{
 80249a8:	b510      	push	{r4, lr}
  /* Check the parameter */
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));

#ifdef CORE_CM0PLUS
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->C2CR1, PWR_C2CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
 80249aa:	490d      	ldr	r1, [pc, #52]	; (80249e0 <HAL_PWREx_EnterSTOP2Mode+0x38>)
 80249ac:	2280      	movs	r2, #128	; 0x80
 80249ae:	588b      	ldr	r3, [r1, r2]
 80249b0:	2407      	movs	r4, #7
 80249b2:	43a3      	bics	r3, r4
 80249b4:	3c05      	subs	r4, #5
 80249b6:	4323      	orrs	r3, r4
 80249b8:	508b      	str	r3, [r1, r2]
  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_LOWPOWERMODE_STOP2);
#endif

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 80249ba:	4a0a      	ldr	r2, [pc, #40]	; (80249e4 <HAL_PWREx_EnterSTOP2Mode+0x3c>)
 80249bc:	6913      	ldr	r3, [r2, #16]
 80249be:	2104      	movs	r1, #4
 80249c0:	430b      	orrs	r3, r1
 80249c2:	6113      	str	r3, [r2, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if (STOPEntry == PWR_STOPENTRY_WFI)
 80249c4:	2801      	cmp	r0, #1
 80249c6:	d008      	beq.n	80249da <HAL_PWREx_EnterSTOP2Mode+0x32>
    __WFI();
  }
  else
  {
    /* Request Wait For Event */
    __SEV();
 80249c8:	bf40      	sev
    __WFE();
 80249ca:	bf20      	wfe
    __WFE();
 80249cc:	bf20      	wfe
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 80249ce:	4a05      	ldr	r2, [pc, #20]	; (80249e4 <HAL_PWREx_EnterSTOP2Mode+0x3c>)
 80249d0:	6913      	ldr	r3, [r2, #16]
 80249d2:	2104      	movs	r1, #4
 80249d4:	438b      	bics	r3, r1
 80249d6:	6113      	str	r3, [r2, #16]
}
 80249d8:	bd10      	pop	{r4, pc}
    __WFI();
 80249da:	bf30      	wfi
 80249dc:	e7f7      	b.n	80249ce <HAL_PWREx_EnterSTOP2Mode+0x26>
 80249de:	46c0      	nop			; (mov r8, r8)
 80249e0:	58000400 	.word	0x58000400
 80249e4:	e000ed00 	.word	0xe000ed00

080249e8 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80249e8:	b510      	push	{r4, lr}
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 80249ea:	23b0      	movs	r3, #176	; 0xb0
 80249ec:	05db      	lsls	r3, r3, #23
 80249ee:	689a      	ldr	r2, [r3, #8]
 80249f0:	210c      	movs	r1, #12
 80249f2:	000c      	movs	r4, r1
 80249f4:	4014      	ands	r4, r2
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 80249f6:	68d8      	ldr	r0, [r3, #12]
 80249f8:	2303      	movs	r3, #3
 80249fa:	4003      	ands	r3, r0
  uint32_t pllinputfreq;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
  pllsource = __HAL_RCC_GET_PLL_OSCSOURCE();

  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 80249fc:	4211      	tst	r1, r2
 80249fe:	d00a      	beq.n	8024a16 <HAL_RCC_GetSysClockFreq+0x2e>
 8024a00:	2c0c      	cmp	r4, #12
 8024a02:	d006      	beq.n	8024a12 <HAL_RCC_GetSysClockFreq+0x2a>
    {
      /* MSI used as system clock source */
      sysclockfreq = msifreq;
    }
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 8024a04:	2c04      	cmp	r4, #4
 8024a06:	d04f      	beq.n	8024aa8 <HAL_RCC_GetSysClockFreq+0xc0>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 8024a08:	2c08      	cmp	r4, #8
 8024a0a:	d040      	beq.n	8024a8e <HAL_RCC_GetSysClockFreq+0xa6>
  uint32_t msifreq = 0U;
 8024a0c:	2100      	movs	r1, #0
  uint32_t sysclockfreq = 0U;
 8024a0e:	2000      	movs	r0, #0
 8024a10:	e02a      	b.n	8024a68 <HAL_RCC_GetSysClockFreq+0x80>
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 8024a12:	2b01      	cmp	r3, #1
 8024a14:	d1f6      	bne.n	8024a04 <HAL_RCC_GetSysClockFreq+0x1c>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 8024a16:	23b0      	movs	r3, #176	; 0xb0
 8024a18:	05db      	lsls	r3, r3, #23
 8024a1a:	681a      	ldr	r2, [r3, #0]
 8024a1c:	2108      	movs	r1, #8
 8024a1e:	000b      	movs	r3, r1
 8024a20:	4013      	ands	r3, r2
 8024a22:	4211      	tst	r1, r2
 8024a24:	d00e      	beq.n	8024a44 <HAL_RCC_GetSysClockFreq+0x5c>
 8024a26:	23b0      	movs	r3, #176	; 0xb0
 8024a28:	05db      	lsls	r3, r3, #23
 8024a2a:	681a      	ldr	r2, [r3, #0]
 8024a2c:	000b      	movs	r3, r1
 8024a2e:	4013      	ands	r3, r2
 8024a30:	4211      	tst	r1, r2
 8024a32:	d125      	bne.n	8024a80 <HAL_RCC_GetSysClockFreq+0x98>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 8024a34:	21b0      	movs	r1, #176	; 0xb0
 8024a36:	05c9      	lsls	r1, r1, #23
 8024a38:	2294      	movs	r2, #148	; 0x94
 8024a3a:	588a      	ldr	r2, [r1, r2]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 8024a3c:	009b      	lsls	r3, r3, #2
 8024a3e:	4a31      	ldr	r2, [pc, #196]	; (8024b04 <HAL_RCC_GetSysClockFreq+0x11c>)
 8024a40:	5899      	ldr	r1, [r3, r2]
 8024a42:	e00e      	b.n	8024a62 <HAL_RCC_GetSysClockFreq+0x7a>
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 8024a44:	22b0      	movs	r2, #176	; 0xb0
 8024a46:	05d2      	lsls	r2, r2, #23
 8024a48:	6812      	ldr	r2, [r2, #0]
 8024a4a:	0712      	lsls	r2, r2, #28
 8024a4c:	d414      	bmi.n	8024a78 <HAL_RCC_GetSysClockFreq+0x90>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 8024a4e:	22b0      	movs	r2, #176	; 0xb0
 8024a50:	05d2      	lsls	r2, r2, #23
 8024a52:	2394      	movs	r3, #148	; 0x94
 8024a54:	58d2      	ldr	r2, [r2, r3]
 8024a56:	0a12      	lsrs	r2, r2, #8
 8024a58:	3b85      	subs	r3, #133	; 0x85
 8024a5a:	4013      	ands	r3, r2
 8024a5c:	009b      	lsls	r3, r3, #2
 8024a5e:	4a29      	ldr	r2, [pc, #164]	; (8024b04 <HAL_RCC_GetSysClockFreq+0x11c>)
 8024a60:	5899      	ldr	r1, [r3, r2]
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8024a62:	2c00      	cmp	r4, #0
 8024a64:	d01e      	beq.n	8024aa4 <HAL_RCC_GetSysClockFreq+0xbc>
  uint32_t sysclockfreq = 0U;
 8024a66:	2000      	movs	r0, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8024a68:	23b0      	movs	r3, #176	; 0xb0
 8024a6a:	05db      	lsls	r3, r3, #23
 8024a6c:	689a      	ldr	r2, [r3, #8]
 8024a6e:	230c      	movs	r3, #12
 8024a70:	4013      	ands	r3, r2
  else
  {
    /* Nothing to do */
  }

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8024a72:	2b0c      	cmp	r3, #12
 8024a74:	d01e      	beq.n	8024ab4 <HAL_RCC_GetSysClockFreq+0xcc>
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
                                             LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
  }

  return sysclockfreq;
}
 8024a76:	bd10      	pop	{r4, pc}
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 8024a78:	22b0      	movs	r2, #176	; 0xb0
 8024a7a:	05d2      	lsls	r2, r2, #23
 8024a7c:	6812      	ldr	r2, [r2, #0]
 8024a7e:	e7ed      	b.n	8024a5c <HAL_RCC_GetSysClockFreq+0x74>
 8024a80:	23b0      	movs	r3, #176	; 0xb0
 8024a82:	05db      	lsls	r3, r3, #23
 8024a84:	681a      	ldr	r2, [r3, #0]
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 8024a86:	0912      	lsrs	r2, r2, #4
 8024a88:	230f      	movs	r3, #15
 8024a8a:	4013      	ands	r3, r2
 8024a8c:	e7d6      	b.n	8024a3c <HAL_RCC_GetSysClockFreq+0x54>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 8024a8e:	23b0      	movs	r3, #176	; 0xb0
 8024a90:	05db      	lsls	r3, r3, #23
 8024a92:	681a      	ldr	r2, [r3, #0]
 8024a94:	2380      	movs	r3, #128	; 0x80
 8024a96:	035b      	lsls	r3, r3, #13
 8024a98:	0011      	movs	r1, r2
 8024a9a:	4019      	ands	r1, r3
 8024a9c:	421a      	tst	r2, r3
 8024a9e:	d106      	bne.n	8024aae <HAL_RCC_GetSysClockFreq+0xc6>
      sysclockfreq = HSE_VALUE;
 8024aa0:	4819      	ldr	r0, [pc, #100]	; (8024b08 <HAL_RCC_GetSysClockFreq+0x120>)
 8024aa2:	e7e1      	b.n	8024a68 <HAL_RCC_GetSysClockFreq+0x80>
      sysclockfreq = msifreq;
 8024aa4:	0008      	movs	r0, r1
 8024aa6:	e7df      	b.n	8024a68 <HAL_RCC_GetSysClockFreq+0x80>
  uint32_t msifreq = 0U;
 8024aa8:	2100      	movs	r1, #0
    sysclockfreq = HSI_VALUE;
 8024aaa:	4818      	ldr	r0, [pc, #96]	; (8024b0c <HAL_RCC_GetSysClockFreq+0x124>)
 8024aac:	e7dc      	b.n	8024a68 <HAL_RCC_GetSysClockFreq+0x80>
  uint32_t msifreq = 0U;
 8024aae:	2100      	movs	r1, #0
      sysclockfreq = HSE_VALUE / 2U;
 8024ab0:	4816      	ldr	r0, [pc, #88]	; (8024b0c <HAL_RCC_GetSysClockFreq+0x124>)
 8024ab2:	e7d9      	b.n	8024a68 <HAL_RCC_GetSysClockFreq+0x80>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8024ab4:	23b0      	movs	r3, #176	; 0xb0
 8024ab6:	05db      	lsls	r3, r3, #23
 8024ab8:	68da      	ldr	r2, [r3, #12]
 8024aba:	2303      	movs	r3, #3
 8024abc:	4013      	ands	r3, r2
    switch (pllsource)
 8024abe:	2b02      	cmp	r3, #2
 8024ac0:	d008      	beq.n	8024ad4 <HAL_RCC_GetSysClockFreq+0xec>
 8024ac2:	2b03      	cmp	r3, #3
 8024ac4:	d107      	bne.n	8024ad6 <HAL_RCC_GetSysClockFreq+0xee>
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 8024ac6:	23b0      	movs	r3, #176	; 0xb0
 8024ac8:	05db      	lsls	r3, r3, #23
 8024aca:	681b      	ldr	r3, [r3, #0]
 8024acc:	02db      	lsls	r3, r3, #11
 8024ace:	d416      	bmi.n	8024afe <HAL_RCC_GetSysClockFreq+0x116>
          pllinputfreq = HSE_VALUE;
 8024ad0:	490d      	ldr	r1, [pc, #52]	; (8024b08 <HAL_RCC_GetSysClockFreq+0x120>)
 8024ad2:	e000      	b.n	8024ad6 <HAL_RCC_GetSysClockFreq+0xee>
    switch (pllsource)
 8024ad4:	490d      	ldr	r1, [pc, #52]	; (8024b0c <HAL_RCC_GetSysClockFreq+0x124>)
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 8024ad6:	24b0      	movs	r4, #176	; 0xb0
 8024ad8:	05e4      	lsls	r4, r4, #23
 8024ada:	68e3      	ldr	r3, [r4, #12]
 8024adc:	0a1b      	lsrs	r3, r3, #8
 8024ade:	207f      	movs	r0, #127	; 0x7f
 8024ae0:	4018      	ands	r0, r3
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 8024ae2:	4348      	muls	r0, r1
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 8024ae4:	68e3      	ldr	r3, [r4, #12]
 8024ae6:	091b      	lsrs	r3, r3, #4
 8024ae8:	2107      	movs	r1, #7
 8024aea:	4019      	ands	r1, r3
 8024aec:	3101      	adds	r1, #1
 8024aee:	f7fb fb13 	bl	8020118 <__udivsi3>
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 8024af2:	68e1      	ldr	r1, [r4, #12]
 8024af4:	0f49      	lsrs	r1, r1, #29
 8024af6:	3101      	adds	r1, #1
 8024af8:	f7fb fb0e 	bl	8020118 <__udivsi3>
  return sysclockfreq;
 8024afc:	e7bb      	b.n	8024a76 <HAL_RCC_GetSysClockFreq+0x8e>
          pllinputfreq = HSE_VALUE / 2U;
 8024afe:	4903      	ldr	r1, [pc, #12]	; (8024b0c <HAL_RCC_GetSysClockFreq+0x124>)
 8024b00:	e7e9      	b.n	8024ad6 <HAL_RCC_GetSysClockFreq+0xee>
 8024b02:	46c0      	nop			; (mov r8, r8)
 8024b04:	08035034 	.word	0x08035034
 8024b08:	01e84800 	.word	0x01e84800
 8024b0c:	00f42400 	.word	0x00f42400

08024b10 <HAL_RCC_GetHCLK2Freq>:
/**
  * @brief  Return the HCLK2 frequency.
  * @retval HCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetHCLK2Freq(void)
{
 8024b10:	b510      	push	{r4, lr}
  /* Get SysClock and Compute HCLK2 frequency --------------------------------*/
  return ((uint32_t)(__LL_RCC_CALC_HCLK2_FREQ(HAL_RCC_GetSysClockFreq(), LL_C2_RCC_GetAHBPrescaler())));
 8024b12:	f7ff ff69 	bl	80249e8 <HAL_RCC_GetSysClockFreq>
  return (uint32_t)(READ_BIT(RCC->EXTCFGR, RCC_EXTCFGR_C2HPRE));
 8024b16:	22b0      	movs	r2, #176	; 0xb0
 8024b18:	05d2      	lsls	r2, r2, #23
 8024b1a:	2384      	movs	r3, #132	; 0x84
 8024b1c:	005b      	lsls	r3, r3, #1
 8024b1e:	58d2      	ldr	r2, [r2, r3]
 8024b20:	0912      	lsrs	r2, r2, #4
 8024b22:	3bf9      	subs	r3, #249	; 0xf9
 8024b24:	4013      	ands	r3, r2
 8024b26:	009b      	lsls	r3, r3, #2
 8024b28:	4a02      	ldr	r2, [pc, #8]	; (8024b34 <HAL_RCC_GetHCLK2Freq+0x24>)
 8024b2a:	5899      	ldr	r1, [r3, r2]
 8024b2c:	f7fb faf4 	bl	8020118 <__udivsi3>
}
 8024b30:	bd10      	pop	{r4, pc}
 8024b32:	46c0      	nop			; (mov r8, r8)
 8024b34:	08034ff4 	.word	0x08034ff4

08024b38 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8024b38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8024b3a:	0004      	movs	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8024b3c:	6803      	ldr	r3, [r0, #0]
 8024b3e:	03db      	lsls	r3, r3, #15
 8024b40:	d500      	bpl.n	8024b44 <HAL_RCCEx_PeriphCLKConfig+0xc>
 8024b42:	e099      	b.n	8024c78 <HAL_RCCEx_PeriphCLKConfig+0x140>
  HAL_StatusTypeDef status  = HAL_OK;   /* Final status */
 8024b44:	2500      	movs	r5, #0
    }

  }

  /*-------------------- USART1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8024b46:	6823      	ldr	r3, [r4, #0]
 8024b48:	07db      	lsls	r3, r3, #31
 8024b4a:	d50a      	bpl.n	8024b62 <HAL_RCCEx_PeriphCLKConfig+0x2a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8024b4c:	6863      	ldr	r3, [r4, #4]
  MODIFY_REG(RCC->CCIPR, (USARTxSource >> 16), (USARTxSource & 0x0000FFFFU));
 8024b4e:	20b0      	movs	r0, #176	; 0xb0
 8024b50:	05c0      	lsls	r0, r0, #23
 8024b52:	2188      	movs	r1, #136	; 0x88
 8024b54:	5842      	ldr	r2, [r0, r1]
 8024b56:	0c1e      	lsrs	r6, r3, #16
 8024b58:	43b2      	bics	r2, r6
 8024b5a:	041b      	lsls	r3, r3, #16
 8024b5c:	0c1b      	lsrs	r3, r3, #16
 8024b5e:	4313      	orrs	r3, r2
 8024b60:	5043      	str	r3, [r0, r1]
  }

  /*-------------------- USART2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8024b62:	6823      	ldr	r3, [r4, #0]
 8024b64:	079b      	lsls	r3, r3, #30
 8024b66:	d50a      	bpl.n	8024b7e <HAL_RCCEx_PeriphCLKConfig+0x46>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8024b68:	68a3      	ldr	r3, [r4, #8]
 8024b6a:	20b0      	movs	r0, #176	; 0xb0
 8024b6c:	05c0      	lsls	r0, r0, #23
 8024b6e:	2188      	movs	r1, #136	; 0x88
 8024b70:	5842      	ldr	r2, [r0, r1]
 8024b72:	0c1e      	lsrs	r6, r3, #16
 8024b74:	43b2      	bics	r2, r6
 8024b76:	041b      	lsls	r3, r3, #16
 8024b78:	0c1b      	lsrs	r3, r3, #16
 8024b7a:	4313      	orrs	r3, r2
 8024b7c:	5043      	str	r3, [r0, r1]
  }

  /*-------------------- LPUART1 clock source configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8024b7e:	6823      	ldr	r3, [r4, #0]
 8024b80:	069b      	lsls	r3, r3, #26
 8024b82:	d508      	bpl.n	8024b96 <HAL_RCCEx_PeriphCLKConfig+0x5e>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_LPUART1SEL, LPUARTxSource);
 8024b84:	21b0      	movs	r1, #176	; 0xb0
 8024b86:	05c9      	lsls	r1, r1, #23
 8024b88:	2288      	movs	r2, #136	; 0x88
 8024b8a:	588b      	ldr	r3, [r1, r2]
 8024b8c:	4880      	ldr	r0, [pc, #512]	; (8024d90 <HAL_RCCEx_PeriphCLKConfig+0x258>)
 8024b8e:	4003      	ands	r3, r0
 8024b90:	6920      	ldr	r0, [r4, #16]
 8024b92:	4303      	orrs	r3, r0
 8024b94:	508b      	str	r3, [r1, r2]
    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
  }

  /*-------------------- LPTIM1 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8024b96:	6823      	ldr	r3, [r4, #0]
 8024b98:	059b      	lsls	r3, r3, #22
 8024b9a:	d50a      	bpl.n	8024bb2 <HAL_RCCEx_PeriphCLKConfig+0x7a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8024b9c:	6a22      	ldr	r2, [r4, #32]
  MODIFY_REG(RCC->CCIPR, (LPTIMxSource & 0xFFFF0000U), (LPTIMxSource << 16));
 8024b9e:	26b0      	movs	r6, #176	; 0xb0
 8024ba0:	05f6      	lsls	r6, r6, #23
 8024ba2:	2088      	movs	r0, #136	; 0x88
 8024ba4:	5833      	ldr	r3, [r6, r0]
 8024ba6:	0c11      	lsrs	r1, r2, #16
 8024ba8:	0409      	lsls	r1, r1, #16
 8024baa:	438b      	bics	r3, r1
 8024bac:	0412      	lsls	r2, r2, #16
 8024bae:	4313      	orrs	r3, r2
 8024bb0:	5033      	str	r3, [r6, r0]
  }

  /*-------------------- LPTIM2 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8024bb2:	6823      	ldr	r3, [r4, #0]
 8024bb4:	055b      	lsls	r3, r3, #21
 8024bb6:	d50a      	bpl.n	8024bce <HAL_RCCEx_PeriphCLKConfig+0x96>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM2CLKSOURCE(PeriphClkInit->Lptim2ClockSelection));

    /* Configure the LPTIM2 clock source */
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8024bb8:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8024bba:	26b0      	movs	r6, #176	; 0xb0
 8024bbc:	05f6      	lsls	r6, r6, #23
 8024bbe:	2088      	movs	r0, #136	; 0x88
 8024bc0:	5833      	ldr	r3, [r6, r0]
 8024bc2:	0c11      	lsrs	r1, r2, #16
 8024bc4:	0409      	lsls	r1, r1, #16
 8024bc6:	438b      	bics	r3, r1
 8024bc8:	0412      	lsls	r2, r2, #16
 8024bca:	4313      	orrs	r3, r2
 8024bcc:	5033      	str	r3, [r6, r0]
  }

  /*-------------------- LPTIM3 clock source configuration -------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM3) == (RCC_PERIPHCLK_LPTIM3))
 8024bce:	6823      	ldr	r3, [r4, #0]
 8024bd0:	051b      	lsls	r3, r3, #20
 8024bd2:	d50a      	bpl.n	8024bea <HAL_RCCEx_PeriphCLKConfig+0xb2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM3CLKSOURCE(PeriphClkInit->Lptim3ClockSelection));

    /* Configure the LPTIM3 clock source */
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
 8024bd4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8024bd6:	26b0      	movs	r6, #176	; 0xb0
 8024bd8:	05f6      	lsls	r6, r6, #23
 8024bda:	2088      	movs	r0, #136	; 0x88
 8024bdc:	5833      	ldr	r3, [r6, r0]
 8024bde:	0c11      	lsrs	r1, r2, #16
 8024be0:	0409      	lsls	r1, r1, #16
 8024be2:	438b      	bics	r3, r1
 8024be4:	0412      	lsls	r2, r2, #16
 8024be6:	4313      	orrs	r3, r2
 8024be8:	5033      	str	r3, [r6, r0]
  }

  /*-------------------- I2C1 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8024bea:	6823      	ldr	r3, [r4, #0]
 8024bec:	065b      	lsls	r3, r3, #25
 8024bee:	d500      	bpl.n	8024bf2 <HAL_RCCEx_PeriphCLKConfig+0xba>
 8024bf0:	e092      	b.n	8024d18 <HAL_RCCEx_PeriphCLKConfig+0x1e0>
    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
  }

  /*-------------------- I2C2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8024bf2:	6823      	ldr	r3, [r4, #0]
 8024bf4:	061b      	lsls	r3, r3, #24
 8024bf6:	d500      	bpl.n	8024bfa <HAL_RCCEx_PeriphCLKConfig+0xc2>
 8024bf8:	e09d      	b.n	8024d36 <HAL_RCCEx_PeriphCLKConfig+0x1fe>
    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
  }

  /*-------------------- I2C3 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8024bfa:	6823      	ldr	r3, [r4, #0]
 8024bfc:	05db      	lsls	r3, r3, #23
 8024bfe:	d500      	bpl.n	8024c02 <HAL_RCCEx_PeriphCLKConfig+0xca>
 8024c00:	e0a8      	b.n	8024d54 <HAL_RCCEx_PeriphCLKConfig+0x21c>
    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
  }

  /*-------------------- I2S2 clock source configuration ---------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S2) == (RCC_PERIPHCLK_I2S2))
 8024c02:	6823      	ldr	r3, [r4, #0]
 8024c04:	06db      	lsls	r3, r3, #27
 8024c06:	d50e      	bpl.n	8024c26 <HAL_RCCEx_PeriphCLKConfig+0xee>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_I2S2SEL, I2SxSource);
 8024c08:	21b0      	movs	r1, #176	; 0xb0
 8024c0a:	05c9      	lsls	r1, r1, #23
 8024c0c:	2288      	movs	r2, #136	; 0x88
 8024c0e:	588b      	ldr	r3, [r1, r2]
 8024c10:	4860      	ldr	r0, [pc, #384]	; (8024d94 <HAL_RCCEx_PeriphCLKConfig+0x25c>)
 8024c12:	4003      	ands	r3, r0
 8024c14:	68e0      	ldr	r0, [r4, #12]
 8024c16:	4303      	orrs	r3, r0
 8024c18:	508b      	str	r3, [r1, r2]
    assert_param(IS_RCC_I2S2CLKSOURCE(PeriphClkInit->I2s2ClockSelection));

    /* Configure the I2S2 clock source */
    __HAL_RCC_I2S2_CONFIG(PeriphClkInit->I2s2ClockSelection);

    if (PeriphClkInit->I2s2ClockSelection == RCC_I2S2CLKSOURCE_PLL)
 8024c1a:	2380      	movs	r3, #128	; 0x80
 8024c1c:	005b      	lsls	r3, r3, #1
 8024c1e:	68e2      	ldr	r2, [r4, #12]
 8024c20:	429a      	cmp	r2, r3
 8024c22:	d100      	bne.n	8024c26 <HAL_RCCEx_PeriphCLKConfig+0xee>
 8024c24:	e0a5      	b.n	8024d72 <HAL_RCCEx_PeriphCLKConfig+0x23a>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_I2S2CLK);
    }
  }

  /*-------------------- RNG clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8024c26:	6823      	ldr	r3, [r4, #0]
 8024c28:	041b      	lsls	r3, r3, #16
 8024c2a:	d511      	bpl.n	8024c50 <HAL_RCCEx_PeriphCLKConfig+0x118>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_RNGSEL, RNGxSource);
 8024c2c:	21b0      	movs	r1, #176	; 0xb0
 8024c2e:	05c9      	lsls	r1, r1, #23
 8024c30:	2288      	movs	r2, #136	; 0x88
 8024c32:	588b      	ldr	r3, [r1, r2]
 8024c34:	009b      	lsls	r3, r3, #2
 8024c36:	089b      	lsrs	r3, r3, #2
 8024c38:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8024c3a:	4303      	orrs	r3, r0
 8024c3c:	508b      	str	r3, [r1, r2]
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);

    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8024c3e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8024c40:	2b00      	cmp	r3, #0
 8024c42:	d105      	bne.n	8024c50 <HAL_RCCEx_PeriphCLKConfig+0x118>
    {
      /* Enable RCC_PLL_RNGCLK output */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_RNGCLK);
 8024c44:	000a      	movs	r2, r1
 8024c46:	68c9      	ldr	r1, [r1, #12]
 8024c48:	2380      	movs	r3, #128	; 0x80
 8024c4a:	045b      	lsls	r3, r3, #17
 8024c4c:	430b      	orrs	r3, r1
 8024c4e:	60d3      	str	r3, [r2, #12]
    }
  }

  /*-------------------- ADC clock source configuration ----------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8024c50:	6823      	ldr	r3, [r4, #0]
 8024c52:	045b      	lsls	r3, r3, #17
 8024c54:	d50e      	bpl.n	8024c74 <HAL_RCCEx_PeriphCLKConfig+0x13c>
  MODIFY_REG(RCC->CCIPR, RCC_CCIPR_ADCSEL, ADCxSource);
 8024c56:	21b0      	movs	r1, #176	; 0xb0
 8024c58:	05c9      	lsls	r1, r1, #23
 8024c5a:	2288      	movs	r2, #136	; 0x88
 8024c5c:	588b      	ldr	r3, [r1, r2]
 8024c5e:	484e      	ldr	r0, [pc, #312]	; (8024d98 <HAL_RCCEx_PeriphCLKConfig+0x260>)
 8024c60:	4003      	ands	r3, r0
 8024c62:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8024c64:	4303      	orrs	r3, r0
 8024c66:	508b      	str	r3, [r1, r2]
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC interface clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);

    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLL)
 8024c68:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8024c6a:	2380      	movs	r3, #128	; 0x80
 8024c6c:	059b      	lsls	r3, r3, #22
 8024c6e:	429a      	cmp	r2, r3
 8024c70:	d100      	bne.n	8024c74 <HAL_RCCEx_PeriphCLKConfig+0x13c>
 8024c72:	e085      	b.n	8024d80 <HAL_RCCEx_PeriphCLKConfig+0x248>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
    }
  }

  return status;
}
 8024c74:	0028      	movs	r0, r5
 8024c76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    HAL_PWR_EnableBkUpAccess();
 8024c78:	f7ff fe36 	bl	80248e8 <HAL_PWR_EnableBkUpAccess>
    tickstart = HAL_GetTick();
 8024c7c:	f7fc ff94 	bl	8021ba8 <HAL_GetTick>
 8024c80:	0005      	movs	r5, r0
    while (!(READ_BIT(PWR->CR1, PWR_CR1_DBP) == (PWR_CR1_DBP)))
 8024c82:	4b46      	ldr	r3, [pc, #280]	; (8024d9c <HAL_RCCEx_PeriphCLKConfig+0x264>)
 8024c84:	681b      	ldr	r3, [r3, #0]
 8024c86:	05db      	lsls	r3, r3, #23
 8024c88:	d406      	bmi.n	8024c98 <HAL_RCCEx_PeriphCLKConfig+0x160>
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8024c8a:	f7fc ff8d 	bl	8021ba8 <HAL_GetTick>
 8024c8e:	1b40      	subs	r0, r0, r5
 8024c90:	2802      	cmp	r0, #2
 8024c92:	d9f6      	bls.n	8024c82 <HAL_RCCEx_PeriphCLKConfig+0x14a>
        ret = HAL_TIMEOUT;
 8024c94:	2503      	movs	r5, #3
 8024c96:	e000      	b.n	8024c9a <HAL_RCCEx_PeriphCLKConfig+0x162>
  HAL_StatusTypeDef ret = HAL_OK;   /* Intermediate status */
 8024c98:	2500      	movs	r5, #0
    if (ret == HAL_OK)
 8024c9a:	2d00      	cmp	r5, #0
 8024c9c:	d000      	beq.n	8024ca0 <HAL_RCCEx_PeriphCLKConfig+0x168>
 8024c9e:	e752      	b.n	8024b46 <HAL_RCCEx_PeriphCLKConfig+0xe>
  return (uint32_t)(READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL));
 8024ca0:	22b0      	movs	r2, #176	; 0xb0
 8024ca2:	05d2      	lsls	r2, r2, #23
 8024ca4:	2390      	movs	r3, #144	; 0x90
 8024ca6:	58d3      	ldr	r3, [r2, r3]
 8024ca8:	22c0      	movs	r2, #192	; 0xc0
 8024caa:	0092      	lsls	r2, r2, #2
 8024cac:	4013      	ands	r3, r2
      if (LL_RCC_GetRTCClockSource() != PeriphClkInit->RTCClockSelection)
 8024cae:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8024cb0:	429a      	cmp	r2, r3
 8024cb2:	d01e      	beq.n	8024cf2 <HAL_RCCEx_PeriphCLKConfig+0x1ba>
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8024cb4:	22b0      	movs	r2, #176	; 0xb0
 8024cb6:	05d2      	lsls	r2, r2, #23
 8024cb8:	2390      	movs	r3, #144	; 0x90
 8024cba:	58d1      	ldr	r1, [r2, r3]
 8024cbc:	4835      	ldr	r0, [pc, #212]	; (8024d94 <HAL_RCCEx_PeriphCLKConfig+0x25c>)
 8024cbe:	4001      	ands	r1, r0
  SET_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8024cc0:	58d6      	ldr	r6, [r2, r3]
 8024cc2:	2080      	movs	r0, #128	; 0x80
 8024cc4:	0240      	lsls	r0, r0, #9
 8024cc6:	4330      	orrs	r0, r6
 8024cc8:	50d0      	str	r0, [r2, r3]
  CLEAR_BIT(RCC->BDCR, RCC_BDCR_BDRST);
 8024cca:	58d0      	ldr	r0, [r2, r3]
 8024ccc:	4e34      	ldr	r6, [pc, #208]	; (8024da0 <HAL_RCCEx_PeriphCLKConfig+0x268>)
 8024cce:	4030      	ands	r0, r6
 8024cd0:	50d0      	str	r0, [r2, r3]
        RCC->BDCR = tmpregister;
 8024cd2:	50d1      	str	r1, [r2, r3]
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSERDY))
 8024cd4:	078b      	lsls	r3, r1, #30
 8024cd6:	d40e      	bmi.n	8024cf6 <HAL_RCCEx_PeriphCLKConfig+0x1be>
      if (ret == HAL_OK)
 8024cd8:	2d00      	cmp	r5, #0
 8024cda:	d000      	beq.n	8024cde <HAL_RCCEx_PeriphCLKConfig+0x1a6>
 8024cdc:	e733      	b.n	8024b46 <HAL_RCCEx_PeriphCLKConfig+0xe>
  MODIFY_REG(RCC->BDCR, RCC_BDCR_RTCSEL, Source);
 8024cde:	21b0      	movs	r1, #176	; 0xb0
 8024ce0:	05c9      	lsls	r1, r1, #23
 8024ce2:	2290      	movs	r2, #144	; 0x90
 8024ce4:	588b      	ldr	r3, [r1, r2]
 8024ce6:	482b      	ldr	r0, [pc, #172]	; (8024d94 <HAL_RCCEx_PeriphCLKConfig+0x25c>)
 8024ce8:	4003      	ands	r3, r0
 8024cea:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8024cec:	4303      	orrs	r3, r0
 8024cee:	508b      	str	r3, [r1, r2]
}
 8024cf0:	e729      	b.n	8024b46 <HAL_RCCEx_PeriphCLKConfig+0xe>
  uint32_t tmpregister = 0;
 8024cf2:	2100      	movs	r1, #0
 8024cf4:	e7ee      	b.n	8024cd4 <HAL_RCCEx_PeriphCLKConfig+0x19c>
        tickstart = HAL_GetTick();
 8024cf6:	f7fc ff57 	bl	8021ba8 <HAL_GetTick>
 8024cfa:	0006      	movs	r6, r0
  return ((READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY)) ? 1UL : 0UL);
 8024cfc:	22b0      	movs	r2, #176	; 0xb0
 8024cfe:	05d2      	lsls	r2, r2, #23
 8024d00:	2390      	movs	r3, #144	; 0x90
 8024d02:	58d3      	ldr	r3, [r2, r3]
 8024d04:	079b      	lsls	r3, r3, #30
 8024d06:	d4e7      	bmi.n	8024cd8 <HAL_RCCEx_PeriphCLKConfig+0x1a0>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8024d08:	f7fc ff4e 	bl	8021ba8 <HAL_GetTick>
 8024d0c:	1b80      	subs	r0, r0, r6
 8024d0e:	4a25      	ldr	r2, [pc, #148]	; (8024da4 <HAL_RCCEx_PeriphCLKConfig+0x26c>)
 8024d10:	4290      	cmp	r0, r2
 8024d12:	d9f3      	bls.n	8024cfc <HAL_RCCEx_PeriphCLKConfig+0x1c4>
            ret = HAL_TIMEOUT;
 8024d14:	2503      	movs	r5, #3
 8024d16:	e7df      	b.n	8024cd8 <HAL_RCCEx_PeriphCLKConfig+0x1a0>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8024d18:	6963      	ldr	r3, [r4, #20]
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 8024d1a:	26b0      	movs	r6, #176	; 0xb0
 8024d1c:	05f6      	lsls	r6, r6, #23
 8024d1e:	2088      	movs	r0, #136	; 0x88
 8024d20:	5832      	ldr	r2, [r6, r0]
 8024d22:	0919      	lsrs	r1, r3, #4
 8024d24:	27ff      	movs	r7, #255	; 0xff
 8024d26:	033f      	lsls	r7, r7, #12
 8024d28:	4039      	ands	r1, r7
 8024d2a:	438a      	bics	r2, r1
 8024d2c:	011b      	lsls	r3, r3, #4
 8024d2e:	403b      	ands	r3, r7
 8024d30:	4313      	orrs	r3, r2
 8024d32:	5033      	str	r3, [r6, r0]
}
 8024d34:	e75d      	b.n	8024bf2 <HAL_RCCEx_PeriphCLKConfig+0xba>
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8024d36:	69a3      	ldr	r3, [r4, #24]
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 8024d38:	26b0      	movs	r6, #176	; 0xb0
 8024d3a:	05f6      	lsls	r6, r6, #23
 8024d3c:	2088      	movs	r0, #136	; 0x88
 8024d3e:	5832      	ldr	r2, [r6, r0]
 8024d40:	0919      	lsrs	r1, r3, #4
 8024d42:	27ff      	movs	r7, #255	; 0xff
 8024d44:	033f      	lsls	r7, r7, #12
 8024d46:	4039      	ands	r1, r7
 8024d48:	438a      	bics	r2, r1
 8024d4a:	011b      	lsls	r3, r3, #4
 8024d4c:	403b      	ands	r3, r7
 8024d4e:	4313      	orrs	r3, r2
 8024d50:	5033      	str	r3, [r6, r0]
}
 8024d52:	e752      	b.n	8024bfa <HAL_RCCEx_PeriphCLKConfig+0xc2>
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8024d54:	69e3      	ldr	r3, [r4, #28]
  MODIFY_REG(RCC->CCIPR, ((I2CxSource >> 4) & 0x000FF000U), ((I2CxSource << 4) & 0x000FF000U));
 8024d56:	26b0      	movs	r6, #176	; 0xb0
 8024d58:	05f6      	lsls	r6, r6, #23
 8024d5a:	2088      	movs	r0, #136	; 0x88
 8024d5c:	5832      	ldr	r2, [r6, r0]
 8024d5e:	0919      	lsrs	r1, r3, #4
 8024d60:	27ff      	movs	r7, #255	; 0xff
 8024d62:	033f      	lsls	r7, r7, #12
 8024d64:	4039      	ands	r1, r7
 8024d66:	438a      	bics	r2, r1
 8024d68:	011b      	lsls	r3, r3, #4
 8024d6a:	403b      	ands	r3, r7
 8024d6c:	4313      	orrs	r3, r2
 8024d6e:	5033      	str	r3, [r6, r0]
}
 8024d70:	e747      	b.n	8024c02 <HAL_RCCEx_PeriphCLKConfig+0xca>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_I2S2CLK);
 8024d72:	000a      	movs	r2, r1
 8024d74:	68c9      	ldr	r1, [r1, #12]
 8024d76:	2380      	movs	r3, #128	; 0x80
 8024d78:	045b      	lsls	r3, r3, #17
 8024d7a:	430b      	orrs	r3, r1
 8024d7c:	60d3      	str	r3, [r2, #12]
 8024d7e:	e752      	b.n	8024c26 <HAL_RCCEx_PeriphCLKConfig+0xee>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 8024d80:	000a      	movs	r2, r1
 8024d82:	68c9      	ldr	r1, [r1, #12]
 8024d84:	2380      	movs	r3, #128	; 0x80
 8024d86:	025b      	lsls	r3, r3, #9
 8024d88:	430b      	orrs	r3, r1
 8024d8a:	60d3      	str	r3, [r2, #12]
 8024d8c:	e772      	b.n	8024c74 <HAL_RCCEx_PeriphCLKConfig+0x13c>
 8024d8e:	46c0      	nop			; (mov r8, r8)
 8024d90:	fffff3ff 	.word	0xfffff3ff
 8024d94:	fffffcff 	.word	0xfffffcff
 8024d98:	cfffffff 	.word	0xcfffffff
 8024d9c:	58000400 	.word	0x58000400
 8024da0:	fffeffff 	.word	0xfffeffff
 8024da4:	00001388 	.word	0x00001388

08024da8 <HAL_RTC_DeactivateAlarm>:
{
  /* Check the parameters */
  assert_param(IS_RTC_ALARM(Alarm));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8024da8:	232c      	movs	r3, #44	; 0x2c
 8024daa:	5cc3      	ldrb	r3, [r0, r3]
 8024dac:	2b01      	cmp	r3, #1
 8024dae:	d036      	beq.n	8024e1e <HAL_RTC_DeactivateAlarm+0x76>
 8024db0:	232c      	movs	r3, #44	; 0x2c
 8024db2:	2201      	movs	r2, #1
 8024db4:	54c2      	strb	r2, [r0, r3]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8024db6:	3301      	adds	r3, #1
 8024db8:	3201      	adds	r2, #1
 8024dba:	54c2      	strb	r2, [r0, r3]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8024dbc:	4b19      	ldr	r3, [pc, #100]	; (8024e24 <HAL_RTC_DeactivateAlarm+0x7c>)
 8024dbe:	32c8      	adds	r2, #200	; 0xc8
 8024dc0:	625a      	str	r2, [r3, #36]	; 0x24
 8024dc2:	3a77      	subs	r2, #119	; 0x77
 8024dc4:	625a      	str	r2, [r3, #36]	; 0x24

  if (Alarm == RTC_ALARM_A)
 8024dc6:	2380      	movs	r3, #128	; 0x80
 8024dc8:	005b      	lsls	r3, r3, #1
 8024dca:	4299      	cmp	r1, r3
 8024dcc:	d018      	beq.n	8024e00 <HAL_RTC_DeactivateAlarm+0x58>
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
  }
  else
  {
    /* AlarmB, In case of interrupt mode is used, the interrupt source must disabled */
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 8024dce:	4b15      	ldr	r3, [pc, #84]	; (8024e24 <HAL_RTC_DeactivateAlarm+0x7c>)
 8024dd0:	699a      	ldr	r2, [r3, #24]
 8024dd2:	4915      	ldr	r1, [pc, #84]	; (8024e28 <HAL_RTC_DeactivateAlarm+0x80>)
 8024dd4:	400a      	ands	r2, r1
 8024dd6:	619a      	str	r2, [r3, #24]

    /* AlarmB, Clear SSCLR */
    CLEAR_BIT(RTC->ALRMBSSR, RTC_ALRMBSSR_SSCLR);
 8024dd8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8024dda:	0052      	lsls	r2, r2, #1
 8024ddc:	0852      	lsrs	r2, r2, #1
 8024dde:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Store in the handle the Alarm B disabled */
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 8024de0:	2102      	movs	r1, #2
 8024de2:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8024de4:	438a      	bics	r2, r1
 8024de6:	6302      	str	r2, [r0, #48]	; 0x30

    /* Clear AlarmB flag */
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8024de8:	65d9      	str	r1, [r3, #92]	; 0x5c
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8024dea:	4b0e      	ldr	r3, [pc, #56]	; (8024e24 <HAL_RTC_DeactivateAlarm+0x7c>)
 8024dec:	22ff      	movs	r2, #255	; 0xff
 8024dee:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 8024df0:	232d      	movs	r3, #45	; 0x2d
 8024df2:	3afe      	subs	r2, #254	; 0xfe
 8024df4:	54c2      	strb	r2, [r0, r3]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8024df6:	3b01      	subs	r3, #1
 8024df8:	2200      	movs	r2, #0
 8024dfa:	54c2      	strb	r2, [r0, r3]

  return HAL_OK;
 8024dfc:	2000      	movs	r0, #0
}
 8024dfe:	4770      	bx	lr
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8024e00:	4b08      	ldr	r3, [pc, #32]	; (8024e24 <HAL_RTC_DeactivateAlarm+0x7c>)
 8024e02:	699a      	ldr	r2, [r3, #24]
 8024e04:	4909      	ldr	r1, [pc, #36]	; (8024e2c <HAL_RTC_DeactivateAlarm+0x84>)
 8024e06:	400a      	ands	r2, r1
 8024e08:	619a      	str	r2, [r3, #24]
    CLEAR_BIT(RTC->ALRMASSR, RTC_ALRMASSR_SSCLR);
 8024e0a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8024e0c:	0052      	lsls	r2, r2, #1
 8024e0e:	0852      	lsrs	r2, r2, #1
 8024e10:	645a      	str	r2, [r3, #68]	; 0x44
    CLEAR_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 8024e12:	2101      	movs	r1, #1
 8024e14:	6b02      	ldr	r2, [r0, #48]	; 0x30
 8024e16:	438a      	bics	r2, r1
 8024e18:	6302      	str	r2, [r0, #48]	; 0x30
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8024e1a:	65d9      	str	r1, [r3, #92]	; 0x5c
 8024e1c:	e7e5      	b.n	8024dea <HAL_RTC_DeactivateAlarm+0x42>
  __HAL_LOCK(hrtc);
 8024e1e:	2002      	movs	r0, #2
 8024e20:	e7ed      	b.n	8024dfe <HAL_RTC_DeactivateAlarm+0x56>
 8024e22:	46c0      	nop			; (mov r8, r8)
 8024e24:	40002800 	.word	0x40002800
 8024e28:	ffffddff 	.word	0xffffddff
 8024e2c:	ffffeeff 	.word	0xffffeeff

08024e30 <HAL_RTC_AlarmIRQHandler>:
  * @brief  Handle Alarm interrupt request.
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)
{
 8024e30:	b570      	push	{r4, r5, r6, lr}
 8024e32:	0004      	movs	r4, r0
  uint32_t tmp = READ_REG(RTC->MISR) & READ_REG(hrtc->IsEnabled.RtcFeatures);
 8024e34:	4b0c      	ldr	r3, [pc, #48]	; (8024e68 <HAL_RTC_AlarmIRQHandler+0x38>)
 8024e36:	6d5d      	ldr	r5, [r3, #84]	; 0x54
 8024e38:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8024e3a:	401d      	ands	r5, r3

  if ((tmp & RTC_MISR_ALRAMF) != 0U)
 8024e3c:	07eb      	lsls	r3, r5, #31
 8024e3e:	d405      	bmi.n	8024e4c <HAL_RTC_AlarmIRQHandler+0x1c>
#else
    HAL_RTC_AlarmAEventCallback(hrtc);
#endif
  }

  if ((tmp & RTC_MISR_ALRBMF) != 0U)
 8024e40:	07ab      	lsls	r3, r5, #30
 8024e42:	d409      	bmi.n	8024e58 <HAL_RTC_AlarmIRQHandler+0x28>
    HAL_RTCEx_AlarmBEventCallback(hrtc);
#endif
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8024e44:	232d      	movs	r3, #45	; 0x2d
 8024e46:	2201      	movs	r2, #1
 8024e48:	54e2      	strb	r2, [r4, r3]
}
 8024e4a:	bd70      	pop	{r4, r5, r6, pc}
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8024e4c:	4b06      	ldr	r3, [pc, #24]	; (8024e68 <HAL_RTC_AlarmIRQHandler+0x38>)
 8024e4e:	2201      	movs	r2, #1
 8024e50:	65da      	str	r2, [r3, #92]	; 0x5c
    HAL_RTC_AlarmAEventCallback(hrtc);
 8024e52:	f7fc fff3 	bl	8021e3c <HAL_RTC_AlarmAEventCallback>
 8024e56:	e7f3      	b.n	8024e40 <HAL_RTC_AlarmIRQHandler+0x10>
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 8024e58:	4b03      	ldr	r3, [pc, #12]	; (8024e68 <HAL_RTC_AlarmIRQHandler+0x38>)
 8024e5a:	2202      	movs	r2, #2
 8024e5c:	65da      	str	r2, [r3, #92]	; 0x5c
    HAL_RTCEx_AlarmBEventCallback(hrtc);
 8024e5e:	0020      	movs	r0, r4
 8024e60:	f7fd f802 	bl	8021e68 <HAL_RTCEx_AlarmBEventCallback>
 8024e64:	e7ee      	b.n	8024e44 <HAL_RTC_AlarmIRQHandler+0x14>
 8024e66:	46c0      	nop			; (mov r8, r8)
 8024e68:	40002800 	.word	0x40002800

08024e6c <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 8024e6c:	b510      	push	{r4, lr}
  uint32_t tickstart;

  UNUSED(hrtc);
  /* Clear RSF flag */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_RSF);
 8024e6e:	4a0b      	ldr	r2, [pc, #44]	; (8024e9c <HAL_RTC_WaitForSynchro+0x30>)
 8024e70:	68d3      	ldr	r3, [r2, #12]
 8024e72:	2120      	movs	r1, #32
 8024e74:	438b      	bics	r3, r1
 8024e76:	60d3      	str	r3, [r2, #12]

  tickstart = HAL_GetTick();
 8024e78:	f7fc fe96 	bl	8021ba8 <HAL_GetTick>
 8024e7c:	0004      	movs	r4, r0

  /* Wait the registers to be synchronised */
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
 8024e7e:	4b07      	ldr	r3, [pc, #28]	; (8024e9c <HAL_RTC_WaitForSynchro+0x30>)
 8024e80:	68db      	ldr	r3, [r3, #12]
 8024e82:	069b      	lsls	r3, r3, #26
 8024e84:	d408      	bmi.n	8024e98 <HAL_RTC_WaitForSynchro+0x2c>
  {
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 8024e86:	f7fc fe8f 	bl	8021ba8 <HAL_GetTick>
 8024e8a:	1b00      	subs	r0, r0, r4
 8024e8c:	23fa      	movs	r3, #250	; 0xfa
 8024e8e:	009b      	lsls	r3, r3, #2
 8024e90:	4298      	cmp	r0, r3
 8024e92:	d9f4      	bls.n	8024e7e <HAL_RTC_WaitForSynchro+0x12>
    {
      return HAL_TIMEOUT;
 8024e94:	2003      	movs	r0, #3
 8024e96:	e000      	b.n	8024e9a <HAL_RTC_WaitForSynchro+0x2e>
    }
  }

  return HAL_OK;
 8024e98:	2000      	movs	r0, #0
}
 8024e9a:	bd10      	pop	{r4, pc}
 8024e9c:	40002800 	.word	0x40002800

08024ea0 <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 8024ea0:	b570      	push	{r4, r5, r6, lr}
 8024ea2:	0004      	movs	r4, r0
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  UNUSED(hrtc);
  /* Check if the Initialization mode is set */
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 8024ea4:	4b10      	ldr	r3, [pc, #64]	; (8024ee8 <RTC_EnterInitMode+0x48>)
 8024ea6:	68db      	ldr	r3, [r3, #12]
 8024ea8:	065b      	lsls	r3, r3, #25
 8024eaa:	d502      	bpl.n	8024eb2 <RTC_EnterInitMode+0x12>
  HAL_StatusTypeDef status = HAL_OK;
 8024eac:	2500      	movs	r5, #0
      }
    }
  }

  return status;
}
 8024eae:	0028      	movs	r0, r5
 8024eb0:	bd70      	pop	{r4, r5, r6, pc}
    SET_BIT(RTC->ICSR, RTC_ICSR_INIT);
 8024eb2:	4a0d      	ldr	r2, [pc, #52]	; (8024ee8 <RTC_EnterInitMode+0x48>)
 8024eb4:	68d3      	ldr	r3, [r2, #12]
 8024eb6:	2180      	movs	r1, #128	; 0x80
 8024eb8:	430b      	orrs	r3, r1
 8024eba:	60d3      	str	r3, [r2, #12]
    tickstart = HAL_GetTick();
 8024ebc:	f7fc fe74 	bl	8021ba8 <HAL_GetTick>
 8024ec0:	0006      	movs	r6, r0
  HAL_StatusTypeDef status = HAL_OK;
 8024ec2:	2500      	movs	r5, #0
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
 8024ec4:	4b08      	ldr	r3, [pc, #32]	; (8024ee8 <RTC_EnterInitMode+0x48>)
 8024ec6:	68db      	ldr	r3, [r3, #12]
 8024ec8:	065b      	lsls	r3, r3, #25
 8024eca:	d4f0      	bmi.n	8024eae <RTC_EnterInitMode+0xe>
 8024ecc:	2d03      	cmp	r5, #3
 8024ece:	d0ee      	beq.n	8024eae <RTC_EnterInitMode+0xe>
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 8024ed0:	f7fc fe6a 	bl	8021ba8 <HAL_GetTick>
 8024ed4:	1b80      	subs	r0, r0, r6
 8024ed6:	22fa      	movs	r2, #250	; 0xfa
 8024ed8:	0092      	lsls	r2, r2, #2
 8024eda:	4290      	cmp	r0, r2
 8024edc:	d9f2      	bls.n	8024ec4 <RTC_EnterInitMode+0x24>
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8024ede:	232d      	movs	r3, #45	; 0x2d
 8024ee0:	2203      	movs	r2, #3
 8024ee2:	54e2      	strb	r2, [r4, r3]
        status = HAL_TIMEOUT;
 8024ee4:	2503      	movs	r5, #3
 8024ee6:	e7ed      	b.n	8024ec4 <RTC_EnterInitMode+0x24>
 8024ee8:	40002800 	.word	0x40002800

08024eec <RTC_ExitInitMode>:
  * @brief  Exit the RTC Initialization mode.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
 8024eec:	b510      	push	{r4, lr}
 8024eee:	0004      	movs	r4, r0
  HAL_StatusTypeDef status = HAL_OK;

  /* Exit Initialization mode */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 8024ef0:	4b11      	ldr	r3, [pc, #68]	; (8024f38 <RTC_ExitInitMode+0x4c>)
 8024ef2:	68da      	ldr	r2, [r3, #12]
 8024ef4:	2180      	movs	r1, #128	; 0x80
 8024ef6:	438a      	bics	r2, r1
 8024ef8:	60da      	str	r2, [r3, #12]

  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 8024efa:	699b      	ldr	r3, [r3, #24]
 8024efc:	069b      	lsls	r3, r3, #26
 8024efe:	d408      	bmi.n	8024f12 <RTC_ExitInitMode+0x26>
  {
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8024f00:	f7ff ffb4 	bl	8024e6c <HAL_RTC_WaitForSynchro>
 8024f04:	2800      	cmp	r0, #0
 8024f06:	d016      	beq.n	8024f36 <RTC_ExitInitMode+0x4a>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8024f08:	232d      	movs	r3, #45	; 0x2d
 8024f0a:	2203      	movs	r2, #3
 8024f0c:	54e2      	strb	r2, [r4, r3]
      status = HAL_TIMEOUT;
 8024f0e:	2003      	movs	r0, #3
 8024f10:	e011      	b.n	8024f36 <RTC_ExitInitMode+0x4a>
    }
  }
  else /* WA 2.9.6 Calendar initialization may fail in case of consecutive INIT mode entry. */
  {
    /* Clear BYPSHAD bit */
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8024f12:	4a09      	ldr	r2, [pc, #36]	; (8024f38 <RTC_ExitInitMode+0x4c>)
 8024f14:	6993      	ldr	r3, [r2, #24]
 8024f16:	2120      	movs	r1, #32
 8024f18:	438b      	bics	r3, r1
 8024f1a:	6193      	str	r3, [r2, #24]
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8024f1c:	f7ff ffa6 	bl	8024e6c <HAL_RTC_WaitForSynchro>
 8024f20:	2800      	cmp	r0, #0
 8024f22:	d003      	beq.n	8024f2c <RTC_ExitInitMode+0x40>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8024f24:	232d      	movs	r3, #45	; 0x2d
 8024f26:	2203      	movs	r2, #3
 8024f28:	54e2      	strb	r2, [r4, r3]
      status = HAL_TIMEOUT;
 8024f2a:	2003      	movs	r0, #3
    }
    /* Restore BYPSHAD bit */
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8024f2c:	4a02      	ldr	r2, [pc, #8]	; (8024f38 <RTC_ExitInitMode+0x4c>)
 8024f2e:	6993      	ldr	r3, [r2, #24]
 8024f30:	2120      	movs	r1, #32
 8024f32:	430b      	orrs	r3, r1
 8024f34:	6193      	str	r3, [r2, #24]
  }

  return status;
}
 8024f36:	bd10      	pop	{r4, pc}
 8024f38:	40002800 	.word	0x40002800

08024f3c <HAL_RTC_Init>:
{
 8024f3c:	b570      	push	{r4, r5, r6, lr}
 8024f3e:	1e04      	subs	r4, r0, #0
  if (hrtc != NULL)
 8024f40:	d050      	beq.n	8024fe4 <HAL_RTC_Init+0xa8>
    if (hrtc->State == HAL_RTC_STATE_RESET)
 8024f42:	232d      	movs	r3, #45	; 0x2d
 8024f44:	5cc3      	ldrb	r3, [r0, r3]
 8024f46:	2b00      	cmp	r3, #0
 8024f48:	d00b      	beq.n	8024f62 <HAL_RTC_Init+0x26>
    hrtc->State = HAL_RTC_STATE_BUSY;
 8024f4a:	232d      	movs	r3, #45	; 0x2d
 8024f4c:	2202      	movs	r2, #2
 8024f4e:	54e2      	strb	r2, [r4, r3]
    if (__HAL_RTC_IS_CALENDAR_INITIALIZED(hrtc) == 0U)
 8024f50:	4b25      	ldr	r3, [pc, #148]	; (8024fe8 <HAL_RTC_Init+0xac>)
 8024f52:	68db      	ldr	r3, [r3, #12]
 8024f54:	06db      	lsls	r3, r3, #27
 8024f56:	d50a      	bpl.n	8024f6e <HAL_RTC_Init+0x32>
      status = HAL_OK;
 8024f58:	2000      	movs	r0, #0
      hrtc->State = HAL_RTC_STATE_READY;
 8024f5a:	232d      	movs	r3, #45	; 0x2d
 8024f5c:	2201      	movs	r2, #1
 8024f5e:	54e2      	strb	r2, [r4, r3]
}
 8024f60:	bd70      	pop	{r4, r5, r6, pc}
      hrtc->Lock = HAL_UNLOCKED;
 8024f62:	332c      	adds	r3, #44	; 0x2c
 8024f64:	2200      	movs	r2, #0
 8024f66:	54c2      	strb	r2, [r0, r3]
      HAL_RTC_MspInit(hrtc);
 8024f68:	f7fc fc8e 	bl	8021888 <HAL_RTC_MspInit>
 8024f6c:	e7ed      	b.n	8024f4a <HAL_RTC_Init+0xe>
      __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8024f6e:	4b1e      	ldr	r3, [pc, #120]	; (8024fe8 <HAL_RTC_Init+0xac>)
 8024f70:	32c8      	adds	r2, #200	; 0xc8
 8024f72:	625a      	str	r2, [r3, #36]	; 0x24
 8024f74:	3a77      	subs	r2, #119	; 0x77
 8024f76:	625a      	str	r2, [r3, #36]	; 0x24
      status = RTC_EnterInitMode(hrtc);
 8024f78:	0020      	movs	r0, r4
 8024f7a:	f7ff ff91 	bl	8024ea0 <RTC_EnterInitMode>
      if (status == HAL_OK)
 8024f7e:	2800      	cmp	r0, #0
 8024f80:	d005      	beq.n	8024f8e <HAL_RTC_Init+0x52>
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8024f82:	4b19      	ldr	r3, [pc, #100]	; (8024fe8 <HAL_RTC_Init+0xac>)
 8024f84:	22ff      	movs	r2, #255	; 0xff
 8024f86:	625a      	str	r2, [r3, #36]	; 0x24
    if (status == HAL_OK)
 8024f88:	2800      	cmp	r0, #0
 8024f8a:	d1e9      	bne.n	8024f60 <HAL_RTC_Init+0x24>
 8024f8c:	e7e5      	b.n	8024f5a <HAL_RTC_Init+0x1e>
        CLEAR_BIT(RTC->CR, (RTC_CR_FMT | RTC_CR_POL | RTC_CR_OSEL | RTC_CR_TAMPOE));
 8024f8e:	4b16      	ldr	r3, [pc, #88]	; (8024fe8 <HAL_RTC_Init+0xac>)
 8024f90:	699a      	ldr	r2, [r3, #24]
 8024f92:	4916      	ldr	r1, [pc, #88]	; (8024fec <HAL_RTC_Init+0xb0>)
 8024f94:	400a      	ands	r2, r1
 8024f96:	619a      	str	r2, [r3, #24]
        SET_BIT(RTC->CR, (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity));
 8024f98:	6999      	ldr	r1, [r3, #24]
 8024f9a:	6862      	ldr	r2, [r4, #4]
 8024f9c:	6920      	ldr	r0, [r4, #16]
 8024f9e:	4302      	orrs	r2, r0
 8024fa0:	69a0      	ldr	r0, [r4, #24]
 8024fa2:	4302      	orrs	r2, r0
 8024fa4:	430a      	orrs	r2, r1
 8024fa6:	619a      	str	r2, [r3, #24]
        WRITE_REG(RTC->PRER, ((hrtc->Init.SynchPrediv) | (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos)));
 8024fa8:	68a2      	ldr	r2, [r4, #8]
 8024faa:	0412      	lsls	r2, r2, #16
 8024fac:	68e1      	ldr	r1, [r4, #12]
 8024fae:	430a      	orrs	r2, r1
 8024fb0:	611a      	str	r2, [r3, #16]
        MODIFY_REG(RTC->ICSR, RTC_ICSR_BIN | RTC_ICSR_BCDU, hrtc->Init.BinMode | hrtc->Init.BinMixBcdU);
 8024fb2:	68da      	ldr	r2, [r3, #12]
 8024fb4:	490e      	ldr	r1, [pc, #56]	; (8024ff0 <HAL_RTC_Init+0xb4>)
 8024fb6:	400a      	ands	r2, r1
 8024fb8:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8024fba:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8024fbc:	4301      	orrs	r1, r0
 8024fbe:	430a      	orrs	r2, r1
 8024fc0:	60da      	str	r2, [r3, #12]
        status = RTC_ExitInitMode(hrtc);
 8024fc2:	0020      	movs	r0, r4
 8024fc4:	f7ff ff92 	bl	8024eec <RTC_ExitInitMode>
        if (status == HAL_OK)
 8024fc8:	2800      	cmp	r0, #0
 8024fca:	d1da      	bne.n	8024f82 <HAL_RTC_Init+0x46>
          MODIFY_REG(RTC->CR, \
 8024fcc:	4906      	ldr	r1, [pc, #24]	; (8024fe8 <HAL_RTC_Init+0xac>)
 8024fce:	698b      	ldr	r3, [r1, #24]
 8024fd0:	00db      	lsls	r3, r3, #3
 8024fd2:	08db      	lsrs	r3, r3, #3
 8024fd4:	6a22      	ldr	r2, [r4, #32]
 8024fd6:	69e5      	ldr	r5, [r4, #28]
 8024fd8:	432a      	orrs	r2, r5
 8024fda:	6965      	ldr	r5, [r4, #20]
 8024fdc:	432a      	orrs	r2, r5
 8024fde:	4313      	orrs	r3, r2
 8024fe0:	618b      	str	r3, [r1, #24]
 8024fe2:	e7ce      	b.n	8024f82 <HAL_RTC_Init+0x46>
  HAL_StatusTypeDef status = HAL_ERROR;
 8024fe4:	2001      	movs	r0, #1
 8024fe6:	e7bb      	b.n	8024f60 <HAL_RTC_Init+0x24>
 8024fe8:	40002800 	.word	0x40002800
 8024fec:	fb8fffbf 	.word	0xfb8fffbf
 8024ff0:	ffffe0ff 	.word	0xffffe0ff

08024ff4 <RTC_ByteToBcd2>:
  * @param  Value Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0U;
 8024ff4:	2300      	movs	r3, #0
  uint8_t tmp_Value = Value;

  while (tmp_Value >= 10U)
 8024ff6:	e002      	b.n	8024ffe <RTC_ByteToBcd2+0xa>
  {
    bcdhigh++;
 8024ff8:	3301      	adds	r3, #1
    tmp_Value -= 10U;
 8024ffa:	380a      	subs	r0, #10
 8024ffc:	b2c0      	uxtb	r0, r0
  while (tmp_Value >= 10U)
 8024ffe:	2809      	cmp	r0, #9
 8025000:	d8fa      	bhi.n	8024ff8 <RTC_ByteToBcd2+0x4>
  }

  return ((uint8_t)(bcdhigh << 4U) | tmp_Value);
 8025002:	011b      	lsls	r3, r3, #4
 8025004:	b2db      	uxtb	r3, r3
 8025006:	4318      	orrs	r0, r3
}
 8025008:	4770      	bx	lr
	...

0802500c <HAL_RTC_SetAlarm_IT>:
{
 802500c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802500e:	46c6      	mov	lr, r8
 8025010:	b500      	push	{lr}
 8025012:	0005      	movs	r5, r0
 8025014:	000c      	movs	r4, r1
  __HAL_LOCK(hrtc);
 8025016:	232c      	movs	r3, #44	; 0x2c
 8025018:	5cc3      	ldrb	r3, [r0, r3]
 802501a:	2b01      	cmp	r3, #1
 802501c:	d100      	bne.n	8025020 <HAL_RTC_SetAlarm_IT+0x14>
 802501e:	e0b5      	b.n	802518c <HAL_RTC_SetAlarm_IT+0x180>
 8025020:	232c      	movs	r3, #44	; 0x2c
 8025022:	2101      	movs	r1, #1
 8025024:	54c1      	strb	r1, [r0, r3]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8025026:	3301      	adds	r3, #1
 8025028:	3101      	adds	r1, #1
 802502a:	54c1      	strb	r1, [r0, r3]
  binaryMode = READ_BIT(RTC->ICSR, RTC_ICSR_BIN);
 802502c:	4b58      	ldr	r3, [pc, #352]	; (8025190 <HAL_RTC_SetAlarm_IT+0x184>)
 802502e:	68de      	ldr	r6, [r3, #12]
 8025030:	23c0      	movs	r3, #192	; 0xc0
 8025032:	009b      	lsls	r3, r3, #2
 8025034:	401e      	ands	r6, r3
  if (binaryMode != RTC_BINARY_ONLY)
 8025036:	2380      	movs	r3, #128	; 0x80
 8025038:	005b      	lsls	r3, r3, #1
 802503a:	429e      	cmp	r6, r3
 802503c:	d044      	beq.n	80250c8 <HAL_RTC_SetAlarm_IT+0xbc>
    if (Format == RTC_FORMAT_BIN)
 802503e:	2a00      	cmp	r2, #0
 8025040:	d122      	bne.n	8025088 <HAL_RTC_SetAlarm_IT+0x7c>
      if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 8025042:	4b53      	ldr	r3, [pc, #332]	; (8025190 <HAL_RTC_SetAlarm_IT+0x184>)
 8025044:	699b      	ldr	r3, [r3, #24]
 8025046:	065b      	lsls	r3, r3, #25
 8025048:	d401      	bmi.n	802504e <HAL_RTC_SetAlarm_IT+0x42>
        sAlarm->AlarmTime.TimeFormat = 0x00U;
 802504a:	2300      	movs	r3, #0
 802504c:	70e3      	strb	r3, [r4, #3]
      if( sAlarm->AlarmMask != RTC_ALARMMASK_DATEWEEKDAY )
 802504e:	6963      	ldr	r3, [r4, #20]
 8025050:	4698      	mov	r8, r3
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8025052:	7820      	ldrb	r0, [r4, #0]
 8025054:	f7ff ffce 	bl	8024ff4 <RTC_ByteToBcd2>
 8025058:	0407      	lsls	r7, r0, #16
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 802505a:	7860      	ldrb	r0, [r4, #1]
 802505c:	f7ff ffca 	bl	8024ff4 <RTC_ByteToBcd2>
 8025060:	0200      	lsls	r0, r0, #8
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8025062:	4307      	orrs	r7, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 8025064:	78a0      	ldrb	r0, [r4, #2]
 8025066:	f7ff ffc5 	bl	8024ff4 <RTC_ByteToBcd2>
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 802506a:	4307      	orrs	r7, r0
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 802506c:	78e0      	ldrb	r0, [r4, #3]
 802506e:	0580      	lsls	r0, r0, #22
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 8025070:	4307      	orrs	r7, r0
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 8025072:	2324      	movs	r3, #36	; 0x24
 8025074:	5ce0      	ldrb	r0, [r4, r3]
 8025076:	f7ff ffbd 	bl	8024ff4 <RTC_ByteToBcd2>
 802507a:	0600      	lsls	r0, r0, #24
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 802507c:	4338      	orrs	r0, r7
                ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 802507e:	6a23      	ldr	r3, [r4, #32]
 8025080:	4318      	orrs	r0, r3
      tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 8025082:	4643      	mov	r3, r8
 8025084:	4318      	orrs	r0, r3
 8025086:	e020      	b.n	80250ca <HAL_RTC_SetAlarm_IT+0xbe>
      if( sAlarm->AlarmMask != RTC_ALARMMASK_ALL )
 8025088:	6962      	ldr	r2, [r4, #20]
 802508a:	4b42      	ldr	r3, [pc, #264]	; (8025194 <HAL_RTC_SetAlarm_IT+0x188>)
 802508c:	429a      	cmp	r2, r3
 802508e:	d009      	beq.n	80250a4 <HAL_RTC_SetAlarm_IT+0x98>
        if( sAlarm->AlarmMask != RTC_ALARMMASK_HOURS )
 8025090:	2380      	movs	r3, #128	; 0x80
 8025092:	041b      	lsls	r3, r3, #16
 8025094:	429a      	cmp	r2, r3
 8025096:	d005      	beq.n	80250a4 <HAL_RTC_SetAlarm_IT+0x98>
          if (READ_BIT(RTC->CR, RTC_CR_FMT) != 0U)
 8025098:	4b3d      	ldr	r3, [pc, #244]	; (8025190 <HAL_RTC_SetAlarm_IT+0x184>)
 802509a:	699b      	ldr	r3, [r3, #24]
 802509c:	065b      	lsls	r3, r3, #25
 802509e:	d401      	bmi.n	80250a4 <HAL_RTC_SetAlarm_IT+0x98>
            sAlarm->AlarmTime.TimeFormat = 0x00U;
 80250a0:	2300      	movs	r3, #0
 80250a2:	70e3      	strb	r3, [r4, #3]
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 80250a4:	7820      	ldrb	r0, [r4, #0]
 80250a6:	0400      	lsls	r0, r0, #16
                ((uint32_t)(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 80250a8:	7863      	ldrb	r3, [r4, #1]
 80250aa:	021b      	lsls	r3, r3, #8
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 80250ac:	4318      	orrs	r0, r3
                ((uint32_t)(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 80250ae:	78a3      	ldrb	r3, [r4, #2]
                ((uint32_t)(sAlarm->AlarmTime.Minutes) << RTC_ALRMAR_MNU_Pos) | \
 80250b0:	4318      	orrs	r0, r3
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 80250b2:	78e3      	ldrb	r3, [r4, #3]
 80250b4:	059b      	lsls	r3, r3, #22
                ((uint32_t)(sAlarm->AlarmTime.Seconds) << RTC_ALRMAR_SU_Pos) | \
 80250b6:	4318      	orrs	r0, r3
                ((uint32_t)(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 80250b8:	2324      	movs	r3, #36	; 0x24
 80250ba:	5ce3      	ldrb	r3, [r4, r3]
 80250bc:	061b      	lsls	r3, r3, #24
                ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << RTC_ALRMAR_PM_Pos) | \
 80250be:	4318      	orrs	r0, r3
                ((uint32_t)(sAlarm->AlarmDateWeekDay) << RTC_ALRMAR_DU_Pos) | \
 80250c0:	6a23      	ldr	r3, [r4, #32]
 80250c2:	4318      	orrs	r0, r3
      tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << RTC_ALRMAR_HU_Pos) | \
 80250c4:	4310      	orrs	r0, r2
 80250c6:	e000      	b.n	80250ca <HAL_RTC_SetAlarm_IT+0xbe>
  uint32_t tmpreg = 0;
 80250c8:	2000      	movs	r0, #0
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80250ca:	4b31      	ldr	r3, [pc, #196]	; (8025190 <HAL_RTC_SetAlarm_IT+0x184>)
 80250cc:	22ca      	movs	r2, #202	; 0xca
 80250ce:	625a      	str	r2, [r3, #36]	; 0x24
 80250d0:	3a77      	subs	r2, #119	; 0x77
 80250d2:	625a      	str	r2, [r3, #36]	; 0x24
  if (sAlarm->Alarm == RTC_ALARM_A)
 80250d4:	2380      	movs	r3, #128	; 0x80
 80250d6:	005b      	lsls	r3, r3, #1
 80250d8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80250da:	429a      	cmp	r2, r3
 80250dc:	d02e      	beq.n	802513c <HAL_RTC_SetAlarm_IT+0x130>
    CLEAR_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 80250de:	4b2c      	ldr	r3, [pc, #176]	; (8025190 <HAL_RTC_SetAlarm_IT+0x184>)
 80250e0:	699a      	ldr	r2, [r3, #24]
 80250e2:	492d      	ldr	r1, [pc, #180]	; (8025198 <HAL_RTC_SetAlarm_IT+0x18c>)
 80250e4:	400a      	ands	r2, r1
 80250e6:	619a      	str	r2, [r3, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRBF);
 80250e8:	2202      	movs	r2, #2
 80250ea:	65da      	str	r2, [r3, #92]	; 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 80250ec:	2380      	movs	r3, #128	; 0x80
 80250ee:	005b      	lsls	r3, r3, #1
 80250f0:	429e      	cmp	r6, r3
 80250f2:	d045      	beq.n	8025180 <HAL_RTC_SetAlarm_IT+0x174>
      WRITE_REG(RTC->ALRMBR, tmpreg);
 80250f4:	4b26      	ldr	r3, [pc, #152]	; (8025190 <HAL_RTC_SetAlarm_IT+0x184>)
 80250f6:	6498      	str	r0, [r3, #72]	; 0x48
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask);
 80250f8:	69a2      	ldr	r2, [r4, #24]
 80250fa:	64da      	str	r2, [r3, #76]	; 0x4c
    WRITE_REG(RTC->ALRBBINR, sAlarm->AlarmTime.SubSeconds);
 80250fc:	6862      	ldr	r2, [r4, #4]
 80250fe:	4b24      	ldr	r3, [pc, #144]	; (8025190 <HAL_RTC_SetAlarm_IT+0x184>)
 8025100:	675a      	str	r2, [r3, #116]	; 0x74
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRBMF);
 8025102:	2202      	movs	r2, #2
 8025104:	6b29      	ldr	r1, [r5, #48]	; 0x30
 8025106:	430a      	orrs	r2, r1
 8025108:	632a      	str	r2, [r5, #48]	; 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRBE | RTC_CR_ALRBIE);
 802510a:	6999      	ldr	r1, [r3, #24]
 802510c:	2288      	movs	r2, #136	; 0x88
 802510e:	0192      	lsls	r2, r2, #6
 8025110:	430a      	orrs	r2, r1
 8025112:	619a      	str	r2, [r3, #24]
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 8025114:	4921      	ldr	r1, [pc, #132]	; (802519c <HAL_RTC_SetAlarm_IT+0x190>)
 8025116:	22c0      	movs	r2, #192	; 0xc0
 8025118:	5888      	ldr	r0, [r1, r2]
 802511a:	2380      	movs	r3, #128	; 0x80
 802511c:	029b      	lsls	r3, r3, #10
 802511e:	4303      	orrs	r3, r0
 8025120:	508b      	str	r3, [r1, r2]
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8025122:	4b1b      	ldr	r3, [pc, #108]	; (8025190 <HAL_RTC_SetAlarm_IT+0x184>)
 8025124:	323f      	adds	r2, #63	; 0x3f
 8025126:	625a      	str	r2, [r3, #36]	; 0x24
  hrtc->State = HAL_RTC_STATE_READY;
 8025128:	232d      	movs	r3, #45	; 0x2d
 802512a:	3afe      	subs	r2, #254	; 0xfe
 802512c:	54ea      	strb	r2, [r5, r3]
  __HAL_UNLOCK(hrtc);
 802512e:	3b01      	subs	r3, #1
 8025130:	2200      	movs	r2, #0
 8025132:	54ea      	strb	r2, [r5, r3]
  return HAL_OK;
 8025134:	2000      	movs	r0, #0
}
 8025136:	bc80      	pop	{r7}
 8025138:	46b8      	mov	r8, r7
 802513a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 802513c:	4b14      	ldr	r3, [pc, #80]	; (8025190 <HAL_RTC_SetAlarm_IT+0x184>)
 802513e:	699a      	ldr	r2, [r3, #24]
 8025140:	4917      	ldr	r1, [pc, #92]	; (80251a0 <HAL_RTC_SetAlarm_IT+0x194>)
 8025142:	400a      	ands	r2, r1
 8025144:	619a      	str	r2, [r3, #24]
    WRITE_REG(RTC->SCR, RTC_SCR_CALRAF);
 8025146:	2201      	movs	r2, #1
 8025148:	65da      	str	r2, [r3, #92]	; 0x5c
    if (binaryMode == RTC_BINARY_ONLY)
 802514a:	2380      	movs	r3, #128	; 0x80
 802514c:	005b      	lsls	r3, r3, #1
 802514e:	429e      	cmp	r6, r3
 8025150:	d010      	beq.n	8025174 <HAL_RTC_SetAlarm_IT+0x168>
      WRITE_REG(RTC->ALRMAR, tmpreg);
 8025152:	4b0f      	ldr	r3, [pc, #60]	; (8025190 <HAL_RTC_SetAlarm_IT+0x184>)
 8025154:	6418      	str	r0, [r3, #64]	; 0x40
      WRITE_REG(RTC->ALRMASSR, sAlarm->AlarmSubSecondMask);
 8025156:	69a2      	ldr	r2, [r4, #24]
 8025158:	645a      	str	r2, [r3, #68]	; 0x44
    WRITE_REG(RTC->ALRABINR, sAlarm->AlarmTime.SubSeconds);
 802515a:	6862      	ldr	r2, [r4, #4]
 802515c:	4b0c      	ldr	r3, [pc, #48]	; (8025190 <HAL_RTC_SetAlarm_IT+0x184>)
 802515e:	671a      	str	r2, [r3, #112]	; 0x70
    SET_BIT(hrtc->IsEnabled.RtcFeatures, RTC_MISR_ALRAMF);
 8025160:	2201      	movs	r2, #1
 8025162:	6b29      	ldr	r1, [r5, #48]	; 0x30
 8025164:	430a      	orrs	r2, r1
 8025166:	632a      	str	r2, [r5, #48]	; 0x30
    SET_BIT(RTC->CR, RTC_CR_ALRAE | RTC_CR_ALRAIE);
 8025168:	6999      	ldr	r1, [r3, #24]
 802516a:	2288      	movs	r2, #136	; 0x88
 802516c:	0152      	lsls	r2, r2, #5
 802516e:	430a      	orrs	r2, r1
 8025170:	619a      	str	r2, [r3, #24]
 8025172:	e7cf      	b.n	8025114 <HAL_RTC_SetAlarm_IT+0x108>
      RTC->ALRMASSR = sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr;
 8025174:	69a3      	ldr	r3, [r4, #24]
 8025176:	69e2      	ldr	r2, [r4, #28]
 8025178:	4313      	orrs	r3, r2
 802517a:	4a05      	ldr	r2, [pc, #20]	; (8025190 <HAL_RTC_SetAlarm_IT+0x184>)
 802517c:	6453      	str	r3, [r2, #68]	; 0x44
 802517e:	e7ec      	b.n	802515a <HAL_RTC_SetAlarm_IT+0x14e>
      WRITE_REG(RTC->ALRMBSSR, sAlarm->AlarmSubSecondMask | sAlarm->BinaryAutoClr);
 8025180:	69a3      	ldr	r3, [r4, #24]
 8025182:	69e2      	ldr	r2, [r4, #28]
 8025184:	4313      	orrs	r3, r2
 8025186:	4a02      	ldr	r2, [pc, #8]	; (8025190 <HAL_RTC_SetAlarm_IT+0x184>)
 8025188:	64d3      	str	r3, [r2, #76]	; 0x4c
 802518a:	e7b7      	b.n	80250fc <HAL_RTC_SetAlarm_IT+0xf0>
  __HAL_LOCK(hrtc);
 802518c:	2002      	movs	r0, #2
 802518e:	e7d2      	b.n	8025136 <HAL_RTC_SetAlarm_IT+0x12a>
 8025190:	40002800 	.word	0x40002800
 8025194:	80808080 	.word	0x80808080
 8025198:	ffffddff 	.word	0xffffddff
 802519c:	58000800 	.word	0x58000800
 80251a0:	ffffeeff 	.word	0xffffeeff

080251a4 <HAL_RTCEx_EnableBypassShadow>:
  *         directly from the Calendar counter.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_EnableBypassShadow(RTC_HandleTypeDef *hrtc)
{
 80251a4:	b570      	push	{r4, r5, r6, lr}
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80251a6:	232c      	movs	r3, #44	; 0x2c
 80251a8:	5cc3      	ldrb	r3, [r0, r3]
 80251aa:	2b01      	cmp	r3, #1
 80251ac:	d015      	beq.n	80251da <HAL_RTCEx_EnableBypassShadow+0x36>
 80251ae:	212c      	movs	r1, #44	; 0x2c
 80251b0:	2501      	movs	r5, #1
 80251b2:	5445      	strb	r5, [r0, r1]

  hrtc->State = HAL_RTC_STATE_BUSY;
 80251b4:	242d      	movs	r4, #45	; 0x2d
 80251b6:	2302      	movs	r3, #2
 80251b8:	5503      	strb	r3, [r0, r4]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80251ba:	4b09      	ldr	r3, [pc, #36]	; (80251e0 <HAL_RTCEx_EnableBypassShadow+0x3c>)
 80251bc:	22ca      	movs	r2, #202	; 0xca
 80251be:	625a      	str	r2, [r3, #36]	; 0x24
 80251c0:	3a77      	subs	r2, #119	; 0x77
 80251c2:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set the BYPSHAD bit */
  SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 80251c4:	699a      	ldr	r2, [r3, #24]
 80251c6:	2620      	movs	r6, #32
 80251c8:	4332      	orrs	r2, r6
 80251ca:	619a      	str	r2, [r3, #24]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80251cc:	22ff      	movs	r2, #255	; 0xff
 80251ce:	625a      	str	r2, [r3, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 80251d0:	5505      	strb	r5, [r0, r4]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 80251d2:	2300      	movs	r3, #0
 80251d4:	5443      	strb	r3, [r0, r1]

  return HAL_OK;
 80251d6:	2000      	movs	r0, #0
}
 80251d8:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(hrtc);
 80251da:	2002      	movs	r0, #2
 80251dc:	e7fc      	b.n	80251d8 <HAL_RTCEx_EnableBypassShadow+0x34>
 80251de:	46c0      	nop			; (mov r8, r8)
 80251e0:	40002800 	.word	0x40002800

080251e4 <HAL_RTCEx_SetSSRU_IT>:
  * @brief  Set SSR Underflow detection with Interrupt.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetSSRU_IT(RTC_HandleTypeDef *hrtc)
{
 80251e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80251e6:	46c6      	mov	lr, r8
 80251e8:	b500      	push	{lr}
  /* Process Locked */
  __HAL_LOCK(hrtc);
 80251ea:	232c      	movs	r3, #44	; 0x2c
 80251ec:	5cc3      	ldrb	r3, [r0, r3]
 80251ee:	2b01      	cmp	r3, #1
 80251f0:	d022      	beq.n	8025238 <HAL_RTCEx_SetSSRU_IT+0x54>
 80251f2:	232c      	movs	r3, #44	; 0x2c
 80251f4:	4698      	mov	r8, r3
 80251f6:	2501      	movs	r5, #1
 80251f8:	54c5      	strb	r5, [r0, r3]

  hrtc->State = HAL_RTC_STATE_BUSY;
 80251fa:	242d      	movs	r4, #45	; 0x2d
 80251fc:	3b2a      	subs	r3, #42	; 0x2a
 80251fe:	5503      	strb	r3, [r0, r4]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8025200:	4b0e      	ldr	r3, [pc, #56]	; (802523c <HAL_RTCEx_SetSSRU_IT+0x58>)
 8025202:	22ca      	movs	r2, #202	; 0xca
 8025204:	625a      	str	r2, [r3, #36]	; 0x24
 8025206:	3a77      	subs	r2, #119	; 0x77
 8025208:	625a      	str	r2, [r3, #36]	; 0x24

  /* Enable IT SSRU */
  __HAL_RTC_SSRU_ENABLE_IT(hrtc, RTC_IT_SSRU);
 802520a:	699a      	ldr	r2, [r3, #24]
 802520c:	2680      	movs	r6, #128	; 0x80
 802520e:	4332      	orrs	r2, r6
 8025210:	619a      	str	r2, [r3, #24]

  /* RTC SSRU Interrupt Configuration: EXTI configuration */
  __HAL_RTC_SSRU_EXTI_ENABLE_IT();
 8025212:	4f0b      	ldr	r7, [pc, #44]	; (8025240 <HAL_RTCEx_SetSSRU_IT+0x5c>)
 8025214:	3640      	adds	r6, #64	; 0x40
 8025216:	59ba      	ldr	r2, [r7, r6]
 8025218:	4694      	mov	ip, r2
 802521a:	2280      	movs	r2, #128	; 0x80
 802521c:	02d2      	lsls	r2, r2, #11
 802521e:	4661      	mov	r1, ip
 8025220:	430a      	orrs	r2, r1
 8025222:	51ba      	str	r2, [r7, r6]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8025224:	22ff      	movs	r2, #255	; 0xff
 8025226:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;
 8025228:	5505      	strb	r5, [r0, r4]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 802522a:	2300      	movs	r3, #0
 802522c:	4642      	mov	r2, r8
 802522e:	5483      	strb	r3, [r0, r2]

  return HAL_OK;
 8025230:	2000      	movs	r0, #0
}
 8025232:	bc80      	pop	{r7}
 8025234:	46b8      	mov	r8, r7
 8025236:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __HAL_LOCK(hrtc);
 8025238:	2002      	movs	r0, #2
 802523a:	e7fa      	b.n	8025232 <HAL_RTCEx_SetSSRU_IT+0x4e>
 802523c:	40002800 	.word	0x40002800
 8025240:	58000800 	.word	0x58000800

08025244 <HAL_RTCEx_SSRUIRQHandler>:
  * @brief  Handle SSR underflow interrupt request.
  * @param  hrtc RTC handle
  * @retval None
  */
void HAL_RTCEx_SSRUIRQHandler(RTC_HandleTypeDef *hrtc)
{
 8025244:	b510      	push	{r4, lr}
 8025246:	0004      	movs	r4, r0
  if ((RTC->MISR & RTC_MISR_SSRUMF) != 0u)
 8025248:	4b06      	ldr	r3, [pc, #24]	; (8025264 <HAL_RTCEx_SSRUIRQHandler+0x20>)
 802524a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802524c:	065b      	lsls	r3, r3, #25
 802524e:	d403      	bmi.n	8025258 <HAL_RTCEx_SSRUIRQHandler+0x14>
    HAL_RTCEx_SSRUEventCallback(hrtc);
#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8025250:	232d      	movs	r3, #45	; 0x2d
 8025252:	2201      	movs	r2, #1
 8025254:	54e2      	strb	r2, [r4, r3]
}
 8025256:	bd10      	pop	{r4, pc}
    RTC->SCR = RTC_SCR_CSSRUF;
 8025258:	4b02      	ldr	r3, [pc, #8]	; (8025264 <HAL_RTCEx_SSRUIRQHandler+0x20>)
 802525a:	2240      	movs	r2, #64	; 0x40
 802525c:	65da      	str	r2, [r3, #92]	; 0x5c
    HAL_RTCEx_SSRUEventCallback(hrtc);
 802525e:	f7fc fe07 	bl	8021e70 <HAL_RTCEx_SSRUEventCallback>
 8025262:	e7f5      	b.n	8025250 <HAL_RTCEx_SSRUIRQHandler+0xc>
 8025264:	40002800 	.word	0x40002800

08025268 <HAL_RTCEx_BKUPWrite>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 8025268:	0089      	lsls	r1, r1, #2
 802526a:	4b02      	ldr	r3, [pc, #8]	; (8025274 <HAL_RTCEx_BKUPWrite+0xc>)
 802526c:	469c      	mov	ip, r3
 802526e:	4461      	add	r1, ip

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 8025270:	600a      	str	r2, [r1, #0]
}
 8025272:	4770      	bx	lr
 8025274:	4000b100 	.word	0x4000b100

08025278 <HAL_RTCEx_BKUPRead>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 8025278:	0089      	lsls	r1, r1, #2
 802527a:	4b02      	ldr	r3, [pc, #8]	; (8025284 <HAL_RTCEx_BKUPRead+0xc>)
 802527c:	469c      	mov	ip, r3
 802527e:	4461      	add	r1, ip

  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
 8025280:	6808      	ldr	r0, [r1, #0]
}
 8025282:	4770      	bx	lr
 8025284:	4000b100 	.word	0x4000b100

08025288 <SUBGHZSPI_Init>:
  * @brief  Initializes the SUBGHZSPI peripheral
  * @param  BaudratePrescaler SPI Baudrate prescaler
  * @retval None
  */
void SUBGHZSPI_Init(uint32_t BaudratePrescaler)
{
 8025288:	b530      	push	{r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_SUBGHZ_ALL_INSTANCE(SUBGHZSPI));

  /* Disable SUBGHZSPI Peripheral */
  CLEAR_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 802528a:	4b08      	ldr	r3, [pc, #32]	; (80252ac <SUBGHZSPI_Init+0x24>)
 802528c:	681c      	ldr	r4, [r3, #0]
 802528e:	2540      	movs	r5, #64	; 0x40
 8025290:	43ac      	bics	r4, r5
 8025292:	601c      	str	r4, [r3, #0]
   *       NSS management: Internal (Done with External bit inside PWR        *
   *  Communication speed: BaudratePrescaler                             *
   *            First bit: MSB                                                *
   *      CRC calculation: Disable                                            *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR1, (SPI_CR1_MSTR | SPI_CR1_SSI | BaudratePrescaler | SPI_CR1_SSM));
 8025294:	21c1      	movs	r1, #193	; 0xc1
 8025296:	0089      	lsls	r1, r1, #2
 8025298:	4301      	orrs	r1, r0
 802529a:	6019      	str	r1, [r3, #0]
   *            Data Size: 8bits                                              *
   *              TI Mode: Disable                                            *
   *            NSS Pulse: Disable                                            *
   *    Rx FIFO Threshold: 8bits                                              *
   *--------------------------------------------------------------------------*/
  WRITE_REG(SUBGHZSPI->CR2, (SPI_CR2_FRXTH |  SPI_CR2_DS_0 | SPI_CR2_DS_1 | SPI_CR2_DS_2));
 802529c:	22b8      	movs	r2, #184	; 0xb8
 802529e:	0152      	lsls	r2, r2, #5
 80252a0:	605a      	str	r2, [r3, #4]

  /* Enable SUBGHZSPI Peripheral */
  SET_BIT(SUBGHZSPI->CR1, SPI_CR1_SPE);
 80252a2:	681a      	ldr	r2, [r3, #0]
 80252a4:	432a      	orrs	r2, r5
 80252a6:	601a      	str	r2, [r3, #0]
}
 80252a8:	bd30      	pop	{r4, r5, pc}
 80252aa:	46c0      	nop			; (mov r8, r8)
 80252ac:	58010000 	.word	0x58010000

080252b0 <HAL_SUBGHZ_Init>:
{
 80252b0:	b530      	push	{r4, r5, lr}
 80252b2:	b083      	sub	sp, #12
 80252b4:	1e04      	subs	r4, r0, #0
  if (hsubghz == NULL)
 80252b6:	d058      	beq.n	802536a <HAL_SUBGHZ_Init+0xba>
  subghz_state = hsubghz->State;
 80252b8:	7983      	ldrb	r3, [r0, #6]
 80252ba:	b2dd      	uxtb	r5, r3
  if ((subghz_state == HAL_SUBGHZ_STATE_RESET) ||
 80252bc:	2b00      	cmp	r3, #0
 80252be:	d001      	beq.n	80252c4 <HAL_SUBGHZ_Init+0x14>
 80252c0:	2d03      	cmp	r5, #3
 80252c2:	d10b      	bne.n	80252dc <HAL_SUBGHZ_Init+0x2c>
    hsubghz->Lock = HAL_UNLOCKED;
 80252c4:	2300      	movs	r3, #0
 80252c6:	7163      	strb	r3, [r4, #5]
    HAL_SUBGHZ_MspInit(hsubghz);
 80252c8:	0020      	movs	r0, r4
 80252ca:	f7fc fb6b 	bl	80219a4 <HAL_SUBGHZ_MspInit>
  SET_BIT(EXTI->IMR2, ExtiLine);
 80252ce:	4928      	ldr	r1, [pc, #160]	; (8025370 <HAL_SUBGHZ_Init+0xc0>)
 80252d0:	2290      	movs	r2, #144	; 0x90
 80252d2:	5888      	ldr	r0, [r1, r2]
 80252d4:	2380      	movs	r3, #128	; 0x80
 80252d6:	015b      	lsls	r3, r3, #5
 80252d8:	4303      	orrs	r3, r0
 80252da:	508b      	str	r3, [r1, r2]
  if (subghz_state == HAL_SUBGHZ_STATE_RESET)
 80252dc:	2d00      	cmp	r5, #0
 80252de:	d010      	beq.n	8025302 <HAL_SUBGHZ_Init+0x52>
  WRITE_REG(PWR->SCR, PWR_SCR_CWRFBUSYF);
 80252e0:	4b24      	ldr	r3, [pc, #144]	; (8025374 <HAL_SUBGHZ_Init+0xc4>)
 80252e2:	2280      	movs	r2, #128	; 0x80
 80252e4:	0112      	lsls	r2, r2, #4
 80252e6:	619a      	str	r2, [r3, #24]
    status = HAL_OK;
 80252e8:	2500      	movs	r5, #0
    SUBGHZSPI_Init(hsubghz->Init.BaudratePrescaler);
 80252ea:	6820      	ldr	r0, [r4, #0]
 80252ec:	f7ff ffcc 	bl	8025288 <SUBGHZSPI_Init>
    hsubghz->DeepSleep = SUBGHZ_DEEP_SLEEP_ENABLE;
 80252f0:	2301      	movs	r3, #1
 80252f2:	7123      	strb	r3, [r4, #4]
    hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_NONE;
 80252f4:	2300      	movs	r3, #0
 80252f6:	60a3      	str	r3, [r4, #8]
  hsubghz->State = HAL_SUBGHZ_STATE_READY;
 80252f8:	2301      	movs	r3, #1
 80252fa:	71a3      	strb	r3, [r4, #6]
}
 80252fc:	0028      	movs	r0, r5
 80252fe:	b003      	add	sp, #12
 8025300:	bd30      	pop	{r4, r5, pc}
    hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 8025302:	2302      	movs	r3, #2
 8025304:	71a3      	strb	r3, [r4, #6]
  CLEAR_BIT(RCC->CSR, RCC_CSR_RFRST);
 8025306:	21b0      	movs	r1, #176	; 0xb0
 8025308:	05c9      	lsls	r1, r1, #23
 802530a:	2294      	movs	r2, #148	; 0x94
 802530c:	588b      	ldr	r3, [r1, r2]
 802530e:	481a      	ldr	r0, [pc, #104]	; (8025378 <HAL_SUBGHZ_Init+0xc8>)
 8025310:	4003      	ands	r3, r0
 8025312:	508b      	str	r3, [r1, r2]
    count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8025314:	4b19      	ldr	r3, [pc, #100]	; (802537c <HAL_SUBGHZ_Init+0xcc>)
 8025316:	681a      	ldr	r2, [r3, #0]
 8025318:	00d3      	lsls	r3, r2, #3
 802531a:	1a9b      	subs	r3, r3, r2
 802531c:	009b      	lsls	r3, r3, #2
 802531e:	0cdb      	lsrs	r3, r3, #19
 8025320:	2264      	movs	r2, #100	; 0x64
 8025322:	4353      	muls	r3, r2
 8025324:	9301      	str	r3, [sp, #4]
      if (count == 0U)
 8025326:	9b01      	ldr	r3, [sp, #4]
 8025328:	2b00      	cmp	r3, #0
 802532a:	d01a      	beq.n	8025362 <HAL_SUBGHZ_Init+0xb2>
      count--;
 802532c:	9b01      	ldr	r3, [sp, #4]
 802532e:	3b01      	subs	r3, #1
 8025330:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(RCC->CSR, RCC_CSR_RFRSTF) == (RCC_CSR_RFRSTF)) ? 1UL : 0UL);
 8025332:	22b0      	movs	r2, #176	; 0xb0
 8025334:	05d2      	lsls	r2, r2, #23
 8025336:	2394      	movs	r3, #148	; 0x94
 8025338:	58d3      	ldr	r3, [r2, r3]
 802533a:	045b      	lsls	r3, r3, #17
 802533c:	d4f3      	bmi.n	8025326 <HAL_SUBGHZ_Init+0x76>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 802533e:	4b0d      	ldr	r3, [pc, #52]	; (8025374 <HAL_SUBGHZ_Init+0xc4>)
 8025340:	2190      	movs	r1, #144	; 0x90
 8025342:	5858      	ldr	r0, [r3, r1]
 8025344:	2280      	movs	r2, #128	; 0x80
 8025346:	0212      	lsls	r2, r2, #8
 8025348:	4302      	orrs	r2, r0
 802534a:	505a      	str	r2, [r3, r1]
  MODIFY_REG(PWR->CR3, PWR_CR3_EWRFBUSY, RadioBusyTrigger);
 802534c:	689a      	ldr	r2, [r3, #8]
 802534e:	490c      	ldr	r1, [pc, #48]	; (8025380 <HAL_SUBGHZ_Init+0xd0>)
 8025350:	400a      	ands	r2, r1
 8025352:	2180      	movs	r1, #128	; 0x80
 8025354:	0109      	lsls	r1, r1, #4
 8025356:	430a      	orrs	r2, r1
 8025358:	609a      	str	r2, [r3, #8]
  WRITE_REG(PWR->SCR, PWR_SCR_CWRFBUSYF);
 802535a:	6199      	str	r1, [r3, #24]
  if (status == HAL_OK)
 802535c:	2d00      	cmp	r5, #0
 802535e:	d1cb      	bne.n	80252f8 <HAL_SUBGHZ_Init+0x48>
 8025360:	e7c3      	b.n	80252ea <HAL_SUBGHZ_Init+0x3a>
        hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 8025362:	3301      	adds	r3, #1
 8025364:	60a3      	str	r3, [r4, #8]
        status  = HAL_ERROR;
 8025366:	2501      	movs	r5, #1
        break;
 8025368:	e7e9      	b.n	802533e <HAL_SUBGHZ_Init+0x8e>
    return status;
 802536a:	2501      	movs	r5, #1
 802536c:	e7c6      	b.n	80252fc <HAL_SUBGHZ_Init+0x4c>
 802536e:	46c0      	nop			; (mov r8, r8)
 8025370:	58000800 	.word	0x58000800
 8025374:	58000400 	.word	0x58000400
 8025378:	ffff7fff 	.word	0xffff7fff
 802537c:	2000b04c 	.word	0x2000b04c
 8025380:	fffff7ff 	.word	0xfffff7ff

08025384 <SUBGHZSPI_Transmit>:
  * @param  Data  data to transmit
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Transmit(SUBGHZ_HandleTypeDef *hsubghz,
                                     uint8_t Data)
{
 8025384:	b082      	sub	sp, #8
 8025386:	0002      	movs	r2, r0
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8025388:	4b1a      	ldr	r3, [pc, #104]	; (80253f4 <SUBGHZSPI_Transmit+0x70>)
 802538a:	6818      	ldr	r0, [r3, #0]
 802538c:	00c3      	lsls	r3, r0, #3
 802538e:	1a1b      	subs	r3, r3, r0
 8025390:	009b      	lsls	r3, r3, #2
 8025392:	0cdb      	lsrs	r3, r3, #19
 8025394:	2064      	movs	r0, #100	; 0x64
 8025396:	4343      	muls	r3, r0
 8025398:	9301      	str	r3, [sp, #4]

  /* Wait until TXE flag is set */
  do
  {
    if (count == 0U)
 802539a:	9b01      	ldr	r3, [sp, #4]
 802539c:	2b00      	cmp	r3, #0
 802539e:	d008      	beq.n	80253b2 <SUBGHZSPI_Transmit+0x2e>
    {
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
 80253a0:	9b01      	ldr	r3, [sp, #4]
 80253a2:	3b01      	subs	r3, #1
 80253a4:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 80253a6:	4b14      	ldr	r3, [pc, #80]	; (80253f8 <SUBGHZSPI_Transmit+0x74>)
 80253a8:	689b      	ldr	r3, [r3, #8]
 80253aa:	079b      	lsls	r3, r3, #30
 80253ac:	d5f5      	bpl.n	802539a <SUBGHZSPI_Transmit+0x16>
  HAL_StatusTypeDef status = HAL_OK;
 80253ae:	2000      	movs	r0, #0
 80253b0:	e002      	b.n	80253b8 <SUBGHZSPI_Transmit+0x34>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 80253b2:	3301      	adds	r3, #1
 80253b4:	6093      	str	r3, [r2, #8]
      status = HAL_ERROR;
 80253b6:	2001      	movs	r0, #1

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = Data;
 80253b8:	4b10      	ldr	r3, [pc, #64]	; (80253fc <SUBGHZSPI_Transmit+0x78>)
 80253ba:	7019      	strb	r1, [r3, #0]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = Data;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 80253bc:	4b0d      	ldr	r3, [pc, #52]	; (80253f4 <SUBGHZSPI_Transmit+0x70>)
 80253be:	6819      	ldr	r1, [r3, #0]
 80253c0:	00cb      	lsls	r3, r1, #3
 80253c2:	1a5b      	subs	r3, r3, r1
 80253c4:	009b      	lsls	r3, r3, #2
 80253c6:	0cdb      	lsrs	r3, r3, #19
 80253c8:	2164      	movs	r1, #100	; 0x64
 80253ca:	434b      	muls	r3, r1
 80253cc:	9301      	str	r3, [sp, #4]

  /* Wait until RXNE flag is set */
  do
  {
    if (count == 0U)
 80253ce:	9b01      	ldr	r3, [sp, #4]
 80253d0:	2b00      	cmp	r3, #0
 80253d2:	d007      	beq.n	80253e4 <SUBGHZSPI_Transmit+0x60>
    {
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
 80253d4:	9b01      	ldr	r3, [sp, #4]
 80253d6:	3b01      	subs	r3, #1
 80253d8:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 80253da:	4b07      	ldr	r3, [pc, #28]	; (80253f8 <SUBGHZSPI_Transmit+0x74>)
 80253dc:	689b      	ldr	r3, [r3, #8]
 80253de:	07db      	lsls	r3, r3, #31
 80253e0:	d5f5      	bpl.n	80253ce <SUBGHZSPI_Transmit+0x4a>
 80253e2:	e002      	b.n	80253ea <SUBGHZSPI_Transmit+0x66>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 80253e4:	3301      	adds	r3, #1
 80253e6:	6093      	str	r3, [r2, #8]
      status = HAL_ERROR;
 80253e8:	2001      	movs	r0, #1

  /* Flush Rx data */
  READ_REG(SUBGHZSPI->DR);
 80253ea:	4b03      	ldr	r3, [pc, #12]	; (80253f8 <SUBGHZSPI_Transmit+0x74>)
 80253ec:	68db      	ldr	r3, [r3, #12]

  return status;
}
 80253ee:	b002      	add	sp, #8
 80253f0:	4770      	bx	lr
 80253f2:	46c0      	nop			; (mov r8, r8)
 80253f4:	2000b04c 	.word	0x2000b04c
 80253f8:	58010000 	.word	0x58010000
 80253fc:	5801000c 	.word	0x5801000c

08025400 <SUBGHZSPI_Receive>:
  * @param  pData  pointer on data to receive
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZSPI_Receive(SUBGHZ_HandleTypeDef *hsubghz,
                                    uint8_t *pData)
{
 8025400:	b510      	push	{r4, lr}
 8025402:	b082      	sub	sp, #8
 8025404:	0002      	movs	r2, r0
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t count;

  /* Handle Tx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 8025406:	4b1b      	ldr	r3, [pc, #108]	; (8025474 <SUBGHZSPI_Receive+0x74>)
 8025408:	6818      	ldr	r0, [r3, #0]
 802540a:	00c3      	lsls	r3, r0, #3
 802540c:	1a1b      	subs	r3, r3, r0
 802540e:	009b      	lsls	r3, r3, #2
 8025410:	0cdb      	lsrs	r3, r3, #19
 8025412:	2064      	movs	r0, #100	; 0x64
 8025414:	4343      	muls	r3, r0
 8025416:	9301      	str	r3, [sp, #4]

  /* Wait until TXE flag is set */
  do
  {
    if (count == 0U)
 8025418:	9b01      	ldr	r3, [sp, #4]
 802541a:	2b00      	cmp	r3, #0
 802541c:	d008      	beq.n	8025430 <SUBGHZSPI_Receive+0x30>
    {
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
 802541e:	9b01      	ldr	r3, [sp, #4]
 8025420:	3b01      	subs	r3, #1
 8025422:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_TXE) != (SPI_SR_TXE));
 8025424:	4b14      	ldr	r3, [pc, #80]	; (8025478 <SUBGHZSPI_Receive+0x78>)
 8025426:	689b      	ldr	r3, [r3, #8]
 8025428:	079b      	lsls	r3, r3, #30
 802542a:	d5f5      	bpl.n	8025418 <SUBGHZSPI_Receive+0x18>
  HAL_StatusTypeDef status = HAL_OK;
 802542c:	2000      	movs	r0, #0
 802542e:	e002      	b.n	8025436 <SUBGHZSPI_Receive+0x36>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 8025430:	3301      	adds	r3, #1
 8025432:	6093      	str	r3, [r2, #8]
      status = HAL_ERROR;
 8025434:	2001      	movs	r0, #1

  /* Transmit Data*/
#if defined (__GNUC__)
  __IO uint8_t *spidr = ((__IO uint8_t *)&SUBGHZSPI->DR);
  *spidr = SUBGHZ_DUMMY_DATA;
 8025436:	4b11      	ldr	r3, [pc, #68]	; (802547c <SUBGHZSPI_Receive+0x7c>)
 8025438:	24ff      	movs	r4, #255	; 0xff
 802543a:	701c      	strb	r4, [r3, #0]
  *((__IO uint8_t *)&SUBGHZSPI->DR) = SUBGHZ_DUMMY_DATA;
#endif /* __GNUC__ */

  /* Handle Rx transmission from SUBGHZSPI peripheral to Radio ****************/
  /* Initialize Timeout */
  count = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_DEFAULT_LOOP_TIME;
 802543c:	4b0d      	ldr	r3, [pc, #52]	; (8025474 <SUBGHZSPI_Receive+0x74>)
 802543e:	681c      	ldr	r4, [r3, #0]
 8025440:	00e3      	lsls	r3, r4, #3
 8025442:	1b1b      	subs	r3, r3, r4
 8025444:	009b      	lsls	r3, r3, #2
 8025446:	0cdb      	lsrs	r3, r3, #19
 8025448:	2464      	movs	r4, #100	; 0x64
 802544a:	4363      	muls	r3, r4
 802544c:	9301      	str	r3, [sp, #4]

  /* Wait until RXNE flag is set */
  do
  {
    if (count == 0U)
 802544e:	9b01      	ldr	r3, [sp, #4]
 8025450:	2b00      	cmp	r3, #0
 8025452:	d007      	beq.n	8025464 <SUBGHZSPI_Receive+0x64>
    {
      status = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
      break;
    }
    count--;
 8025454:	9b01      	ldr	r3, [sp, #4]
 8025456:	3b01      	subs	r3, #1
 8025458:	9301      	str	r3, [sp, #4]
  } while (READ_BIT(SUBGHZSPI->SR, SPI_SR_RXNE) != (SPI_SR_RXNE));
 802545a:	4b07      	ldr	r3, [pc, #28]	; (8025478 <SUBGHZSPI_Receive+0x78>)
 802545c:	689b      	ldr	r3, [r3, #8]
 802545e:	07db      	lsls	r3, r3, #31
 8025460:	d5f5      	bpl.n	802544e <SUBGHZSPI_Receive+0x4e>
 8025462:	e002      	b.n	802546a <SUBGHZSPI_Receive+0x6a>
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_TIMEOUT;
 8025464:	3301      	adds	r3, #1
 8025466:	6093      	str	r3, [r2, #8]
      status = HAL_ERROR;
 8025468:	2001      	movs	r0, #1

  /* Retrieve pData */
  *pData = (uint8_t)(READ_REG(SUBGHZSPI->DR));
 802546a:	4b03      	ldr	r3, [pc, #12]	; (8025478 <SUBGHZSPI_Receive+0x78>)
 802546c:	68db      	ldr	r3, [r3, #12]
 802546e:	700b      	strb	r3, [r1, #0]

  return status;
}
 8025470:	b002      	add	sp, #8
 8025472:	bd10      	pop	{r4, pc}
 8025474:	2000b04c 	.word	0x2000b04c
 8025478:	58010000 	.word	0x58010000
 802547c:	5801000c 	.word	0x5801000c

08025480 <SUBGHZ_WaitOnBusy>:
  * @param  hsubghz pointer to a SUBGHZ_HandleTypeDef structure that contains
  *         the handle information for SUBGHZ module.
  * @retval HAL status
  */
HAL_StatusTypeDef SUBGHZ_WaitOnBusy(SUBGHZ_HandleTypeDef *hsubghz)
{
 8025480:	b510      	push	{r4, lr}
 8025482:	b082      	sub	sp, #8
  HAL_StatusTypeDef status;
  __IO uint32_t count;
  uint32_t mask;

  status = HAL_OK;
  count  = SUBGHZ_DEFAULT_TIMEOUT * SUBGHZ_RFBUSY_LOOP_TIME;
 8025484:	4b14      	ldr	r3, [pc, #80]	; (80254d8 <SUBGHZ_WaitOnBusy+0x58>)
 8025486:	681a      	ldr	r2, [r3, #0]
 8025488:	0053      	lsls	r3, r2, #1
 802548a:	189b      	adds	r3, r3, r2
 802548c:	00db      	lsls	r3, r3, #3
 802548e:	0d1b      	lsrs	r3, r3, #20
 8025490:	2264      	movs	r2, #100	; 0x64
 8025492:	4353      	muls	r3, r2
 8025494:	9301      	str	r3, [sp, #4]
 8025496:	e006      	b.n	80254a6 <SUBGHZ_WaitOnBusy+0x26>
    mask = LL_PWR_IsActiveFlag_RFBUSYMS();

    if (count == 0U)
    {
      status  = HAL_ERROR;
      hsubghz->ErrorCode = HAL_SUBGHZ_ERROR_RF_BUSY;
 8025498:	3302      	adds	r3, #2
 802549a:	6083      	str	r3, [r0, #8]
      status  = HAL_ERROR;
 802549c:	2001      	movs	r0, #1
    }
    count--;
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);

  return status;
}
 802549e:	b002      	add	sp, #8
 80254a0:	bd10      	pop	{r4, pc}
  } while ((LL_PWR_IsActiveFlag_RFBUSYS()& mask) == 1UL);
 80254a2:	420c      	tst	r4, r1
 80254a4:	d016      	beq.n	80254d4 <SUBGHZ_WaitOnBusy+0x54>
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYMS) == (PWR_SR2_RFBUSYMS)) ? 1UL : 0UL);
 80254a6:	4b0d      	ldr	r3, [pc, #52]	; (80254dc <SUBGHZ_WaitOnBusy+0x5c>)
 80254a8:	695b      	ldr	r3, [r3, #20]
 80254aa:	2204      	movs	r2, #4
 80254ac:	0011      	movs	r1, r2
 80254ae:	4019      	ands	r1, r3
 80254b0:	421a      	tst	r2, r3
 80254b2:	d000      	beq.n	80254b6 <SUBGHZ_WaitOnBusy+0x36>
 80254b4:	2101      	movs	r1, #1
    if (count == 0U)
 80254b6:	9b01      	ldr	r3, [sp, #4]
 80254b8:	2b00      	cmp	r3, #0
 80254ba:	d0ed      	beq.n	8025498 <SUBGHZ_WaitOnBusy+0x18>
    count--;
 80254bc:	9b01      	ldr	r3, [sp, #4]
 80254be:	3b01      	subs	r3, #1
 80254c0:	9301      	str	r3, [sp, #4]
  return ((READ_BIT(PWR->SR2, PWR_SR2_RFBUSYS) == (PWR_SR2_RFBUSYS)) ? 1UL : 0UL);
 80254c2:	4b06      	ldr	r3, [pc, #24]	; (80254dc <SUBGHZ_WaitOnBusy+0x5c>)
 80254c4:	695b      	ldr	r3, [r3, #20]
 80254c6:	2202      	movs	r2, #2
 80254c8:	0014      	movs	r4, r2
 80254ca:	401c      	ands	r4, r3
 80254cc:	421a      	tst	r2, r3
 80254ce:	d0e8      	beq.n	80254a2 <SUBGHZ_WaitOnBusy+0x22>
 80254d0:	2401      	movs	r4, #1
 80254d2:	e7e6      	b.n	80254a2 <SUBGHZ_WaitOnBusy+0x22>
  status = HAL_OK;
 80254d4:	2000      	movs	r0, #0
 80254d6:	e7e2      	b.n	802549e <SUBGHZ_WaitOnBusy+0x1e>
 80254d8:	2000b04c 	.word	0x2000b04c
 80254dc:	58000400 	.word	0x58000400

080254e0 <SUBGHZ_CheckDeviceReady>:
{
 80254e0:	b510      	push	{r4, lr}
 80254e2:	b082      	sub	sp, #8
  if (hsubghz->DeepSleep == SUBGHZ_DEEP_SLEEP_ENABLE)
 80254e4:	7903      	ldrb	r3, [r0, #4]
 80254e6:	2b01      	cmp	r3, #1
 80254e8:	d003      	beq.n	80254f2 <SUBGHZ_CheckDeviceReady+0x12>
  return (SUBGHZ_WaitOnBusy(hsubghz));
 80254ea:	f7ff ffc9 	bl	8025480 <SUBGHZ_WaitOnBusy>
}
 80254ee:	b002      	add	sp, #8
 80254f0:	bd10      	pop	{r4, pc}
    count  = SUBGHZ_NSS_LOOP_TIME;
 80254f2:	4b0d      	ldr	r3, [pc, #52]	; (8025528 <SUBGHZ_CheckDeviceReady+0x48>)
 80254f4:	681a      	ldr	r2, [r3, #0]
 80254f6:	0053      	lsls	r3, r2, #1
 80254f8:	189b      	adds	r3, r3, r2
 80254fa:	00db      	lsls	r3, r3, #3
 80254fc:	0c1b      	lsrs	r3, r3, #16
 80254fe:	9301      	str	r3, [sp, #4]
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8025500:	490a      	ldr	r1, [pc, #40]	; (802552c <SUBGHZ_CheckDeviceReady+0x4c>)
 8025502:	2290      	movs	r2, #144	; 0x90
 8025504:	588b      	ldr	r3, [r1, r2]
 8025506:	4c0a      	ldr	r4, [pc, #40]	; (8025530 <SUBGHZ_CheckDeviceReady+0x50>)
 8025508:	4023      	ands	r3, r4
 802550a:	508b      	str	r3, [r1, r2]
      count--;
 802550c:	9b01      	ldr	r3, [sp, #4]
 802550e:	3b01      	subs	r3, #1
 8025510:	9301      	str	r3, [sp, #4]
    } while (count != 0UL);
 8025512:	9b01      	ldr	r3, [sp, #4]
 8025514:	2b00      	cmp	r3, #0
 8025516:	d1f9      	bne.n	802550c <SUBGHZ_CheckDeviceReady+0x2c>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8025518:	4904      	ldr	r1, [pc, #16]	; (802552c <SUBGHZ_CheckDeviceReady+0x4c>)
 802551a:	2290      	movs	r2, #144	; 0x90
 802551c:	588c      	ldr	r4, [r1, r2]
 802551e:	2380      	movs	r3, #128	; 0x80
 8025520:	021b      	lsls	r3, r3, #8
 8025522:	4323      	orrs	r3, r4
 8025524:	508b      	str	r3, [r1, r2]
}
 8025526:	e7e0      	b.n	80254ea <SUBGHZ_CheckDeviceReady+0xa>
 8025528:	2000b04c 	.word	0x2000b04c
 802552c:	58000400 	.word	0x58000400
 8025530:	ffff7fff 	.word	0xffff7fff

08025534 <HAL_SUBGHZ_WriteRegisters>:
{
 8025534:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025536:	46c6      	mov	lr, r8
 8025538:	b500      	push	{lr}
 802553a:	0005      	movs	r5, r0
 802553c:	000c      	movs	r4, r1
 802553e:	0017      	movs	r7, r2
 8025540:	001e      	movs	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8025542:	7983      	ldrb	r3, [r0, #6]
 8025544:	b2da      	uxtb	r2, r3
 8025546:	4690      	mov	r8, r2
 8025548:	2b01      	cmp	r3, #1
 802554a:	d13a      	bne.n	80255c2 <HAL_SUBGHZ_WriteRegisters+0x8e>
    __HAL_LOCK(hsubghz);
 802554c:	7943      	ldrb	r3, [r0, #5]
 802554e:	2b01      	cmp	r3, #1
 8025550:	d03a      	beq.n	80255c8 <HAL_SUBGHZ_WriteRegisters+0x94>
 8025552:	2301      	movs	r3, #1
 8025554:	7143      	strb	r3, [r0, #5]
    hsubghz->State = HAL_SUBGHZ_STATE_BUSY;
 8025556:	3301      	adds	r3, #1
 8025558:	7183      	strb	r3, [r0, #6]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802555a:	f7ff ffc1 	bl	80254e0 <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 802555e:	491c      	ldr	r1, [pc, #112]	; (80255d0 <HAL_SUBGHZ_WriteRegisters+0x9c>)
 8025560:	2290      	movs	r2, #144	; 0x90
 8025562:	588b      	ldr	r3, [r1, r2]
 8025564:	481b      	ldr	r0, [pc, #108]	; (80255d4 <HAL_SUBGHZ_WriteRegisters+0xa0>)
 8025566:	4003      	ands	r3, r0
 8025568:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_REGISTER);
 802556a:	210d      	movs	r1, #13
 802556c:	0028      	movs	r0, r5
 802556e:	f7ff ff09 	bl	8025384 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 8025572:	0a21      	lsrs	r1, r4, #8
 8025574:	0028      	movs	r0, r5
 8025576:	f7ff ff05 	bl	8025384 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 802557a:	b2e1      	uxtb	r1, r4
 802557c:	0028      	movs	r0, r5
 802557e:	f7ff ff01 	bl	8025384 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 8025582:	2400      	movs	r4, #0
 8025584:	e005      	b.n	8025592 <HAL_SUBGHZ_WriteRegisters+0x5e>
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 8025586:	5d39      	ldrb	r1, [r7, r4]
 8025588:	0028      	movs	r0, r5
 802558a:	f7ff fefb 	bl	8025384 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802558e:	3401      	adds	r4, #1
 8025590:	b2a4      	uxth	r4, r4
 8025592:	42b4      	cmp	r4, r6
 8025594:	d3f7      	bcc.n	8025586 <HAL_SUBGHZ_WriteRegisters+0x52>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8025596:	490e      	ldr	r1, [pc, #56]	; (80255d0 <HAL_SUBGHZ_WriteRegisters+0x9c>)
 8025598:	2290      	movs	r2, #144	; 0x90
 802559a:	5888      	ldr	r0, [r1, r2]
 802559c:	2380      	movs	r3, #128	; 0x80
 802559e:	021b      	lsls	r3, r3, #8
 80255a0:	4303      	orrs	r3, r0
 80255a2:	508b      	str	r3, [r1, r2]
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 80255a4:	0028      	movs	r0, r5
 80255a6:	f7ff ff6b 	bl	8025480 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 80255aa:	68ab      	ldr	r3, [r5, #8]
 80255ac:	2b00      	cmp	r3, #0
 80255ae:	d100      	bne.n	80255b2 <HAL_SUBGHZ_WriteRegisters+0x7e>
      status = HAL_OK;
 80255b0:	4698      	mov	r8, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 80255b2:	2301      	movs	r3, #1
 80255b4:	71ab      	strb	r3, [r5, #6]
    __HAL_UNLOCK(hsubghz);
 80255b6:	2300      	movs	r3, #0
 80255b8:	716b      	strb	r3, [r5, #5]
}
 80255ba:	4640      	mov	r0, r8
 80255bc:	bc80      	pop	{r7}
 80255be:	46b8      	mov	r8, r7
 80255c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_BUSY;
 80255c2:	2302      	movs	r3, #2
 80255c4:	4698      	mov	r8, r3
 80255c6:	e7f8      	b.n	80255ba <HAL_SUBGHZ_WriteRegisters+0x86>
    __HAL_LOCK(hsubghz);
 80255c8:	2302      	movs	r3, #2
 80255ca:	4698      	mov	r8, r3
 80255cc:	e7f5      	b.n	80255ba <HAL_SUBGHZ_WriteRegisters+0x86>
 80255ce:	46c0      	nop			; (mov r8, r8)
 80255d0:	58000400 	.word	0x58000400
 80255d4:	ffff7fff 	.word	0xffff7fff

080255d8 <HAL_SUBGHZ_ReadRegisters>:
{
 80255d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80255da:	46c6      	mov	lr, r8
 80255dc:	b500      	push	{lr}
 80255de:	0006      	movs	r6, r0
 80255e0:	000c      	movs	r4, r1
 80255e2:	0015      	movs	r5, r2
 80255e4:	001f      	movs	r7, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 80255e6:	7983      	ldrb	r3, [r0, #6]
 80255e8:	b2da      	uxtb	r2, r3
 80255ea:	4690      	mov	r8, r2
 80255ec:	2b01      	cmp	r3, #1
 80255ee:	d13d      	bne.n	802566c <HAL_SUBGHZ_ReadRegisters+0x94>
    __HAL_LOCK(hsubghz);
 80255f0:	7943      	ldrb	r3, [r0, #5]
 80255f2:	2b01      	cmp	r3, #1
 80255f4:	d03d      	beq.n	8025672 <HAL_SUBGHZ_ReadRegisters+0x9a>
 80255f6:	2301      	movs	r3, #1
 80255f8:	7143      	strb	r3, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 80255fa:	f7ff ff71 	bl	80254e0 <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80255fe:	491e      	ldr	r1, [pc, #120]	; (8025678 <HAL_SUBGHZ_ReadRegisters+0xa0>)
 8025600:	2290      	movs	r2, #144	; 0x90
 8025602:	588b      	ldr	r3, [r1, r2]
 8025604:	481d      	ldr	r0, [pc, #116]	; (802567c <HAL_SUBGHZ_ReadRegisters+0xa4>)
 8025606:	4003      	ands	r3, r0
 8025608:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_REGISTER);
 802560a:	211d      	movs	r1, #29
 802560c:	0030      	movs	r0, r6
 802560e:	f7ff feb9 	bl	8025384 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)((Address & 0xFF00U) >> 8U));
 8025612:	0a21      	lsrs	r1, r4, #8
 8025614:	0030      	movs	r0, r6
 8025616:	f7ff feb5 	bl	8025384 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)(Address & 0x00FFU));
 802561a:	b2e1      	uxtb	r1, r4
 802561c:	0030      	movs	r0, r6
 802561e:	f7ff feb1 	bl	8025384 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0U);
 8025622:	2100      	movs	r1, #0
 8025624:	0030      	movs	r0, r6
 8025626:	f7ff fead 	bl	8025384 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802562a:	2400      	movs	r4, #0
 802562c:	e006      	b.n	802563c <HAL_SUBGHZ_ReadRegisters+0x64>
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 802562e:	0029      	movs	r1, r5
 8025630:	0030      	movs	r0, r6
 8025632:	f7ff fee5 	bl	8025400 <SUBGHZSPI_Receive>
      pData++;
 8025636:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 8025638:	3401      	adds	r4, #1
 802563a:	b2a4      	uxth	r4, r4
 802563c:	42bc      	cmp	r4, r7
 802563e:	d3f6      	bcc.n	802562e <HAL_SUBGHZ_ReadRegisters+0x56>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8025640:	490d      	ldr	r1, [pc, #52]	; (8025678 <HAL_SUBGHZ_ReadRegisters+0xa0>)
 8025642:	2290      	movs	r2, #144	; 0x90
 8025644:	5888      	ldr	r0, [r1, r2]
 8025646:	2380      	movs	r3, #128	; 0x80
 8025648:	021b      	lsls	r3, r3, #8
 802564a:	4303      	orrs	r3, r0
 802564c:	508b      	str	r3, [r1, r2]
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 802564e:	0030      	movs	r0, r6
 8025650:	f7ff ff16 	bl	8025480 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8025654:	68b3      	ldr	r3, [r6, #8]
 8025656:	2b00      	cmp	r3, #0
 8025658:	d100      	bne.n	802565c <HAL_SUBGHZ_ReadRegisters+0x84>
      status = HAL_OK;
 802565a:	4698      	mov	r8, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 802565c:	2301      	movs	r3, #1
 802565e:	71b3      	strb	r3, [r6, #6]
    __HAL_UNLOCK(hsubghz);
 8025660:	2300      	movs	r3, #0
 8025662:	7173      	strb	r3, [r6, #5]
}
 8025664:	4640      	mov	r0, r8
 8025666:	bc80      	pop	{r7}
 8025668:	46b8      	mov	r8, r7
 802566a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_BUSY;
 802566c:	2302      	movs	r3, #2
 802566e:	4698      	mov	r8, r3
 8025670:	e7f8      	b.n	8025664 <HAL_SUBGHZ_ReadRegisters+0x8c>
    __HAL_LOCK(hsubghz);
 8025672:	2302      	movs	r3, #2
 8025674:	4698      	mov	r8, r3
 8025676:	e7f5      	b.n	8025664 <HAL_SUBGHZ_ReadRegisters+0x8c>
 8025678:	58000400 	.word	0x58000400
 802567c:	ffff7fff 	.word	0xffff7fff

08025680 <HAL_SUBGHZ_ExecSetCmd>:
{
 8025680:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8025682:	46ce      	mov	lr, r9
 8025684:	4647      	mov	r7, r8
 8025686:	b580      	push	{r7, lr}
 8025688:	0005      	movs	r5, r0
 802568a:	4688      	mov	r8, r1
 802568c:	0017      	movs	r7, r2
 802568e:	001e      	movs	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8025690:	7983      	ldrb	r3, [r0, #6]
 8025692:	b2da      	uxtb	r2, r3
 8025694:	4691      	mov	r9, r2
 8025696:	2b01      	cmp	r3, #1
 8025698:	d13f      	bne.n	802571a <HAL_SUBGHZ_ExecSetCmd+0x9a>
    __HAL_LOCK(hsubghz);
 802569a:	7943      	ldrb	r3, [r0, #5]
 802569c:	2b01      	cmp	r3, #1
 802569e:	d03f      	beq.n	8025720 <HAL_SUBGHZ_ExecSetCmd+0xa0>
 80256a0:	2301      	movs	r3, #1
 80256a2:	7143      	strb	r3, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 80256a4:	f7ff ff1c 	bl	80254e0 <SUBGHZ_CheckDeviceReady>
    if ((Command == RADIO_SET_SLEEP) || (Command == RADIO_SET_RXDUTYCYCLE))
 80256a8:	4643      	mov	r3, r8
 80256aa:	2b84      	cmp	r3, #132	; 0x84
 80256ac:	d004      	beq.n	80256b8 <HAL_SUBGHZ_ExecSetCmd+0x38>
 80256ae:	2b94      	cmp	r3, #148	; 0x94
 80256b0:	d002      	beq.n	80256b8 <HAL_SUBGHZ_ExecSetCmd+0x38>
      hsubghz->DeepSleep = SUBGHZ_DEEP_SLEEP_DISABLE;
 80256b2:	2300      	movs	r3, #0
 80256b4:	712b      	strb	r3, [r5, #4]
 80256b6:	e001      	b.n	80256bc <HAL_SUBGHZ_ExecSetCmd+0x3c>
      hsubghz->DeepSleep = SUBGHZ_DEEP_SLEEP_ENABLE;
 80256b8:	2301      	movs	r3, #1
 80256ba:	712b      	strb	r3, [r5, #4]
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80256bc:	491a      	ldr	r1, [pc, #104]	; (8025728 <HAL_SUBGHZ_ExecSetCmd+0xa8>)
 80256be:	2290      	movs	r2, #144	; 0x90
 80256c0:	588b      	ldr	r3, [r1, r2]
 80256c2:	481a      	ldr	r0, [pc, #104]	; (802572c <HAL_SUBGHZ_ExecSetCmd+0xac>)
 80256c4:	4003      	ands	r3, r0
 80256c6:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 80256c8:	4641      	mov	r1, r8
 80256ca:	0028      	movs	r0, r5
 80256cc:	f7ff fe5a 	bl	8025384 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 80256d0:	2400      	movs	r4, #0
 80256d2:	e005      	b.n	80256e0 <HAL_SUBGHZ_ExecSetCmd+0x60>
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 80256d4:	5d39      	ldrb	r1, [r7, r4]
 80256d6:	0028      	movs	r0, r5
 80256d8:	f7ff fe54 	bl	8025384 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 80256dc:	3401      	adds	r4, #1
 80256de:	b2a4      	uxth	r4, r4
 80256e0:	42b4      	cmp	r4, r6
 80256e2:	d3f7      	bcc.n	80256d4 <HAL_SUBGHZ_ExecSetCmd+0x54>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80256e4:	4910      	ldr	r1, [pc, #64]	; (8025728 <HAL_SUBGHZ_ExecSetCmd+0xa8>)
 80256e6:	2290      	movs	r2, #144	; 0x90
 80256e8:	5888      	ldr	r0, [r1, r2]
 80256ea:	2380      	movs	r3, #128	; 0x80
 80256ec:	021b      	lsls	r3, r3, #8
 80256ee:	4303      	orrs	r3, r0
 80256f0:	508b      	str	r3, [r1, r2]
    if (Command != RADIO_SET_SLEEP)
 80256f2:	4643      	mov	r3, r8
 80256f4:	2b84      	cmp	r3, #132	; 0x84
 80256f6:	d10c      	bne.n	8025712 <HAL_SUBGHZ_ExecSetCmd+0x92>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 80256f8:	68ab      	ldr	r3, [r5, #8]
 80256fa:	2b00      	cmp	r3, #0
 80256fc:	d100      	bne.n	8025700 <HAL_SUBGHZ_ExecSetCmd+0x80>
      status = HAL_OK;
 80256fe:	4699      	mov	r9, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8025700:	2301      	movs	r3, #1
 8025702:	71ab      	strb	r3, [r5, #6]
    __HAL_UNLOCK(hsubghz);
 8025704:	2300      	movs	r3, #0
 8025706:	716b      	strb	r3, [r5, #5]
}
 8025708:	4648      	mov	r0, r9
 802570a:	bcc0      	pop	{r6, r7}
 802570c:	46b9      	mov	r9, r7
 802570e:	46b0      	mov	r8, r6
 8025710:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void)SUBGHZ_WaitOnBusy(hsubghz);
 8025712:	0028      	movs	r0, r5
 8025714:	f7ff feb4 	bl	8025480 <SUBGHZ_WaitOnBusy>
 8025718:	e7ee      	b.n	80256f8 <HAL_SUBGHZ_ExecSetCmd+0x78>
    return HAL_BUSY;
 802571a:	2302      	movs	r3, #2
 802571c:	4699      	mov	r9, r3
 802571e:	e7f3      	b.n	8025708 <HAL_SUBGHZ_ExecSetCmd+0x88>
    __HAL_LOCK(hsubghz);
 8025720:	2302      	movs	r3, #2
 8025722:	4699      	mov	r9, r3
 8025724:	e7f0      	b.n	8025708 <HAL_SUBGHZ_ExecSetCmd+0x88>
 8025726:	46c0      	nop			; (mov r8, r8)
 8025728:	58000400 	.word	0x58000400
 802572c:	ffff7fff 	.word	0xffff7fff

08025730 <HAL_SUBGHZ_ExecGetCmd>:
{
 8025730:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025732:	46c6      	mov	lr, r8
 8025734:	b500      	push	{lr}
 8025736:	0006      	movs	r6, r0
 8025738:	000c      	movs	r4, r1
 802573a:	0015      	movs	r5, r2
 802573c:	001f      	movs	r7, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802573e:	7983      	ldrb	r3, [r0, #6]
 8025740:	b2da      	uxtb	r2, r3
 8025742:	4690      	mov	r8, r2
 8025744:	2b01      	cmp	r3, #1
 8025746:	d135      	bne.n	80257b4 <HAL_SUBGHZ_ExecGetCmd+0x84>
    __HAL_LOCK(hsubghz);
 8025748:	7943      	ldrb	r3, [r0, #5]
 802574a:	2b01      	cmp	r3, #1
 802574c:	d035      	beq.n	80257ba <HAL_SUBGHZ_ExecGetCmd+0x8a>
 802574e:	2301      	movs	r3, #1
 8025750:	7143      	strb	r3, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 8025752:	f7ff fec5 	bl	80254e0 <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8025756:	491a      	ldr	r1, [pc, #104]	; (80257c0 <HAL_SUBGHZ_ExecGetCmd+0x90>)
 8025758:	2290      	movs	r2, #144	; 0x90
 802575a:	588b      	ldr	r3, [r1, r2]
 802575c:	4819      	ldr	r0, [pc, #100]	; (80257c4 <HAL_SUBGHZ_ExecGetCmd+0x94>)
 802575e:	4003      	ands	r3, r0
 8025760:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, (uint8_t)Command);
 8025762:	0021      	movs	r1, r4
 8025764:	0030      	movs	r0, r6
 8025766:	f7ff fe0d 	bl	8025384 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 802576a:	2100      	movs	r1, #0
 802576c:	0030      	movs	r0, r6
 802576e:	f7ff fe09 	bl	8025384 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 8025772:	2400      	movs	r4, #0
 8025774:	e006      	b.n	8025784 <HAL_SUBGHZ_ExecGetCmd+0x54>
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 8025776:	0029      	movs	r1, r5
 8025778:	0030      	movs	r0, r6
 802577a:	f7ff fe41 	bl	8025400 <SUBGHZSPI_Receive>
      pData++;
 802577e:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 8025780:	3401      	adds	r4, #1
 8025782:	b2a4      	uxth	r4, r4
 8025784:	42bc      	cmp	r4, r7
 8025786:	d3f6      	bcc.n	8025776 <HAL_SUBGHZ_ExecGetCmd+0x46>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8025788:	490d      	ldr	r1, [pc, #52]	; (80257c0 <HAL_SUBGHZ_ExecGetCmd+0x90>)
 802578a:	2290      	movs	r2, #144	; 0x90
 802578c:	5888      	ldr	r0, [r1, r2]
 802578e:	2380      	movs	r3, #128	; 0x80
 8025790:	021b      	lsls	r3, r3, #8
 8025792:	4303      	orrs	r3, r0
 8025794:	508b      	str	r3, [r1, r2]
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 8025796:	0030      	movs	r0, r6
 8025798:	f7ff fe72 	bl	8025480 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 802579c:	68b3      	ldr	r3, [r6, #8]
 802579e:	2b00      	cmp	r3, #0
 80257a0:	d100      	bne.n	80257a4 <HAL_SUBGHZ_ExecGetCmd+0x74>
      status = HAL_OK;
 80257a2:	4698      	mov	r8, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 80257a4:	2301      	movs	r3, #1
 80257a6:	71b3      	strb	r3, [r6, #6]
    __HAL_UNLOCK(hsubghz);
 80257a8:	2300      	movs	r3, #0
 80257aa:	7173      	strb	r3, [r6, #5]
}
 80257ac:	4640      	mov	r0, r8
 80257ae:	bc80      	pop	{r7}
 80257b0:	46b8      	mov	r8, r7
 80257b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_BUSY;
 80257b4:	2302      	movs	r3, #2
 80257b6:	4698      	mov	r8, r3
 80257b8:	e7f8      	b.n	80257ac <HAL_SUBGHZ_ExecGetCmd+0x7c>
    __HAL_LOCK(hsubghz);
 80257ba:	2302      	movs	r3, #2
 80257bc:	4698      	mov	r8, r3
 80257be:	e7f5      	b.n	80257ac <HAL_SUBGHZ_ExecGetCmd+0x7c>
 80257c0:	58000400 	.word	0x58000400
 80257c4:	ffff7fff 	.word	0xffff7fff

080257c8 <HAL_SUBGHZ_IRQHandler>:
{
 80257c8:	b570      	push	{r4, r5, r6, lr}
 80257ca:	b082      	sub	sp, #8
 80257cc:	0005      	movs	r5, r0
  uint8_t tmpisr[2U] = {0U};
 80257ce:	ae01      	add	r6, sp, #4
 80257d0:	2300      	movs	r3, #0
 80257d2:	8033      	strh	r3, [r6, #0]
  (void)HAL_SUBGHZ_ExecGetCmd(hsubghz, RADIO_GET_IRQSTATUS, tmpisr, 2U);
 80257d4:	3302      	adds	r3, #2
 80257d6:	0032      	movs	r2, r6
 80257d8:	2112      	movs	r1, #18
 80257da:	f7ff ffa9 	bl	8025730 <HAL_SUBGHZ_ExecGetCmd>
  itsource = tmpisr[0U];
 80257de:	7833      	ldrb	r3, [r6, #0]
  itsource = (itsource << 8U) | tmpisr[1U];
 80257e0:	021b      	lsls	r3, r3, #8
 80257e2:	7874      	ldrb	r4, [r6, #1]
 80257e4:	431c      	orrs	r4, r3
  (void)HAL_SUBGHZ_ExecSetCmd(hsubghz, RADIO_CLR_IRQSTATUS, tmpisr, 2U);
 80257e6:	2302      	movs	r3, #2
 80257e8:	0032      	movs	r2, r6
 80257ea:	2102      	movs	r1, #2
 80257ec:	0028      	movs	r0, r5
 80257ee:	f7ff ff47 	bl	8025680 <HAL_SUBGHZ_ExecSetCmd>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_TX_CPLT) != RESET)
 80257f2:	07e3      	lsls	r3, r4, #31
 80257f4:	d419      	bmi.n	802582a <HAL_SUBGHZ_IRQHandler+0x62>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_CPLT) != RESET)
 80257f6:	07a3      	lsls	r3, r4, #30
 80257f8:	d41b      	bmi.n	8025832 <HAL_SUBGHZ_IRQHandler+0x6a>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_PREAMBLE_DETECTED) != RESET)
 80257fa:	0763      	lsls	r3, r4, #29
 80257fc:	d41d      	bmi.n	802583a <HAL_SUBGHZ_IRQHandler+0x72>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_SYNCWORD_VALID) != RESET)
 80257fe:	0723      	lsls	r3, r4, #28
 8025800:	d41f      	bmi.n	8025842 <HAL_SUBGHZ_IRQHandler+0x7a>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_VALID) != RESET)
 8025802:	06e3      	lsls	r3, r4, #27
 8025804:	d421      	bmi.n	802584a <HAL_SUBGHZ_IRQHandler+0x82>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_HEADER_ERROR) != RESET)
 8025806:	06a3      	lsls	r3, r4, #26
 8025808:	d423      	bmi.n	8025852 <HAL_SUBGHZ_IRQHandler+0x8a>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CRC_ERROR) != RESET)
 802580a:	0663      	lsls	r3, r4, #25
 802580c:	d425      	bmi.n	802585a <HAL_SUBGHZ_IRQHandler+0x92>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_DONE) != RESET)
 802580e:	0623      	lsls	r3, r4, #24
 8025810:	d505      	bpl.n	802581e <HAL_SUBGHZ_IRQHandler+0x56>
    if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_CAD_ACTIVITY_DETECTED) != RESET)
 8025812:	05e3      	lsls	r3, r4, #23
 8025814:	d525      	bpl.n	8025862 <HAL_SUBGHZ_IRQHandler+0x9a>
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_DETECTED);
 8025816:	2101      	movs	r1, #1
 8025818:	0028      	movs	r0, r5
 802581a:	f00e f99b 	bl	8033b54 <HAL_SUBGHZ_CADStatusCallback>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_RX_TX_TIMEOUT) != RESET)
 802581e:	05a3      	lsls	r3, r4, #22
 8025820:	d424      	bmi.n	802586c <HAL_SUBGHZ_IRQHandler+0xa4>
  if (SUBGHZ_CHECK_IT_SOURCE(itsource, SUBGHZ_IT_LR_FHSS_HOP) != RESET)
 8025822:	0463      	lsls	r3, r4, #17
 8025824:	d426      	bmi.n	8025874 <HAL_SUBGHZ_IRQHandler+0xac>
}
 8025826:	b002      	add	sp, #8
 8025828:	bd70      	pop	{r4, r5, r6, pc}
    HAL_SUBGHZ_TxCpltCallback(hsubghz);
 802582a:	0028      	movs	r0, r5
 802582c:	f00e f97a 	bl	8033b24 <HAL_SUBGHZ_TxCpltCallback>
 8025830:	e7e1      	b.n	80257f6 <HAL_SUBGHZ_IRQHandler+0x2e>
    HAL_SUBGHZ_RxCpltCallback(hsubghz);
 8025832:	0028      	movs	r0, r5
 8025834:	f00e f97e 	bl	8033b34 <HAL_SUBGHZ_RxCpltCallback>
 8025838:	e7df      	b.n	80257fa <HAL_SUBGHZ_IRQHandler+0x32>
    HAL_SUBGHZ_PreambleDetectedCallback(hsubghz);
 802583a:	0028      	movs	r0, r5
 802583c:	f00e f9b0 	bl	8033ba0 <HAL_SUBGHZ_PreambleDetectedCallback>
 8025840:	e7dd      	b.n	80257fe <HAL_SUBGHZ_IRQHandler+0x36>
    HAL_SUBGHZ_SyncWordValidCallback(hsubghz);
 8025842:	0028      	movs	r0, r5
 8025844:	f00e f9b4 	bl	8033bb0 <HAL_SUBGHZ_SyncWordValidCallback>
 8025848:	e7db      	b.n	8025802 <HAL_SUBGHZ_IRQHandler+0x3a>
    HAL_SUBGHZ_HeaderValidCallback(hsubghz);
 802584a:	0028      	movs	r0, r5
 802584c:	f00e f9b8 	bl	8033bc0 <HAL_SUBGHZ_HeaderValidCallback>
 8025850:	e7d9      	b.n	8025806 <HAL_SUBGHZ_IRQHandler+0x3e>
    HAL_SUBGHZ_HeaderErrorCallback(hsubghz);
 8025852:	0028      	movs	r0, r5
 8025854:	f00e f99c 	bl	8033b90 <HAL_SUBGHZ_HeaderErrorCallback>
 8025858:	e7d7      	b.n	802580a <HAL_SUBGHZ_IRQHandler+0x42>
    HAL_SUBGHZ_CRCErrorCallback(hsubghz);
 802585a:	0028      	movs	r0, r5
 802585c:	f00e f972 	bl	8033b44 <HAL_SUBGHZ_CRCErrorCallback>
 8025860:	e7d5      	b.n	802580e <HAL_SUBGHZ_IRQHandler+0x46>
      HAL_SUBGHZ_CADStatusCallback(hsubghz, HAL_SUBGHZ_CAD_CLEAR);
 8025862:	2100      	movs	r1, #0
 8025864:	0028      	movs	r0, r5
 8025866:	f00e f975 	bl	8033b54 <HAL_SUBGHZ_CADStatusCallback>
 802586a:	e7d8      	b.n	802581e <HAL_SUBGHZ_IRQHandler+0x56>
    HAL_SUBGHZ_RxTxTimeoutCallback(hsubghz);
 802586c:	0028      	movs	r0, r5
 802586e:	f00e f985 	bl	8033b7c <HAL_SUBGHZ_RxTxTimeoutCallback>
 8025872:	e7d6      	b.n	8025822 <HAL_SUBGHZ_IRQHandler+0x5a>
    HAL_SUBGHZ_LrFhssHopCallback(hsubghz);
 8025874:	0028      	movs	r0, r5
 8025876:	f00e f9ab 	bl	8033bd0 <HAL_SUBGHZ_LrFhssHopCallback>
}
 802587a:	e7d4      	b.n	8025826 <HAL_SUBGHZ_IRQHandler+0x5e>

0802587c <HAL_SUBGHZ_WriteBuffer>:
{
 802587c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802587e:	46c6      	mov	lr, r8
 8025880:	b500      	push	{lr}
 8025882:	0005      	movs	r5, r0
 8025884:	000c      	movs	r4, r1
 8025886:	0017      	movs	r7, r2
 8025888:	001e      	movs	r6, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 802588a:	7983      	ldrb	r3, [r0, #6]
 802588c:	b2da      	uxtb	r2, r3
 802588e:	4690      	mov	r8, r2
 8025890:	2b01      	cmp	r3, #1
 8025892:	d134      	bne.n	80258fe <HAL_SUBGHZ_WriteBuffer+0x82>
    __HAL_LOCK(hsubghz);
 8025894:	7943      	ldrb	r3, [r0, #5]
 8025896:	2b01      	cmp	r3, #1
 8025898:	d034      	beq.n	8025904 <HAL_SUBGHZ_WriteBuffer+0x88>
 802589a:	2301      	movs	r3, #1
 802589c:	7143      	strb	r3, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 802589e:	f7ff fe1f 	bl	80254e0 <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80258a2:	491a      	ldr	r1, [pc, #104]	; (802590c <HAL_SUBGHZ_WriteBuffer+0x90>)
 80258a4:	2290      	movs	r2, #144	; 0x90
 80258a6:	588b      	ldr	r3, [r1, r2]
 80258a8:	4819      	ldr	r0, [pc, #100]	; (8025910 <HAL_SUBGHZ_WriteBuffer+0x94>)
 80258aa:	4003      	ands	r3, r0
 80258ac:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_WRITE_BUFFER);
 80258ae:	210e      	movs	r1, #14
 80258b0:	0028      	movs	r0, r5
 80258b2:	f7ff fd67 	bl	8025384 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 80258b6:	0021      	movs	r1, r4
 80258b8:	0028      	movs	r0, r5
 80258ba:	f7ff fd63 	bl	8025384 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 80258be:	2400      	movs	r4, #0
 80258c0:	e005      	b.n	80258ce <HAL_SUBGHZ_WriteBuffer+0x52>
      (void)SUBGHZSPI_Transmit(hsubghz, pBuffer[i]);
 80258c2:	5d39      	ldrb	r1, [r7, r4]
 80258c4:	0028      	movs	r0, r5
 80258c6:	f7ff fd5d 	bl	8025384 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 80258ca:	3401      	adds	r4, #1
 80258cc:	b2a4      	uxth	r4, r4
 80258ce:	42b4      	cmp	r4, r6
 80258d0:	d3f7      	bcc.n	80258c2 <HAL_SUBGHZ_WriteBuffer+0x46>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 80258d2:	490e      	ldr	r1, [pc, #56]	; (802590c <HAL_SUBGHZ_WriteBuffer+0x90>)
 80258d4:	2290      	movs	r2, #144	; 0x90
 80258d6:	5888      	ldr	r0, [r1, r2]
 80258d8:	2380      	movs	r3, #128	; 0x80
 80258da:	021b      	lsls	r3, r3, #8
 80258dc:	4303      	orrs	r3, r0
 80258de:	508b      	str	r3, [r1, r2]
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 80258e0:	0028      	movs	r0, r5
 80258e2:	f7ff fdcd 	bl	8025480 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 80258e6:	68ab      	ldr	r3, [r5, #8]
 80258e8:	2b00      	cmp	r3, #0
 80258ea:	d100      	bne.n	80258ee <HAL_SUBGHZ_WriteBuffer+0x72>
      status = HAL_OK;
 80258ec:	4698      	mov	r8, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 80258ee:	2301      	movs	r3, #1
 80258f0:	71ab      	strb	r3, [r5, #6]
    __HAL_UNLOCK(hsubghz);
 80258f2:	2300      	movs	r3, #0
 80258f4:	716b      	strb	r3, [r5, #5]
}
 80258f6:	4640      	mov	r0, r8
 80258f8:	bc80      	pop	{r7}
 80258fa:	46b8      	mov	r8, r7
 80258fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_BUSY;
 80258fe:	2302      	movs	r3, #2
 8025900:	4698      	mov	r8, r3
 8025902:	e7f8      	b.n	80258f6 <HAL_SUBGHZ_WriteBuffer+0x7a>
    __HAL_LOCK(hsubghz);
 8025904:	2302      	movs	r3, #2
 8025906:	4698      	mov	r8, r3
 8025908:	e7f5      	b.n	80258f6 <HAL_SUBGHZ_WriteBuffer+0x7a>
 802590a:	46c0      	nop			; (mov r8, r8)
 802590c:	58000400 	.word	0x58000400
 8025910:	ffff7fff 	.word	0xffff7fff

08025914 <HAL_SUBGHZ_ReadBuffer>:
{
 8025914:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025916:	46c6      	mov	lr, r8
 8025918:	b500      	push	{lr}
 802591a:	0006      	movs	r6, r0
 802591c:	000c      	movs	r4, r1
 802591e:	0015      	movs	r5, r2
 8025920:	001f      	movs	r7, r3
  if (hsubghz->State == HAL_SUBGHZ_STATE_READY)
 8025922:	7983      	ldrb	r3, [r0, #6]
 8025924:	b2da      	uxtb	r2, r3
 8025926:	4690      	mov	r8, r2
 8025928:	2b01      	cmp	r3, #1
 802592a:	d139      	bne.n	80259a0 <HAL_SUBGHZ_ReadBuffer+0x8c>
    __HAL_LOCK(hsubghz);
 802592c:	7943      	ldrb	r3, [r0, #5]
 802592e:	2b01      	cmp	r3, #1
 8025930:	d039      	beq.n	80259a6 <HAL_SUBGHZ_ReadBuffer+0x92>
 8025932:	2301      	movs	r3, #1
 8025934:	7143      	strb	r3, [r0, #5]
    (void)SUBGHZ_CheckDeviceReady(hsubghz);
 8025936:	f7ff fdd3 	bl	80254e0 <SUBGHZ_CheckDeviceReady>
  CLEAR_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 802593a:	491c      	ldr	r1, [pc, #112]	; (80259ac <HAL_SUBGHZ_ReadBuffer+0x98>)
 802593c:	2290      	movs	r2, #144	; 0x90
 802593e:	588b      	ldr	r3, [r1, r2]
 8025940:	481b      	ldr	r0, [pc, #108]	; (80259b0 <HAL_SUBGHZ_ReadBuffer+0x9c>)
 8025942:	4003      	ands	r3, r0
 8025944:	508b      	str	r3, [r1, r2]
    (void)SUBGHZSPI_Transmit(hsubghz, SUBGHZ_RADIO_READ_BUFFER);
 8025946:	211e      	movs	r1, #30
 8025948:	0030      	movs	r0, r6
 802594a:	f7ff fd1b 	bl	8025384 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, Offset);
 802594e:	0021      	movs	r1, r4
 8025950:	0030      	movs	r0, r6
 8025952:	f7ff fd17 	bl	8025384 <SUBGHZSPI_Transmit>
    (void)SUBGHZSPI_Transmit(hsubghz, 0x00U);
 8025956:	2100      	movs	r1, #0
 8025958:	0030      	movs	r0, r6
 802595a:	f7ff fd13 	bl	8025384 <SUBGHZSPI_Transmit>
    for (uint16_t i = 0U; i < Size; i++)
 802595e:	2400      	movs	r4, #0
 8025960:	e006      	b.n	8025970 <HAL_SUBGHZ_ReadBuffer+0x5c>
      (void)SUBGHZSPI_Receive(hsubghz, (pData));
 8025962:	0029      	movs	r1, r5
 8025964:	0030      	movs	r0, r6
 8025966:	f7ff fd4b 	bl	8025400 <SUBGHZSPI_Receive>
      pData++;
 802596a:	3501      	adds	r5, #1
    for (uint16_t i = 0U; i < Size; i++)
 802596c:	3401      	adds	r4, #1
 802596e:	b2a4      	uxth	r4, r4
 8025970:	42bc      	cmp	r4, r7
 8025972:	d3f6      	bcc.n	8025962 <HAL_SUBGHZ_ReadBuffer+0x4e>
  SET_BIT(PWR->SUBGHZSPICR, PWR_SUBGHZSPICR_NSS);
 8025974:	490d      	ldr	r1, [pc, #52]	; (80259ac <HAL_SUBGHZ_ReadBuffer+0x98>)
 8025976:	2290      	movs	r2, #144	; 0x90
 8025978:	5888      	ldr	r0, [r1, r2]
 802597a:	2380      	movs	r3, #128	; 0x80
 802597c:	021b      	lsls	r3, r3, #8
 802597e:	4303      	orrs	r3, r0
 8025980:	508b      	str	r3, [r1, r2]
    (void)SUBGHZ_WaitOnBusy(hsubghz);
 8025982:	0030      	movs	r0, r6
 8025984:	f7ff fd7c 	bl	8025480 <SUBGHZ_WaitOnBusy>
    if (hsubghz->ErrorCode != HAL_SUBGHZ_ERROR_NONE)
 8025988:	68b3      	ldr	r3, [r6, #8]
 802598a:	2b00      	cmp	r3, #0
 802598c:	d100      	bne.n	8025990 <HAL_SUBGHZ_ReadBuffer+0x7c>
      status = HAL_OK;
 802598e:	4698      	mov	r8, r3
    hsubghz->State = HAL_SUBGHZ_STATE_READY;
 8025990:	2301      	movs	r3, #1
 8025992:	71b3      	strb	r3, [r6, #6]
    __HAL_UNLOCK(hsubghz);
 8025994:	2300      	movs	r3, #0
 8025996:	7173      	strb	r3, [r6, #5]
}
 8025998:	4640      	mov	r0, r8
 802599a:	bc80      	pop	{r7}
 802599c:	46b8      	mov	r8, r7
 802599e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return HAL_BUSY;
 80259a0:	2302      	movs	r3, #2
 80259a2:	4698      	mov	r8, r3
 80259a4:	e7f8      	b.n	8025998 <HAL_SUBGHZ_ReadBuffer+0x84>
    __HAL_LOCK(hsubghz);
 80259a6:	2302      	movs	r3, #2
 80259a8:	4698      	mov	r8, r3
 80259aa:	e7f5      	b.n	8025998 <HAL_SUBGHZ_ReadBuffer+0x84>
 80259ac:	58000400 	.word	0x58000400
 80259b0:	ffff7fff 	.word	0xffff7fff

080259b4 <load_block>:
  * @retval  None
  */
static void load_block(const uint8_t *input_start,
                       uint32_t num_els,
                       uint32_t *load_buffer)
{
 80259b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80259b6:	46ce      	mov	lr, r9
 80259b8:	4647      	mov	r7, r8
 80259ba:	b580      	push	{r7, lr}
 80259bc:	468c      	mov	ip, r1
  uint32_t i;
  uint32_t j;
  uint32_t full_words = num_els / 4u;
 80259be:	088d      	lsrs	r5, r1, #2

  uint32_t remaining_bytes = num_els % 4u;
 80259c0:	2603      	movs	r6, #3
 80259c2:	400e      	ands	r6, r1
 80259c4:	46b1      	mov	r9, r6
  uint32_t temp_word;

  /* Convert any 4 bytes in one 32 bits word */
  for (i = 0; i < full_words; i++)
 80259c6:	2400      	movs	r4, #0
 80259c8:	e00d      	b.n	80259e6 <load_block+0x32>
  {
    load_buffer[i] = BYTES_TO_WORD(input_start, 4u * i);
 80259ca:	00a7      	lsls	r7, r4, #2
 80259cc:	5dc3      	ldrb	r3, [r0, r7]
 80259ce:	061b      	lsls	r3, r3, #24
 80259d0:	19c1      	adds	r1, r0, r7
 80259d2:	784e      	ldrb	r6, [r1, #1]
 80259d4:	0436      	lsls	r6, r6, #16
 80259d6:	4333      	orrs	r3, r6
 80259d8:	788e      	ldrb	r6, [r1, #2]
 80259da:	0236      	lsls	r6, r6, #8
 80259dc:	4333      	orrs	r3, r6
 80259de:	78c9      	ldrb	r1, [r1, #3]
 80259e0:	430b      	orrs	r3, r1
 80259e2:	51d3      	str	r3, [r2, r7]
  for (i = 0; i < full_words; i++)
 80259e4:	3401      	adds	r4, #1
 80259e6:	42ac      	cmp	r4, r5
 80259e8:	d3ef      	bcc.n	80259ca <load_block+0x16>
  }

  /* If the block is not multiple of 16 bytes, pad the buffer */
  if ((num_els == 0u) || (full_words < 4u))
 80259ea:	4663      	mov	r3, ip
 80259ec:	2b00      	cmp	r3, #0
 80259ee:	d001      	beq.n	80259f4 <load_block+0x40>
 80259f0:	2b0f      	cmp	r3, #15
 80259f2:	d823      	bhi.n	8025a3c <load_block+0x88>
  {
    /* last block: 0x [remaining data] 80 00 00 .. 00 */
    temp_word = 0x80u;

    /* Insert the 0x80 byte in the correct position */
    load_buffer[full_words] = temp_word << (24u - (8u * remaining_bytes));
 80259f4:	2303      	movs	r3, #3
 80259f6:	4649      	mov	r1, r9
 80259f8:	1a5c      	subs	r4, r3, r1
 80259fa:	00e4      	lsls	r4, r4, #3
 80259fc:	4661      	mov	r1, ip
 80259fe:	4399      	bics	r1, r3
 8025a00:	468c      	mov	ip, r1
 8025a02:	1851      	adds	r1, r2, r1
 8025a04:	2380      	movs	r3, #128	; 0x80
 8025a06:	40a3      	lsls	r3, r4
 8025a08:	600b      	str	r3, [r1, #0]

    /* Include the remaining bytes of data */
    for (j = 0u; j < remaining_bytes; j++)
 8025a0a:	2400      	movs	r4, #0
 8025a0c:	e00b      	b.n	8025a26 <load_block+0x72>
    {
      load_buffer[full_words]
      |= (uint32_t)(input_start[(4u * full_words) + j]) << (24u - (8u * j));
 8025a0e:	4663      	mov	r3, ip
 8025a10:	191b      	adds	r3, r3, r4
 8025a12:	5cc7      	ldrb	r7, [r0, r3]
 8025a14:	2303      	movs	r3, #3
 8025a16:	1b1b      	subs	r3, r3, r4
 8025a18:	00db      	lsls	r3, r3, #3
 8025a1a:	409f      	lsls	r7, r3
 8025a1c:	003b      	movs	r3, r7
 8025a1e:	680e      	ldr	r6, [r1, #0]
 8025a20:	4333      	orrs	r3, r6
 8025a22:	600b      	str	r3, [r1, #0]
    for (j = 0u; j < remaining_bytes; j++)
 8025a24:	3401      	adds	r4, #1
 8025a26:	454c      	cmp	r4, r9
 8025a28:	d3f1      	bcc.n	8025a0e <load_block+0x5a>
    }

    /* Fill the rest of the block with zeros */
    for (i = full_words + 1u; i < 4u; i++)
 8025a2a:	3501      	adds	r5, #1
 8025a2c:	e004      	b.n	8025a38 <load_block+0x84>
    {
      load_buffer[i] = 0u;
 8025a2e:	00ab      	lsls	r3, r5, #2
 8025a30:	18d3      	adds	r3, r2, r3
 8025a32:	2100      	movs	r1, #0
 8025a34:	6019      	str	r1, [r3, #0]
    for (i = full_words + 1u; i < 4u; i++)
 8025a36:	3501      	adds	r5, #1
 8025a38:	2d03      	cmp	r5, #3
 8025a3a:	d9f8      	bls.n	8025a2e <load_block+0x7a>
    }
  }
}
 8025a3c:	bcc0      	pop	{r6, r7}
 8025a3e:	46b9      	mov	r9, r7
 8025a40:	46b0      	mov	r8, r6
 8025a42:	bdf0      	pop	{r4, r5, r6, r7, pc}

08025a44 <derive_subkey2>:
  * @param   output_buffer Buffer that will contain the computed K2 subkey
  *
  * @retval  None
  */
static void derive_subkey2(const uint32_t *sub_key1, uint32_t *output_buffer)
{
 8025a44:	b510      	push	{r4, lr}
  uint32_t carry = ((sub_key1[0] >> 31) & 1u) * 0x00000087u;
 8025a46:	6803      	ldr	r3, [r0, #0]
 8025a48:	0fdc      	lsrs	r4, r3, #31
 8025a4a:	00e2      	lsls	r2, r4, #3
 8025a4c:	1912      	adds	r2, r2, r4
 8025a4e:	0114      	lsls	r4, r2, #4
 8025a50:	1aa4      	subs	r4, r4, r2

  output_buffer[0] = ((sub_key1[0] << 1) | (sub_key1[1] >> 31));
 8025a52:	005b      	lsls	r3, r3, #1
 8025a54:	6842      	ldr	r2, [r0, #4]
 8025a56:	0fd2      	lsrs	r2, r2, #31
 8025a58:	4313      	orrs	r3, r2
 8025a5a:	600b      	str	r3, [r1, #0]
  output_buffer[1] = ((sub_key1[1] << 1) | (sub_key1[2] >> 31));
 8025a5c:	6843      	ldr	r3, [r0, #4]
 8025a5e:	005a      	lsls	r2, r3, #1
 8025a60:	6883      	ldr	r3, [r0, #8]
 8025a62:	0fdb      	lsrs	r3, r3, #31
 8025a64:	431a      	orrs	r2, r3
 8025a66:	604a      	str	r2, [r1, #4]
  output_buffer[2] = ((sub_key1[2] << 1) | (sub_key1[3] >> 31));
 8025a68:	6883      	ldr	r3, [r0, #8]
 8025a6a:	005a      	lsls	r2, r3, #1
 8025a6c:	68c3      	ldr	r3, [r0, #12]
 8025a6e:	0fdb      	lsrs	r3, r3, #31
 8025a70:	431a      	orrs	r2, r3
 8025a72:	608a      	str	r2, [r1, #8]
  output_buffer[3] = (sub_key1[3] << 1) ^ carry;
 8025a74:	68c3      	ldr	r3, [r0, #12]
 8025a76:	005b      	lsls	r3, r3, #1
 8025a78:	4063      	eors	r3, r4
 8025a7a:	60cb      	str	r3, [r1, #12]

}
 8025a7c:	bd10      	pop	{r4, pc}

08025a7e <xor_key>:
  * @param   key Buffer containing the key
  *
  * @retval  None
  */
static void xor_key(uint32_t *block, const uint32_t *key)
{
 8025a7e:	b530      	push	{r4, r5, lr}
  uint32_t i;

  for (i = 0u; i < 4u; i++)
 8025a80:	2300      	movs	r3, #0
 8025a82:	e006      	b.n	8025a92 <xor_key+0x14>
  {
    block[i] ^= key[i];
 8025a84:	009a      	lsls	r2, r3, #2
 8025a86:	1884      	adds	r4, r0, r2
 8025a88:	588a      	ldr	r2, [r1, r2]
 8025a8a:	6825      	ldr	r5, [r4, #0]
 8025a8c:	406a      	eors	r2, r5
 8025a8e:	6022      	str	r2, [r4, #0]
  for (i = 0u; i < 4u; i++)
 8025a90:	3301      	adds	r3, #1
 8025a92:	2b03      	cmp	r3, #3
 8025a94:	d9f6      	bls.n	8025a84 <xor_key+0x6>
  }
}
 8025a96:	bd30      	pop	{r4, r5, pc}

08025a98 <cleanup_handle>:
static uint32_t secure_memcmp(const void *s1, const void *s2, size_t n);
#endif /* KMS_ENCRYPT_DECRYPT_BLOB */

/* Private function definitions -----------------------------------------------*/
static void cleanup_handle(CRYP_HandleTypeDef *CrypHandle)
{
 8025a98:	b510      	push	{r4, lr}
  (void)memset(CrypHandle, 0, sizeof(CRYP_HandleTypeDef));
 8025a9a:	2286      	movs	r2, #134	; 0x86
 8025a9c:	0052      	lsls	r2, r2, #1
 8025a9e:	2100      	movs	r1, #0
 8025aa0:	f00f f849 	bl	8034b36 <memset>
}
 8025aa4:	bd10      	pop	{r4, pc}

08025aa6 <AES_Encrypt>:
{
 8025aa6:	b500      	push	{lr}
 8025aa8:	b083      	sub	sp, #12
  hcryp->Init.pKey = key;
 8025aaa:	60c3      	str	r3, [r0, #12]
  hcryp->Init.pInitVect = iv;
 8025aac:	9b04      	ldr	r3, [sp, #16]
 8025aae:	6103      	str	r3, [r0, #16]
  periph_retval = HAL_CRYP_Encrypt(hcryp, input, (uint16_t)inputSize,
 8025ab0:	b292      	uxth	r2, r2
 8025ab2:	23ff      	movs	r3, #255	; 0xff
 8025ab4:	9300      	str	r3, [sp, #0]
 8025ab6:	9b05      	ldr	r3, [sp, #20]
 8025ab8:	f7fe f9a0 	bl	8023dfc <HAL_CRYP_Encrypt>
  if (periph_retval != HAL_OK)
 8025abc:	2800      	cmp	r0, #0
 8025abe:	d101      	bne.n	8025ac4 <AES_Encrypt+0x1e>
}
 8025ac0:	b003      	add	sp, #12
 8025ac2:	bd00      	pop	{pc}
    retval = MAC_ERROR_HW_FAILURE;
 8025ac4:	2004      	movs	r0, #4
 8025ac6:	e7fb      	b.n	8025ac0 <AES_Encrypt+0x1a>

08025ac8 <derive_subkey1>:
{
 8025ac8:	b530      	push	{r4, r5, lr}
 8025aca:	b083      	sub	sp, #12
 8025acc:	000b      	movs	r3, r1
 8025ace:	0014      	movs	r4, r2
  retval = AES_Encrypt(hcryp, output_buffer, 4u,
 8025ad0:	9201      	str	r2, [sp, #4]
 8025ad2:	9200      	str	r2, [sp, #0]
 8025ad4:	2204      	movs	r2, #4
 8025ad6:	0021      	movs	r1, r4
 8025ad8:	f7ff ffe5 	bl	8025aa6 <AES_Encrypt>
 8025adc:	1e05      	subs	r5, r0, #0
  if (retval == MAC_SUCCESS)
 8025ade:	d002      	beq.n	8025ae6 <derive_subkey1+0x1e>
}
 8025ae0:	0028      	movs	r0, r5
 8025ae2:	b003      	add	sp, #12
 8025ae4:	bd30      	pop	{r4, r5, pc}
    derive_subkey2(output_buffer, output_buffer);
 8025ae6:	0021      	movs	r1, r4
 8025ae8:	0020      	movs	r0, r4
 8025aea:	f7ff ffab 	bl	8025a44 <derive_subkey2>
 8025aee:	e7f7      	b.n	8025ae0 <derive_subkey1+0x18>

08025af0 <CMAC_compute>:
                         uint32_t inputDataLength,
                         const uint8_t *key,
                         uint32_t keySize,
                         uint32_t macSize,
                         uint8_t *macBuff)
{
 8025af0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025af2:	46de      	mov	lr, fp
 8025af4:	4657      	mov	r7, sl
 8025af6:	464e      	mov	r6, r9
 8025af8:	4645      	mov	r5, r8
 8025afa:	b5e0      	push	{r5, r6, r7, lr}
 8025afc:	4c85      	ldr	r4, [pc, #532]	; (8025d14 <CMAC_compute+0x224>)
 8025afe:	44a5      	add	sp, r4
 8025b00:	0005      	movs	r5, r0
 8025b02:	9103      	str	r1, [sp, #12]
 8025b04:	0014      	movs	r4, r2
 8025b06:	001e      	movs	r6, r3
  mac_error_t retval;

  /* Internal variables, buffers */
  uint32_t temp_iv[4] = {0,};
 8025b08:	2210      	movs	r2, #16
 8025b0a:	2100      	movs	r1, #0
 8025b0c:	a89a      	add	r0, sp, #616	; 0x268
 8025b0e:	f00f f812 	bl	8034b36 <memset>
  uint32_t temp_key[8] = {0,};
 8025b12:	2220      	movs	r2, #32
 8025b14:	2100      	movs	r1, #0
 8025b16:	a892      	add	r0, sp, #584	; 0x248
 8025b18:	f00f f80d 	bl	8034b36 <memset>
  uint32_t temp_buffer[4u * MAX_PROCESSED_BLOCKS];

  uint32_t k1[4] = {0,};
 8025b1c:	2210      	movs	r2, #16
 8025b1e:	2100      	movs	r1, #0
 8025b20:	a84e      	add	r0, sp, #312	; 0x138
 8025b22:	f00f f808 	bl	8034b36 <memset>
  uint32_t k2[4] = {0,};
 8025b26:	2210      	movs	r2, #16
 8025b28:	2100      	movs	r1, #0
 8025b2a:	a84a      	add	r0, sp, #296	; 0x128
 8025b2c:	f00f f803 	bl	8034b36 <memset>

  CRYP_HandleTypeDef hcryp;
  HAL_StatusTypeDef periph_retval;

  /* Check that pointers to buffers are not null */
  if ((key == NULL) || (macBuff == NULL))
 8025b30:	2c00      	cmp	r4, #0
 8025b32:	d100      	bne.n	8025b36 <CMAC_compute+0x46>
 8025b34:	e0cc      	b.n	8025cd0 <CMAC_compute+0x1e0>
 8025b36:	9ba9      	ldr	r3, [sp, #676]	; 0x2a4
 8025b38:	2b00      	cmp	r3, #0
 8025b3a:	d100      	bne.n	8025b3e <CMAC_compute+0x4e>
 8025b3c:	e0d4      	b.n	8025ce8 <CMAC_compute+0x1f8>
  {
    return MAC_ERROR_BAD_PARAMETER;
  }

  /* Plaintext buffer can be null only when there is no data to authenticate */
  if ((inputData == NULL) && (inputDataLength > 0u))
 8025b3e:	2d00      	cmp	r5, #0
 8025b40:	d03f      	beq.n	8025bc2 <CMAC_compute+0xd2>
  {
    return MAC_ERROR_BAD_PARAMETER;
  }

  /* check that the requested mac size is less or equal than the block size */
  if (macSize > AES_BLOCK_SIZE)
 8025b42:	9ba8      	ldr	r3, [sp, #672]	; 0x2a0
 8025b44:	2b10      	cmp	r3, #16
 8025b46:	d900      	bls.n	8025b4a <CMAC_compute+0x5a>
 8025b48:	e0d1      	b.n	8025cee <CMAC_compute+0x1fe>
  {
    return MAC_ERROR_WRONG_MAC_SIZE;
  }
  /* check that the requested mac size is greater than 0 */
  if (macSize == 0u)
 8025b4a:	2b00      	cmp	r3, #0
 8025b4c:	d100      	bne.n	8025b50 <CMAC_compute+0x60>
 8025b4e:	e0d1      	b.n	8025cf4 <CMAC_compute+0x204>
  {
    return MAC_ERROR_WRONG_MAC_SIZE;
  }

  /* Initialize the AES peripheral */
  (void)memset((uint8_t *)&hcryp, 0, sizeof(CRYP_HandleTypeDef));
 8025b50:	2286      	movs	r2, #134	; 0x86
 8025b52:	0052      	lsls	r2, r2, #1
 8025b54:	2100      	movs	r1, #0
 8025b56:	a807      	add	r0, sp, #28
 8025b58:	f00e ffed 	bl	8034b36 <memset>

  /* check that the provided key size is acceptable */
  switch (keySize)
 8025b5c:	2e10      	cmp	r6, #16
 8025b5e:	d005      	beq.n	8025b6c <CMAC_compute+0x7c>
 8025b60:	2e20      	cmp	r6, #32
 8025b62:	d000      	beq.n	8025b66 <CMAC_compute+0x76>
 8025b64:	e0c9      	b.n	8025cfa <CMAC_compute+0x20a>
  {
    case AES128_KEY:
      hcryp.Init.KeySize = CRYP_KEYSIZE_128B;
      break;
    case AES256_KEY:
      hcryp.Init.KeySize = CRYP_KEYSIZE_256B;
 8025b66:	2380      	movs	r3, #128	; 0x80
 8025b68:	02db      	lsls	r3, r3, #11
 8025b6a:	9309      	str	r3, [sp, #36]	; 0x24
      return MAC_ERROR_UNSUPPORTED_KEY_SIZE;
      break;
  }

  /* Complete the configuration of the AES peripheral */
  hcryp.Instance = CA_AES_INSTANCE;
 8025b6c:	4b6a      	ldr	r3, [pc, #424]	; (8025d18 <CMAC_compute+0x228>)
 8025b6e:	9307      	str	r3, [sp, #28]
  hcryp.Init.DataType = CRYP_DATATYPE_32B;
  hcryp.Init.Algorithm = CRYP_AES_CBC;
 8025b70:	2320      	movs	r3, #32
 8025b72:	930c      	str	r3, [sp, #48]	; 0x30
  hcryp.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_WORD;

  /* Initialize the CRYP peripheral */
  periph_retval = HAL_CRYP_Init(&hcryp);
 8025b74:	a807      	add	r0, sp, #28
 8025b76:	f7fd fd53 	bl	8023620 <HAL_CRYP_Init>
  if (periph_retval != HAL_OK)
 8025b7a:	2800      	cmp	r0, #0
 8025b7c:	d000      	beq.n	8025b80 <CMAC_compute+0x90>
 8025b7e:	e0bf      	b.n	8025d00 <CMAC_compute+0x210>
  {
    return MAC_ERROR_HW_FAILURE;
  }

  /* Generate the subkeys K1 and K2 */
  load_block(key, keySize, temp_key);
 8025b80:	aa92      	add	r2, sp, #584	; 0x248
 8025b82:	0031      	movs	r1, r6
 8025b84:	0020      	movs	r0, r4
 8025b86:	f7ff ff15 	bl	80259b4 <load_block>
  retval = derive_subkey1(&hcryp, temp_key, k1);
 8025b8a:	aa4e      	add	r2, sp, #312	; 0x138
 8025b8c:	a992      	add	r1, sp, #584	; 0x248
 8025b8e:	a807      	add	r0, sp, #28
 8025b90:	f7ff ff9a 	bl	8025ac8 <derive_subkey1>
 8025b94:	4680      	mov	r8, r0
  if (retval != MAC_SUCCESS)
 8025b96:	2800      	cmp	r0, #0
 8025b98:	d000      	beq.n	8025b9c <CMAC_compute+0xac>
 8025b9a:	e09b      	b.n	8025cd4 <CMAC_compute+0x1e4>
  {
    return retval;
  }
  derive_subkey2(k1, k2);
 8025b9c:	a94a      	add	r1, sp, #296	; 0x128
 8025b9e:	a84e      	add	r0, sp, #312	; 0x138
 8025ba0:	f7ff ff50 	bl	8025a44 <derive_subkey2>

  /* get the number of AES blocks included into the input */
  num_blocks = inputDataLength / AES_BLOCK_SIZE;
 8025ba4:	9a03      	ldr	r2, [sp, #12]
 8025ba6:	0913      	lsrs	r3, r2, #4
  remaining_bytes = inputDataLength % AES_BLOCK_SIZE;
  if (remaining_bytes > 0u)
 8025ba8:	0712      	lsls	r2, r2, #28
 8025baa:	d000      	beq.n	8025bae <CMAC_compute+0xbe>
  {
    num_blocks++;
 8025bac:	3301      	adds	r3, #1
  }

  /* Transform the number of blocks in number of bytes */
  num_blocks *= AES_BLOCK_SIZE;
 8025bae:	011b      	lsls	r3, r3, #4
 8025bb0:	9304      	str	r3, [sp, #16]
  uint32_t encrypt = 0u;
 8025bb2:	2300      	movs	r3, #0
  uint32_t processed_block = 0u;
 8025bb4:	2400      	movs	r4, #0

  i = 0u;
 8025bb6:	2600      	movs	r6, #0
 8025bb8:	469a      	mov	sl, r3
 8025bba:	4643      	mov	r3, r8
 8025bbc:	9305      	str	r3, [sp, #20]
 8025bbe:	46ab      	mov	fp, r5
 8025bc0:	e016      	b.n	8025bf0 <CMAC_compute+0x100>
  if ((inputData == NULL) && (inputDataLength > 0u))
 8025bc2:	9b03      	ldr	r3, [sp, #12]
 8025bc4:	2b00      	cmp	r3, #0
 8025bc6:	d0bc      	beq.n	8025b42 <CMAC_compute+0x52>
    return MAC_ERROR_BAD_PARAMETER;
 8025bc8:	2301      	movs	r3, #1
 8025bca:	4698      	mov	r8, r3
 8025bcc:	e082      	b.n	8025cd4 <CMAC_compute+0x1e4>
      block_size = inputDataLength - i;
      encrypt = 1u;
    }
    else
    {
      block_size = AES_BLOCK_SIZE;
 8025bce:	2310      	movs	r3, #16
 8025bd0:	4698      	mov	r8, r3
 8025bd2:	e014      	b.n	8025bfe <CMAC_compute+0x10e>
    load_block(&inputData[i], block_size, &temp_buffer[processed_block * 4u]);

    /* If needed, include the subkey into the block of data to process */
    if (block_size < AES_BLOCK_SIZE)
    {
      xor_key(&temp_buffer[processed_block * 4u], k2);
 8025bd4:	a94a      	add	r1, sp, #296	; 0x128
 8025bd6:	0038      	movs	r0, r7
 8025bd8:	f7ff ff51 	bl	8025a7e <xor_key>
    {
      /* do nothing */
    }

    /* If the buffer is full, let's encrypt it */
    if (processed_block == (MAX_PROCESSED_BLOCKS - 1u))
 8025bdc:	2c0f      	cmp	r4, #15
 8025bde:	d026      	beq.n	8025c2e <CMAC_compute+0x13e>
    else
    {
      /* do nothing */
    }

    if (encrypt == 0u)
 8025be0:	4653      	mov	r3, sl
 8025be2:	2b00      	cmp	r3, #0
 8025be4:	d123      	bne.n	8025c2e <CMAC_compute+0x13e>
    {
      processed_block++;
 8025be6:	3401      	adds	r4, #1
      encrypt = 0u;
      processed_block = 0u;
    }

    /* Ready for the next iteration */
    i += AES_BLOCK_SIZE;
 8025be8:	3610      	adds	r6, #16

  } while (i < num_blocks);
 8025bea:	9b04      	ldr	r3, [sp, #16]
 8025bec:	42b3      	cmp	r3, r6
 8025bee:	d93b      	bls.n	8025c68 <CMAC_compute+0x178>
    if ((inputDataLength - i) < AES_BLOCK_SIZE)
 8025bf0:	9b03      	ldr	r3, [sp, #12]
 8025bf2:	1b9d      	subs	r5, r3, r6
 8025bf4:	2d0f      	cmp	r5, #15
 8025bf6:	d8ea      	bhi.n	8025bce <CMAC_compute+0xde>
      block_size = inputDataLength - i;
 8025bf8:	46a8      	mov	r8, r5
      encrypt = 1u;
 8025bfa:	2301      	movs	r3, #1
 8025bfc:	469a      	mov	sl, r3
    load_block(&inputData[i], block_size, &temp_buffer[processed_block * 4u]);
 8025bfe:	00a3      	lsls	r3, r4, #2
 8025c00:	4699      	mov	r9, r3
 8025c02:	0127      	lsls	r7, r4, #4
 8025c04:	ab52      	add	r3, sp, #328	; 0x148
 8025c06:	469c      	mov	ip, r3
 8025c08:	4467      	add	r7, ip
 8025c0a:	465b      	mov	r3, fp
 8025c0c:	1998      	adds	r0, r3, r6
 8025c0e:	003a      	movs	r2, r7
 8025c10:	4641      	mov	r1, r8
 8025c12:	f7ff fecf 	bl	80259b4 <load_block>
    if (block_size < AES_BLOCK_SIZE)
 8025c16:	4643      	mov	r3, r8
 8025c18:	2b0f      	cmp	r3, #15
 8025c1a:	d9db      	bls.n	8025bd4 <CMAC_compute+0xe4>
    else if ((inputDataLength - i) == AES_BLOCK_SIZE)
 8025c1c:	2d10      	cmp	r5, #16
 8025c1e:	d1dd      	bne.n	8025bdc <CMAC_compute+0xec>
      xor_key(&temp_buffer[processed_block * 4u], k1);
 8025c20:	a94e      	add	r1, sp, #312	; 0x138
 8025c22:	0038      	movs	r0, r7
 8025c24:	f7ff ff2b 	bl	8025a7e <xor_key>
      encrypt = 1u;
 8025c28:	2301      	movs	r3, #1
 8025c2a:	469a      	mov	sl, r3
 8025c2c:	e7d6      	b.n	8025bdc <CMAC_compute+0xec>
      retval = AES_Encrypt(&hcryp, temp_buffer, 4u * (processed_block + 1u),
 8025c2e:	3401      	adds	r4, #1
 8025c30:	00a2      	lsls	r2, r4, #2
 8025c32:	a952      	add	r1, sp, #328	; 0x148
 8025c34:	9101      	str	r1, [sp, #4]
 8025c36:	ab9a      	add	r3, sp, #616	; 0x268
 8025c38:	9300      	str	r3, [sp, #0]
 8025c3a:	ab92      	add	r3, sp, #584	; 0x248
 8025c3c:	a807      	add	r0, sp, #28
 8025c3e:	f7ff ff32 	bl	8025aa6 <AES_Encrypt>
 8025c42:	1e03      	subs	r3, r0, #0
 8025c44:	9005      	str	r0, [sp, #20]
      if (retval != MAC_SUCCESS)
 8025c46:	d161      	bne.n	8025d0c <CMAC_compute+0x21c>
 8025c48:	464c      	mov	r4, r9
 8025c4a:	e007      	b.n	8025c5c <CMAC_compute+0x16c>
        temp_iv[j] = temp_buffer[(processed_block * 4u) + j];
 8025c4c:	18e2      	adds	r2, r4, r3
 8025c4e:	0092      	lsls	r2, r2, #2
 8025c50:	a952      	add	r1, sp, #328	; 0x148
 8025c52:	5850      	ldr	r0, [r2, r1]
 8025c54:	0099      	lsls	r1, r3, #2
 8025c56:	aa9a      	add	r2, sp, #616	; 0x268
 8025c58:	5088      	str	r0, [r1, r2]
      for (j = 0; j < 4u; j++)
 8025c5a:	3301      	adds	r3, #1
 8025c5c:	2b03      	cmp	r3, #3
 8025c5e:	d9f5      	bls.n	8025c4c <CMAC_compute+0x15c>
      encrypt = 0u;
 8025c60:	2300      	movs	r3, #0
 8025c62:	469a      	mov	sl, r3
      processed_block = 0u;
 8025c64:	2400      	movs	r4, #0
 8025c66:	e7bf      	b.n	8025be8 <CMAC_compute+0xf8>

  /* The CRYP peripheral isno more needed. Let's deinit it */
  periph_retval = HAL_CRYP_DeInit(&hcryp);
 8025c68:	9b05      	ldr	r3, [sp, #20]
 8025c6a:	4698      	mov	r8, r3
 8025c6c:	a807      	add	r0, sp, #28
 8025c6e:	f7fd fcfd 	bl	802366c <HAL_CRYP_DeInit>
  if (periph_retval != HAL_OK)
 8025c72:	2800      	cmp	r0, #0
 8025c74:	d147      	bne.n	8025d06 <CMAC_compute+0x216>
  {
    return MAC_ERROR_HW_FAILURE;
  }

  /* Extract the MAC */
  for (i = 0u; i < (macSize / 4u); i++)
 8025c76:	2100      	movs	r1, #0
 8025c78:	9ba8      	ldr	r3, [sp, #672]	; 0x2a0
 8025c7a:	0898      	lsrs	r0, r3, #2
 8025c7c:	4288      	cmp	r0, r1
 8025c7e:	d910      	bls.n	8025ca2 <CMAC_compute+0x1b2>
  {
    WORD_TO_BYTES(temp_iv[i], macBuff[(4u * i) + 3u], macBuff[(4u * i) + 2u],
 8025c80:	008a      	lsls	r2, r1, #2
 8025c82:	ab9a      	add	r3, sp, #616	; 0x268
 8025c84:	58d3      	ldr	r3, [r2, r3]
 8025c86:	1cd0      	adds	r0, r2, #3
 8025c88:	9ca9      	ldr	r4, [sp, #676]	; 0x2a4
 8025c8a:	5423      	strb	r3, [r4, r0]
 8025c8c:	0a1c      	lsrs	r4, r3, #8
 8025c8e:	1c90      	adds	r0, r2, #2
 8025c90:	9da9      	ldr	r5, [sp, #676]	; 0x2a4
 8025c92:	542c      	strb	r4, [r5, r0]
 8025c94:	0c1c      	lsrs	r4, r3, #16
 8025c96:	1c50      	adds	r0, r2, #1
 8025c98:	542c      	strb	r4, [r5, r0]
 8025c9a:	0e1b      	lsrs	r3, r3, #24
 8025c9c:	54ab      	strb	r3, [r5, r2]
  for (i = 0u; i < (macSize / 4u); i++)
 8025c9e:	3101      	adds	r1, #1
 8025ca0:	e7ea      	b.n	8025c78 <CMAC_compute+0x188>
                  macBuff[(4u * i) + 1u], macBuff[(4u * i) + 0u]);
  }

  if (macSize < 16u)
 8025ca2:	2b0f      	cmp	r3, #15
 8025ca4:	d816      	bhi.n	8025cd4 <CMAC_compute+0x1e4>
  {
    /* copy remaining bytes */
    for (i = 0; i < (macSize % 4u); i++)
 8025ca6:	2300      	movs	r3, #0
 8025ca8:	e00c      	b.n	8025cc4 <CMAC_compute+0x1d4>
    {
      macBuff[((macSize / 4u) * 4u) + i] = BYTE_X(temp_iv[macSize / 4u], i);
 8025caa:	0082      	lsls	r2, r0, #2
 8025cac:	a99a      	add	r1, sp, #616	; 0x268
 8025cae:	5851      	ldr	r1, [r2, r1]
 8025cb0:	2403      	movs	r4, #3
 8025cb2:	1ae2      	subs	r2, r4, r3
 8025cb4:	00d2      	lsls	r2, r2, #3
 8025cb6:	40d1      	lsrs	r1, r2
 8025cb8:	9aa8      	ldr	r2, [sp, #672]	; 0x2a0
 8025cba:	43a2      	bics	r2, r4
 8025cbc:	18d2      	adds	r2, r2, r3
 8025cbe:	9ca9      	ldr	r4, [sp, #676]	; 0x2a4
 8025cc0:	54a1      	strb	r1, [r4, r2]
    for (i = 0; i < (macSize % 4u); i++)
 8025cc2:	3301      	adds	r3, #1
 8025cc4:	2203      	movs	r2, #3
 8025cc6:	99a8      	ldr	r1, [sp, #672]	; 0x2a0
 8025cc8:	400a      	ands	r2, r1
 8025cca:	429a      	cmp	r2, r3
 8025ccc:	d8ed      	bhi.n	8025caa <CMAC_compute+0x1ba>
 8025cce:	e001      	b.n	8025cd4 <CMAC_compute+0x1e4>
    return MAC_ERROR_BAD_PARAMETER;
 8025cd0:	2301      	movs	r3, #1
 8025cd2:	4698      	mov	r8, r3
    }
  }

  return retval;
}
 8025cd4:	4640      	mov	r0, r8
 8025cd6:	239f      	movs	r3, #159	; 0x9f
 8025cd8:	009b      	lsls	r3, r3, #2
 8025cda:	449d      	add	sp, r3
 8025cdc:	bcf0      	pop	{r4, r5, r6, r7}
 8025cde:	46bb      	mov	fp, r7
 8025ce0:	46b2      	mov	sl, r6
 8025ce2:	46a9      	mov	r9, r5
 8025ce4:	46a0      	mov	r8, r4
 8025ce6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return MAC_ERROR_BAD_PARAMETER;
 8025ce8:	2301      	movs	r3, #1
 8025cea:	4698      	mov	r8, r3
 8025cec:	e7f2      	b.n	8025cd4 <CMAC_compute+0x1e4>
    return MAC_ERROR_WRONG_MAC_SIZE;
 8025cee:	2302      	movs	r3, #2
 8025cf0:	4698      	mov	r8, r3
 8025cf2:	e7ef      	b.n	8025cd4 <CMAC_compute+0x1e4>
    return MAC_ERROR_WRONG_MAC_SIZE;
 8025cf4:	2302      	movs	r3, #2
 8025cf6:	4698      	mov	r8, r3
 8025cf8:	e7ec      	b.n	8025cd4 <CMAC_compute+0x1e4>
  switch (keySize)
 8025cfa:	2303      	movs	r3, #3
 8025cfc:	4698      	mov	r8, r3
 8025cfe:	e7e9      	b.n	8025cd4 <CMAC_compute+0x1e4>
    return MAC_ERROR_HW_FAILURE;
 8025d00:	2304      	movs	r3, #4
 8025d02:	4698      	mov	r8, r3
 8025d04:	e7e6      	b.n	8025cd4 <CMAC_compute+0x1e4>
    return MAC_ERROR_HW_FAILURE;
 8025d06:	2304      	movs	r3, #4
 8025d08:	4698      	mov	r8, r3
 8025d0a:	e7e3      	b.n	8025cd4 <CMAC_compute+0x1e4>
 8025d0c:	9b05      	ldr	r3, [sp, #20]
 8025d0e:	4698      	mov	r8, r3
 8025d10:	e7e0      	b.n	8025cd4 <CMAC_compute+0x1e4>
 8025d12:	46c0      	nop			; (mov r8, r8)
 8025d14:	fffffd84 	.word	0xfffffd84
 8025d18:	58001800 	.word	0x58001800

08025d1c <CA_AES_CBC_Encrypt_Init>:
  *                                  See note
  */
int32_t CA_AES_CBC_Encrypt_Init(CA_AESCBCctx_stt *P_pAESCBCctx,
                                const uint8_t *P_pKey,
                                const uint8_t *P_pIv)
{
 8025d1c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025d1e:	46de      	mov	lr, fp
 8025d20:	4657      	mov	r7, sl
 8025d22:	464e      	mov	r6, r9
 8025d24:	4645      	mov	r5, r8
 8025d26:	b5e0      	push	{r5, r6, r7, lr}
 8025d28:	b085      	sub	sp, #20
 8025d2a:	0004      	movs	r4, r0
 8025d2c:	000d      	movs	r5, r1
 8025d2e:	0017      	movs	r7, r2
  int32_t aes_ret_status = CA_AES_SUCCESS;

  if ((P_pAESCBCctx == NULL) || (P_pKey == NULL) || (P_pIv == NULL))
 8025d30:	2800      	cmp	r0, #0
 8025d32:	d100      	bne.n	8025d36 <CA_AES_CBC_Encrypt_Init+0x1a>
 8025d34:	e094      	b.n	8025e60 <CA_AES_CBC_Encrypt_Init+0x144>
 8025d36:	2900      	cmp	r1, #0
 8025d38:	d100      	bne.n	8025d3c <CA_AES_CBC_Encrypt_Init+0x20>
 8025d3a:	e094      	b.n	8025e66 <CA_AES_CBC_Encrypt_Init+0x14a>
 8025d3c:	2a00      	cmp	r2, #0
 8025d3e:	d100      	bne.n	8025d42 <CA_AES_CBC_Encrypt_Init+0x26>
 8025d40:	e094      	b.n	8025e6c <CA_AES_CBC_Encrypt_Init+0x150>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  if ((P_pAESCBCctx->mKeySize == 0)
 8025d42:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8025d44:	2b00      	cmp	r3, #0
 8025d46:	d100      	bne.n	8025d4a <CA_AES_CBC_Encrypt_Init+0x2e>
 8025d48:	e093      	b.n	8025e72 <CA_AES_CBC_Encrypt_Init+0x156>
      || (P_pAESCBCctx->mIvSize == 0))
 8025d4a:	6903      	ldr	r3, [r0, #16]
 8025d4c:	2b00      	cmp	r3, #0
 8025d4e:	d100      	bne.n	8025d52 <CA_AES_CBC_Encrypt_Init+0x36>
 8025d50:	e091      	b.n	8025e76 <CA_AES_CBC_Encrypt_Init+0x15a>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  cleanup_handle(&(P_pAESCBCctx->CrypHandle));
 8025d52:	232c      	movs	r3, #44	; 0x2c
 8025d54:	469c      	mov	ip, r3
 8025d56:	4484      	add	ip, r0
 8025d58:	4663      	mov	r3, ip
 8025d5a:	4666      	mov	r6, ip
 8025d5c:	9303      	str	r3, [sp, #12]
 8025d5e:	4660      	mov	r0, ip
 8025d60:	f7ff fe9a 	bl	8025a98 <cleanup_handle>
  P_pAESCBCctx->CrypHandle.Instance = CA_AES_INSTANCE;
 8025d64:	4b4a      	ldr	r3, [pc, #296]	; (8025e90 <CA_AES_CBC_Encrypt_Init+0x174>)
 8025d66:	62e3      	str	r3, [r4, #44]	; 0x2c

  if (HAL_CRYP_DeInit(&P_pAESCBCctx->CrypHandle) != HAL_OK)
 8025d68:	0030      	movs	r0, r6
 8025d6a:	f7fd fc7f 	bl	802366c <HAL_CRYP_DeInit>
 8025d6e:	1e01      	subs	r1, r0, #0
 8025d70:	d000      	beq.n	8025d74 <CA_AES_CBC_Encrypt_Init+0x58>
 8025d72:	e088      	b.n	8025e86 <CA_AES_CBC_Encrypt_Init+0x16a>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  /* Initialize the CRYP peripheral */
  P_pAESCBCctx->CrypHandle.Init.DataType      = CRYP_DATATYPE_8B;
 8025d74:	2304      	movs	r3, #4
 8025d76:	6323      	str	r3, [r4, #48]	; 0x30
  if (P_pAESCBCctx->mKeySize == (int32_t)CA_CRL_AES128_KEY)
 8025d78:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8025d7a:	9301      	str	r3, [sp, #4]
 8025d7c:	2b10      	cmp	r3, #16
 8025d7e:	d007      	beq.n	8025d90 <CA_AES_CBC_Encrypt_Init+0x74>
  {
    P_pAESCBCctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
  }
  else if (P_pAESCBCctx->mKeySize == (int32_t)CA_CRL_AES256_KEY)
 8025d80:	9b01      	ldr	r3, [sp, #4]
 8025d82:	2b20      	cmp	r3, #32
 8025d84:	d000      	beq.n	8025d88 <CA_AES_CBC_Encrypt_Init+0x6c>
 8025d86:	e080      	b.n	8025e8a <CA_AES_CBC_Encrypt_Init+0x16e>
  {
    P_pAESCBCctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_256B;
 8025d88:	2380      	movs	r3, #128	; 0x80
 8025d8a:	02db      	lsls	r3, r3, #11
 8025d8c:	6363      	str	r3, [r4, #52]	; 0x34
 8025d8e:	e02b      	b.n	8025de8 <CA_AES_CBC_Encrypt_Init+0xcc>
    P_pAESCBCctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
 8025d90:	2300      	movs	r3, #0
 8025d92:	6363      	str	r3, [r4, #52]	; 0x34
 8025d94:	e028      	b.n	8025de8 <CA_AES_CBC_Encrypt_Init+0xcc>
  }

  /* Init IV and key here because of endianness */
  for (uint8_t i = 0; i < 4U; i++)
  {
    P_pAESCBCctx->Iv_endian[4U * i]        = P_pIv[3U + (4U * i)];
 8025d96:	0083      	lsls	r3, r0, #2
 8025d98:	4698      	mov	r8, r3
 8025d9a:	3303      	adds	r3, #3
 8025d9c:	9302      	str	r3, [sp, #8]
 8025d9e:	5cfa      	ldrb	r2, [r7, r3]
 8025da0:	4691      	mov	r9, r2
 8025da2:	4642      	mov	r2, r8
 8025da4:	18a2      	adds	r2, r4, r2
 8025da6:	3239      	adds	r2, #57	; 0x39
 8025da8:	32ff      	adds	r2, #255	; 0xff
 8025daa:	464e      	mov	r6, r9
 8025dac:	7016      	strb	r6, [r2, #0]
    P_pAESCBCctx->Iv_endian[1U + (4U * i)] = P_pIv[2U + (4U * i)];
 8025dae:	4642      	mov	r2, r8
 8025db0:	3202      	adds	r2, #2
 8025db2:	2601      	movs	r6, #1
 8025db4:	4446      	add	r6, r8
 8025db6:	46b2      	mov	sl, r6
 8025db8:	5cbe      	ldrb	r6, [r7, r2]
 8025dba:	46b3      	mov	fp, r6
 8025dbc:	46a1      	mov	r9, r4
 8025dbe:	44d1      	add	r9, sl
 8025dc0:	269c      	movs	r6, #156	; 0x9c
 8025dc2:	0076      	lsls	r6, r6, #1
 8025dc4:	46b4      	mov	ip, r6
 8025dc6:	44e1      	add	r9, ip
 8025dc8:	464e      	mov	r6, r9
 8025dca:	465b      	mov	r3, fp
 8025dcc:	7033      	strb	r3, [r6, #0]
    P_pAESCBCctx->Iv_endian[2U + (4U * i)] = P_pIv[1U + (4U * i)];
 8025dce:	4653      	mov	r3, sl
 8025dd0:	5cfb      	ldrb	r3, [r7, r3]
 8025dd2:	18a2      	adds	r2, r4, r2
 8025dd4:	4462      	add	r2, ip
 8025dd6:	7013      	strb	r3, [r2, #0]
    P_pAESCBCctx->Iv_endian[3U + (4U * i)] = P_pIv[4U * i];
 8025dd8:	4643      	mov	r3, r8
 8025dda:	5cfa      	ldrb	r2, [r7, r3]
 8025ddc:	9b02      	ldr	r3, [sp, #8]
 8025dde:	18e3      	adds	r3, r4, r3
 8025de0:	4463      	add	r3, ip
 8025de2:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < 4U; i++)
 8025de4:	3001      	adds	r0, #1
 8025de6:	b2c0      	uxtb	r0, r0
 8025de8:	2803      	cmp	r0, #3
 8025dea:	d9d4      	bls.n	8025d96 <CA_AES_CBC_Encrypt_Init+0x7a>
 8025dec:	e01e      	b.n	8025e2c <CA_AES_CBC_Encrypt_Init+0x110>
  }

  for (uint8_t i = 0; i < ((uint32_t)(P_pAESCBCctx->mKeySize) / 4U); i++)
  {
    P_pAESCBCctx->Key_endian[4U * i]        = P_pKey[3U + (4U * i)];
 8025dee:	0088      	lsls	r0, r1, #2
 8025df0:	1cc3      	adds	r3, r0, #3
 8025df2:	5cef      	ldrb	r7, [r5, r3]
 8025df4:	1822      	adds	r2, r4, r0
 8025df6:	3249      	adds	r2, #73	; 0x49
 8025df8:	32ff      	adds	r2, #255	; 0xff
 8025dfa:	7017      	strb	r7, [r2, #0]
    P_pAESCBCctx->Key_endian[1U + (4U * i)] = P_pKey[2U + (4U * i)];
 8025dfc:	1c82      	adds	r2, r0, #2
 8025dfe:	1c47      	adds	r7, r0, #1
 8025e00:	46b8      	mov	r8, r7
 8025e02:	5caf      	ldrb	r7, [r5, r2]
 8025e04:	46b9      	mov	r9, r7
 8025e06:	4647      	mov	r7, r8
 8025e08:	19e7      	adds	r7, r4, r7
 8025e0a:	3749      	adds	r7, #73	; 0x49
 8025e0c:	37ff      	adds	r7, #255	; 0xff
 8025e0e:	464e      	mov	r6, r9
 8025e10:	703e      	strb	r6, [r7, #0]
    P_pAESCBCctx->Key_endian[2U + (4U * i)] = P_pKey[1U + (4U * i)];
 8025e12:	4646      	mov	r6, r8
 8025e14:	5daf      	ldrb	r7, [r5, r6]
 8025e16:	18a2      	adds	r2, r4, r2
 8025e18:	3249      	adds	r2, #73	; 0x49
 8025e1a:	32ff      	adds	r2, #255	; 0xff
 8025e1c:	7017      	strb	r7, [r2, #0]
    P_pAESCBCctx->Key_endian[3U + (4U * i)] = P_pKey[4U * i];
 8025e1e:	5c2a      	ldrb	r2, [r5, r0]
 8025e20:	18e3      	adds	r3, r4, r3
 8025e22:	3349      	adds	r3, #73	; 0x49
 8025e24:	33ff      	adds	r3, #255	; 0xff
 8025e26:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < ((uint32_t)(P_pAESCBCctx->mKeySize) / 4U); i++)
 8025e28:	3101      	adds	r1, #1
 8025e2a:	b2c9      	uxtb	r1, r1
 8025e2c:	9b01      	ldr	r3, [sp, #4]
 8025e2e:	089b      	lsrs	r3, r3, #2
 8025e30:	4299      	cmp	r1, r3
 8025e32:	d3dc      	bcc.n	8025dee <CA_AES_CBC_Encrypt_Init+0xd2>
  }

  P_pAESCBCctx->CrypHandle.Init.Algorithm       = CRYP_AES_CBC;
 8025e34:	2320      	movs	r3, #32
 8025e36:	6423      	str	r3, [r4, #64]	; 0x40
  P_pAESCBCctx->CrypHandle.Init.pKey = (uint32_t *)(uint32_t)(P_pAESCBCctx->Key_endian);
 8025e38:	0023      	movs	r3, r4
 8025e3a:	3349      	adds	r3, #73	; 0x49
 8025e3c:	33ff      	adds	r3, #255	; 0xff
 8025e3e:	63a3      	str	r3, [r4, #56]	; 0x38
  P_pAESCBCctx->CrypHandle.Init.pInitVect = (uint32_t *)(uint32_t)(P_pAESCBCctx->Iv_endian);
 8025e40:	3b10      	subs	r3, #16
 8025e42:	63e3      	str	r3, [r4, #60]	; 0x3c

  P_pAESCBCctx->CrypHandle.Init.Header = NULL;
 8025e44:	2300      	movs	r3, #0
 8025e46:	6463      	str	r3, [r4, #68]	; 0x44
  P_pAESCBCctx->CrypHandle.Init.HeaderSize = 0;
 8025e48:	64a3      	str	r3, [r4, #72]	; 0x48
  P_pAESCBCctx->CrypHandle.Init.B0 = NULL;
 8025e4a:	64e3      	str	r3, [r4, #76]	; 0x4c
  P_pAESCBCctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 8025e4c:	3301      	adds	r3, #1
 8025e4e:	6523      	str	r3, [r4, #80]	; 0x50
  P_pAESCBCctx->CrypHandle.Init.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ONCE;
 8025e50:	65a3      	str	r3, [r4, #88]	; 0x58

  if (HAL_CRYP_Init(&P_pAESCBCctx->CrypHandle) != HAL_OK)
 8025e52:	9803      	ldr	r0, [sp, #12]
 8025e54:	f7fd fbe4 	bl	8023620 <HAL_CRYP_Init>
 8025e58:	2800      	cmp	r0, #0
 8025e5a:	d00d      	beq.n	8025e78 <CA_AES_CBC_Encrypt_Init+0x15c>
  {
    /* Initialization Error */
    aes_ret_status = CA_AES_ERR_BAD_CONTEXT;
 8025e5c:	480d      	ldr	r0, [pc, #52]	; (8025e94 <CA_AES_CBC_Encrypt_Init+0x178>)
 8025e5e:	e00b      	b.n	8025e78 <CA_AES_CBC_Encrypt_Init+0x15c>
    return CA_AES_ERR_BAD_PARAMETER;
 8025e60:	20c2      	movs	r0, #194	; 0xc2
 8025e62:	0100      	lsls	r0, r0, #4
 8025e64:	e008      	b.n	8025e78 <CA_AES_CBC_Encrypt_Init+0x15c>
 8025e66:	20c2      	movs	r0, #194	; 0xc2
 8025e68:	0100      	lsls	r0, r0, #4
 8025e6a:	e005      	b.n	8025e78 <CA_AES_CBC_Encrypt_Init+0x15c>
 8025e6c:	20c2      	movs	r0, #194	; 0xc2
 8025e6e:	0100      	lsls	r0, r0, #4
 8025e70:	e002      	b.n	8025e78 <CA_AES_CBC_Encrypt_Init+0x15c>
    return CA_AES_ERR_BAD_CONTEXT;
 8025e72:	4808      	ldr	r0, [pc, #32]	; (8025e94 <CA_AES_CBC_Encrypt_Init+0x178>)
 8025e74:	e000      	b.n	8025e78 <CA_AES_CBC_Encrypt_Init+0x15c>
 8025e76:	4807      	ldr	r0, [pc, #28]	; (8025e94 <CA_AES_CBC_Encrypt_Init+0x178>)
  }
  return aes_ret_status;
}
 8025e78:	b005      	add	sp, #20
 8025e7a:	bcf0      	pop	{r4, r5, r6, r7}
 8025e7c:	46bb      	mov	fp, r7
 8025e7e:	46b2      	mov	sl, r6
 8025e80:	46a9      	mov	r9, r5
 8025e82:	46a0      	mov	r8, r4
 8025e84:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CA_AES_ERR_BAD_CONTEXT;
 8025e86:	4803      	ldr	r0, [pc, #12]	; (8025e94 <CA_AES_CBC_Encrypt_Init+0x178>)
 8025e88:	e7f6      	b.n	8025e78 <CA_AES_CBC_Encrypt_Init+0x15c>
    return CA_AES_ERR_BAD_CONTEXT;
 8025e8a:	4802      	ldr	r0, [pc, #8]	; (8025e94 <CA_AES_CBC_Encrypt_Init+0x178>)
 8025e8c:	e7f4      	b.n	8025e78 <CA_AES_CBC_Encrypt_Init+0x15c>
 8025e8e:	46c0      	nop			; (mov r8, r8)
 8025e90:	58001800 	.word	0x58001800
 8025e94:	00000c1f 	.word	0x00000c1f

08025e98 <CA_AES_CBC_Encrypt_Append>:
int32_t CA_AES_CBC_Encrypt_Append(CA_AESCBCctx_stt *P_pAESCBCctx,
                                  const uint8_t *P_pInputBuffer,
                                  int32_t P_inputSize,
                                  uint8_t *P_pOutputBuffer,
                                  int32_t *P_pOutputSize)
{
 8025e98:	b530      	push	{r4, r5, lr}
 8025e9a:	b083      	sub	sp, #12
 8025e9c:	0014      	movs	r4, r2

  int32_t aes_ret_status = CA_AES_SUCCESS;

  if ((P_pAESCBCctx == NULL)
 8025e9e:	2800      	cmp	r0, #0
 8025ea0:	d014      	beq.n	8025ecc <CA_AES_CBC_Encrypt_Append+0x34>
      || (P_pInputBuffer == NULL)
 8025ea2:	2900      	cmp	r1, #0
 8025ea4:	d015      	beq.n	8025ed2 <CA_AES_CBC_Encrypt_Append+0x3a>
      || (P_pOutputBuffer == NULL)
 8025ea6:	2b00      	cmp	r3, #0
 8025ea8:	d016      	beq.n	8025ed8 <CA_AES_CBC_Encrypt_Append+0x40>
      || (P_pOutputSize == NULL))
 8025eaa:	9a06      	ldr	r2, [sp, #24]
 8025eac:	2a00      	cmp	r2, #0
 8025eae:	d016      	beq.n	8025ede <CA_AES_CBC_Encrypt_Append+0x46>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }
  if (P_inputSize < (int32_t)CA_CRL_AES_BLOCK)
 8025eb0:	2c0f      	cmp	r4, #15
 8025eb2:	dd17      	ble.n	8025ee4 <CA_AES_CBC_Encrypt_Append+0x4c>
  {
    return CA_AES_ERR_BAD_INPUT_SIZE;
  }

  if (HAL_CRYP_Encrypt(&P_pAESCBCctx->CrypHandle, (uint32_t *)(uint32_t)P_pInputBuffer, (uint16_t)P_inputSize,
 8025eb4:	b2a2      	uxth	r2, r4
 8025eb6:	302c      	adds	r0, #44	; 0x2c
 8025eb8:	25ff      	movs	r5, #255	; 0xff
 8025eba:	9500      	str	r5, [sp, #0]
 8025ebc:	f7fd ff9e 	bl	8023dfc <HAL_CRYP_Encrypt>
 8025ec0:	2800      	cmp	r0, #0
 8025ec2:	d111      	bne.n	8025ee8 <CA_AES_CBC_Encrypt_Append+0x50>
  {
    aes_ret_status = CA_AES_ERR_BAD_OPERATION;
  }
  else
  {
    *P_pOutputSize = P_inputSize;
 8025ec4:	9b06      	ldr	r3, [sp, #24]
 8025ec6:	601c      	str	r4, [r3, #0]
  }

  return aes_ret_status;
}
 8025ec8:	b003      	add	sp, #12
 8025eca:	bd30      	pop	{r4, r5, pc}
    return CA_AES_ERR_BAD_PARAMETER;
 8025ecc:	20c2      	movs	r0, #194	; 0xc2
 8025ece:	0100      	lsls	r0, r0, #4
 8025ed0:	e7fa      	b.n	8025ec8 <CA_AES_CBC_Encrypt_Append+0x30>
 8025ed2:	20c2      	movs	r0, #194	; 0xc2
 8025ed4:	0100      	lsls	r0, r0, #4
 8025ed6:	e7f7      	b.n	8025ec8 <CA_AES_CBC_Encrypt_Append+0x30>
 8025ed8:	20c2      	movs	r0, #194	; 0xc2
 8025eda:	0100      	lsls	r0, r0, #4
 8025edc:	e7f4      	b.n	8025ec8 <CA_AES_CBC_Encrypt_Append+0x30>
 8025ede:	20c2      	movs	r0, #194	; 0xc2
 8025ee0:	0100      	lsls	r0, r0, #4
 8025ee2:	e7f1      	b.n	8025ec8 <CA_AES_CBC_Encrypt_Append+0x30>
    return CA_AES_ERR_BAD_INPUT_SIZE;
 8025ee4:	4801      	ldr	r0, [pc, #4]	; (8025eec <CA_AES_CBC_Encrypt_Append+0x54>)
 8025ee6:	e7ef      	b.n	8025ec8 <CA_AES_CBC_Encrypt_Append+0x30>
    aes_ret_status = CA_AES_ERR_BAD_OPERATION;
 8025ee8:	4801      	ldr	r0, [pc, #4]	; (8025ef0 <CA_AES_CBC_Encrypt_Append+0x58>)
 8025eea:	e7ed      	b.n	8025ec8 <CA_AES_CBC_Encrypt_Append+0x30>
 8025eec:	00000c1d 	.word	0x00000c1d
 8025ef0:	00000c1e 	.word	0x00000c1e

08025ef4 <CA_AES_CBC_Encrypt_Finish>:
  * @retval     CA_AES_ERR_BAD_PARAMETER: At least one parameter is a NULL pointer
  */
int32_t CA_AES_CBC_Encrypt_Finish(CA_AESCBCctx_stt *P_pAESCBCctx,
                                  uint8_t       *P_pOutputBuffer,
                                  int32_t       *P_pOutputSize)
{
 8025ef4:	b570      	push	{r4, r5, r6, lr}
  int32_t aes_ret_status = CA_AES_SUCCESS;

  (void)P_pOutputBuffer;
  (void)P_pOutputSize;

  if (HAL_CRYP_DeInit(&P_pAESCBCctx->CrypHandle) != HAL_OK)
 8025ef6:	302c      	adds	r0, #44	; 0x2c
 8025ef8:	0004      	movs	r4, r0
 8025efa:	f7fd fbb7 	bl	802366c <HAL_CRYP_DeInit>
 8025efe:	2800      	cmp	r0, #0
 8025f00:	d105      	bne.n	8025f0e <CA_AES_CBC_Encrypt_Finish+0x1a>
  int32_t aes_ret_status = CA_AES_SUCCESS;
 8025f02:	2500      	movs	r5, #0
  {
    aes_ret_status = CA_AES_ERR_BAD_PARAMETER;
  }
  cleanup_handle(&(P_pAESCBCctx->CrypHandle));
 8025f04:	0020      	movs	r0, r4
 8025f06:	f7ff fdc7 	bl	8025a98 <cleanup_handle>

  return aes_ret_status;
}
 8025f0a:	0028      	movs	r0, r5
 8025f0c:	bd70      	pop	{r4, r5, r6, pc}
    aes_ret_status = CA_AES_ERR_BAD_PARAMETER;
 8025f0e:	25c2      	movs	r5, #194	; 0xc2
 8025f10:	012d      	lsls	r5, r5, #4
 8025f12:	e7f7      	b.n	8025f04 <CA_AES_CBC_Encrypt_Finish+0x10>

08025f14 <CA_AES_CBC_Decrypt_Init>:
  *                                  See note
  */
int32_t CA_AES_CBC_Decrypt_Init(CA_AESCBCctx_stt *P_pAESCBCctx,
                                const uint8_t *P_pKey,
                                const uint8_t *P_pIv)
{
 8025f14:	b5f0      	push	{r4, r5, r6, r7, lr}
 8025f16:	46de      	mov	lr, fp
 8025f18:	4657      	mov	r7, sl
 8025f1a:	464e      	mov	r6, r9
 8025f1c:	4645      	mov	r5, r8
 8025f1e:	b5e0      	push	{r5, r6, r7, lr}
 8025f20:	b085      	sub	sp, #20
 8025f22:	0004      	movs	r4, r0
 8025f24:	000d      	movs	r5, r1
 8025f26:	0016      	movs	r6, r2
  int32_t aes_ret_status = CA_AES_SUCCESS;

  if ((P_pAESCBCctx == NULL) || (P_pKey == NULL) || (P_pIv == NULL))
 8025f28:	2800      	cmp	r0, #0
 8025f2a:	d100      	bne.n	8025f2e <CA_AES_CBC_Decrypt_Init+0x1a>
 8025f2c:	e08f      	b.n	802604e <CA_AES_CBC_Decrypt_Init+0x13a>
 8025f2e:	2900      	cmp	r1, #0
 8025f30:	d100      	bne.n	8025f34 <CA_AES_CBC_Decrypt_Init+0x20>
 8025f32:	e08f      	b.n	8026054 <CA_AES_CBC_Decrypt_Init+0x140>
 8025f34:	2a00      	cmp	r2, #0
 8025f36:	d100      	bne.n	8025f3a <CA_AES_CBC_Decrypt_Init+0x26>
 8025f38:	e08f      	b.n	802605a <CA_AES_CBC_Decrypt_Init+0x146>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  if ((P_pAESCBCctx->mKeySize == 0)
 8025f3a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8025f3c:	2b00      	cmp	r3, #0
 8025f3e:	d100      	bne.n	8025f42 <CA_AES_CBC_Decrypt_Init+0x2e>
 8025f40:	e08e      	b.n	8026060 <CA_AES_CBC_Decrypt_Init+0x14c>
      || (P_pAESCBCctx->mIvSize == 0))
 8025f42:	6903      	ldr	r3, [r0, #16]
 8025f44:	2b00      	cmp	r3, #0
 8025f46:	d100      	bne.n	8025f4a <CA_AES_CBC_Decrypt_Init+0x36>
 8025f48:	e08c      	b.n	8026064 <CA_AES_CBC_Decrypt_Init+0x150>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  cleanup_handle(&(P_pAESCBCctx->CrypHandle));
 8025f4a:	232c      	movs	r3, #44	; 0x2c
 8025f4c:	4698      	mov	r8, r3
 8025f4e:	4480      	add	r8, r0
 8025f50:	4640      	mov	r0, r8
 8025f52:	f7ff fda1 	bl	8025a98 <cleanup_handle>
  P_pAESCBCctx->CrypHandle.Instance = CA_AES_INSTANCE;
 8025f56:	4b49      	ldr	r3, [pc, #292]	; (802607c <CA_AES_CBC_Decrypt_Init+0x168>)
 8025f58:	62e3      	str	r3, [r4, #44]	; 0x2c

  if (HAL_CRYP_DeInit(&P_pAESCBCctx->CrypHandle) != HAL_OK)
 8025f5a:	4640      	mov	r0, r8
 8025f5c:	f7fd fb86 	bl	802366c <HAL_CRYP_DeInit>
 8025f60:	1e03      	subs	r3, r0, #0
 8025f62:	9001      	str	r0, [sp, #4]
 8025f64:	d000      	beq.n	8025f68 <CA_AES_CBC_Decrypt_Init+0x54>
 8025f66:	e085      	b.n	8026074 <CA_AES_CBC_Decrypt_Init+0x160>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  /* Initialize the CRYP peripheral */
  P_pAESCBCctx->CrypHandle.Init.DataType      = CRYP_DATATYPE_8B;
 8025f68:	3304      	adds	r3, #4
 8025f6a:	6323      	str	r3, [r4, #48]	; 0x30
  if (P_pAESCBCctx->mKeySize == (int32_t)CA_CRL_AES128_KEY)
 8025f6c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8025f6e:	9302      	str	r3, [sp, #8]
 8025f70:	2b10      	cmp	r3, #16
 8025f72:	d007      	beq.n	8025f84 <CA_AES_CBC_Decrypt_Init+0x70>
  {
    P_pAESCBCctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
  }
  else if (P_pAESCBCctx->mKeySize == (int32_t)CA_CRL_AES256_KEY)
 8025f74:	9b02      	ldr	r3, [sp, #8]
 8025f76:	2b20      	cmp	r3, #32
 8025f78:	d000      	beq.n	8025f7c <CA_AES_CBC_Decrypt_Init+0x68>
 8025f7a:	e07d      	b.n	8026078 <CA_AES_CBC_Decrypt_Init+0x164>
  {
    P_pAESCBCctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_256B;
 8025f7c:	2380      	movs	r3, #128	; 0x80
 8025f7e:	02db      	lsls	r3, r3, #11
 8025f80:	6363      	str	r3, [r4, #52]	; 0x34
 8025f82:	e026      	b.n	8025fd2 <CA_AES_CBC_Decrypt_Init+0xbe>
    P_pAESCBCctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
 8025f84:	2300      	movs	r3, #0
 8025f86:	6363      	str	r3, [r4, #52]	; 0x34
 8025f88:	e023      	b.n	8025fd2 <CA_AES_CBC_Decrypt_Init+0xbe>
  }

  /* Init IV and key here because of endianness */
  for (uint8_t i = 0; i < 4U; i++)
  {
    P_pAESCBCctx->Iv_endian[4U * i]        = P_pIv[3U + (4U * i)];
 8025f8a:	0081      	lsls	r1, r0, #2
 8025f8c:	1ccb      	adds	r3, r1, #3
 8025f8e:	9303      	str	r3, [sp, #12]
 8025f90:	5cf2      	ldrb	r2, [r6, r3]
 8025f92:	4691      	mov	r9, r2
 8025f94:	1862      	adds	r2, r4, r1
 8025f96:	3239      	adds	r2, #57	; 0x39
 8025f98:	32ff      	adds	r2, #255	; 0xff
 8025f9a:	464f      	mov	r7, r9
 8025f9c:	7017      	strb	r7, [r2, #0]
    P_pAESCBCctx->Iv_endian[1U + (4U * i)] = P_pIv[2U + (4U * i)];
 8025f9e:	1c8a      	adds	r2, r1, #2
 8025fa0:	1c4f      	adds	r7, r1, #1
 8025fa2:	46ba      	mov	sl, r7
 8025fa4:	5cb7      	ldrb	r7, [r6, r2]
 8025fa6:	46bb      	mov	fp, r7
 8025fa8:	46a1      	mov	r9, r4
 8025faa:	44d1      	add	r9, sl
 8025fac:	279c      	movs	r7, #156	; 0x9c
 8025fae:	007f      	lsls	r7, r7, #1
 8025fb0:	46bc      	mov	ip, r7
 8025fb2:	44e1      	add	r9, ip
 8025fb4:	464f      	mov	r7, r9
 8025fb6:	465b      	mov	r3, fp
 8025fb8:	703b      	strb	r3, [r7, #0]
    P_pAESCBCctx->Iv_endian[2U + (4U * i)] = P_pIv[1U + (4U * i)];
 8025fba:	4653      	mov	r3, sl
 8025fbc:	5cf3      	ldrb	r3, [r6, r3]
 8025fbe:	18a2      	adds	r2, r4, r2
 8025fc0:	4462      	add	r2, ip
 8025fc2:	7013      	strb	r3, [r2, #0]
    P_pAESCBCctx->Iv_endian[3U + (4U * i)] = P_pIv[4U * i];
 8025fc4:	5c72      	ldrb	r2, [r6, r1]
 8025fc6:	9b03      	ldr	r3, [sp, #12]
 8025fc8:	18e3      	adds	r3, r4, r3
 8025fca:	4463      	add	r3, ip
 8025fcc:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < 4U; i++)
 8025fce:	3001      	adds	r0, #1
 8025fd0:	b2c0      	uxtb	r0, r0
 8025fd2:	2803      	cmp	r0, #3
 8025fd4:	d9d9      	bls.n	8025f8a <CA_AES_CBC_Decrypt_Init+0x76>
 8025fd6:	e01e      	b.n	8026016 <CA_AES_CBC_Decrypt_Init+0x102>
  }

  for (uint8_t i = 0; i < ((uint8_t)(P_pAESCBCctx->mKeySize) / 4U); i++)
  {
    P_pAESCBCctx->Key_endian[4U * i]        = P_pKey[3U + (4U * i)];
 8025fd8:	9f01      	ldr	r7, [sp, #4]
 8025fda:	00b8      	lsls	r0, r7, #2
 8025fdc:	1cc3      	adds	r3, r0, #3
 8025fde:	5ce9      	ldrb	r1, [r5, r3]
 8025fe0:	1822      	adds	r2, r4, r0
 8025fe2:	3249      	adds	r2, #73	; 0x49
 8025fe4:	32ff      	adds	r2, #255	; 0xff
 8025fe6:	7011      	strb	r1, [r2, #0]
    P_pAESCBCctx->Key_endian[1U + (4U * i)] = P_pKey[2U + (4U * i)];
 8025fe8:	1c82      	adds	r2, r0, #2
 8025fea:	1c46      	adds	r6, r0, #1
 8025fec:	5ca9      	ldrb	r1, [r5, r2]
 8025fee:	4689      	mov	r9, r1
 8025ff0:	19a1      	adds	r1, r4, r6
 8025ff2:	3149      	adds	r1, #73	; 0x49
 8025ff4:	31ff      	adds	r1, #255	; 0xff
 8025ff6:	464f      	mov	r7, r9
 8025ff8:	700f      	strb	r7, [r1, #0]
    P_pAESCBCctx->Key_endian[2U + (4U * i)] = P_pKey[1U + (4U * i)];
 8025ffa:	5dae      	ldrb	r6, [r5, r6]
 8025ffc:	18a2      	adds	r2, r4, r2
 8025ffe:	3249      	adds	r2, #73	; 0x49
 8026000:	32ff      	adds	r2, #255	; 0xff
 8026002:	7016      	strb	r6, [r2, #0]
    P_pAESCBCctx->Key_endian[3U + (4U * i)] = P_pKey[4U * i];
 8026004:	5c2a      	ldrb	r2, [r5, r0]
 8026006:	18e3      	adds	r3, r4, r3
 8026008:	3349      	adds	r3, #73	; 0x49
 802600a:	33ff      	adds	r3, #255	; 0xff
 802600c:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESCBCctx->mKeySize) / 4U); i++)
 802600e:	9f01      	ldr	r7, [sp, #4]
 8026010:	3701      	adds	r7, #1
 8026012:	b2fb      	uxtb	r3, r7
 8026014:	9301      	str	r3, [sp, #4]
 8026016:	466b      	mov	r3, sp
 8026018:	7a1b      	ldrb	r3, [r3, #8]
 802601a:	089b      	lsrs	r3, r3, #2
 802601c:	9a01      	ldr	r2, [sp, #4]
 802601e:	4293      	cmp	r3, r2
 8026020:	d8da      	bhi.n	8025fd8 <CA_AES_CBC_Decrypt_Init+0xc4>
  }

  P_pAESCBCctx->CrypHandle.Init.Algorithm       = CRYP_AES_CBC;
 8026022:	2320      	movs	r3, #32
 8026024:	6423      	str	r3, [r4, #64]	; 0x40
  P_pAESCBCctx->CrypHandle.Init.pKey = (uint32_t *)(uint32_t)(P_pAESCBCctx->Key_endian);
 8026026:	0023      	movs	r3, r4
 8026028:	3349      	adds	r3, #73	; 0x49
 802602a:	33ff      	adds	r3, #255	; 0xff
 802602c:	63a3      	str	r3, [r4, #56]	; 0x38
  P_pAESCBCctx->CrypHandle.Init.pInitVect = (uint32_t *)(uint32_t)(P_pAESCBCctx->Iv_endian);
 802602e:	3b10      	subs	r3, #16
 8026030:	63e3      	str	r3, [r4, #60]	; 0x3c

  P_pAESCBCctx->CrypHandle.Init.Header = NULL;
 8026032:	2300      	movs	r3, #0
 8026034:	6463      	str	r3, [r4, #68]	; 0x44
  P_pAESCBCctx->CrypHandle.Init.HeaderSize = 0;
 8026036:	64a3      	str	r3, [r4, #72]	; 0x48
  P_pAESCBCctx->CrypHandle.Init.B0 = NULL;
 8026038:	64e3      	str	r3, [r4, #76]	; 0x4c
  P_pAESCBCctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 802603a:	3301      	adds	r3, #1
 802603c:	6523      	str	r3, [r4, #80]	; 0x50
  P_pAESCBCctx->CrypHandle.Init.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ONCE;
 802603e:	65a3      	str	r3, [r4, #88]	; 0x58

  if (HAL_CRYP_Init(&P_pAESCBCctx->CrypHandle) != HAL_OK)
 8026040:	4640      	mov	r0, r8
 8026042:	f7fd faed 	bl	8023620 <HAL_CRYP_Init>
 8026046:	2800      	cmp	r0, #0
 8026048:	d00d      	beq.n	8026066 <CA_AES_CBC_Decrypt_Init+0x152>
  {
    /* Initialization Error */
    aes_ret_status = CA_AES_ERR_BAD_CONTEXT;
 802604a:	480d      	ldr	r0, [pc, #52]	; (8026080 <CA_AES_CBC_Decrypt_Init+0x16c>)
 802604c:	e00b      	b.n	8026066 <CA_AES_CBC_Decrypt_Init+0x152>
    return CA_AES_ERR_BAD_PARAMETER;
 802604e:	20c2      	movs	r0, #194	; 0xc2
 8026050:	0100      	lsls	r0, r0, #4
 8026052:	e008      	b.n	8026066 <CA_AES_CBC_Decrypt_Init+0x152>
 8026054:	20c2      	movs	r0, #194	; 0xc2
 8026056:	0100      	lsls	r0, r0, #4
 8026058:	e005      	b.n	8026066 <CA_AES_CBC_Decrypt_Init+0x152>
 802605a:	20c2      	movs	r0, #194	; 0xc2
 802605c:	0100      	lsls	r0, r0, #4
 802605e:	e002      	b.n	8026066 <CA_AES_CBC_Decrypt_Init+0x152>
    return CA_AES_ERR_BAD_CONTEXT;
 8026060:	4807      	ldr	r0, [pc, #28]	; (8026080 <CA_AES_CBC_Decrypt_Init+0x16c>)
 8026062:	e000      	b.n	8026066 <CA_AES_CBC_Decrypt_Init+0x152>
 8026064:	4806      	ldr	r0, [pc, #24]	; (8026080 <CA_AES_CBC_Decrypt_Init+0x16c>)
  {
    add_aec_cbc_decrypt_handle(&P_pAESCBCctx->CrypHandle);
  }
#endif /* KMS_ENCRYPT_DECRYPT_BLOB */
  return aes_ret_status;
}
 8026066:	b005      	add	sp, #20
 8026068:	bcf0      	pop	{r4, r5, r6, r7}
 802606a:	46bb      	mov	fp, r7
 802606c:	46b2      	mov	sl, r6
 802606e:	46a9      	mov	r9, r5
 8026070:	46a0      	mov	r8, r4
 8026072:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CA_AES_ERR_BAD_CONTEXT;
 8026074:	4802      	ldr	r0, [pc, #8]	; (8026080 <CA_AES_CBC_Decrypt_Init+0x16c>)
 8026076:	e7f6      	b.n	8026066 <CA_AES_CBC_Decrypt_Init+0x152>
    return CA_AES_ERR_BAD_CONTEXT;
 8026078:	4801      	ldr	r0, [pc, #4]	; (8026080 <CA_AES_CBC_Decrypt_Init+0x16c>)
 802607a:	e7f4      	b.n	8026066 <CA_AES_CBC_Decrypt_Init+0x152>
 802607c:	58001800 	.word	0x58001800
 8026080:	00000c1f 	.word	0x00000c1f

08026084 <CA_AES_CMAC_Encrypt_Init>:
  * @retval     CA_AES_ERR_BAD_PARAMETER: At least one parameter is a NULL pointer
  * @retval     CA_AES_ERR_BAD_CONTEXT: Context not initialized with valid values
  */
int32_t CA_AES_CMAC_Encrypt_Init(CA_AESCMACctx_stt *P_pAESCMACctx)
{
  if (P_pAESCMACctx == NULL)
 8026084:	2800      	cmp	r0, #0
 8026086:	d00d      	beq.n	80260a4 <CA_AES_CMAC_Encrypt_Init+0x20>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }
  if (P_pAESCMACctx->pmKey == NULL)
 8026088:	6883      	ldr	r3, [r0, #8]
 802608a:	2b00      	cmp	r3, #0
 802608c:	d00d      	beq.n	80260aa <CA_AES_CMAC_Encrypt_Init+0x26>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }
  if ((P_pAESCMACctx->mKeySize != (int32_t)CA_CRL_AES128_KEY)
 802608e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8026090:	2b10      	cmp	r3, #16
 8026092:	d001      	beq.n	8026098 <CA_AES_CMAC_Encrypt_Init+0x14>
      && (P_pAESCMACctx->mKeySize != (int32_t)CA_CRL_AES256_KEY))
 8026094:	2b20      	cmp	r3, #32
 8026096:	d10a      	bne.n	80260ae <CA_AES_CMAC_Encrypt_Init+0x2a>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }
  if ((P_pAESCMACctx->mTagSize <= 0) || (P_pAESCMACctx->mTagSize > (int32_t)CA_CRL_AES_BLOCK))
 8026098:	6b03      	ldr	r3, [r0, #48]	; 0x30
 802609a:	3b01      	subs	r3, #1
 802609c:	2b0f      	cmp	r3, #15
 802609e:	d808      	bhi.n	80260b2 <CA_AES_CMAC_Encrypt_Init+0x2e>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }
  return CA_AES_SUCCESS;
 80260a0:	2000      	movs	r0, #0
}
 80260a2:	4770      	bx	lr
    return CA_AES_ERR_BAD_PARAMETER;
 80260a4:	20c2      	movs	r0, #194	; 0xc2
 80260a6:	0100      	lsls	r0, r0, #4
 80260a8:	e7fb      	b.n	80260a2 <CA_AES_CMAC_Encrypt_Init+0x1e>
    return CA_AES_ERR_BAD_CONTEXT;
 80260aa:	4803      	ldr	r0, [pc, #12]	; (80260b8 <CA_AES_CMAC_Encrypt_Init+0x34>)
 80260ac:	e7f9      	b.n	80260a2 <CA_AES_CMAC_Encrypt_Init+0x1e>
    return CA_AES_ERR_BAD_CONTEXT;
 80260ae:	4802      	ldr	r0, [pc, #8]	; (80260b8 <CA_AES_CMAC_Encrypt_Init+0x34>)
 80260b0:	e7f7      	b.n	80260a2 <CA_AES_CMAC_Encrypt_Init+0x1e>
    return CA_AES_ERR_BAD_CONTEXT;
 80260b2:	4801      	ldr	r0, [pc, #4]	; (80260b8 <CA_AES_CMAC_Encrypt_Init+0x34>)
 80260b4:	e7f5      	b.n	80260a2 <CA_AES_CMAC_Encrypt_Init+0x1e>
 80260b6:	46c0      	nop			; (mov r8, r8)
 80260b8:	00000c1f 	.word	0x00000c1f

080260bc <CA_AES_CMAC_Encrypt_Append>:
  * @retval     CA_AES_ERR_BAD_OPERATION: Append not allowed
  */
int32_t CA_AES_CMAC_Encrypt_Append(CA_AESCMACctx_stt *P_pAESCMACctx,
                                   const uint8_t  *P_pInputBuffer,
                                   int32_t         P_inputSize)
{
 80260bc:	b570      	push	{r4, r5, r6, lr}
 80260be:	b082      	sub	sp, #8
 80260c0:	0004      	movs	r4, r0
 80260c2:	0008      	movs	r0, r1
 80260c4:	0011      	movs	r1, r2
  mac_error_t error;
  if ((P_pAESCMACctx == NULL) || (P_pInputBuffer == NULL) || (P_inputSize == 0))
 80260c6:	2c00      	cmp	r4, #0
 80260c8:	d010      	beq.n	80260ec <CA_AES_CMAC_Encrypt_Append+0x30>
 80260ca:	2800      	cmp	r0, #0
 80260cc:	d011      	beq.n	80260f2 <CA_AES_CMAC_Encrypt_Append+0x36>
 80260ce:	2a00      	cmp	r2, #0
 80260d0:	d012      	beq.n	80260f8 <CA_AES_CMAC_Encrypt_Append+0x3c>
    return CA_AES_ERR_BAD_PARAMETER;
  }
  error = CMAC_compute(P_pInputBuffer,
                       (uint32_t)P_inputSize,
                       P_pAESCMACctx->pmKey,
                       (uint32_t)(P_pAESCMACctx->mKeySize),
 80260d2:	6a63      	ldr	r3, [r4, #36]	; 0x24
                       (uint32_t)(P_pAESCMACctx->mTagSize),
 80260d4:	6b25      	ldr	r5, [r4, #48]	; 0x30
                       P_pAESCMACctx->mac);
 80260d6:	0026      	movs	r6, r4
 80260d8:	3634      	adds	r6, #52	; 0x34
  error = CMAC_compute(P_pInputBuffer,
 80260da:	68a2      	ldr	r2, [r4, #8]
 80260dc:	9601      	str	r6, [sp, #4]
 80260de:	9500      	str	r5, [sp, #0]
 80260e0:	f7ff fd06 	bl	8025af0 <CMAC_compute>
  if (error == MAC_SUCCESS)
 80260e4:	2800      	cmp	r0, #0
 80260e6:	d10a      	bne.n	80260fe <CA_AES_CMAC_Encrypt_Append+0x42>
  }
  else
  {
    return CA_AES_ERR_BAD_OPERATION;
  }
}
 80260e8:	b002      	add	sp, #8
 80260ea:	bd70      	pop	{r4, r5, r6, pc}
    return CA_AES_ERR_BAD_PARAMETER;
 80260ec:	20c2      	movs	r0, #194	; 0xc2
 80260ee:	0100      	lsls	r0, r0, #4
 80260f0:	e7fa      	b.n	80260e8 <CA_AES_CMAC_Encrypt_Append+0x2c>
 80260f2:	20c2      	movs	r0, #194	; 0xc2
 80260f4:	0100      	lsls	r0, r0, #4
 80260f6:	e7f7      	b.n	80260e8 <CA_AES_CMAC_Encrypt_Append+0x2c>
 80260f8:	20c2      	movs	r0, #194	; 0xc2
 80260fa:	0100      	lsls	r0, r0, #4
 80260fc:	e7f4      	b.n	80260e8 <CA_AES_CMAC_Encrypt_Append+0x2c>
    return CA_AES_ERR_BAD_OPERATION;
 80260fe:	4801      	ldr	r0, [pc, #4]	; (8026104 <CA_AES_CMAC_Encrypt_Append+0x48>)
 8026100:	e7f2      	b.n	80260e8 <CA_AES_CMAC_Encrypt_Append+0x2c>
 8026102:	46c0      	nop			; (mov r8, r8)
 8026104:	00000c1e 	.word	0x00000c1e

08026108 <CA_AES_CMAC_Encrypt_Finish>:
  *             see note
  */
int32_t CA_AES_CMAC_Encrypt_Finish(CA_AESCMACctx_stt *P_pAESCMACctx,
                                   uint8_t        *P_pOutputBuffer,
                                   int32_t        *P_pOutputSize)
{
 8026108:	b570      	push	{r4, r5, r6, lr}
 802610a:	0004      	movs	r4, r0
 802610c:	0008      	movs	r0, r1
 802610e:	0015      	movs	r5, r2
  if ((P_pAESCMACctx == NULL) || (P_pOutputBuffer == NULL) || (P_pOutputSize == NULL))
 8026110:	2c00      	cmp	r4, #0
 8026112:	d00c      	beq.n	802612e <CA_AES_CMAC_Encrypt_Finish+0x26>
 8026114:	2900      	cmp	r1, #0
 8026116:	d00d      	beq.n	8026134 <CA_AES_CMAC_Encrypt_Finish+0x2c>
 8026118:	2a00      	cmp	r2, #0
 802611a:	d00e      	beq.n	802613a <CA_AES_CMAC_Encrypt_Finish+0x32>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }
  (void)memcpy(P_pOutputBuffer, P_pAESCMACctx->mac, (uint32_t)(P_pAESCMACctx->mTagSize));
 802611c:	0021      	movs	r1, r4
 802611e:	3134      	adds	r1, #52	; 0x34
 8026120:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8026122:	f00e fcff 	bl	8034b24 <memcpy>
  *P_pOutputSize = P_pAESCMACctx->mTagSize;
 8026126:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8026128:	602b      	str	r3, [r5, #0]
  return CA_AES_SUCCESS;
 802612a:	2000      	movs	r0, #0
}
 802612c:	bd70      	pop	{r4, r5, r6, pc}
    return CA_AES_ERR_BAD_PARAMETER;
 802612e:	20c2      	movs	r0, #194	; 0xc2
 8026130:	0100      	lsls	r0, r0, #4
 8026132:	e7fb      	b.n	802612c <CA_AES_CMAC_Encrypt_Finish+0x24>
 8026134:	20c2      	movs	r0, #194	; 0xc2
 8026136:	0100      	lsls	r0, r0, #4
 8026138:	e7f8      	b.n	802612c <CA_AES_CMAC_Encrypt_Finish+0x24>
 802613a:	20c2      	movs	r0, #194	; 0xc2
 802613c:	0100      	lsls	r0, r0, #4
 802613e:	e7f5      	b.n	802612c <CA_AES_CMAC_Encrypt_Finish+0x24>

08026140 <CA_AES_CMAC_Decrypt_Init>:
  * @retval     CA_AES_ERR_BAD_CONTEXT: Context not initialized with valid values,
  *                                   see the note below
  */
int32_t CA_AES_CMAC_Decrypt_Init(CA_AESCMACctx_stt *P_pAESCMACctx)
{
  if (P_pAESCMACctx == NULL)
 8026140:	2800      	cmp	r0, #0
 8026142:	d010      	beq.n	8026166 <CA_AES_CMAC_Decrypt_Init+0x26>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }
  if (P_pAESCMACctx->pmKey == NULL)
 8026144:	6883      	ldr	r3, [r0, #8]
 8026146:	2b00      	cmp	r3, #0
 8026148:	d010      	beq.n	802616c <CA_AES_CMAC_Decrypt_Init+0x2c>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }
  if ((P_pAESCMACctx->mKeySize != (int32_t)CA_CRL_AES128_KEY)
 802614a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 802614c:	2b10      	cmp	r3, #16
 802614e:	d001      	beq.n	8026154 <CA_AES_CMAC_Decrypt_Init+0x14>
      && (P_pAESCMACctx->mKeySize != (int32_t)CA_CRL_AES256_KEY))
 8026150:	2b20      	cmp	r3, #32
 8026152:	d10d      	bne.n	8026170 <CA_AES_CMAC_Decrypt_Init+0x30>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }
  if (P_pAESCMACctx->pmTag == NULL)
 8026154:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8026156:	2b00      	cmp	r3, #0
 8026158:	d00c      	beq.n	8026174 <CA_AES_CMAC_Decrypt_Init+0x34>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }
  if ((P_pAESCMACctx->mTagSize <= 0) || (P_pAESCMACctx->mTagSize > (int32_t)CA_CRL_AES_BLOCK))
 802615a:	6b03      	ldr	r3, [r0, #48]	; 0x30
 802615c:	3b01      	subs	r3, #1
 802615e:	2b0f      	cmp	r3, #15
 8026160:	d80a      	bhi.n	8026178 <CA_AES_CMAC_Decrypt_Init+0x38>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }
  return CA_AES_SUCCESS;
 8026162:	2000      	movs	r0, #0
}
 8026164:	4770      	bx	lr
    return CA_AES_ERR_BAD_PARAMETER;
 8026166:	20c2      	movs	r0, #194	; 0xc2
 8026168:	0100      	lsls	r0, r0, #4
 802616a:	e7fb      	b.n	8026164 <CA_AES_CMAC_Decrypt_Init+0x24>
    return CA_AES_ERR_BAD_CONTEXT;
 802616c:	4803      	ldr	r0, [pc, #12]	; (802617c <CA_AES_CMAC_Decrypt_Init+0x3c>)
 802616e:	e7f9      	b.n	8026164 <CA_AES_CMAC_Decrypt_Init+0x24>
    return CA_AES_ERR_BAD_CONTEXT;
 8026170:	4802      	ldr	r0, [pc, #8]	; (802617c <CA_AES_CMAC_Decrypt_Init+0x3c>)
 8026172:	e7f7      	b.n	8026164 <CA_AES_CMAC_Decrypt_Init+0x24>
    return CA_AES_ERR_BAD_CONTEXT;
 8026174:	4801      	ldr	r0, [pc, #4]	; (802617c <CA_AES_CMAC_Decrypt_Init+0x3c>)
 8026176:	e7f5      	b.n	8026164 <CA_AES_CMAC_Decrypt_Init+0x24>
    return CA_AES_ERR_BAD_CONTEXT;
 8026178:	4800      	ldr	r0, [pc, #0]	; (802617c <CA_AES_CMAC_Decrypt_Init+0x3c>)
 802617a:	e7f3      	b.n	8026164 <CA_AES_CMAC_Decrypt_Init+0x24>
 802617c:	00000c1f 	.word	0x00000c1f

08026180 <CA_AES_CMAC_Decrypt_Append>:
  * @retval     CA_AES_ERR_BAD_OPERATION: Append not allowed
  */
int32_t CA_AES_CMAC_Decrypt_Append(CA_AESCMACctx_stt *P_pAESCMACctx,
                                   const uint8_t  *P_pInputBuffer,
                                   int32_t         P_inputSize)
{
 8026180:	b570      	push	{r4, r5, r6, lr}
 8026182:	b082      	sub	sp, #8
 8026184:	0004      	movs	r4, r0
 8026186:	0008      	movs	r0, r1
 8026188:	0011      	movs	r1, r2
  mac_error_t error;
  if ((P_pAESCMACctx == NULL) || (P_pInputBuffer == NULL) || (P_inputSize == 0))
 802618a:	2c00      	cmp	r4, #0
 802618c:	d010      	beq.n	80261b0 <CA_AES_CMAC_Decrypt_Append+0x30>
 802618e:	2800      	cmp	r0, #0
 8026190:	d011      	beq.n	80261b6 <CA_AES_CMAC_Decrypt_Append+0x36>
 8026192:	2a00      	cmp	r2, #0
 8026194:	d012      	beq.n	80261bc <CA_AES_CMAC_Decrypt_Append+0x3c>
    return CA_AES_ERR_BAD_PARAMETER;
  }
  error = CMAC_compute(P_pInputBuffer,
                       (uint32_t)P_inputSize,
                       P_pAESCMACctx->pmKey,
                       (uint32_t)(P_pAESCMACctx->mKeySize),
 8026196:	6a63      	ldr	r3, [r4, #36]	; 0x24
                       (uint32_t)(P_pAESCMACctx->mTagSize),
 8026198:	6b25      	ldr	r5, [r4, #48]	; 0x30
                       P_pAESCMACctx->mac);
 802619a:	0026      	movs	r6, r4
 802619c:	3634      	adds	r6, #52	; 0x34
  error = CMAC_compute(P_pInputBuffer,
 802619e:	68a2      	ldr	r2, [r4, #8]
 80261a0:	9601      	str	r6, [sp, #4]
 80261a2:	9500      	str	r5, [sp, #0]
 80261a4:	f7ff fca4 	bl	8025af0 <CMAC_compute>
  if (error == MAC_SUCCESS)
 80261a8:	2800      	cmp	r0, #0
 80261aa:	d10a      	bne.n	80261c2 <CA_AES_CMAC_Decrypt_Append+0x42>
  }
  else
  {
    return CA_AES_ERR_BAD_OPERATION;
  }
}
 80261ac:	b002      	add	sp, #8
 80261ae:	bd70      	pop	{r4, r5, r6, pc}
    return CA_AES_ERR_BAD_PARAMETER;
 80261b0:	20c2      	movs	r0, #194	; 0xc2
 80261b2:	0100      	lsls	r0, r0, #4
 80261b4:	e7fa      	b.n	80261ac <CA_AES_CMAC_Decrypt_Append+0x2c>
 80261b6:	20c2      	movs	r0, #194	; 0xc2
 80261b8:	0100      	lsls	r0, r0, #4
 80261ba:	e7f7      	b.n	80261ac <CA_AES_CMAC_Decrypt_Append+0x2c>
 80261bc:	20c2      	movs	r0, #194	; 0xc2
 80261be:	0100      	lsls	r0, r0, #4
 80261c0:	e7f4      	b.n	80261ac <CA_AES_CMAC_Decrypt_Append+0x2c>
    return CA_AES_ERR_BAD_OPERATION;
 80261c2:	4801      	ldr	r0, [pc, #4]	; (80261c8 <CA_AES_CMAC_Decrypt_Append+0x48>)
 80261c4:	e7f2      	b.n	80261ac <CA_AES_CMAC_Decrypt_Append+0x2c>
 80261c6:	46c0      	nop			; (mov r8, r8)
 80261c8:	00000c1e 	.word	0x00000c1e

080261cc <CA_AES_CMAC_Decrypt_Finish>:
  *             see note
  */
int32_t CA_AES_CMAC_Decrypt_Finish(CA_AESCMACctx_stt *P_pAESCMACctx,
                                   uint8_t        *P_pOutputBuffer,
                                   int32_t        *P_pOutputSize)
{
 80261cc:	b510      	push	{r4, lr}
 80261ce:	1e03      	subs	r3, r0, #0
  (void)P_pOutputBuffer;
  if ((P_pAESCMACctx == NULL) || (P_pOutputSize == NULL))
 80261d0:	d00e      	beq.n	80261f0 <CA_AES_CMAC_Decrypt_Finish+0x24>
 80261d2:	2a00      	cmp	r2, #0
 80261d4:	d00f      	beq.n	80261f6 <CA_AES_CMAC_Decrypt_Finish+0x2a>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }
  *P_pOutputSize = 0;
 80261d6:	2100      	movs	r1, #0
 80261d8:	6011      	str	r1, [r2, #0]
  if (memcmp(P_pAESCMACctx->pmTag, P_pAESCMACctx->mac, (uint32_t)(P_pAESCMACctx->mTagSize)) != 0)
 80261da:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 80261dc:	0019      	movs	r1, r3
 80261de:	3134      	adds	r1, #52	; 0x34
 80261e0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80261e2:	f00e fc91 	bl	8034b08 <memcmp>
 80261e6:	2800      	cmp	r0, #0
 80261e8:	d008      	beq.n	80261fc <CA_AES_CMAC_Decrypt_Finish+0x30>
  {
    return CA_AUTHENTICATION_FAILED;
 80261ea:	20fb      	movs	r0, #251	; 0xfb
 80261ec:	0080      	lsls	r0, r0, #2
  }
  else
  {
    return CA_AUTHENTICATION_SUCCESSFUL;
  }
}
 80261ee:	bd10      	pop	{r4, pc}
    return CA_AES_ERR_BAD_PARAMETER;
 80261f0:	20c2      	movs	r0, #194	; 0xc2
 80261f2:	0100      	lsls	r0, r0, #4
 80261f4:	e7fb      	b.n	80261ee <CA_AES_CMAC_Decrypt_Finish+0x22>
 80261f6:	20c2      	movs	r0, #194	; 0xc2
 80261f8:	0100      	lsls	r0, r0, #4
 80261fa:	e7f8      	b.n	80261ee <CA_AES_CMAC_Decrypt_Finish+0x22>
    return CA_AUTHENTICATION_SUCCESSFUL;
 80261fc:	4800      	ldr	r0, [pc, #0]	; (8026200 <CA_AES_CMAC_Decrypt_Finish+0x34>)
 80261fe:	e7f6      	b.n	80261ee <CA_AES_CMAC_Decrypt_Finish+0x22>
 8026200:	000003eb 	.word	0x000003eb

08026204 <CA_AES_ECB_Encrypt_Init>:
  *                                  See note
  */
int32_t CA_AES_ECB_Encrypt_Init(CA_AESECBctx_stt *P_pAESECBctx,
                                const uint8_t *P_pKey,
                                const uint8_t *P_pIv)
{
 8026204:	b5f0      	push	{r4, r5, r6, r7, lr}
 8026206:	46ce      	mov	lr, r9
 8026208:	4647      	mov	r7, r8
 802620a:	b580      	push	{r7, lr}
 802620c:	b083      	sub	sp, #12
 802620e:	0004      	movs	r4, r0
 8026210:	000d      	movs	r5, r1
  int32_t aes_ret_status = CA_AES_SUCCESS;

  (void)P_pIv;

  if ((P_pAESECBctx == NULL) || (P_pKey == NULL))
 8026212:	2800      	cmp	r0, #0
 8026214:	d059      	beq.n	80262ca <CA_AES_ECB_Encrypt_Init+0xc6>
 8026216:	2900      	cmp	r1, #0
 8026218:	d05a      	beq.n	80262d0 <CA_AES_ECB_Encrypt_Init+0xcc>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  if (P_pAESECBctx->mKeySize == 0)
 802621a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 802621c:	2b00      	cmp	r3, #0
 802621e:	d05a      	beq.n	80262d6 <CA_AES_ECB_Encrypt_Init+0xd2>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  cleanup_handle(&(P_pAESECBctx->CrypHandle));
 8026220:	232c      	movs	r3, #44	; 0x2c
 8026222:	4698      	mov	r8, r3
 8026224:	4480      	add	r8, r0
 8026226:	4640      	mov	r0, r8
 8026228:	f7ff fc36 	bl	8025a98 <cleanup_handle>
  P_pAESECBctx->CrypHandle.Instance = CA_AES_INSTANCE;
 802622c:	4b2f      	ldr	r3, [pc, #188]	; (80262ec <CA_AES_ECB_Encrypt_Init+0xe8>)
 802622e:	62e3      	str	r3, [r4, #44]	; 0x2c

  if (HAL_CRYP_DeInit(&P_pAESECBctx->CrypHandle) != HAL_OK)
 8026230:	4640      	mov	r0, r8
 8026232:	f7fd fa1b 	bl	802366c <HAL_CRYP_DeInit>
 8026236:	2800      	cmp	r0, #0
 8026238:	d153      	bne.n	80262e2 <CA_AES_ECB_Encrypt_Init+0xde>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  /* Initialize the CRYP peripheral */
  P_pAESECBctx->CrypHandle.Init.DataType      = CRYP_DATATYPE_8B;
 802623a:	2304      	movs	r3, #4
 802623c:	6323      	str	r3, [r4, #48]	; 0x30
  P_pAESECBctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_WORD;
 802623e:	2300      	movs	r3, #0
 8026240:	6523      	str	r3, [r4, #80]	; 0x50
  if (P_pAESECBctx->mKeySize == (int32_t)CA_CRL_AES128_KEY)
 8026242:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8026244:	9301      	str	r3, [sp, #4]
 8026246:	2b10      	cmp	r3, #16
 8026248:	d006      	beq.n	8026258 <CA_AES_ECB_Encrypt_Init+0x54>
  {
    P_pAESECBctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
  }
  else if (P_pAESECBctx->mKeySize == (int32_t)CA_CRL_AES256_KEY)
 802624a:	9b01      	ldr	r3, [sp, #4]
 802624c:	2b20      	cmp	r3, #32
 802624e:	d14a      	bne.n	80262e6 <CA_AES_ECB_Encrypt_Init+0xe2>
  {
    P_pAESECBctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_256B;
 8026250:	2380      	movs	r3, #128	; 0x80
 8026252:	02db      	lsls	r3, r3, #11
 8026254:	6363      	str	r3, [r4, #52]	; 0x34
 8026256:	e020      	b.n	802629a <CA_AES_ECB_Encrypt_Init+0x96>
    P_pAESECBctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
 8026258:	2300      	movs	r3, #0
 802625a:	6363      	str	r3, [r4, #52]	; 0x34
 802625c:	e01d      	b.n	802629a <CA_AES_ECB_Encrypt_Init+0x96>
  }

  /* Init key here because of endianness */
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESECBctx->mKeySize) / 4U); i++)
  {
    P_pAESECBctx->Key_endian[4U * i]        = P_pKey[3U + (4U * i)];
 802625e:	0087      	lsls	r7, r0, #2
 8026260:	1cfb      	adds	r3, r7, #3
 8026262:	469c      	mov	ip, r3
 8026264:	5ce9      	ldrb	r1, [r5, r3]
 8026266:	19e2      	adds	r2, r4, r7
 8026268:	3249      	adds	r2, #73	; 0x49
 802626a:	32ff      	adds	r2, #255	; 0xff
 802626c:	7011      	strb	r1, [r2, #0]
    P_pAESECBctx->Key_endian[1U + (4U * i)] = P_pKey[2U + (4U * i)];
 802626e:	1cba      	adds	r2, r7, #2
 8026270:	1c79      	adds	r1, r7, #1
 8026272:	5cae      	ldrb	r6, [r5, r2]
 8026274:	46b1      	mov	r9, r6
 8026276:	1866      	adds	r6, r4, r1
 8026278:	3649      	adds	r6, #73	; 0x49
 802627a:	36ff      	adds	r6, #255	; 0xff
 802627c:	464b      	mov	r3, r9
 802627e:	7033      	strb	r3, [r6, #0]
    P_pAESECBctx->Key_endian[2U + (4U * i)] = P_pKey[1U + (4U * i)];
 8026280:	5c69      	ldrb	r1, [r5, r1]
 8026282:	18a2      	adds	r2, r4, r2
 8026284:	3249      	adds	r2, #73	; 0x49
 8026286:	32ff      	adds	r2, #255	; 0xff
 8026288:	7011      	strb	r1, [r2, #0]
    P_pAESECBctx->Key_endian[3U + (4U * i)] = P_pKey[4U * i];
 802628a:	5dea      	ldrb	r2, [r5, r7]
 802628c:	4663      	mov	r3, ip
 802628e:	18e3      	adds	r3, r4, r3
 8026290:	3349      	adds	r3, #73	; 0x49
 8026292:	33ff      	adds	r3, #255	; 0xff
 8026294:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESECBctx->mKeySize) / 4U); i++)
 8026296:	3001      	adds	r0, #1
 8026298:	b2c0      	uxtb	r0, r0
 802629a:	466b      	mov	r3, sp
 802629c:	791b      	ldrb	r3, [r3, #4]
 802629e:	089b      	lsrs	r3, r3, #2
 80262a0:	4283      	cmp	r3, r0
 80262a2:	d8dc      	bhi.n	802625e <CA_AES_ECB_Encrypt_Init+0x5a>
  }

  P_pAESECBctx->CrypHandle.Init.Algorithm       = CRYP_AES_ECB;
 80262a4:	2300      	movs	r3, #0
 80262a6:	6423      	str	r3, [r4, #64]	; 0x40
  P_pAESECBctx->CrypHandle.Init.pKey            = (uint32_t *)(uint32_t)(P_pAESECBctx->Key_endian);
 80262a8:	0022      	movs	r2, r4
 80262aa:	3249      	adds	r2, #73	; 0x49
 80262ac:	32ff      	adds	r2, #255	; 0xff
 80262ae:	63a2      	str	r2, [r4, #56]	; 0x38

  P_pAESECBctx->CrypHandle.Init.Header = NULL;
 80262b0:	6463      	str	r3, [r4, #68]	; 0x44
  P_pAESECBctx->CrypHandle.Init.HeaderSize = 0;
 80262b2:	64a3      	str	r3, [r4, #72]	; 0x48
  P_pAESECBctx->CrypHandle.Init.B0 = NULL;
 80262b4:	64e3      	str	r3, [r4, #76]	; 0x4c
  P_pAESECBctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 80262b6:	3301      	adds	r3, #1
 80262b8:	6523      	str	r3, [r4, #80]	; 0x50
  P_pAESECBctx->CrypHandle.Init.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ONCE;
 80262ba:	65a3      	str	r3, [r4, #88]	; 0x58

  if (HAL_CRYP_Init(&P_pAESECBctx->CrypHandle) != HAL_OK)
 80262bc:	4640      	mov	r0, r8
 80262be:	f7fd f9af 	bl	8023620 <HAL_CRYP_Init>
 80262c2:	2800      	cmp	r0, #0
 80262c4:	d008      	beq.n	80262d8 <CA_AES_ECB_Encrypt_Init+0xd4>
  {
    /* Initialization Error */
    aes_ret_status = CA_AES_ERR_BAD_CONTEXT;
 80262c6:	480a      	ldr	r0, [pc, #40]	; (80262f0 <CA_AES_ECB_Encrypt_Init+0xec>)
 80262c8:	e006      	b.n	80262d8 <CA_AES_ECB_Encrypt_Init+0xd4>
    return CA_AES_ERR_BAD_PARAMETER;
 80262ca:	20c2      	movs	r0, #194	; 0xc2
 80262cc:	0100      	lsls	r0, r0, #4
 80262ce:	e003      	b.n	80262d8 <CA_AES_ECB_Encrypt_Init+0xd4>
 80262d0:	20c2      	movs	r0, #194	; 0xc2
 80262d2:	0100      	lsls	r0, r0, #4
 80262d4:	e000      	b.n	80262d8 <CA_AES_ECB_Encrypt_Init+0xd4>
    return CA_AES_ERR_BAD_CONTEXT;
 80262d6:	4806      	ldr	r0, [pc, #24]	; (80262f0 <CA_AES_ECB_Encrypt_Init+0xec>)
  }
  return aes_ret_status;
}
 80262d8:	b003      	add	sp, #12
 80262da:	bcc0      	pop	{r6, r7}
 80262dc:	46b9      	mov	r9, r7
 80262de:	46b0      	mov	r8, r6
 80262e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CA_AES_ERR_BAD_CONTEXT;
 80262e2:	4803      	ldr	r0, [pc, #12]	; (80262f0 <CA_AES_ECB_Encrypt_Init+0xec>)
 80262e4:	e7f8      	b.n	80262d8 <CA_AES_ECB_Encrypt_Init+0xd4>
    return CA_AES_ERR_BAD_CONTEXT;
 80262e6:	4802      	ldr	r0, [pc, #8]	; (80262f0 <CA_AES_ECB_Encrypt_Init+0xec>)
 80262e8:	e7f6      	b.n	80262d8 <CA_AES_ECB_Encrypt_Init+0xd4>
 80262ea:	46c0      	nop			; (mov r8, r8)
 80262ec:	58001800 	.word	0x58001800
 80262f0:	00000c1f 	.word	0x00000c1f

080262f4 <CA_AES_ECB_Encrypt_Append>:
int32_t CA_AES_ECB_Encrypt_Append(CA_AESECBctx_stt *P_pAESECBctx,
                                  const uint8_t *P_pInputBuffer,
                                  int32_t        P_inputSize,
                                  uint8_t       *P_pOutputBuffer,
                                  int32_t       *P_pOutputSize)
{
 80262f4:	b530      	push	{r4, r5, lr}
 80262f6:	b083      	sub	sp, #12
 80262f8:	0014      	movs	r4, r2

  int32_t aes_ret_status = CA_AES_SUCCESS;

  if ((P_pAESECBctx == NULL)
 80262fa:	2800      	cmp	r0, #0
 80262fc:	d014      	beq.n	8026328 <CA_AES_ECB_Encrypt_Append+0x34>
      || (P_pInputBuffer == NULL)
 80262fe:	2900      	cmp	r1, #0
 8026300:	d015      	beq.n	802632e <CA_AES_ECB_Encrypt_Append+0x3a>
      || (P_pOutputBuffer == NULL)
 8026302:	2b00      	cmp	r3, #0
 8026304:	d016      	beq.n	8026334 <CA_AES_ECB_Encrypt_Append+0x40>
      || (P_pOutputSize == NULL))
 8026306:	9a06      	ldr	r2, [sp, #24]
 8026308:	2a00      	cmp	r2, #0
 802630a:	d016      	beq.n	802633a <CA_AES_ECB_Encrypt_Append+0x46>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }
  if ((P_inputSize % (int32_t)CA_CRL_AES_BLOCK) != 0)
 802630c:	0722      	lsls	r2, r4, #28
 802630e:	d117      	bne.n	8026340 <CA_AES_ECB_Encrypt_Append+0x4c>
  {
    return CA_AES_ERR_BAD_INPUT_SIZE;
  }

  if (HAL_CRYP_Encrypt(&P_pAESECBctx->CrypHandle, (uint32_t *)(uint32_t)P_pInputBuffer, (uint16_t)P_inputSize,
 8026310:	b2a2      	uxth	r2, r4
 8026312:	302c      	adds	r0, #44	; 0x2c
 8026314:	25ff      	movs	r5, #255	; 0xff
 8026316:	9500      	str	r5, [sp, #0]
 8026318:	f7fd fd70 	bl	8023dfc <HAL_CRYP_Encrypt>
 802631c:	2800      	cmp	r0, #0
 802631e:	d111      	bne.n	8026344 <CA_AES_ECB_Encrypt_Append+0x50>
  {
    aes_ret_status = CA_AES_ERR_BAD_OPERATION;
  }
  else
  {
    *P_pOutputSize = P_inputSize;
 8026320:	9b06      	ldr	r3, [sp, #24]
 8026322:	601c      	str	r4, [r3, #0]
  }

  return aes_ret_status;
}
 8026324:	b003      	add	sp, #12
 8026326:	bd30      	pop	{r4, r5, pc}
    return CA_AES_ERR_BAD_PARAMETER;
 8026328:	20c2      	movs	r0, #194	; 0xc2
 802632a:	0100      	lsls	r0, r0, #4
 802632c:	e7fa      	b.n	8026324 <CA_AES_ECB_Encrypt_Append+0x30>
 802632e:	20c2      	movs	r0, #194	; 0xc2
 8026330:	0100      	lsls	r0, r0, #4
 8026332:	e7f7      	b.n	8026324 <CA_AES_ECB_Encrypt_Append+0x30>
 8026334:	20c2      	movs	r0, #194	; 0xc2
 8026336:	0100      	lsls	r0, r0, #4
 8026338:	e7f4      	b.n	8026324 <CA_AES_ECB_Encrypt_Append+0x30>
 802633a:	20c2      	movs	r0, #194	; 0xc2
 802633c:	0100      	lsls	r0, r0, #4
 802633e:	e7f1      	b.n	8026324 <CA_AES_ECB_Encrypt_Append+0x30>
    return CA_AES_ERR_BAD_INPUT_SIZE;
 8026340:	4801      	ldr	r0, [pc, #4]	; (8026348 <CA_AES_ECB_Encrypt_Append+0x54>)
 8026342:	e7ef      	b.n	8026324 <CA_AES_ECB_Encrypt_Append+0x30>
    aes_ret_status = CA_AES_ERR_BAD_OPERATION;
 8026344:	4801      	ldr	r0, [pc, #4]	; (802634c <CA_AES_ECB_Encrypt_Append+0x58>)
 8026346:	e7ed      	b.n	8026324 <CA_AES_ECB_Encrypt_Append+0x30>
 8026348:	00000c1d 	.word	0x00000c1d
 802634c:	00000c1e 	.word	0x00000c1e

08026350 <CA_AES_ECB_Encrypt_Finish>:
  * @retval     CA_AES_SUCCESS: Operation Successful
  */
int32_t CA_AES_ECB_Encrypt_Finish(CA_AESECBctx_stt *P_pAESECBctx,
                                  uint8_t       *P_pOutputBuffer,
                                  int32_t       *P_pOutputSize)
{
 8026350:	b570      	push	{r4, r5, r6, lr}
  int32_t aes_ret_status = CA_AES_SUCCESS;

  (void)P_pOutputBuffer;
  (void)P_pOutputSize;

  if (HAL_CRYP_DeInit(&P_pAESECBctx->CrypHandle) != HAL_OK)
 8026352:	302c      	adds	r0, #44	; 0x2c
 8026354:	0004      	movs	r4, r0
 8026356:	f7fd f989 	bl	802366c <HAL_CRYP_DeInit>
 802635a:	2800      	cmp	r0, #0
 802635c:	d105      	bne.n	802636a <CA_AES_ECB_Encrypt_Finish+0x1a>
  int32_t aes_ret_status = CA_AES_SUCCESS;
 802635e:	2500      	movs	r5, #0
  {
    aes_ret_status = CA_AES_ERR_BAD_PARAMETER;
  }
  cleanup_handle(&(P_pAESECBctx->CrypHandle));
 8026360:	0020      	movs	r0, r4
 8026362:	f7ff fb99 	bl	8025a98 <cleanup_handle>

  return aes_ret_status;
}
 8026366:	0028      	movs	r0, r5
 8026368:	bd70      	pop	{r4, r5, r6, pc}
    aes_ret_status = CA_AES_ERR_BAD_PARAMETER;
 802636a:	25c2      	movs	r5, #194	; 0xc2
 802636c:	012d      	lsls	r5, r5, #4
 802636e:	e7f7      	b.n	8026360 <CA_AES_ECB_Encrypt_Finish+0x10>

08026370 <CA_AES_ECB_Decrypt_Init>:
  *                                  See note
  */
int32_t CA_AES_ECB_Decrypt_Init(CA_AESECBctx_stt *P_pAESECBctx,
                                const uint8_t *P_pKey,
                                const uint8_t *P_pIv)
{
 8026370:	b5f0      	push	{r4, r5, r6, r7, lr}
 8026372:	46ce      	mov	lr, r9
 8026374:	4647      	mov	r7, r8
 8026376:	b580      	push	{r7, lr}
 8026378:	b083      	sub	sp, #12
 802637a:	0004      	movs	r4, r0
 802637c:	000d      	movs	r5, r1
  int32_t aes_ret_status = CA_AES_SUCCESS;

  (void)P_pIv;

  if ((P_pAESECBctx == NULL) || (P_pKey == NULL))
 802637e:	2800      	cmp	r0, #0
 8026380:	d059      	beq.n	8026436 <CA_AES_ECB_Decrypt_Init+0xc6>
 8026382:	2900      	cmp	r1, #0
 8026384:	d05a      	beq.n	802643c <CA_AES_ECB_Decrypt_Init+0xcc>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  if (P_pAESECBctx->mKeySize == 0)
 8026386:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8026388:	2b00      	cmp	r3, #0
 802638a:	d05a      	beq.n	8026442 <CA_AES_ECB_Decrypt_Init+0xd2>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  cleanup_handle(&(P_pAESECBctx->CrypHandle));
 802638c:	232c      	movs	r3, #44	; 0x2c
 802638e:	4698      	mov	r8, r3
 8026390:	4480      	add	r8, r0
 8026392:	4640      	mov	r0, r8
 8026394:	f7ff fb80 	bl	8025a98 <cleanup_handle>
  P_pAESECBctx->CrypHandle.Instance = CA_AES_INSTANCE;
 8026398:	4b2f      	ldr	r3, [pc, #188]	; (8026458 <CA_AES_ECB_Decrypt_Init+0xe8>)
 802639a:	62e3      	str	r3, [r4, #44]	; 0x2c

  if (HAL_CRYP_DeInit(&P_pAESECBctx->CrypHandle) != HAL_OK)
 802639c:	4640      	mov	r0, r8
 802639e:	f7fd f965 	bl	802366c <HAL_CRYP_DeInit>
 80263a2:	2800      	cmp	r0, #0
 80263a4:	d153      	bne.n	802644e <CA_AES_ECB_Decrypt_Init+0xde>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  /* Initialize the CRYP peripheral */
  P_pAESECBctx->CrypHandle.Init.DataType      = CRYP_DATATYPE_8B;
 80263a6:	2304      	movs	r3, #4
 80263a8:	6323      	str	r3, [r4, #48]	; 0x30
  P_pAESECBctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_WORD;
 80263aa:	2300      	movs	r3, #0
 80263ac:	6523      	str	r3, [r4, #80]	; 0x50
  if (P_pAESECBctx->mKeySize == (int32_t)CA_CRL_AES128_KEY)
 80263ae:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80263b0:	9301      	str	r3, [sp, #4]
 80263b2:	2b10      	cmp	r3, #16
 80263b4:	d006      	beq.n	80263c4 <CA_AES_ECB_Decrypt_Init+0x54>
  {
    P_pAESECBctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
  }
  else if (P_pAESECBctx->mKeySize == (int32_t)CA_CRL_AES256_KEY)
 80263b6:	9b01      	ldr	r3, [sp, #4]
 80263b8:	2b20      	cmp	r3, #32
 80263ba:	d14a      	bne.n	8026452 <CA_AES_ECB_Decrypt_Init+0xe2>
  {
    P_pAESECBctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_256B;
 80263bc:	2380      	movs	r3, #128	; 0x80
 80263be:	02db      	lsls	r3, r3, #11
 80263c0:	6363      	str	r3, [r4, #52]	; 0x34
 80263c2:	e020      	b.n	8026406 <CA_AES_ECB_Decrypt_Init+0x96>
    P_pAESECBctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
 80263c4:	2300      	movs	r3, #0
 80263c6:	6363      	str	r3, [r4, #52]	; 0x34
 80263c8:	e01d      	b.n	8026406 <CA_AES_ECB_Decrypt_Init+0x96>
  }

  /* Init key here because of endianness */
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESECBctx->mKeySize) / 4U); i++)
  {
    P_pAESECBctx->Key_endian[4U * i]        = P_pKey[3U + (4U * i)];
 80263ca:	0087      	lsls	r7, r0, #2
 80263cc:	1cfb      	adds	r3, r7, #3
 80263ce:	469c      	mov	ip, r3
 80263d0:	5ce9      	ldrb	r1, [r5, r3]
 80263d2:	19e2      	adds	r2, r4, r7
 80263d4:	3249      	adds	r2, #73	; 0x49
 80263d6:	32ff      	adds	r2, #255	; 0xff
 80263d8:	7011      	strb	r1, [r2, #0]
    P_pAESECBctx->Key_endian[1U + (4U * i)] = P_pKey[2U + (4U * i)];
 80263da:	1cba      	adds	r2, r7, #2
 80263dc:	1c79      	adds	r1, r7, #1
 80263de:	5cae      	ldrb	r6, [r5, r2]
 80263e0:	46b1      	mov	r9, r6
 80263e2:	1866      	adds	r6, r4, r1
 80263e4:	3649      	adds	r6, #73	; 0x49
 80263e6:	36ff      	adds	r6, #255	; 0xff
 80263e8:	464b      	mov	r3, r9
 80263ea:	7033      	strb	r3, [r6, #0]
    P_pAESECBctx->Key_endian[2U + (4U * i)] = P_pKey[1U + (4U * i)];
 80263ec:	5c69      	ldrb	r1, [r5, r1]
 80263ee:	18a2      	adds	r2, r4, r2
 80263f0:	3249      	adds	r2, #73	; 0x49
 80263f2:	32ff      	adds	r2, #255	; 0xff
 80263f4:	7011      	strb	r1, [r2, #0]
    P_pAESECBctx->Key_endian[3U + (4U * i)] = P_pKey[4U * i];
 80263f6:	5dea      	ldrb	r2, [r5, r7]
 80263f8:	4663      	mov	r3, ip
 80263fa:	18e3      	adds	r3, r4, r3
 80263fc:	3349      	adds	r3, #73	; 0x49
 80263fe:	33ff      	adds	r3, #255	; 0xff
 8026400:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESECBctx->mKeySize) / 4U); i++)
 8026402:	3001      	adds	r0, #1
 8026404:	b2c0      	uxtb	r0, r0
 8026406:	466b      	mov	r3, sp
 8026408:	791b      	ldrb	r3, [r3, #4]
 802640a:	089b      	lsrs	r3, r3, #2
 802640c:	4283      	cmp	r3, r0
 802640e:	d8dc      	bhi.n	80263ca <CA_AES_ECB_Decrypt_Init+0x5a>
  }
  P_pAESECBctx->CrypHandle.Init.Algorithm       = CRYP_AES_ECB;
 8026410:	2300      	movs	r3, #0
 8026412:	6423      	str	r3, [r4, #64]	; 0x40
  P_pAESECBctx->CrypHandle.Init.pKey            = (uint32_t *)(uint32_t)(P_pAESECBctx->Key_endian);
 8026414:	0022      	movs	r2, r4
 8026416:	3249      	adds	r2, #73	; 0x49
 8026418:	32ff      	adds	r2, #255	; 0xff
 802641a:	63a2      	str	r2, [r4, #56]	; 0x38

  P_pAESECBctx->CrypHandle.Init.Header = NULL;
 802641c:	6463      	str	r3, [r4, #68]	; 0x44
  P_pAESECBctx->CrypHandle.Init.HeaderSize = 0;
 802641e:	64a3      	str	r3, [r4, #72]	; 0x48
  P_pAESECBctx->CrypHandle.Init.B0 = NULL;
 8026420:	64e3      	str	r3, [r4, #76]	; 0x4c
  P_pAESECBctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 8026422:	3301      	adds	r3, #1
 8026424:	6523      	str	r3, [r4, #80]	; 0x50
  P_pAESECBctx->CrypHandle.Init.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ONCE;
 8026426:	65a3      	str	r3, [r4, #88]	; 0x58

  if (HAL_CRYP_Init(&P_pAESECBctx->CrypHandle) != HAL_OK)
 8026428:	4640      	mov	r0, r8
 802642a:	f7fd f8f9 	bl	8023620 <HAL_CRYP_Init>
 802642e:	2800      	cmp	r0, #0
 8026430:	d008      	beq.n	8026444 <CA_AES_ECB_Decrypt_Init+0xd4>
  {
    /* Initialization Error */
    aes_ret_status = CA_AES_ERR_BAD_CONTEXT;
 8026432:	480a      	ldr	r0, [pc, #40]	; (802645c <CA_AES_ECB_Decrypt_Init+0xec>)
 8026434:	e006      	b.n	8026444 <CA_AES_ECB_Decrypt_Init+0xd4>
    return CA_AES_ERR_BAD_PARAMETER;
 8026436:	20c2      	movs	r0, #194	; 0xc2
 8026438:	0100      	lsls	r0, r0, #4
 802643a:	e003      	b.n	8026444 <CA_AES_ECB_Decrypt_Init+0xd4>
 802643c:	20c2      	movs	r0, #194	; 0xc2
 802643e:	0100      	lsls	r0, r0, #4
 8026440:	e000      	b.n	8026444 <CA_AES_ECB_Decrypt_Init+0xd4>
    return CA_AES_ERR_BAD_CONTEXT;
 8026442:	4806      	ldr	r0, [pc, #24]	; (802645c <CA_AES_ECB_Decrypt_Init+0xec>)
  }
  return aes_ret_status;
}
 8026444:	b003      	add	sp, #12
 8026446:	bcc0      	pop	{r6, r7}
 8026448:	46b9      	mov	r9, r7
 802644a:	46b0      	mov	r8, r6
 802644c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CA_AES_ERR_BAD_CONTEXT;
 802644e:	4803      	ldr	r0, [pc, #12]	; (802645c <CA_AES_ECB_Decrypt_Init+0xec>)
 8026450:	e7f8      	b.n	8026444 <CA_AES_ECB_Decrypt_Init+0xd4>
    return CA_AES_ERR_BAD_CONTEXT;
 8026452:	4802      	ldr	r0, [pc, #8]	; (802645c <CA_AES_ECB_Decrypt_Init+0xec>)
 8026454:	e7f6      	b.n	8026444 <CA_AES_ECB_Decrypt_Init+0xd4>
 8026456:	46c0      	nop			; (mov r8, r8)
 8026458:	58001800 	.word	0x58001800
 802645c:	00000c1f 	.word	0x00000c1f

08026460 <CA_AES_GCM_Encrypt_Init>:
  *                                  see note
  */
int32_t CA_AES_GCM_Encrypt_Init(CA_AESGCMctx_stt *P_pAESGCMctx,
                                const uint8_t *P_pKey,
                                const uint8_t *P_pIv)
{
 8026460:	b5f0      	push	{r4, r5, r6, r7, lr}
 8026462:	46de      	mov	lr, fp
 8026464:	4657      	mov	r7, sl
 8026466:	464e      	mov	r6, r9
 8026468:	4645      	mov	r5, r8
 802646a:	b5e0      	push	{r5, r6, r7, lr}
 802646c:	b083      	sub	sp, #12
 802646e:	0004      	movs	r4, r0
 8026470:	000d      	movs	r5, r1
 8026472:	0017      	movs	r7, r2
  int32_t aes_ret_status = CA_AES_SUCCESS;

  if ((P_pAESGCMctx == NULL) || (P_pKey == NULL) || (P_pIv == NULL))
 8026474:	2800      	cmp	r0, #0
 8026476:	d100      	bne.n	802647a <CA_AES_GCM_Encrypt_Init+0x1a>
 8026478:	e0a0      	b.n	80265bc <CA_AES_GCM_Encrypt_Init+0x15c>
 802647a:	2900      	cmp	r1, #0
 802647c:	d100      	bne.n	8026480 <CA_AES_GCM_Encrypt_Init+0x20>
 802647e:	e0a0      	b.n	80265c2 <CA_AES_GCM_Encrypt_Init+0x162>
 8026480:	2a00      	cmp	r2, #0
 8026482:	d100      	bne.n	8026486 <CA_AES_GCM_Encrypt_Init+0x26>
 8026484:	e0a0      	b.n	80265c8 <CA_AES_GCM_Encrypt_Init+0x168>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  if ((P_pAESGCMctx->mKeySize == 0) || (P_pAESGCMctx->mIvSize != 12))
 8026486:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8026488:	2b00      	cmp	r3, #0
 802648a:	d100      	bne.n	802648e <CA_AES_GCM_Encrypt_Init+0x2e>
 802648c:	e09f      	b.n	80265ce <CA_AES_GCM_Encrypt_Init+0x16e>
 802648e:	6903      	ldr	r3, [r0, #16]
 8026490:	2b0c      	cmp	r3, #12
 8026492:	d007      	beq.n	80264a4 <CA_AES_GCM_Encrypt_Init+0x44>
  {
    return CA_AES_ERR_BAD_CONTEXT;
 8026494:	4851      	ldr	r0, [pc, #324]	; (80265dc <CA_AES_GCM_Encrypt_Init+0x17c>)
  P_pAESGCMctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
  P_pAESGCMctx->CrypHandle.Init.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ONCE;

  P_pAESGCMctx->flags = GCM_ENCRYPTION_ONGOING | GCM_INIT_NOT_DONE;
  return aes_ret_status;
}
 8026496:	b003      	add	sp, #12
 8026498:	bcf0      	pop	{r4, r5, r6, r7}
 802649a:	46bb      	mov	fp, r7
 802649c:	46b2      	mov	sl, r6
 802649e:	46a9      	mov	r9, r5
 80264a0:	46a0      	mov	r8, r4
 80264a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cleanup_handle(&(P_pAESGCMctx->CrypHandle));
 80264a4:	0006      	movs	r6, r0
 80264a6:	3634      	adds	r6, #52	; 0x34
 80264a8:	0030      	movs	r0, r6
 80264aa:	f7ff faf5 	bl	8025a98 <cleanup_handle>
  P_pAESGCMctx->CrypHandle.Instance = CA_AES_INSTANCE;
 80264ae:	4b4c      	ldr	r3, [pc, #304]	; (80265e0 <CA_AES_GCM_Encrypt_Init+0x180>)
 80264b0:	6363      	str	r3, [r4, #52]	; 0x34
  if (HAL_CRYP_DeInit(&P_pAESGCMctx->CrypHandle) != HAL_OK)
 80264b2:	0030      	movs	r0, r6
 80264b4:	f7fd f8da 	bl	802366c <HAL_CRYP_DeInit>
 80264b8:	4683      	mov	fp, r0
 80264ba:	1e03      	subs	r3, r0, #0
 80264bc:	d000      	beq.n	80264c0 <CA_AES_GCM_Encrypt_Init+0x60>
 80264be:	e088      	b.n	80265d2 <CA_AES_GCM_Encrypt_Init+0x172>
  P_pAESGCMctx->CrypHandle.Init.DataType      = CRYP_DATATYPE_8B;
 80264c0:	3304      	adds	r3, #4
 80264c2:	63a3      	str	r3, [r4, #56]	; 0x38
  if (P_pAESGCMctx->mKeySize == (int32_t)CA_CRL_AES128_KEY)
 80264c4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80264c6:	9300      	str	r3, [sp, #0]
 80264c8:	2b10      	cmp	r3, #16
 80264ca:	d007      	beq.n	80264dc <CA_AES_GCM_Encrypt_Init+0x7c>
  else if (P_pAESGCMctx->mKeySize == (int32_t)CA_CRL_AES256_KEY)
 80264cc:	9b00      	ldr	r3, [sp, #0]
 80264ce:	2b20      	cmp	r3, #32
 80264d0:	d000      	beq.n	80264d4 <CA_AES_GCM_Encrypt_Init+0x74>
 80264d2:	e080      	b.n	80265d6 <CA_AES_GCM_Encrypt_Init+0x176>
    P_pAESGCMctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_256B;
 80264d4:	2380      	movs	r3, #128	; 0x80
 80264d6:	02db      	lsls	r3, r3, #11
 80264d8:	63e3      	str	r3, [r4, #60]	; 0x3c
 80264da:	e026      	b.n	802652a <CA_AES_GCM_Encrypt_Init+0xca>
    P_pAESGCMctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
 80264dc:	2300      	movs	r3, #0
 80264de:	63e3      	str	r3, [r4, #60]	; 0x3c
 80264e0:	e023      	b.n	802652a <CA_AES_GCM_Encrypt_Init+0xca>
    P_pAESGCMctx->Iv_endian[4U * i]        = P_pIv[3U + (4U * i)];
 80264e2:	0081      	lsls	r1, r0, #2
 80264e4:	1ccb      	adds	r3, r1, #3
 80264e6:	9301      	str	r3, [sp, #4]
 80264e8:	5cfa      	ldrb	r2, [r7, r3]
 80264ea:	4690      	mov	r8, r2
 80264ec:	1862      	adds	r2, r4, r1
 80264ee:	3241      	adds	r2, #65	; 0x41
 80264f0:	32ff      	adds	r2, #255	; 0xff
 80264f2:	4646      	mov	r6, r8
 80264f4:	7016      	strb	r6, [r2, #0]
    P_pAESGCMctx->Iv_endian[1U + (4U * i)] = P_pIv[2U + (4U * i)];
 80264f6:	1c8a      	adds	r2, r1, #2
 80264f8:	1c4e      	adds	r6, r1, #1
 80264fa:	46b1      	mov	r9, r6
 80264fc:	5cbe      	ldrb	r6, [r7, r2]
 80264fe:	46b2      	mov	sl, r6
 8026500:	46a0      	mov	r8, r4
 8026502:	44c8      	add	r8, r9
 8026504:	26a0      	movs	r6, #160	; 0xa0
 8026506:	0076      	lsls	r6, r6, #1
 8026508:	46b4      	mov	ip, r6
 802650a:	44e0      	add	r8, ip
 802650c:	4646      	mov	r6, r8
 802650e:	4653      	mov	r3, sl
 8026510:	7033      	strb	r3, [r6, #0]
    P_pAESGCMctx->Iv_endian[2U + (4U * i)] = P_pIv[1U + (4U * i)];
 8026512:	464b      	mov	r3, r9
 8026514:	5cfb      	ldrb	r3, [r7, r3]
 8026516:	18a2      	adds	r2, r4, r2
 8026518:	4462      	add	r2, ip
 802651a:	7013      	strb	r3, [r2, #0]
    P_pAESGCMctx->Iv_endian[3U + (4U * i)] = P_pIv[4U * i];
 802651c:	5c7a      	ldrb	r2, [r7, r1]
 802651e:	9b01      	ldr	r3, [sp, #4]
 8026520:	18e3      	adds	r3, r4, r3
 8026522:	4463      	add	r3, ip
 8026524:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < 3U; i++)
 8026526:	3001      	adds	r0, #1
 8026528:	b2c0      	uxtb	r0, r0
 802652a:	2802      	cmp	r0, #2
 802652c:	d9d9      	bls.n	80264e2 <CA_AES_GCM_Encrypt_Init+0x82>
  P_pAESGCMctx->Iv_endian[12] = 2;
 802652e:	23a6      	movs	r3, #166	; 0xa6
 8026530:	005b      	lsls	r3, r3, #1
 8026532:	2202      	movs	r2, #2
 8026534:	54e2      	strb	r2, [r4, r3]
  P_pAESGCMctx->Iv_endian[13] = 0;
 8026536:	2300      	movs	r3, #0
 8026538:	224e      	movs	r2, #78	; 0x4e
 802653a:	32ff      	adds	r2, #255	; 0xff
 802653c:	54a3      	strb	r3, [r4, r2]
  P_pAESGCMctx->Iv_endian[14] = 0;
 802653e:	3201      	adds	r2, #1
 8026540:	54a3      	strb	r3, [r4, r2]
  P_pAESGCMctx->Iv_endian[15] = 0;
 8026542:	2250      	movs	r2, #80	; 0x50
 8026544:	32ff      	adds	r2, #255	; 0xff
 8026546:	54a3      	strb	r3, [r4, r2]
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESGCMctx->mKeySize) / 4U); i++)
 8026548:	e01e      	b.n	8026588 <CA_AES_GCM_Encrypt_Init+0x128>
    P_pAESGCMctx->Key_endian[4U * i]        = P_pKey[3U + (4U * i)];
 802654a:	465b      	mov	r3, fp
 802654c:	0098      	lsls	r0, r3, #2
 802654e:	1cc3      	adds	r3, r0, #3
 8026550:	5cef      	ldrb	r7, [r5, r3]
 8026552:	1822      	adds	r2, r4, r0
 8026554:	3251      	adds	r2, #81	; 0x51
 8026556:	32ff      	adds	r2, #255	; 0xff
 8026558:	7017      	strb	r7, [r2, #0]
    P_pAESGCMctx->Key_endian[1U + (4U * i)] = P_pKey[2U + (4U * i)];
 802655a:	1c82      	adds	r2, r0, #2
 802655c:	1c41      	adds	r1, r0, #1
 802655e:	5caf      	ldrb	r7, [r5, r2]
 8026560:	46b8      	mov	r8, r7
 8026562:	1867      	adds	r7, r4, r1
 8026564:	3751      	adds	r7, #81	; 0x51
 8026566:	37ff      	adds	r7, #255	; 0xff
 8026568:	4646      	mov	r6, r8
 802656a:	703e      	strb	r6, [r7, #0]
    P_pAESGCMctx->Key_endian[2U + (4U * i)] = P_pKey[1U + (4U * i)];
 802656c:	5c6f      	ldrb	r7, [r5, r1]
 802656e:	18a2      	adds	r2, r4, r2
 8026570:	3251      	adds	r2, #81	; 0x51
 8026572:	32ff      	adds	r2, #255	; 0xff
 8026574:	7017      	strb	r7, [r2, #0]
    P_pAESGCMctx->Key_endian[3U + (4U * i)] = P_pKey[4U * i];
 8026576:	5c2a      	ldrb	r2, [r5, r0]
 8026578:	18e3      	adds	r3, r4, r3
 802657a:	3351      	adds	r3, #81	; 0x51
 802657c:	33ff      	adds	r3, #255	; 0xff
 802657e:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESGCMctx->mKeySize) / 4U); i++)
 8026580:	465e      	mov	r6, fp
 8026582:	3601      	adds	r6, #1
 8026584:	b2f3      	uxtb	r3, r6
 8026586:	469b      	mov	fp, r3
 8026588:	466b      	mov	r3, sp
 802658a:	781b      	ldrb	r3, [r3, #0]
 802658c:	089b      	lsrs	r3, r3, #2
 802658e:	455b      	cmp	r3, fp
 8026590:	d8db      	bhi.n	802654a <CA_AES_GCM_Encrypt_Init+0xea>
  P_pAESGCMctx->CrypHandle.Init.Algorithm       = CRYP_AES_GCM_GMAC;
 8026592:	2360      	movs	r3, #96	; 0x60
 8026594:	64a3      	str	r3, [r4, #72]	; 0x48
  P_pAESGCMctx->CrypHandle.Init.pKey            = (uint32_t *)(uint32_t)(P_pAESGCMctx->Key_endian);
 8026596:	0023      	movs	r3, r4
 8026598:	3351      	adds	r3, #81	; 0x51
 802659a:	33ff      	adds	r3, #255	; 0xff
 802659c:	6423      	str	r3, [r4, #64]	; 0x40
  P_pAESGCMctx->CrypHandle.Init.pInitVect       = (uint32_t *)(uint32_t)(P_pAESGCMctx->Iv_endian);
 802659e:	3b10      	subs	r3, #16
 80265a0:	6463      	str	r3, [r4, #68]	; 0x44
  P_pAESGCMctx->CrypHandle.Init.Header = NULL;
 80265a2:	2300      	movs	r3, #0
 80265a4:	64e3      	str	r3, [r4, #76]	; 0x4c
  P_pAESGCMctx->CrypHandle.Init.HeaderSize = 0;
 80265a6:	6523      	str	r3, [r4, #80]	; 0x50
  P_pAESGCMctx->CrypHandle.Init.B0 = NULL;
 80265a8:	6563      	str	r3, [r4, #84]	; 0x54
  P_pAESGCMctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 80265aa:	3301      	adds	r3, #1
 80265ac:	65a3      	str	r3, [r4, #88]	; 0x58
  P_pAESGCMctx->CrypHandle.Init.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ONCE;
 80265ae:	6623      	str	r3, [r4, #96]	; 0x60
  P_pAESGCMctx->flags = GCM_ENCRYPTION_ONGOING | GCM_INIT_NOT_DONE;
 80265b0:	3370      	adds	r3, #112	; 0x70
 80265b2:	33ff      	adds	r3, #255	; 0xff
 80265b4:	2209      	movs	r2, #9
 80265b6:	50e2      	str	r2, [r4, r3]
  return aes_ret_status;
 80265b8:	2000      	movs	r0, #0
 80265ba:	e76c      	b.n	8026496 <CA_AES_GCM_Encrypt_Init+0x36>
    return CA_AES_ERR_BAD_PARAMETER;
 80265bc:	20c2      	movs	r0, #194	; 0xc2
 80265be:	0100      	lsls	r0, r0, #4
 80265c0:	e769      	b.n	8026496 <CA_AES_GCM_Encrypt_Init+0x36>
 80265c2:	20c2      	movs	r0, #194	; 0xc2
 80265c4:	0100      	lsls	r0, r0, #4
 80265c6:	e766      	b.n	8026496 <CA_AES_GCM_Encrypt_Init+0x36>
 80265c8:	20c2      	movs	r0, #194	; 0xc2
 80265ca:	0100      	lsls	r0, r0, #4
 80265cc:	e763      	b.n	8026496 <CA_AES_GCM_Encrypt_Init+0x36>
    return CA_AES_ERR_BAD_CONTEXT;
 80265ce:	4803      	ldr	r0, [pc, #12]	; (80265dc <CA_AES_GCM_Encrypt_Init+0x17c>)
 80265d0:	e761      	b.n	8026496 <CA_AES_GCM_Encrypt_Init+0x36>
    return CA_AES_ERR_BAD_CONTEXT;
 80265d2:	4802      	ldr	r0, [pc, #8]	; (80265dc <CA_AES_GCM_Encrypt_Init+0x17c>)
 80265d4:	e75f      	b.n	8026496 <CA_AES_GCM_Encrypt_Init+0x36>
    return CA_AES_ERR_BAD_CONTEXT;
 80265d6:	4801      	ldr	r0, [pc, #4]	; (80265dc <CA_AES_GCM_Encrypt_Init+0x17c>)
 80265d8:	e75d      	b.n	8026496 <CA_AES_GCM_Encrypt_Init+0x36>
 80265da:	46c0      	nop			; (mov r8, r8)
 80265dc:	00000c1f 	.word	0x00000c1f
 80265e0:	58001800 	.word	0x58001800

080265e4 <CA_AES_GCM_Encrypt_Append>:
int32_t CA_AES_GCM_Encrypt_Append(CA_AESGCMctx_stt *P_pAESGCMctx,
                                  const uint8_t *P_pInputBuffer,
                                  int32_t        P_inputSize,
                                  uint8_t       *P_pOutputBuffer,
                                  int32_t       *P_pOutputSize)
{
 80265e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80265e6:	b083      	sub	sp, #12
 80265e8:	0004      	movs	r4, r0
 80265ea:	000d      	movs	r5, r1
 80265ec:	0016      	movs	r6, r2
 80265ee:	001f      	movs	r7, r3
  int32_t aes_ret_status = CA_AES_SUCCESS;

  if ((P_pAESGCMctx == NULL)
 80265f0:	2800      	cmp	r0, #0
 80265f2:	d02b      	beq.n	802664c <CA_AES_GCM_Encrypt_Append+0x68>
      || (P_pInputBuffer == NULL)
 80265f4:	2900      	cmp	r1, #0
 80265f6:	d02c      	beq.n	8026652 <CA_AES_GCM_Encrypt_Append+0x6e>
      || (P_pOutputBuffer == NULL)
 80265f8:	2b00      	cmp	r3, #0
 80265fa:	d02d      	beq.n	8026658 <CA_AES_GCM_Encrypt_Append+0x74>
      || (P_pOutputSize == NULL))
 80265fc:	9b08      	ldr	r3, [sp, #32]
 80265fe:	2b00      	cmp	r3, #0
 8026600:	d02d      	beq.n	802665e <CA_AES_GCM_Encrypt_Append+0x7a>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  if ((P_pAESGCMctx->flags & GCM_INIT_NOT_DONE) == GCM_INIT_NOT_DONE)
 8026602:	23b8      	movs	r3, #184	; 0xb8
 8026604:	005b      	lsls	r3, r3, #1
 8026606:	58c3      	ldr	r3, [r0, r3]
 8026608:	071b      	lsls	r3, r3, #28
 802660a:	d50a      	bpl.n	8026622 <CA_AES_GCM_Encrypt_Append+0x3e>
  {
    if (HAL_CRYP_Init(&P_pAESGCMctx->CrypHandle) != HAL_OK)
 802660c:	3034      	adds	r0, #52	; 0x34
 802660e:	f7fd f807 	bl	8023620 <HAL_CRYP_Init>
 8026612:	2800      	cmp	r0, #0
 8026614:	d115      	bne.n	8026642 <CA_AES_GCM_Encrypt_Append+0x5e>
    {
      *P_pOutputSize = 0;
      return CA_AES_ERR_BAD_OPERATION;
    }
    P_pAESGCMctx->flags &= ~ GCM_INIT_NOT_DONE;
 8026616:	22b8      	movs	r2, #184	; 0xb8
 8026618:	0052      	lsls	r2, r2, #1
 802661a:	2308      	movs	r3, #8
 802661c:	58a1      	ldr	r1, [r4, r2]
 802661e:	4399      	bics	r1, r3
 8026620:	50a1      	str	r1, [r4, r2]
  }
  if (HAL_CRYP_Encrypt(&P_pAESGCMctx->CrypHandle, (uint32_t *)(uint32_t)P_pInputBuffer, (uint16_t)P_inputSize,
 8026622:	b2b2      	uxth	r2, r6
 8026624:	0020      	movs	r0, r4
 8026626:	3034      	adds	r0, #52	; 0x34
 8026628:	23ff      	movs	r3, #255	; 0xff
 802662a:	9300      	str	r3, [sp, #0]
 802662c:	003b      	movs	r3, r7
 802662e:	0029      	movs	r1, r5
 8026630:	f7fd fbe4 	bl	8023dfc <HAL_CRYP_Encrypt>
 8026634:	2800      	cmp	r0, #0
 8026636:	d000      	beq.n	802663a <CA_AES_GCM_Encrypt_Append+0x56>
                       (uint32_t *)(uint32_t)P_pOutputBuffer,
                       TIMEOUT_VALUE) != HAL_OK)
  {
    aes_ret_status = CA_AES_ERR_BAD_OPERATION;
 8026638:	480a      	ldr	r0, [pc, #40]	; (8026664 <CA_AES_GCM_Encrypt_Append+0x80>)
  }

  *P_pOutputSize = P_inputSize;
 802663a:	9b08      	ldr	r3, [sp, #32]
 802663c:	601e      	str	r6, [r3, #0]
  return aes_ret_status;
}
 802663e:	b003      	add	sp, #12
 8026640:	bdf0      	pop	{r4, r5, r6, r7, pc}
      *P_pOutputSize = 0;
 8026642:	2300      	movs	r3, #0
 8026644:	9a08      	ldr	r2, [sp, #32]
 8026646:	6013      	str	r3, [r2, #0]
      return CA_AES_ERR_BAD_OPERATION;
 8026648:	4806      	ldr	r0, [pc, #24]	; (8026664 <CA_AES_GCM_Encrypt_Append+0x80>)
 802664a:	e7f8      	b.n	802663e <CA_AES_GCM_Encrypt_Append+0x5a>
    return CA_AES_ERR_BAD_PARAMETER;
 802664c:	20c2      	movs	r0, #194	; 0xc2
 802664e:	0100      	lsls	r0, r0, #4
 8026650:	e7f5      	b.n	802663e <CA_AES_GCM_Encrypt_Append+0x5a>
 8026652:	20c2      	movs	r0, #194	; 0xc2
 8026654:	0100      	lsls	r0, r0, #4
 8026656:	e7f2      	b.n	802663e <CA_AES_GCM_Encrypt_Append+0x5a>
 8026658:	20c2      	movs	r0, #194	; 0xc2
 802665a:	0100      	lsls	r0, r0, #4
 802665c:	e7ef      	b.n	802663e <CA_AES_GCM_Encrypt_Append+0x5a>
 802665e:	20c2      	movs	r0, #194	; 0xc2
 8026660:	0100      	lsls	r0, r0, #4
 8026662:	e7ec      	b.n	802663e <CA_AES_GCM_Encrypt_Append+0x5a>
 8026664:	00000c1e 	.word	0x00000c1e

08026668 <CA_AES_GCM_Encrypt_Finish>:
  *                                  See note
  */
int32_t CA_AES_GCM_Encrypt_Finish(CA_AESGCMctx_stt *P_pAESGCMctx,
                                  uint8_t       *P_pOutputBuffer,
                                  int32_t       *P_pOutputSize)
{
 8026668:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802666a:	0004      	movs	r4, r0
 802666c:	0015      	movs	r5, r2
  int32_t aes_ret_status = CA_AES_SUCCESS;


  if ((P_pAESGCMctx == NULL) || (P_pOutputBuffer == NULL) || (P_pOutputSize == NULL))
 802666e:	2800      	cmp	r0, #0
 8026670:	d01e      	beq.n	80266b0 <CA_AES_GCM_Encrypt_Finish+0x48>
 8026672:	2900      	cmp	r1, #0
 8026674:	d01f      	beq.n	80266b6 <CA_AES_GCM_Encrypt_Finish+0x4e>
 8026676:	2a00      	cmp	r2, #0
 8026678:	d020      	beq.n	80266bc <CA_AES_GCM_Encrypt_Finish+0x54>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  if ((P_pAESGCMctx->mTagSize < 0) || (P_pAESGCMctx->mTagSize > 16))
 802667a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 802667c:	2b10      	cmp	r3, #16
 802667e:	d820      	bhi.n	80266c2 <CA_AES_GCM_Encrypt_Finish+0x5a>
  {
    return CA_AES_ERR_BAD_CONTEXT;
  }

  if (HAL_CRYPEx_AESGCM_GenerateAuthTAG(&P_pAESGCMctx->CrypHandle,
 8026680:	0007      	movs	r7, r0
 8026682:	3734      	adds	r7, #52	; 0x34
 8026684:	22ff      	movs	r2, #255	; 0xff
 8026686:	0038      	movs	r0, r7
 8026688:	f7fd fc72 	bl	8023f70 <HAL_CRYPEx_AESGCM_GenerateAuthTAG>
 802668c:	2800      	cmp	r0, #0
 802668e:	d10d      	bne.n	80266ac <CA_AES_GCM_Encrypt_Finish+0x44>
  int32_t aes_ret_status = CA_AES_SUCCESS;
 8026690:	2600      	movs	r6, #0
                                        (uint32_t *)(uint32_t)P_pOutputBuffer, TIMEOUT_VALUE) != HAL_OK)
  {
    aes_ret_status = CA_AES_ERR_BAD_CONTEXT;
  }

  if (HAL_CRYP_DeInit(&P_pAESGCMctx->CrypHandle) != HAL_OK)
 8026692:	0038      	movs	r0, r7
 8026694:	f7fc ffea 	bl	802366c <HAL_CRYP_DeInit>
 8026698:	2800      	cmp	r0, #0
 802669a:	d000      	beq.n	802669e <CA_AES_GCM_Encrypt_Finish+0x36>
  {
    aes_ret_status = CA_AES_ERR_BAD_CONTEXT;
 802669c:	4e0a      	ldr	r6, [pc, #40]	; (80266c8 <CA_AES_GCM_Encrypt_Finish+0x60>)
  }
  cleanup_handle(&(P_pAESGCMctx->CrypHandle));
 802669e:	0038      	movs	r0, r7
 80266a0:	f7ff f9fa 	bl	8025a98 <cleanup_handle>

  *P_pOutputSize = P_pAESGCMctx->mTagSize;
 80266a4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80266a6:	602b      	str	r3, [r5, #0]

  return aes_ret_status;
}
 80266a8:	0030      	movs	r0, r6
 80266aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    aes_ret_status = CA_AES_ERR_BAD_CONTEXT;
 80266ac:	4e06      	ldr	r6, [pc, #24]	; (80266c8 <CA_AES_GCM_Encrypt_Finish+0x60>)
 80266ae:	e7f0      	b.n	8026692 <CA_AES_GCM_Encrypt_Finish+0x2a>
    return CA_AES_ERR_BAD_PARAMETER;
 80266b0:	26c2      	movs	r6, #194	; 0xc2
 80266b2:	0136      	lsls	r6, r6, #4
 80266b4:	e7f8      	b.n	80266a8 <CA_AES_GCM_Encrypt_Finish+0x40>
 80266b6:	26c2      	movs	r6, #194	; 0xc2
 80266b8:	0136      	lsls	r6, r6, #4
 80266ba:	e7f5      	b.n	80266a8 <CA_AES_GCM_Encrypt_Finish+0x40>
 80266bc:	26c2      	movs	r6, #194	; 0xc2
 80266be:	0136      	lsls	r6, r6, #4
 80266c0:	e7f2      	b.n	80266a8 <CA_AES_GCM_Encrypt_Finish+0x40>
    return CA_AES_ERR_BAD_CONTEXT;
 80266c2:	4e01      	ldr	r6, [pc, #4]	; (80266c8 <CA_AES_GCM_Encrypt_Finish+0x60>)
 80266c4:	e7f0      	b.n	80266a8 <CA_AES_GCM_Encrypt_Finish+0x40>
 80266c6:	46c0      	nop			; (mov r8, r8)
 80266c8:	00000c1f 	.word	0x00000c1f

080266cc <CA_AES_GCM_Decrypt_Init>:
  *                                  see note
  */
int32_t CA_AES_GCM_Decrypt_Init(CA_AESGCMctx_stt *P_pAESGCMctx,
                                const uint8_t *P_pKey,
                                const uint8_t *P_pIv)
{
 80266cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80266ce:	46de      	mov	lr, fp
 80266d0:	4657      	mov	r7, sl
 80266d2:	464e      	mov	r6, r9
 80266d4:	4645      	mov	r5, r8
 80266d6:	b5e0      	push	{r5, r6, r7, lr}
 80266d8:	b083      	sub	sp, #12
 80266da:	0004      	movs	r4, r0
 80266dc:	000d      	movs	r5, r1
 80266de:	0017      	movs	r7, r2
  int32_t aes_ret_status = CA_AES_SUCCESS;

  if ((P_pAESGCMctx == NULL) || (P_pKey == NULL) || (P_pIv == NULL))
 80266e0:	2800      	cmp	r0, #0
 80266e2:	d100      	bne.n	80266e6 <CA_AES_GCM_Decrypt_Init+0x1a>
 80266e4:	e0a0      	b.n	8026828 <CA_AES_GCM_Decrypt_Init+0x15c>
 80266e6:	2900      	cmp	r1, #0
 80266e8:	d100      	bne.n	80266ec <CA_AES_GCM_Decrypt_Init+0x20>
 80266ea:	e0a0      	b.n	802682e <CA_AES_GCM_Decrypt_Init+0x162>
 80266ec:	2a00      	cmp	r2, #0
 80266ee:	d100      	bne.n	80266f2 <CA_AES_GCM_Decrypt_Init+0x26>
 80266f0:	e0a0      	b.n	8026834 <CA_AES_GCM_Decrypt_Init+0x168>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  if ((P_pAESGCMctx->mKeySize == 0) || (P_pAESGCMctx->mIvSize != 12))
 80266f2:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80266f4:	2b00      	cmp	r3, #0
 80266f6:	d100      	bne.n	80266fa <CA_AES_GCM_Decrypt_Init+0x2e>
 80266f8:	e09f      	b.n	802683a <CA_AES_GCM_Decrypt_Init+0x16e>
 80266fa:	6903      	ldr	r3, [r0, #16]
 80266fc:	2b0c      	cmp	r3, #12
 80266fe:	d007      	beq.n	8026710 <CA_AES_GCM_Decrypt_Init+0x44>
  {
    return CA_AES_ERR_BAD_CONTEXT;
 8026700:	4851      	ldr	r0, [pc, #324]	; (8026848 <CA_AES_GCM_Decrypt_Init+0x17c>)
  P_pAESGCMctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
  P_pAESGCMctx->CrypHandle.Init.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ONCE;

  P_pAESGCMctx->flags = GCM_DECRYPTION_ONGOING | GCM_INIT_NOT_DONE;
  return aes_ret_status;
}
 8026702:	b003      	add	sp, #12
 8026704:	bcf0      	pop	{r4, r5, r6, r7}
 8026706:	46bb      	mov	fp, r7
 8026708:	46b2      	mov	sl, r6
 802670a:	46a9      	mov	r9, r5
 802670c:	46a0      	mov	r8, r4
 802670e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  cleanup_handle(&(P_pAESGCMctx->CrypHandle));
 8026710:	0006      	movs	r6, r0
 8026712:	3634      	adds	r6, #52	; 0x34
 8026714:	0030      	movs	r0, r6
 8026716:	f7ff f9bf 	bl	8025a98 <cleanup_handle>
  P_pAESGCMctx->CrypHandle.Instance = CA_AES_INSTANCE;
 802671a:	4b4c      	ldr	r3, [pc, #304]	; (802684c <CA_AES_GCM_Decrypt_Init+0x180>)
 802671c:	6363      	str	r3, [r4, #52]	; 0x34
  if (HAL_CRYP_DeInit(&P_pAESGCMctx->CrypHandle) != HAL_OK)
 802671e:	0030      	movs	r0, r6
 8026720:	f7fc ffa4 	bl	802366c <HAL_CRYP_DeInit>
 8026724:	4683      	mov	fp, r0
 8026726:	1e03      	subs	r3, r0, #0
 8026728:	d000      	beq.n	802672c <CA_AES_GCM_Decrypt_Init+0x60>
 802672a:	e088      	b.n	802683e <CA_AES_GCM_Decrypt_Init+0x172>
  P_pAESGCMctx->CrypHandle.Init.DataType      = CRYP_DATATYPE_8B;
 802672c:	3304      	adds	r3, #4
 802672e:	63a3      	str	r3, [r4, #56]	; 0x38
  if (P_pAESGCMctx->mKeySize == (int32_t)CA_CRL_AES128_KEY)
 8026730:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8026732:	9300      	str	r3, [sp, #0]
 8026734:	2b10      	cmp	r3, #16
 8026736:	d007      	beq.n	8026748 <CA_AES_GCM_Decrypt_Init+0x7c>
  else if (P_pAESGCMctx->mKeySize == (int32_t)CA_CRL_AES256_KEY)
 8026738:	9b00      	ldr	r3, [sp, #0]
 802673a:	2b20      	cmp	r3, #32
 802673c:	d000      	beq.n	8026740 <CA_AES_GCM_Decrypt_Init+0x74>
 802673e:	e080      	b.n	8026842 <CA_AES_GCM_Decrypt_Init+0x176>
    P_pAESGCMctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_256B;
 8026740:	2380      	movs	r3, #128	; 0x80
 8026742:	02db      	lsls	r3, r3, #11
 8026744:	63e3      	str	r3, [r4, #60]	; 0x3c
 8026746:	e026      	b.n	8026796 <CA_AES_GCM_Decrypt_Init+0xca>
    P_pAESGCMctx->CrypHandle.Init.KeySize     = CRYP_KEYSIZE_128B;
 8026748:	2300      	movs	r3, #0
 802674a:	63e3      	str	r3, [r4, #60]	; 0x3c
 802674c:	e023      	b.n	8026796 <CA_AES_GCM_Decrypt_Init+0xca>
    P_pAESGCMctx->Iv_endian[4U * i]        = P_pIv[3U + (4U * i)];
 802674e:	0081      	lsls	r1, r0, #2
 8026750:	1ccb      	adds	r3, r1, #3
 8026752:	9301      	str	r3, [sp, #4]
 8026754:	5cfa      	ldrb	r2, [r7, r3]
 8026756:	4690      	mov	r8, r2
 8026758:	1862      	adds	r2, r4, r1
 802675a:	3241      	adds	r2, #65	; 0x41
 802675c:	32ff      	adds	r2, #255	; 0xff
 802675e:	4646      	mov	r6, r8
 8026760:	7016      	strb	r6, [r2, #0]
    P_pAESGCMctx->Iv_endian[1U + (4U * i)] = P_pIv[2U + (4U * i)];
 8026762:	1c8a      	adds	r2, r1, #2
 8026764:	1c4e      	adds	r6, r1, #1
 8026766:	46b1      	mov	r9, r6
 8026768:	5cbe      	ldrb	r6, [r7, r2]
 802676a:	46b2      	mov	sl, r6
 802676c:	46a0      	mov	r8, r4
 802676e:	44c8      	add	r8, r9
 8026770:	26a0      	movs	r6, #160	; 0xa0
 8026772:	0076      	lsls	r6, r6, #1
 8026774:	46b4      	mov	ip, r6
 8026776:	44e0      	add	r8, ip
 8026778:	4646      	mov	r6, r8
 802677a:	4653      	mov	r3, sl
 802677c:	7033      	strb	r3, [r6, #0]
    P_pAESGCMctx->Iv_endian[2U + (4U * i)] = P_pIv[1U + (4U * i)];
 802677e:	464b      	mov	r3, r9
 8026780:	5cfb      	ldrb	r3, [r7, r3]
 8026782:	18a2      	adds	r2, r4, r2
 8026784:	4462      	add	r2, ip
 8026786:	7013      	strb	r3, [r2, #0]
    P_pAESGCMctx->Iv_endian[3U + (4U * i)] = P_pIv[4U * i];
 8026788:	5c7a      	ldrb	r2, [r7, r1]
 802678a:	9b01      	ldr	r3, [sp, #4]
 802678c:	18e3      	adds	r3, r4, r3
 802678e:	4463      	add	r3, ip
 8026790:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < 3U; i++)
 8026792:	3001      	adds	r0, #1
 8026794:	b2c0      	uxtb	r0, r0
 8026796:	2802      	cmp	r0, #2
 8026798:	d9d9      	bls.n	802674e <CA_AES_GCM_Decrypt_Init+0x82>
  P_pAESGCMctx->Iv_endian[12] = 2;
 802679a:	23a6      	movs	r3, #166	; 0xa6
 802679c:	005b      	lsls	r3, r3, #1
 802679e:	2202      	movs	r2, #2
 80267a0:	54e2      	strb	r2, [r4, r3]
  P_pAESGCMctx->Iv_endian[13] = 0;
 80267a2:	2300      	movs	r3, #0
 80267a4:	224e      	movs	r2, #78	; 0x4e
 80267a6:	32ff      	adds	r2, #255	; 0xff
 80267a8:	54a3      	strb	r3, [r4, r2]
  P_pAESGCMctx->Iv_endian[14] = 0;
 80267aa:	3201      	adds	r2, #1
 80267ac:	54a3      	strb	r3, [r4, r2]
  P_pAESGCMctx->Iv_endian[15] = 0;
 80267ae:	2250      	movs	r2, #80	; 0x50
 80267b0:	32ff      	adds	r2, #255	; 0xff
 80267b2:	54a3      	strb	r3, [r4, r2]
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESGCMctx->mKeySize) / 4U); i++)
 80267b4:	e01e      	b.n	80267f4 <CA_AES_GCM_Decrypt_Init+0x128>
    P_pAESGCMctx->Key_endian[4U * i]        = P_pKey[3U + (4U * i)];
 80267b6:	465b      	mov	r3, fp
 80267b8:	0098      	lsls	r0, r3, #2
 80267ba:	1cc3      	adds	r3, r0, #3
 80267bc:	5cef      	ldrb	r7, [r5, r3]
 80267be:	1822      	adds	r2, r4, r0
 80267c0:	3251      	adds	r2, #81	; 0x51
 80267c2:	32ff      	adds	r2, #255	; 0xff
 80267c4:	7017      	strb	r7, [r2, #0]
    P_pAESGCMctx->Key_endian[1U + (4U * i)] = P_pKey[2U + (4U * i)];
 80267c6:	1c82      	adds	r2, r0, #2
 80267c8:	1c41      	adds	r1, r0, #1
 80267ca:	5caf      	ldrb	r7, [r5, r2]
 80267cc:	46b8      	mov	r8, r7
 80267ce:	1867      	adds	r7, r4, r1
 80267d0:	3751      	adds	r7, #81	; 0x51
 80267d2:	37ff      	adds	r7, #255	; 0xff
 80267d4:	4646      	mov	r6, r8
 80267d6:	703e      	strb	r6, [r7, #0]
    P_pAESGCMctx->Key_endian[2U + (4U * i)] = P_pKey[1U + (4U * i)];
 80267d8:	5c6f      	ldrb	r7, [r5, r1]
 80267da:	18a2      	adds	r2, r4, r2
 80267dc:	3251      	adds	r2, #81	; 0x51
 80267de:	32ff      	adds	r2, #255	; 0xff
 80267e0:	7017      	strb	r7, [r2, #0]
    P_pAESGCMctx->Key_endian[3U + (4U * i)] = P_pKey[4U * i];
 80267e2:	5c2a      	ldrb	r2, [r5, r0]
 80267e4:	18e3      	adds	r3, r4, r3
 80267e6:	3351      	adds	r3, #81	; 0x51
 80267e8:	33ff      	adds	r3, #255	; 0xff
 80267ea:	701a      	strb	r2, [r3, #0]
  for (uint8_t i = 0; i < ((uint8_t)(P_pAESGCMctx->mKeySize) / 4U); i++)
 80267ec:	465e      	mov	r6, fp
 80267ee:	3601      	adds	r6, #1
 80267f0:	b2f3      	uxtb	r3, r6
 80267f2:	469b      	mov	fp, r3
 80267f4:	466b      	mov	r3, sp
 80267f6:	781b      	ldrb	r3, [r3, #0]
 80267f8:	089b      	lsrs	r3, r3, #2
 80267fa:	455b      	cmp	r3, fp
 80267fc:	d8db      	bhi.n	80267b6 <CA_AES_GCM_Decrypt_Init+0xea>
  P_pAESGCMctx->CrypHandle.Init.Algorithm       = CRYP_AES_GCM_GMAC;
 80267fe:	2360      	movs	r3, #96	; 0x60
 8026800:	64a3      	str	r3, [r4, #72]	; 0x48
  P_pAESGCMctx->CrypHandle.Init.pKey            = (uint32_t *)(uint32_t)(P_pAESGCMctx->Key_endian);
 8026802:	0023      	movs	r3, r4
 8026804:	3351      	adds	r3, #81	; 0x51
 8026806:	33ff      	adds	r3, #255	; 0xff
 8026808:	6423      	str	r3, [r4, #64]	; 0x40
  P_pAESGCMctx->CrypHandle.Init.pInitVect       = (uint32_t *)(uint32_t)(P_pAESGCMctx->Iv_endian);
 802680a:	3b10      	subs	r3, #16
 802680c:	6463      	str	r3, [r4, #68]	; 0x44
  P_pAESGCMctx->CrypHandle.Init.Header = NULL;
 802680e:	2300      	movs	r3, #0
 8026810:	64e3      	str	r3, [r4, #76]	; 0x4c
  P_pAESGCMctx->CrypHandle.Init.HeaderSize = 0;
 8026812:	6523      	str	r3, [r4, #80]	; 0x50
  P_pAESGCMctx->CrypHandle.Init.B0 = NULL;
 8026814:	6563      	str	r3, [r4, #84]	; 0x54
  P_pAESGCMctx->CrypHandle.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 8026816:	3301      	adds	r3, #1
 8026818:	65a3      	str	r3, [r4, #88]	; 0x58
  P_pAESGCMctx->CrypHandle.Init.KeyIVConfigSkip = CRYP_KEYIVCONFIG_ONCE;
 802681a:	6623      	str	r3, [r4, #96]	; 0x60
  P_pAESGCMctx->flags = GCM_DECRYPTION_ONGOING | GCM_INIT_NOT_DONE;
 802681c:	3370      	adds	r3, #112	; 0x70
 802681e:	33ff      	adds	r3, #255	; 0xff
 8026820:	220a      	movs	r2, #10
 8026822:	50e2      	str	r2, [r4, r3]
  return aes_ret_status;
 8026824:	2000      	movs	r0, #0
 8026826:	e76c      	b.n	8026702 <CA_AES_GCM_Decrypt_Init+0x36>
    return CA_AES_ERR_BAD_PARAMETER;
 8026828:	20c2      	movs	r0, #194	; 0xc2
 802682a:	0100      	lsls	r0, r0, #4
 802682c:	e769      	b.n	8026702 <CA_AES_GCM_Decrypt_Init+0x36>
 802682e:	20c2      	movs	r0, #194	; 0xc2
 8026830:	0100      	lsls	r0, r0, #4
 8026832:	e766      	b.n	8026702 <CA_AES_GCM_Decrypt_Init+0x36>
 8026834:	20c2      	movs	r0, #194	; 0xc2
 8026836:	0100      	lsls	r0, r0, #4
 8026838:	e763      	b.n	8026702 <CA_AES_GCM_Decrypt_Init+0x36>
    return CA_AES_ERR_BAD_CONTEXT;
 802683a:	4803      	ldr	r0, [pc, #12]	; (8026848 <CA_AES_GCM_Decrypt_Init+0x17c>)
 802683c:	e761      	b.n	8026702 <CA_AES_GCM_Decrypt_Init+0x36>
    return CA_AES_ERR_BAD_CONTEXT;
 802683e:	4802      	ldr	r0, [pc, #8]	; (8026848 <CA_AES_GCM_Decrypt_Init+0x17c>)
 8026840:	e75f      	b.n	8026702 <CA_AES_GCM_Decrypt_Init+0x36>
    return CA_AES_ERR_BAD_CONTEXT;
 8026842:	4801      	ldr	r0, [pc, #4]	; (8026848 <CA_AES_GCM_Decrypt_Init+0x17c>)
 8026844:	e75d      	b.n	8026702 <CA_AES_GCM_Decrypt_Init+0x36>
 8026846:	46c0      	nop			; (mov r8, r8)
 8026848:	00000c1f 	.word	0x00000c1f
 802684c:	58001800 	.word	0x58001800

08026850 <CA_AES_GCM_Header_Append>:
  * @retval     CA_AES_ERR_BAD_OPERATION Append not allowed
  */
int32_t CA_AES_GCM_Header_Append(CA_AESGCMctx_stt *P_pAESGCMctx,
                                 const uint8_t *P_pInputBuffer,
                                 int32_t        P_inputSize)
{
 8026850:	b530      	push	{r4, r5, lr}
 8026852:	b083      	sub	sp, #12
 8026854:	1e04      	subs	r4, r0, #0
  int32_t aes_ret_status = CA_AES_SUCCESS;


  if ((P_pAESGCMctx == NULL) || (P_pInputBuffer == NULL))
 8026856:	d02d      	beq.n	80268b4 <CA_AES_GCM_Header_Append+0x64>
 8026858:	2900      	cmp	r1, #0
 802685a:	d02e      	beq.n	80268ba <CA_AES_GCM_Header_Append+0x6a>
  {
    return CA_AES_ERR_BAD_PARAMETER;
  }

  P_pAESGCMctx->mAADsize = P_inputSize;
 802685c:	6302      	str	r2, [r0, #48]	; 0x30
  P_pAESGCMctx->CrypHandle.Init.HeaderSize = (uint32_t)(P_inputSize) / 4U;
 802685e:	0892      	lsrs	r2, r2, #2
 8026860:	6502      	str	r2, [r0, #80]	; 0x50
  P_pAESGCMctx->CrypHandle.Init.Header     = (uint32_t *)(uint32_t)P_pInputBuffer;
 8026862:	64c1      	str	r1, [r0, #76]	; 0x4c

  if (HAL_CRYP_Init(&P_pAESGCMctx->CrypHandle) != HAL_OK)
 8026864:	0005      	movs	r5, r0
 8026866:	3534      	adds	r5, #52	; 0x34
 8026868:	0028      	movs	r0, r5
 802686a:	f7fc fed9 	bl	8023620 <HAL_CRYP_Init>
 802686e:	2800      	cmp	r0, #0
 8026870:	d126      	bne.n	80268c0 <CA_AES_GCM_Header_Append+0x70>
  {
    aes_ret_status = CA_AES_ERR_BAD_OPERATION;
  }
  else
  {
    P_pAESGCMctx->flags &= ~ GCM_INIT_NOT_DONE;
 8026872:	22b8      	movs	r2, #184	; 0xb8
 8026874:	0052      	lsls	r2, r2, #1
 8026876:	2308      	movs	r3, #8
 8026878:	58a1      	ldr	r1, [r4, r2]
 802687a:	4399      	bics	r1, r3
 802687c:	000b      	movs	r3, r1
 802687e:	50a1      	str	r1, [r4, r2]
    if ((P_pAESGCMctx->flags & GCM_ENCRYPTION_ONGOING) == GCM_ENCRYPTION_ONGOING)
 8026880:	07db      	lsls	r3, r3, #31
 8026882:	d50b      	bpl.n	802689c <CA_AES_GCM_Header_Append+0x4c>
    {
      if (HAL_CRYP_Encrypt(&(P_pAESGCMctx->CrypHandle), (uint32_t *)NULL, 0, (uint32_t *)NULL,
 8026884:	23ff      	movs	r3, #255	; 0xff
 8026886:	9300      	str	r3, [sp, #0]
 8026888:	2300      	movs	r3, #0
 802688a:	2200      	movs	r2, #0
 802688c:	2100      	movs	r1, #0
 802688e:	0028      	movs	r0, r5
 8026890:	f7fd fab4 	bl	8023dfc <HAL_CRYP_Encrypt>
 8026894:	2800      	cmp	r0, #0
 8026896:	d014      	beq.n	80268c2 <CA_AES_GCM_Header_Append+0x72>
                           TIMEOUT_VALUE) != HAL_OK)
      {
        aes_ret_status = CA_AES_ERR_BAD_OPERATION;
 8026898:	480b      	ldr	r0, [pc, #44]	; (80268c8 <CA_AES_GCM_Header_Append+0x78>)
 802689a:	e012      	b.n	80268c2 <CA_AES_GCM_Header_Append+0x72>
      }
    }
    else
    {
      if (HAL_CRYP_Decrypt(&(P_pAESGCMctx->CrypHandle), (uint32_t *)NULL, 0, (uint32_t *)NULL,
 802689c:	23ff      	movs	r3, #255	; 0xff
 802689e:	9300      	str	r3, [sp, #0]
 80268a0:	2300      	movs	r3, #0
 80268a2:	2200      	movs	r2, #0
 80268a4:	2100      	movs	r1, #0
 80268a6:	0028      	movs	r0, r5
 80268a8:	f7fd fb04 	bl	8023eb4 <HAL_CRYP_Decrypt>
 80268ac:	2800      	cmp	r0, #0
 80268ae:	d008      	beq.n	80268c2 <CA_AES_GCM_Header_Append+0x72>
                           TIMEOUT_VALUE) != HAL_OK)
      {
        aes_ret_status = CA_AES_ERR_BAD_OPERATION;
 80268b0:	4805      	ldr	r0, [pc, #20]	; (80268c8 <CA_AES_GCM_Header_Append+0x78>)
 80268b2:	e006      	b.n	80268c2 <CA_AES_GCM_Header_Append+0x72>
    return CA_AES_ERR_BAD_PARAMETER;
 80268b4:	20c2      	movs	r0, #194	; 0xc2
 80268b6:	0100      	lsls	r0, r0, #4
 80268b8:	e003      	b.n	80268c2 <CA_AES_GCM_Header_Append+0x72>
 80268ba:	20c2      	movs	r0, #194	; 0xc2
 80268bc:	0100      	lsls	r0, r0, #4
 80268be:	e000      	b.n	80268c2 <CA_AES_GCM_Header_Append+0x72>
    aes_ret_status = CA_AES_ERR_BAD_OPERATION;
 80268c0:	4801      	ldr	r0, [pc, #4]	; (80268c8 <CA_AES_GCM_Header_Append+0x78>)
      }
    }
  }
  return aes_ret_status;
}
 80268c2:	b003      	add	sp, #12
 80268c4:	bd30      	pop	{r4, r5, pc}
 80268c6:	46c0      	nop			; (mov r8, r8)
 80268c8:	00000c1e 	.word	0x00000c1e

080268cc <CA_Init>:
  {
    ecc_ret_status = CA_SUCCESS;
  }
#endif /* CA_MBED_CRYPTOLIB_SUPP && CA_USES_PSA_CRYPTO */
  return ecc_ret_status;
}
 80268cc:	2000      	movs	r0, #0
 80268ce:	4770      	bx	lr

080268d0 <CA_DeInit>:
  int32_t ecc_ret_status = CA_SUCCESS;
#if defined(CA_MBED_CRYPTOLIB_SUPP) && defined(CA_USES_PSA_CRYPTO)
  mbedtls_psa_crypto_free();
#endif /* CA_MBED_CRYPTOLIB_SUPP && CA_USES_PSA_CRYPTO */
  return ecc_ret_status;
}
 80268d0:	2000      	movs	r0, #0
 80268d2:	4770      	bx	lr

080268d4 <KMS_CreateObject>:
  */
CK_RV  KMS_CreateObject(CK_SESSION_HANDLE hSession,
                        CK_ATTRIBUTE_PTR pTemplate,
                        CK_ULONG ulCount,
                        CK_OBJECT_HANDLE_PTR phObject)
{
 80268d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80268d6:	b085      	sub	sp, #20
 80268d8:	0004      	movs	r4, r0
 80268da:	000d      	movs	r5, r1
 80268dc:	0016      	movs	r6, r2
 80268de:	001f      	movs	r7, r3
#if defined(KMS_OBJECTS)
  CK_ATTRIBUTE_PTR  p_attribut_value = NULL_PTR;
 80268e0:	2300      	movs	r3, #0
 80268e2:	9303      	str	r3, [sp, #12]
  CK_RV e_ret_status;

  if (!KMS_IS_INITIALIZED())
 80268e4:	4b27      	ldr	r3, [pc, #156]	; (8026984 <KMS_CreateObject+0xb0>)
 80268e6:	781b      	ldrb	r3, [r3, #0]
 80268e8:	2b00      	cmp	r3, #0
 80268ea:	d041      	beq.n	8026970 <KMS_CreateObject+0x9c>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 80268ec:	f000 fdde 	bl	80274ac <KMS_CheckSessionHdle>
 80268f0:	2800      	cmp	r0, #0
 80268f2:	d141      	bne.n	8026978 <KMS_CreateObject+0xa4>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_IDLE)
 80268f4:	1e62      	subs	r2, r4, #1
 80268f6:	00d3      	lsls	r3, r2, #3
 80268f8:	189b      	adds	r3, r3, r2
 80268fa:	009b      	lsls	r3, r3, #2
 80268fc:	4a21      	ldr	r2, [pc, #132]	; (8026984 <KMS_CreateObject+0xb0>)
 80268fe:	18d3      	adds	r3, r2, r3
 8026900:	68db      	ldr	r3, [r3, #12]
 8026902:	2b00      	cmp	r3, #0
 8026904:	d13a      	bne.n	802697c <KMS_CreateObject+0xa8>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }

  /* Control CLASS ATTRIBUTE */
  if (CKR_OK != KMS_FindAttributeInTemplate(pTemplate, ulCount, CKA_CLASS, &p_attribut_value))
 8026906:	ab03      	add	r3, sp, #12
 8026908:	2200      	movs	r2, #0
 802690a:	0031      	movs	r1, r6
 802690c:	0028      	movs	r0, r5
 802690e:	f001 fdb6 	bl	802847e <KMS_FindAttributeInTemplate>
 8026912:	2800      	cmp	r0, #0
 8026914:	d134      	bne.n	8026980 <KMS_CreateObject+0xac>
  }

  /* The provided creation template should at least include one of the following:
   * CKA_CERTIFICATE_TYPE, CKA_HW_FEATURE_TYPE, CKA_KEY_TYPE or CKA_STM_COUNTER_VALUE
   */
  if (KMS_FindAttributeInTemplate(pTemplate, ulCount, CKA_CERTIFICATE_TYPE, &p_attribut_value) != CKR_OK)
 8026916:	ab03      	add	r3, sp, #12
 8026918:	2280      	movs	r2, #128	; 0x80
 802691a:	0031      	movs	r1, r6
 802691c:	0028      	movs	r0, r5
 802691e:	f001 fdae 	bl	802847e <KMS_FindAttributeInTemplate>
 8026922:	2800      	cmp	r0, #0
 8026924:	d008      	beq.n	8026938 <KMS_CreateObject+0x64>
  {
    if (KMS_FindAttributeInTemplate(pTemplate, ulCount, CKA_HW_FEATURE_TYPE, &p_attribut_value) != CKR_OK)
 8026926:	22c0      	movs	r2, #192	; 0xc0
 8026928:	ab03      	add	r3, sp, #12
 802692a:	0092      	lsls	r2, r2, #2
 802692c:	0031      	movs	r1, r6
 802692e:	0028      	movs	r0, r5
 8026930:	f001 fda5 	bl	802847e <KMS_FindAttributeInTemplate>
 8026934:	2800      	cmp	r0, #0
 8026936:	d108      	bne.n	802694a <KMS_CreateObject+0x76>
      }
    }
  }

  /* Allocate blob object to fill it with template data */
  e_ret_status = KMS_Objects_CreateNStoreBlobFromTemplates(hSession, pTemplate, ulCount, NULL_PTR, 0, phObject);
 8026938:	9701      	str	r7, [sp, #4]
 802693a:	2300      	movs	r3, #0
 802693c:	9300      	str	r3, [sp, #0]
 802693e:	0032      	movs	r2, r6
 8026940:	0029      	movs	r1, r5
 8026942:	0020      	movs	r0, r4
 8026944:	f001 fede 	bl	8028704 <KMS_Objects_CreateNStoreBlobFromTemplates>

  return e_ret_status;
 8026948:	e014      	b.n	8026974 <KMS_CreateObject+0xa0>
      if (KMS_FindAttributeInTemplate(pTemplate, ulCount, CKA_KEY_TYPE, &p_attribut_value) != CKR_OK)
 802694a:	2280      	movs	r2, #128	; 0x80
 802694c:	ab03      	add	r3, sp, #12
 802694e:	0052      	lsls	r2, r2, #1
 8026950:	0031      	movs	r1, r6
 8026952:	0028      	movs	r0, r5
 8026954:	f001 fd93 	bl	802847e <KMS_FindAttributeInTemplate>
 8026958:	2800      	cmp	r0, #0
 802695a:	d0ed      	beq.n	8026938 <KMS_CreateObject+0x64>
        if (KMS_FindAttributeInTemplate(pTemplate, ulCount, CKA_STM_COUNTER_VALUE, &p_attribut_value) != CKR_OK)
 802695c:	ab03      	add	r3, sp, #12
 802695e:	4a0a      	ldr	r2, [pc, #40]	; (8026988 <KMS_CreateObject+0xb4>)
 8026960:	0031      	movs	r1, r6
 8026962:	0028      	movs	r0, r5
 8026964:	f001 fd8b 	bl	802847e <KMS_FindAttributeInTemplate>
 8026968:	2800      	cmp	r0, #0
 802696a:	d0e5      	beq.n	8026938 <KMS_CreateObject+0x64>
          return CKR_TEMPLATE_INCOMPLETE;
 802696c:	20d0      	movs	r0, #208	; 0xd0
 802696e:	e001      	b.n	8026974 <KMS_CreateObject+0xa0>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8026970:	20c8      	movs	r0, #200	; 0xc8
 8026972:	0040      	lsls	r0, r0, #1
#else /* KMS_OBJECTS */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_OBJECTS */
}
 8026974:	b005      	add	sp, #20
 8026976:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8026978:	20b3      	movs	r0, #179	; 0xb3
 802697a:	e7fb      	b.n	8026974 <KMS_CreateObject+0xa0>
    return CKR_SESSION_HANDLE_INVALID;
 802697c:	20b3      	movs	r0, #179	; 0xb3
 802697e:	e7f9      	b.n	8026974 <KMS_CreateObject+0xa0>
    return CKR_TEMPLATE_INCOMPLETE;
 8026980:	20d0      	movs	r0, #208	; 0xd0
 8026982:	e7f7      	b.n	8026974 <KMS_CreateObject+0xa0>
 8026984:	2000b300 	.word	0x2000b300
 8026988:	80000004 	.word	0x80000004

0802698c <KMS_DestroyObject>:
  *         @ref KMS_PlatfObjects_NvmRemoveObject returned values
  *         @ref KMS_PlatfObjects_VmRemoveObject returned values
  */
CK_RV  KMS_DestroyObject(CK_SESSION_HANDLE hSession,
                         CK_OBJECT_HANDLE hObject)
{
 802698c:	b530      	push	{r4, r5, lr}
 802698e:	b083      	sub	sp, #12
 8026990:	0004      	movs	r4, r0
 8026992:	000d      	movs	r5, r1
  CK_RV e_ret_status = CKR_FUNCTION_FAILED;
  kms_obj_keyhead_t *pkms_object;
  kms_attr_t  *pAttribute;
  kms_obj_range_t  ObjectRange;

  if (!KMS_IS_INITIALIZED())
 8026994:	4b1b      	ldr	r3, [pc, #108]	; (8026a04 <KMS_DestroyObject+0x78>)
 8026996:	781b      	ldrb	r3, [r3, #0]
 8026998:	2b00      	cmp	r3, #0
 802699a:	d025      	beq.n	80269e8 <KMS_DestroyObject+0x5c>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 802699c:	f000 fd86 	bl	80274ac <KMS_CheckSessionHdle>
 80269a0:	2800      	cmp	r0, #0
 80269a2:	d125      	bne.n	80269f0 <KMS_DestroyObject+0x64>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_IDLE)
 80269a4:	3c01      	subs	r4, #1
 80269a6:	00e0      	lsls	r0, r4, #3
 80269a8:	1904      	adds	r4, r0, r4
 80269aa:	00a4      	lsls	r4, r4, #2
 80269ac:	4815      	ldr	r0, [pc, #84]	; (8026a04 <KMS_DestroyObject+0x78>)
 80269ae:	1904      	adds	r4, r0, r4
 80269b0:	68e3      	ldr	r3, [r4, #12]
 80269b2:	2b00      	cmp	r3, #0
 80269b4:	d11e      	bne.n	80269f4 <KMS_DestroyObject+0x68>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }

  /* Verify that the object is removable, embedded objects are not */
  ObjectRange = KMS_Objects_GetRange(hObject);
 80269b6:	0028      	movs	r0, r5
 80269b8:	f001 fcf4 	bl	80283a4 <KMS_Objects_GetRange>
  if (ObjectRange == KMS_OBJECT_RANGE_EMBEDDED)
 80269bc:	2800      	cmp	r0, #0
 80269be:	d01b      	beq.n	80269f8 <KMS_DestroyObject+0x6c>

  /* Verify that the object is removable, reading the attributes */

  /* Read the key value from the Key Handle                 */
  /* Key Handle is the index to one of static or nvm        */
  pkms_object = KMS_Objects_GetPointer(hObject);
 80269c0:	0028      	movs	r0, r5
 80269c2:	f001 fd1d 	bl	8028400 <KMS_Objects_GetPointer>
 80269c6:	1e01      	subs	r1, r0, #0

  /* Check that hKey is valid */
  if (pkms_object != NULL_PTR)
 80269c8:	d018      	beq.n	80269fc <KMS_DestroyObject+0x70>
  {
    /* Check the CKA_DESTROYABLE attribute = CK_TRUE      */
    e_ret_status = KMS_Objects_SearchAttributes(CKA_DESTROYABLE, pkms_object, &pAttribute);
 80269ca:	20b9      	movs	r0, #185	; 0xb9
 80269cc:	aa01      	add	r2, sp, #4
 80269ce:	0040      	lsls	r0, r0, #1
 80269d0:	f001 fd73 	bl	80284ba <KMS_Objects_SearchAttributes>

    if (e_ret_status == CKR_OK)
 80269d4:	2800      	cmp	r0, #0
 80269d6:	d103      	bne.n	80269e0 <KMS_DestroyObject+0x54>
    {
      if (*pAttribute->data != CK_TRUE)
 80269d8:	9b01      	ldr	r3, [sp, #4]
 80269da:	689b      	ldr	r3, [r3, #8]
 80269dc:	2b01      	cmp	r3, #1
 80269de:	d10f      	bne.n	8026a00 <KMS_DestroyObject+0x74>

    /* Object is removable */
#ifdef KMS_VM_DYNAMIC_ENABLED
    e_ret_status = KMS_PlatfObjects_VmRemoveObject(hObject);
#else /* KMS_VM_DYNAMIC_ENABLED */
    e_ret_status = KMS_PlatfObjects_NvmRemoveObject(hObject);
 80269e0:	0028      	movs	r0, r5
 80269e2:	f002 f8ab 	bl	8028b3c <KMS_PlatfObjects_NvmRemoveObject>
 80269e6:	e001      	b.n	80269ec <KMS_DestroyObject+0x60>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 80269e8:	20c8      	movs	r0, #200	; 0xc8
 80269ea:	0040      	lsls	r0, r0, #1

  return e_ret_status;
#else /* KMS_OBJECTS */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_OBJECTS */
}
 80269ec:	b003      	add	sp, #12
 80269ee:	bd30      	pop	{r4, r5, pc}
    return CKR_SESSION_HANDLE_INVALID;
 80269f0:	20b3      	movs	r0, #179	; 0xb3
 80269f2:	e7fb      	b.n	80269ec <KMS_DestroyObject+0x60>
    return CKR_SESSION_HANDLE_INVALID;
 80269f4:	20b3      	movs	r0, #179	; 0xb3
 80269f6:	e7f9      	b.n	80269ec <KMS_DestroyObject+0x60>
    return (CKR_ACTION_PROHIBITED);
 80269f8:	201b      	movs	r0, #27
 80269fa:	e7f7      	b.n	80269ec <KMS_DestroyObject+0x60>
    e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 80269fc:	2082      	movs	r0, #130	; 0x82
 80269fe:	e7f5      	b.n	80269ec <KMS_DestroyObject+0x60>
        return (CKR_ACTION_PROHIBITED);
 8026a00:	201b      	movs	r0, #27
 8026a02:	e7f3      	b.n	80269ec <KMS_DestroyObject+0x60>
 8026a04:	2000b300 	.word	0x2000b300

08026a08 <KMS_GetAttributeValue>:
  *         CKR_SESSION_HANDLE_INVALID
  *         @ref KMS_Objects_SearchAttributes returned values
  */
CK_RV KMS_GetAttributeValue(CK_SESSION_HANDLE hSession,  CK_OBJECT_HANDLE  hObject,
                            CK_ATTRIBUTE_PTR  pTemplate, CK_ULONG          ulCount)
{
 8026a08:	b5f0      	push	{r4, r5, r6, r7, lr}
 8026a0a:	46d6      	mov	lr, sl
 8026a0c:	464f      	mov	r7, r9
 8026a0e:	4646      	mov	r6, r8
 8026a10:	b5c0      	push	{r6, r7, lr}
 8026a12:	b082      	sub	sp, #8
 8026a14:	0005      	movs	r5, r0
 8026a16:	000c      	movs	r4, r1
 8026a18:	4691      	mov	r9, r2
 8026a1a:	001e      	movs	r6, r3
#if defined(KMS_ATTRIBUTES)
  CK_RV e_ret_status = CKR_FUNCTION_FAILED;
  kms_obj_keyhead_t *pkms_object;

  if (!KMS_IS_INITIALIZED())
 8026a1c:	4b49      	ldr	r3, [pc, #292]	; (8026b44 <KMS_GetAttributeValue+0x13c>)
 8026a1e:	781b      	ldrb	r3, [r3, #0]
 8026a20:	2b00      	cmp	r3, #0
 8026a22:	d100      	bne.n	8026a26 <KMS_GetAttributeValue+0x1e>
 8026a24:	e07e      	b.n	8026b24 <KMS_GetAttributeValue+0x11c>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 8026a26:	f000 fd41 	bl	80274ac <KMS_CheckSessionHdle>
 8026a2a:	2800      	cmp	r0, #0
 8026a2c:	d000      	beq.n	8026a30 <KMS_GetAttributeValue+0x28>
 8026a2e:	e082      	b.n	8026b36 <KMS_GetAttributeValue+0x12e>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_IDLE)
 8026a30:	1e68      	subs	r0, r5, #1
 8026a32:	00c3      	lsls	r3, r0, #3
 8026a34:	1818      	adds	r0, r3, r0
 8026a36:	0080      	lsls	r0, r0, #2
 8026a38:	4b42      	ldr	r3, [pc, #264]	; (8026b44 <KMS_GetAttributeValue+0x13c>)
 8026a3a:	1818      	adds	r0, r3, r0
 8026a3c:	68c5      	ldr	r5, [r0, #12]
 8026a3e:	2d00      	cmp	r5, #0
 8026a40:	d000      	beq.n	8026a44 <KMS_GetAttributeValue+0x3c>
 8026a42:	e07a      	b.n	8026b3a <KMS_GetAttributeValue+0x132>
  /* GetAttribute() is only authorised for objects with attribute EXTRACTABLE = TRUE or without EXTRACTABLE attribute */
  /* Verify that the object is extractable, reading the attributes */

  /* Read the key value from the Key Handle                 */
  /* Key Handle is the index to one of static or nvm        */
  pkms_object = KMS_Objects_GetPointer(hObject);
 8026a44:	0020      	movs	r0, r4
 8026a46:	f001 fcdb 	bl	8028400 <KMS_Objects_GetPointer>
 8026a4a:	4680      	mov	r8, r0

  /* Check that hObject is valid */
  if (pkms_object != NULL_PTR)
 8026a4c:	2800      	cmp	r0, #0
 8026a4e:	d100      	bne.n	8026a52 <KMS_GetAttributeValue+0x4a>
 8026a50:	e075      	b.n	8026b3e <KMS_GetAttributeValue+0x136>
  {
    kms_attr_t  *pAttribute;

    /* Check the CKA_EXTRACTABLE attribute = CK_TRUE      */
    e_ret_status = KMS_Objects_SearchAttributes(CKA_EXTRACTABLE, pkms_object, &pAttribute);
 8026a52:	20b1      	movs	r0, #177	; 0xb1
 8026a54:	466a      	mov	r2, sp
 8026a56:	4641      	mov	r1, r8
 8026a58:	0040      	lsls	r0, r0, #1
 8026a5a:	f001 fd2e 	bl	80284ba <KMS_Objects_SearchAttributes>

    /* If attribute not found or object not extractable */
    if ((e_ret_status == CKR_OK) && (*pAttribute->data != CK_TRUE))
 8026a5e:	2800      	cmp	r0, #0
 8026a60:	d103      	bne.n	8026a6a <KMS_GetAttributeValue+0x62>
 8026a62:	9b00      	ldr	r3, [sp, #0]
 8026a64:	689b      	ldr	r3, [r3, #8]
 8026a66:	2b01      	cmp	r3, #1
 8026a68:	d10d      	bne.n	8026a86 <KMS_GetAttributeValue+0x7e>
      /* Object cannot be extracted  */
      return (CKR_ATTRIBUTE_SENSITIVE);
    }

    /* Double check to avoid fault attack: Check the CKA_EXTRACTABLE attribute = CK_TRUE */
    e_ret_status = KMS_Objects_SearchAttributes(CKA_EXTRACTABLE, pkms_object, &pAttribute);
 8026a6a:	20b1      	movs	r0, #177	; 0xb1
 8026a6c:	466a      	mov	r2, sp
 8026a6e:	4641      	mov	r1, r8
 8026a70:	0040      	lsls	r0, r0, #1
 8026a72:	f001 fd22 	bl	80284ba <KMS_Objects_SearchAttributes>
 8026a76:	1e07      	subs	r7, r0, #0

    /* If attribute not found or object not extractable */
    if ((e_ret_status == CKR_OK) && (*pAttribute->data != CK_TRUE))
 8026a78:	d12e      	bne.n	8026ad8 <KMS_GetAttributeValue+0xd0>
 8026a7a:	9b00      	ldr	r3, [sp, #0]
 8026a7c:	689b      	ldr	r3, [r3, #8]
 8026a7e:	2b01      	cmp	r3, #1
 8026a80:	d114      	bne.n	8026aac <KMS_GetAttributeValue+0xa4>
 8026a82:	0005      	movs	r5, r0
 8026a84:	e028      	b.n	8026ad8 <KMS_GetAttributeValue+0xd0>
      for (uint32_t i = 0; i < ulCount; i++)
 8026a86:	42b0      	cmp	r0, r6
 8026a88:	d212      	bcs.n	8026ab0 <KMS_GetAttributeValue+0xa8>
        pTemplate[i].ulValueLen = CK_UNAVAILABLE_INFORMATION;
 8026a8a:	0043      	lsls	r3, r0, #1
 8026a8c:	181b      	adds	r3, r3, r0
 8026a8e:	009b      	lsls	r3, r3, #2
 8026a90:	444b      	add	r3, r9
 8026a92:	2201      	movs	r2, #1
 8026a94:	4252      	negs	r2, r2
 8026a96:	609a      	str	r2, [r3, #8]
      for (uint32_t i = 0; i < ulCount; i++)
 8026a98:	3001      	adds	r0, #1
 8026a9a:	e7f4      	b.n	8026a86 <KMS_GetAttributeValue+0x7e>
    {
      for (uint32_t i = 0; i < ulCount; i++)
      {
        pTemplate[i].ulValueLen = CK_UNAVAILABLE_INFORMATION;
 8026a9c:	007b      	lsls	r3, r7, #1
 8026a9e:	19db      	adds	r3, r3, r7
 8026aa0:	009b      	lsls	r3, r3, #2
 8026aa2:	444b      	add	r3, r9
 8026aa4:	2201      	movs	r2, #1
 8026aa6:	4252      	negs	r2, r2
 8026aa8:	609a      	str	r2, [r3, #8]
      for (uint32_t i = 0; i < ulCount; i++)
 8026aaa:	3701      	adds	r7, #1
 8026aac:	42b7      	cmp	r7, r6
 8026aae:	d3f5      	bcc.n	8026a9c <KMS_GetAttributeValue+0x94>
      return (CKR_ATTRIBUTE_SENSITIVE);
 8026ab0:	2711      	movs	r7, #17
 8026ab2:	e039      	b.n	8026b28 <KMS_GetAttributeValue+0x120>
        if (e_ret_status == CKR_OK)
        {
          if (ptemp->pValue == NULL_PTR)
          {
            /* case 3 */
            ptemp->ulValueLen = pfound_attribute->size;
 8026ab4:	9b01      	ldr	r3, [sp, #4]
 8026ab6:	685b      	ldr	r3, [r3, #4]
 8026ab8:	60a3      	str	r3, [r4, #8]
 8026aba:	e00c      	b.n	8026ad6 <KMS_GetAttributeValue+0xce>
                                          pfound_attribute->size,
                                          (uint8_t *)(ptemp->pValue));
            }
            else
            {
              (void)memcpy((uint8_t *)ptemp->pValue, (uint8_t *)(pfound_attribute->data), pfound_attribute->size);
 8026abc:	3308      	adds	r3, #8
 8026abe:	000a      	movs	r2, r1
 8026ac0:	0019      	movs	r1, r3
 8026ac2:	f00e f82f 	bl	8034b24 <memcpy>
 8026ac6:	e029      	b.n	8026b1c <KMS_GetAttributeValue+0x114>
            ptemp->ulValueLen = pfound_attribute->size;
          }
          else
          {
            /* case 4 - section 5.2 */
            ptemp->ulValueLen = CKR_BUFFER_TOO_SMALL;
 8026ac8:	23a8      	movs	r3, #168	; 0xa8
 8026aca:	005b      	lsls	r3, r3, #1
 8026acc:	60a3      	str	r3, [r4, #8]
 8026ace:	e002      	b.n	8026ad6 <KMS_GetAttributeValue+0xce>
          }
        }
        else
        {
          /* case 2 */
          ptemp->ulValueLen = CK_UNAVAILABLE_INFORMATION;
 8026ad0:	2301      	movs	r3, #1
 8026ad2:	425b      	negs	r3, r3
 8026ad4:	60a3      	str	r3, [r4, #8]
      for (index = 0; index < ulCount; index++)
 8026ad6:	3501      	adds	r5, #1
 8026ad8:	42b5      	cmp	r5, r6
 8026ada:	d225      	bcs.n	8026b28 <KMS_GetAttributeValue+0x120>
        ptemp = &(pTemplate[index]);
 8026adc:	006c      	lsls	r4, r5, #1
 8026ade:	1964      	adds	r4, r4, r5
 8026ae0:	00a4      	lsls	r4, r4, #2
 8026ae2:	444c      	add	r4, r9
        e_ret_status = KMS_Objects_SearchAttributes(ptemp->type, pkms_object, &pfound_attribute);
 8026ae4:	aa01      	add	r2, sp, #4
 8026ae6:	4641      	mov	r1, r8
 8026ae8:	6820      	ldr	r0, [r4, #0]
 8026aea:	f001 fce6 	bl	80284ba <KMS_Objects_SearchAttributes>
 8026aee:	1e07      	subs	r7, r0, #0
        if (e_ret_status == CKR_OK)
 8026af0:	d1ee      	bne.n	8026ad0 <KMS_GetAttributeValue+0xc8>
          if (ptemp->pValue == NULL_PTR)
 8026af2:	6860      	ldr	r0, [r4, #4]
 8026af4:	2800      	cmp	r0, #0
 8026af6:	d0dd      	beq.n	8026ab4 <KMS_GetAttributeValue+0xac>
          else if (ptemp->ulValueLen >= pfound_attribute->size)
 8026af8:	9b01      	ldr	r3, [sp, #4]
 8026afa:	6859      	ldr	r1, [r3, #4]
 8026afc:	68a2      	ldr	r2, [r4, #8]
 8026afe:	428a      	cmp	r2, r1
 8026b00:	d3e2      	bcc.n	8026ac8 <KMS_GetAttributeValue+0xc0>
            if ((ptemp->type == CKA_VALUE) || (ptemp->type == CKA_EC_POINT))
 8026b02:	6822      	ldr	r2, [r4, #0]
 8026b04:	4692      	mov	sl, r2
 8026b06:	2a11      	cmp	r2, #17
 8026b08:	d003      	beq.n	8026b12 <KMS_GetAttributeValue+0x10a>
 8026b0a:	2282      	movs	r2, #130	; 0x82
 8026b0c:	32ff      	adds	r2, #255	; 0xff
 8026b0e:	4592      	cmp	sl, r2
 8026b10:	d1d4      	bne.n	8026abc <KMS_GetAttributeValue+0xb4>
              KMS_Objects_BlobU32_2_u8ptr(&(pfound_attribute->data[0]),
 8026b12:	3308      	adds	r3, #8
 8026b14:	0002      	movs	r2, r0
 8026b16:	0018      	movs	r0, r3
 8026b18:	f001 fdb6 	bl	8028688 <KMS_Objects_BlobU32_2_u8ptr>
            ptemp->ulValueLen = pfound_attribute->size;
 8026b1c:	9b01      	ldr	r3, [sp, #4]
 8026b1e:	685b      	ldr	r3, [r3, #4]
 8026b20:	60a3      	str	r3, [r4, #8]
 8026b22:	e7d8      	b.n	8026ad6 <KMS_GetAttributeValue+0xce>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8026b24:	27c8      	movs	r7, #200	; 0xc8
 8026b26:	007f      	lsls	r7, r7, #1

  return e_ret_status;
#else /* KMS_ATTRIBUTES */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_ATTRIBUTES */
}
 8026b28:	0038      	movs	r0, r7
 8026b2a:	b002      	add	sp, #8
 8026b2c:	bce0      	pop	{r5, r6, r7}
 8026b2e:	46ba      	mov	sl, r7
 8026b30:	46b1      	mov	r9, r6
 8026b32:	46a8      	mov	r8, r5
 8026b34:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8026b36:	27b3      	movs	r7, #179	; 0xb3
 8026b38:	e7f6      	b.n	8026b28 <KMS_GetAttributeValue+0x120>
    return CKR_SESSION_HANDLE_INVALID;
 8026b3a:	27b3      	movs	r7, #179	; 0xb3
 8026b3c:	e7f4      	b.n	8026b28 <KMS_GetAttributeValue+0x120>
    e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8026b3e:	2782      	movs	r7, #130	; 0x82
 8026b40:	e7f2      	b.n	8026b28 <KMS_GetAttributeValue+0x120>
 8026b42:	46c0      	nop			; (mov r8, r8)
 8026b44:	2000b300 	.word	0x2000b300

08026b48 <KMS_FindObjectsInit>:
  *         CKR_SESSION_HANDLE_INVALID
  *         @ref KMS_FindObjectsFromTemplate returned values
  */
CK_RV KMS_FindObjectsInit(CK_SESSION_HANDLE hSession, CK_ATTRIBUTE_PTR pTemplate,
                          CK_ULONG ulCount)
{
 8026b48:	b5f0      	push	{r4, r5, r6, r7, lr}
 8026b4a:	46d6      	mov	lr, sl
 8026b4c:	464f      	mov	r7, r9
 8026b4e:	b580      	push	{r7, lr}
 8026b50:	b087      	sub	sp, #28
 8026b52:	0006      	movs	r6, r0
 8026b54:	4689      	mov	r9, r1
 8026b56:	9203      	str	r2, [sp, #12]
  CK_RV e_ret_status;
  kms_find_ctx_t *p_ctx;

  /* ========== Check active operation status ========== */

  if (!KMS_IS_INITIALIZED())
 8026b58:	4b2e      	ldr	r3, [pc, #184]	; (8026c14 <KMS_FindObjectsInit+0xcc>)
 8026b5a:	781b      	ldrb	r3, [r3, #0]
 8026b5c:	2b00      	cmp	r3, #0
 8026b5e:	d04a      	beq.n	8026bf6 <KMS_FindObjectsInit+0xae>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 8026b60:	f000 fca4 	bl	80274ac <KMS_CheckSessionHdle>
 8026b64:	2800      	cmp	r0, #0
 8026b66:	d14e      	bne.n	8026c06 <KMS_FindObjectsInit+0xbe>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_IDLE)
 8026b68:	1e73      	subs	r3, r6, #1
 8026b6a:	469a      	mov	sl, r3
 8026b6c:	00db      	lsls	r3, r3, #3
 8026b6e:	4453      	add	r3, sl
 8026b70:	009b      	lsls	r3, r3, #2
 8026b72:	4a28      	ldr	r2, [pc, #160]	; (8026c14 <KMS_FindObjectsInit+0xcc>)
 8026b74:	18d3      	adds	r3, r2, r3
 8026b76:	68dc      	ldr	r4, [r3, #12]
 8026b78:	2c00      	cmp	r4, #0
 8026b7a:	d146      	bne.n	8026c0a <KMS_FindObjectsInit+0xc2>
    return CKR_SESSION_HANDLE_INVALID;
  }

  /* Check input parameters */
  /* Note: pTemplate = NULL_PTR is ok only if ulCount = 0 */
  if (((pTemplate == NULL_PTR) && (ulCount > 0U)) || ((pTemplate != NULL_PTR) && (ulCount == 0U)))
 8026b7c:	464b      	mov	r3, r9
 8026b7e:	2b00      	cmp	r3, #0
 8026b80:	d00e      	beq.n	8026ba0 <KMS_FindObjectsInit+0x58>
 8026b82:	464b      	mov	r3, r9
 8026b84:	2b00      	cmp	r3, #0
 8026b86:	d002      	beq.n	8026b8e <KMS_FindObjectsInit+0x46>
 8026b88:	9b03      	ldr	r3, [sp, #12]
 8026b8a:	2b00      	cmp	r3, #0
 8026b8c:	d03f      	beq.n	8026c0e <KMS_FindObjectsInit+0xc6>
  {
    return CKR_ARGUMENTS_BAD;
  }

  p_ctx = KMS_Alloc(hSession, sizeof(kms_find_ctx_t));
 8026b8e:	218c      	movs	r1, #140	; 0x8c
 8026b90:	0049      	lsls	r1, r1, #1
 8026b92:	0030      	movs	r0, r6
 8026b94:	f000 fde0 	bl	8027758 <KMS_Alloc>
 8026b98:	1e07      	subs	r7, r0, #0
  if (p_ctx == NULL_PTR)
 8026b9a:	d10a      	bne.n	8026bb2 <KMS_FindObjectsInit+0x6a>
  {
    return CKR_DEVICE_MEMORY;
 8026b9c:	2431      	movs	r4, #49	; 0x31
 8026b9e:	e02c      	b.n	8026bfa <KMS_FindObjectsInit+0xb2>
  if (((pTemplate == NULL_PTR) && (ulCount > 0U)) || ((pTemplate != NULL_PTR) && (ulCount == 0U)))
 8026ba0:	9b03      	ldr	r3, [sp, #12]
 8026ba2:	2b00      	cmp	r3, #0
 8026ba4:	d0ed      	beq.n	8026b82 <KMS_FindObjectsInit+0x3a>
    return CKR_ARGUMENTS_BAD;
 8026ba6:	2407      	movs	r4, #7
 8026ba8:	e027      	b.n	8026bfa <KMS_FindObjectsInit+0xb2>
  }

  /* ========== Look for the objects  ========== */
  for (uint32_t i = 0; i < (sizeof(p_ctx->searchHandles) / sizeof(CK_OBJECT_HANDLE)); i++)
  {
    p_ctx->searchHandles[i] = KMS_HANDLE_KEY_NOT_KNOWN;
 8026baa:	00a3      	lsls	r3, r4, #2
 8026bac:	2500      	movs	r5, #0
 8026bae:	51dd      	str	r5, [r3, r7]
  for (uint32_t i = 0; i < (sizeof(p_ctx->searchHandles) / sizeof(CK_OBJECT_HANDLE)); i++)
 8026bb0:	3401      	adds	r4, #1
 8026bb2:	2c44      	cmp	r4, #68	; 0x44
 8026bb4:	d9f9      	bls.n	8026baa <KMS_FindObjectsInit+0x62>
  }

  /* Note: if ulCount was 0, searchHandles will be filled with a list of all objects handles */
  e_ret_status = KMS_FindObjectsFromTemplate(hSession,
 8026bb6:	9b03      	ldr	r3, [sp, #12]
 8026bb8:	9301      	str	r3, [sp, #4]
 8026bba:	464b      	mov	r3, r9
 8026bbc:	9300      	str	r3, [sp, #0]
 8026bbe:	ab05      	add	r3, sp, #20
 8026bc0:	2245      	movs	r2, #69	; 0x45
 8026bc2:	0039      	movs	r1, r7
 8026bc4:	0030      	movs	r0, r6
 8026bc6:	f001 fc92 	bl	80284ee <KMS_FindObjectsFromTemplate>
 8026bca:	1e04      	subs	r4, r0, #0
                                             sizeof(p_ctx->searchHandles) / sizeof(CK_OBJECT_HANDLE),
                                             &tmp,
                                             pTemplate,
                                             ulCount);

  if (e_ret_status == CKR_OK)
 8026bcc:	d10e      	bne.n	8026bec <KMS_FindObjectsInit+0xa4>
  {
    p_ctx->searchIndex = 0;
 8026bce:	238a      	movs	r3, #138	; 0x8a
 8026bd0:	005b      	lsls	r3, r3, #1
 8026bd2:	2200      	movs	r2, #0
 8026bd4:	50fa      	str	r2, [r7, r3]
    KMS_GETSESSION(hSession).state = KMS_SESSION_SEARCH;
 8026bd6:	490f      	ldr	r1, [pc, #60]	; (8026c14 <KMS_FindObjectsInit+0xcc>)
 8026bd8:	4653      	mov	r3, sl
 8026bda:	00db      	lsls	r3, r3, #3
 8026bdc:	4652      	mov	r2, sl
 8026bde:	189a      	adds	r2, r3, r2
 8026be0:	0092      	lsls	r2, r2, #2
 8026be2:	188a      	adds	r2, r1, r2
 8026be4:	2006      	movs	r0, #6
 8026be6:	60d0      	str	r0, [r2, #12]
    KMS_GETSESSION(hSession).pCtx = p_ctx;
 8026be8:	6297      	str	r7, [r2, #40]	; 0x28
 8026bea:	e006      	b.n	8026bfa <KMS_FindObjectsInit+0xb2>
  }
  else
  {
    KMS_Free(hSession, p_ctx);
 8026bec:	0039      	movs	r1, r7
 8026bee:	0030      	movs	r0, r6
 8026bf0:	f000 fdd8 	bl	80277a4 <KMS_Free>
 8026bf4:	e001      	b.n	8026bfa <KMS_FindObjectsInit+0xb2>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8026bf6:	24c8      	movs	r4, #200	; 0xc8
 8026bf8:	0064      	lsls	r4, r4, #1

  return e_ret_status;
#else /* KMS_SEARCH */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_SEARCH */
}
 8026bfa:	0020      	movs	r0, r4
 8026bfc:	b007      	add	sp, #28
 8026bfe:	bcc0      	pop	{r6, r7}
 8026c00:	46ba      	mov	sl, r7
 8026c02:	46b1      	mov	r9, r6
 8026c04:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8026c06:	24b3      	movs	r4, #179	; 0xb3
 8026c08:	e7f7      	b.n	8026bfa <KMS_FindObjectsInit+0xb2>
    return CKR_SESSION_HANDLE_INVALID;
 8026c0a:	24b3      	movs	r4, #179	; 0xb3
 8026c0c:	e7f5      	b.n	8026bfa <KMS_FindObjectsInit+0xb2>
    return CKR_ARGUMENTS_BAD;
 8026c0e:	2407      	movs	r4, #7
 8026c10:	e7f3      	b.n	8026bfa <KMS_FindObjectsInit+0xb2>
 8026c12:	46c0      	nop			; (mov r8, r8)
 8026c14:	2000b300 	.word	0x2000b300

08026c18 <KMS_FindObjects>:
  *         CKR_FUNCTION_NOT_SUPPORTED
  *         CKR_SESSION_HANDLE_INVALID
  */
CK_RV KMS_FindObjects(CK_SESSION_HANDLE hSession, CK_OBJECT_HANDLE_PTR phObject,
                      CK_ULONG ulMaxObjectCount,  CK_ULONG_PTR pulObjectCount)
{
 8026c18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8026c1a:	0004      	movs	r4, r0
 8026c1c:	000f      	movs	r7, r1
 8026c1e:	0016      	movs	r6, r2
 8026c20:	001d      	movs	r5, r3
#if defined(KMS_SEARCH)
  kms_find_ctx_t *p_ctx;
  uint32_t i;

  if (!KMS_IS_INITIALIZED())
 8026c22:	4b22      	ldr	r3, [pc, #136]	; (8026cac <KMS_FindObjects+0x94>)
 8026c24:	781b      	ldrb	r3, [r3, #0]
 8026c26:	2b00      	cmp	r3, #0
 8026c28:	d031      	beq.n	8026c8e <KMS_FindObjects+0x76>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 8026c2a:	f000 fc3f 	bl	80274ac <KMS_CheckSessionHdle>
 8026c2e:	2800      	cmp	r0, #0
 8026c30:	d130      	bne.n	8026c94 <KMS_FindObjects+0x7c>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* Check if there is a pending operation: i.e. FindObjectInit was called */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_SEARCH)
 8026c32:	3c01      	subs	r4, #1
 8026c34:	00e3      	lsls	r3, r4, #3
 8026c36:	191b      	adds	r3, r3, r4
 8026c38:	009b      	lsls	r3, r3, #2
 8026c3a:	4a1c      	ldr	r2, [pc, #112]	; (8026cac <KMS_FindObjects+0x94>)
 8026c3c:	18d3      	adds	r3, r2, r3
 8026c3e:	68db      	ldr	r3, [r3, #12]
 8026c40:	2b06      	cmp	r3, #6
 8026c42:	d129      	bne.n	8026c98 <KMS_FindObjects+0x80>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }

  /* Check input parameters */
  if ((phObject == NULL_PTR) || (pulObjectCount == NULL_PTR) || (ulMaxObjectCount <= 0UL))
 8026c44:	2f00      	cmp	r7, #0
 8026c46:	d02a      	beq.n	8026c9e <KMS_FindObjects+0x86>
 8026c48:	2d00      	cmp	r5, #0
 8026c4a:	d02a      	beq.n	8026ca2 <KMS_FindObjects+0x8a>
 8026c4c:	2e00      	cmp	r6, #0
 8026c4e:	d02a      	beq.n	8026ca6 <KMS_FindObjects+0x8e>
  {
    return CKR_ARGUMENTS_BAD;
  }

  /* ========== Get active operation objects ========== */
  p_ctx = KMS_GETSESSION(hSession).pCtx;
 8026c50:	00e3      	lsls	r3, r4, #3
 8026c52:	191c      	adds	r4, r3, r4
 8026c54:	00a4      	lsls	r4, r4, #2
 8026c56:	1914      	adds	r4, r2, r4
 8026c58:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  *pulObjectCount = 0;
 8026c5a:	2300      	movs	r3, #0
 8026c5c:	602b      	str	r3, [r5, #0]
  for (i = p_ctx->searchIndex; (i < (sizeof(p_ctx->searchHandles) / sizeof(CK_OBJECT_HANDLE)))
 8026c5e:	3315      	adds	r3, #21
 8026c60:	33ff      	adds	r3, #255	; 0xff
 8026c62:	58cc      	ldr	r4, [r1, r3]
 8026c64:	e000      	b.n	8026c68 <KMS_FindObjects+0x50>
       && (*pulObjectCount < ulMaxObjectCount); i++)
 8026c66:	3401      	adds	r4, #1
  for (i = p_ctx->searchIndex; (i < (sizeof(p_ctx->searchHandles) / sizeof(CK_OBJECT_HANDLE)))
 8026c68:	2c44      	cmp	r4, #68	; 0x44
 8026c6a:	d80c      	bhi.n	8026c86 <KMS_FindObjects+0x6e>
       && (*pulObjectCount < ulMaxObjectCount); i++)
 8026c6c:	682b      	ldr	r3, [r5, #0]
 8026c6e:	42b3      	cmp	r3, r6
 8026c70:	d209      	bcs.n	8026c86 <KMS_FindObjects+0x6e>
  {
    if (p_ctx->searchHandles[i] != KMS_HANDLE_KEY_NOT_KNOWN)
 8026c72:	00a2      	lsls	r2, r4, #2
 8026c74:	5852      	ldr	r2, [r2, r1]
 8026c76:	2a00      	cmp	r2, #0
 8026c78:	d0f5      	beq.n	8026c66 <KMS_FindObjects+0x4e>
    {
      phObject[*pulObjectCount] = p_ctx->searchHandles[i];
 8026c7a:	009b      	lsls	r3, r3, #2
 8026c7c:	50fa      	str	r2, [r7, r3]
      *pulObjectCount += 1UL;
 8026c7e:	682b      	ldr	r3, [r5, #0]
 8026c80:	3301      	adds	r3, #1
 8026c82:	602b      	str	r3, [r5, #0]
 8026c84:	e7ef      	b.n	8026c66 <KMS_FindObjects+0x4e>
    }
  }
  /* Update searchIndex to filter out already transmitted values */
  p_ctx->searchIndex = i;
 8026c86:	238a      	movs	r3, #138	; 0x8a
 8026c88:	005b      	lsls	r3, r3, #1
 8026c8a:	50cc      	str	r4, [r1, r3]

  return CKR_OK;
 8026c8c:	e001      	b.n	8026c92 <KMS_FindObjects+0x7a>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8026c8e:	20c8      	movs	r0, #200	; 0xc8
 8026c90:	0040      	lsls	r0, r0, #1
#else /* KMS_SEARCH */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_SEARCH */
}
 8026c92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8026c94:	20b3      	movs	r0, #179	; 0xb3
 8026c96:	e7fc      	b.n	8026c92 <KMS_FindObjects+0x7a>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8026c98:	20c8      	movs	r0, #200	; 0xc8
 8026c9a:	0040      	lsls	r0, r0, #1
 8026c9c:	e7f9      	b.n	8026c92 <KMS_FindObjects+0x7a>
    return CKR_ARGUMENTS_BAD;
 8026c9e:	2007      	movs	r0, #7
 8026ca0:	e7f7      	b.n	8026c92 <KMS_FindObjects+0x7a>
 8026ca2:	2007      	movs	r0, #7
 8026ca4:	e7f5      	b.n	8026c92 <KMS_FindObjects+0x7a>
 8026ca6:	2007      	movs	r0, #7
 8026ca8:	e7f3      	b.n	8026c92 <KMS_FindObjects+0x7a>
 8026caa:	46c0      	nop			; (mov r8, r8)
 8026cac:	2000b300 	.word	0x2000b300

08026cb0 <KMS_FindObjectsFinal>:
  *         CKR_CRYPTOKI_NOT_INITIALIZED
  *         CKR_FUNCTION_NOT_SUPPORTED
  *         CKR_SESSION_HANDLE_INVALID
  */
CK_RV KMS_FindObjectsFinal(CK_SESSION_HANDLE hSession)
{
 8026cb0:	b570      	push	{r4, r5, r6, lr}
 8026cb2:	0004      	movs	r4, r0
#if defined(KMS_SEARCH)
  /* ========== Check active operation status ========== */

  if (!KMS_IS_INITIALIZED())
 8026cb4:	4b17      	ldr	r3, [pc, #92]	; (8026d14 <KMS_FindObjectsFinal+0x64>)
 8026cb6:	781b      	ldrb	r3, [r3, #0]
 8026cb8:	2b00      	cmp	r3, #0
 8026cba:	d021      	beq.n	8026d00 <KMS_FindObjectsFinal+0x50>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 8026cbc:	f000 fbf6 	bl	80274ac <KMS_CheckSessionHdle>
 8026cc0:	1e05      	subs	r5, r0, #0
 8026cc2:	d121      	bne.n	8026d08 <KMS_FindObjectsFinal+0x58>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* Check if there is a pending operation: i.e. FindObjectInit was called*/
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_SEARCH)
 8026cc4:	1e66      	subs	r6, r4, #1
 8026cc6:	00f3      	lsls	r3, r6, #3
 8026cc8:	199b      	adds	r3, r3, r6
 8026cca:	009b      	lsls	r3, r3, #2
 8026ccc:	4a11      	ldr	r2, [pc, #68]	; (8026d14 <KMS_FindObjectsFinal+0x64>)
 8026cce:	18d3      	adds	r3, r2, r3
 8026cd0:	68db      	ldr	r3, [r3, #12]
 8026cd2:	2b06      	cmp	r3, #6
 8026cd4:	d11a      	bne.n	8026d0c <KMS_FindObjectsFinal+0x5c>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }

  if (KMS_GETSESSION(hSession).pCtx != NULL_PTR)
 8026cd6:	00f3      	lsls	r3, r6, #3
 8026cd8:	199b      	adds	r3, r3, r6
 8026cda:	009b      	lsls	r3, r3, #2
 8026cdc:	18d3      	adds	r3, r2, r3
 8026cde:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8026ce0:	2900      	cmp	r1, #0
 8026ce2:	d009      	beq.n	8026cf8 <KMS_FindObjectsFinal+0x48>
  {
    KMS_Free(hSession, KMS_GETSESSION(hSession).pCtx);
 8026ce4:	0020      	movs	r0, r4
 8026ce6:	f000 fd5d 	bl	80277a4 <KMS_Free>
    KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8026cea:	00f3      	lsls	r3, r6, #3
 8026cec:	199e      	adds	r6, r3, r6
 8026cee:	00b6      	lsls	r6, r6, #2
 8026cf0:	4b08      	ldr	r3, [pc, #32]	; (8026d14 <KMS_FindObjectsFinal+0x64>)
 8026cf2:	199e      	adds	r6, r3, r6
 8026cf4:	2300      	movs	r3, #0
 8026cf6:	62b3      	str	r3, [r6, #40]	; 0x28
  }

  KMS_SetStateIdle(hSession);
 8026cf8:	0020      	movs	r0, r4
 8026cfa:	f000 fc1f 	bl	802753c <KMS_SetStateIdle>

  return CKR_OK;
 8026cfe:	e001      	b.n	8026d04 <KMS_FindObjectsFinal+0x54>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8026d00:	25c8      	movs	r5, #200	; 0xc8
 8026d02:	006d      	lsls	r5, r5, #1
#else /* KMS_SEARCH */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_SEARCH */
}
 8026d04:	0028      	movs	r0, r5
 8026d06:	bd70      	pop	{r4, r5, r6, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8026d08:	25b3      	movs	r5, #179	; 0xb3
 8026d0a:	e7fb      	b.n	8026d04 <KMS_FindObjectsFinal+0x54>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8026d0c:	25c8      	movs	r5, #200	; 0xc8
 8026d0e:	006d      	lsls	r5, r5, #1
 8026d10:	e7f8      	b.n	8026d04 <KMS_FindObjectsFinal+0x54>
 8026d12:	46c0      	nop			; (mov r8, r8)
 8026d14:	2000b300 	.word	0x2000b300

08026d18 <encrypt_decrypt_init>:
  */
static CK_RV encrypt_decrypt_init(CK_SESSION_HANDLE hSession,
                                  CK_MECHANISM_PTR pMechanism,
                                  CK_OBJECT_HANDLE hKey,
                                  int32_t encdec_flag)
{
 8026d18:	b5f0      	push	{r4, r5, r6, r7, lr}
 8026d1a:	46d6      	mov	lr, sl
 8026d1c:	b500      	push	{lr}
 8026d1e:	b084      	sub	sp, #16
 8026d20:	0004      	movs	r4, r0
 8026d22:	000d      	movs	r5, r1
 8026d24:	9200      	str	r2, [sp, #0]
 8026d26:	9301      	str	r3, [sp, #4]
  CK_RV e_ret_status = CKR_FUNCTION_FAILED;

  if (!KMS_IS_INITIALIZED())
 8026d28:	4ba6      	ldr	r3, [pc, #664]	; (8026fc4 <encrypt_decrypt_init+0x2ac>)
 8026d2a:	781b      	ldrb	r3, [r3, #0]
 8026d2c:	2b00      	cmp	r3, #0
 8026d2e:	d100      	bne.n	8026d32 <encrypt_decrypt_init+0x1a>
 8026d30:	e1d8      	b.n	80270e4 <encrypt_decrypt_init+0x3cc>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 8026d32:	f000 fbbb 	bl	80274ac <KMS_CheckSessionHdle>
 8026d36:	2800      	cmp	r0, #0
 8026d38:	d000      	beq.n	8026d3c <encrypt_decrypt_init+0x24>
 8026d3a:	e1da      	b.n	80270f2 <encrypt_decrypt_init+0x3da>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_IDLE)
 8026d3c:	1e66      	subs	r6, r4, #1
 8026d3e:	00f3      	lsls	r3, r6, #3
 8026d40:	199b      	adds	r3, r3, r6
 8026d42:	009b      	lsls	r3, r3, #2
 8026d44:	4a9f      	ldr	r2, [pc, #636]	; (8026fc4 <encrypt_decrypt_init+0x2ac>)
 8026d46:	18d3      	adds	r3, r2, r3
 8026d48:	68db      	ldr	r3, [r3, #12]
 8026d4a:	2b00      	cmp	r3, #0
 8026d4c:	d000      	beq.n	8026d50 <encrypt_decrypt_init+0x38>
 8026d4e:	e1d2      	b.n	80270f6 <encrypt_decrypt_init+0x3de>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* Check parameter */
  if (pMechanism == NULL_PTR)
 8026d50:	2d00      	cmp	r5, #0
 8026d52:	d100      	bne.n	8026d56 <encrypt_decrypt_init+0x3e>
 8026d54:	e1d1      	b.n	80270fa <encrypt_decrypt_init+0x3e2>
  {
    return CKR_ARGUMENTS_BAD;
  }
  switch (pMechanism->mechanism)
 8026d56:	682b      	ldr	r3, [r5, #0]
 8026d58:	4a9b      	ldr	r2, [pc, #620]	; (8026fc8 <encrypt_decrypt_init+0x2b0>)
 8026d5a:	4293      	cmp	r3, r2
 8026d5c:	d009      	beq.n	8026d72 <encrypt_decrypt_init+0x5a>
 8026d5e:	4a9b      	ldr	r2, [pc, #620]	; (8026fcc <encrypt_decrypt_init+0x2b4>)
 8026d60:	4293      	cmp	r3, r2
 8026d62:	d100      	bne.n	8026d66 <encrypt_decrypt_init+0x4e>
 8026d64:	e100      	b.n	8026f68 <encrypt_decrypt_init+0x250>
 8026d66:	4a9a      	ldr	r2, [pc, #616]	; (8026fd0 <encrypt_decrypt_init+0x2b8>)
 8026d68:	4293      	cmp	r3, r2
 8026d6a:	d100      	bne.n	8026d6e <encrypt_decrypt_init+0x56>
 8026d6c:	e081      	b.n	8026e72 <encrypt_decrypt_init+0x15a>
 8026d6e:	2770      	movs	r7, #112	; 0x70
 8026d70:	e1ba      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
      kms_attr_t *P_pKeyAttribute;
      kms_aes_cbc_ec_ctx_t *p_ctx;

      /* Read the key value from the Key Handle                 */
      /* Key Handle is the index to one of static or nvm        */
      pkms_object = KMS_Objects_GetPointer(hKey);
 8026d72:	9800      	ldr	r0, [sp, #0]
 8026d74:	f001 fb44 	bl	8028400 <KMS_Objects_GetPointer>

      /* Check that hKey is valid:
       * - NULL_PTR value means not found key handle
       * - KMS_ABI_VERSION_CK_2_40 & KMS_ABI_CONFIG_KEYHEAD are magic in header of the key
       */
      if ((pkms_object != NULL_PTR) &&
 8026d78:	2800      	cmp	r0, #0
 8026d7a:	d005      	beq.n	8026d88 <encrypt_decrypt_init+0x70>
 8026d7c:	4b95      	ldr	r3, [pc, #596]	; (8026fd4 <encrypt_decrypt_init+0x2bc>)
 8026d7e:	6802      	ldr	r2, [r0, #0]
 8026d80:	429a      	cmp	r2, r3
 8026d82:	d003      	beq.n	8026d8c <encrypt_decrypt_init+0x74>
        }
      }
      else
      {
        /* Can not retrieve proper key handle */
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8026d84:	2782      	movs	r7, #130	; 0x82
 8026d86:	e1af      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
 8026d88:	2782      	movs	r7, #130	; 0x82
 8026d8a:	e1ad      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
          (pkms_object->version == KMS_ABI_VERSION_CK_2_40) &&
 8026d8c:	4b92      	ldr	r3, [pc, #584]	; (8026fd8 <encrypt_decrypt_init+0x2c0>)
 8026d8e:	6842      	ldr	r2, [r0, #4]
 8026d90:	429a      	cmp	r2, r3
 8026d92:	d001      	beq.n	8026d98 <encrypt_decrypt_init+0x80>
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8026d94:	2782      	movs	r7, #130	; 0x82
 8026d96:	e1a7      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
        if ((pMechanism->pParameter != NULL_PTR) &&
 8026d98:	686b      	ldr	r3, [r5, #4]
 8026d9a:	2b00      	cmp	r3, #0
 8026d9c:	d004      	beq.n	8026da8 <encrypt_decrypt_init+0x90>
 8026d9e:	68ab      	ldr	r3, [r5, #8]
 8026da0:	2b00      	cmp	r3, #0
 8026da2:	d103      	bne.n	8026dac <encrypt_decrypt_init+0x94>
          e_ret_status = CKR_ARGUMENTS_BAD;
 8026da4:	2707      	movs	r7, #7
 8026da6:	e19f      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
 8026da8:	2707      	movs	r7, #7
 8026daa:	e19d      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
          e_ret_status = KMS_Objects_SearchAttributes(CKA_VALUE, pkms_object, &P_pKeyAttribute);
 8026dac:	aa03      	add	r2, sp, #12
 8026dae:	0001      	movs	r1, r0
 8026db0:	2011      	movs	r0, #17
 8026db2:	f001 fb82 	bl	80284ba <KMS_Objects_SearchAttributes>
 8026db6:	1e07      	subs	r7, r0, #0
          if (e_ret_status == CKR_OK)
 8026db8:	d000      	beq.n	8026dbc <encrypt_decrypt_init+0xa4>
 8026dba:	e149      	b.n	8027050 <encrypt_decrypt_init+0x338>
            if ((P_pKeyAttribute->size == CA_CRL_AES128_KEY) ||     /* 128 bits */
 8026dbc:	9b03      	ldr	r3, [sp, #12]
 8026dbe:	685b      	ldr	r3, [r3, #4]
 8026dc0:	2b10      	cmp	r3, #16
 8026dc2:	d005      	beq.n	8026dd0 <encrypt_decrypt_init+0xb8>
 8026dc4:	2b18      	cmp	r3, #24
 8026dc6:	d003      	beq.n	8026dd0 <encrypt_decrypt_init+0xb8>
                (P_pKeyAttribute->size == CA_CRL_AES192_KEY) ||     /* 192 bits */
 8026dc8:	2b20      	cmp	r3, #32
 8026dca:	d001      	beq.n	8026dd0 <encrypt_decrypt_init+0xb8>
              e_ret_status = CKR_ARGUMENTS_BAD;
 8026dcc:	3707      	adds	r7, #7
 8026dce:	e18b      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
              p_ctx = KMS_Alloc(hSession, sizeof(kms_aes_cbc_ec_ctx_t));
 8026dd0:	21c4      	movs	r1, #196	; 0xc4
 8026dd2:	0049      	lsls	r1, r1, #1
 8026dd4:	0020      	movs	r0, r4
 8026dd6:	f000 fcbf 	bl	8027758 <KMS_Alloc>
 8026dda:	4682      	mov	sl, r0
              if (p_ctx == NULL_PTR)
 8026ddc:	2800      	cmp	r0, #0
 8026dde:	d046      	beq.n	8026e6e <encrypt_decrypt_init+0x156>
              KMS_GETSESSION(hSession).hKey = hKey;
 8026de0:	00f3      	lsls	r3, r6, #3
 8026de2:	199b      	adds	r3, r3, r6
 8026de4:	009a      	lsls	r2, r3, #2
 8026de6:	4b77      	ldr	r3, [pc, #476]	; (8026fc4 <encrypt_decrypt_init+0x2ac>)
 8026de8:	189b      	adds	r3, r3, r2
 8026dea:	9a00      	ldr	r2, [sp, #0]
 8026dec:	625a      	str	r2, [r3, #36]	; 0x24
              KMS_GETSESSION(hSession).Mechanism = pMechanism->mechanism;
 8026dee:	682a      	ldr	r2, [r5, #0]
 8026df0:	621a      	str	r2, [r3, #32]
              KMS_GETSESSION(hSession).pCtx = p_ctx;
 8026df2:	6298      	str	r0, [r3, #40]	; 0x28
              p_ctx->ca_ctx.mFlags = CA_E_SK_DEFAULT;
 8026df4:	2324      	movs	r3, #36	; 0x24
 8026df6:	2200      	movs	r2, #0
 8026df8:	0001      	movs	r1, r0
 8026dfa:	54c2      	strb	r2, [r0, r3]
              p_ctx->ca_ctx.mKeySize = (int32_t)P_pKeyAttribute->size ;
 8026dfc:	9803      	ldr	r0, [sp, #12]
 8026dfe:	6842      	ldr	r2, [r0, #4]
 8026e00:	644a      	str	r2, [r1, #68]	; 0x44
              p_ctx->ca_ctx.pmKey = p_ctx->key;
 8026e02:	6289      	str	r1, [r1, #40]	; 0x28
              KMS_Objects_BlobU32_2_u8ptr(&(P_pKeyAttribute->data[0]), P_pKeyAttribute->size, p_ctx->key);
 8026e04:	6841      	ldr	r1, [r0, #4]
 8026e06:	3008      	adds	r0, #8
 8026e08:	4652      	mov	r2, sl
 8026e0a:	f001 fc3d 	bl	8028688 <KMS_Objects_BlobU32_2_u8ptr>
              p_ctx->ca_ctx.mIvSize = (int32_t)pMechanism->ulParameterLen;
 8026e0e:	4653      	mov	r3, sl
 8026e10:	68aa      	ldr	r2, [r5, #8]
 8026e12:	631a      	str	r2, [r3, #48]	; 0x30
              if (encdec_flag == KMS_FLAG_ENCRYPT)
 8026e14:	9b01      	ldr	r3, [sp, #4]
 8026e16:	2b00      	cmp	r3, #0
 8026e18:	d114      	bne.n	8026e44 <encrypt_decrypt_init+0x12c>
                                            pMechanism->pParameter) == CA_AES_SUCCESS)
 8026e1a:	686a      	ldr	r2, [r5, #4]
                if (CA_AES_CBC_Encrypt_Init(&(p_ctx->ca_ctx),
 8026e1c:	4650      	mov	r0, sl
 8026e1e:	3020      	adds	r0, #32
 8026e20:	4651      	mov	r1, sl
 8026e22:	f7fe ff7b 	bl	8025d1c <CA_AES_CBC_Encrypt_Init>
 8026e26:	2800      	cmp	r0, #0
 8026e28:	d100      	bne.n	8026e2c <encrypt_decrypt_init+0x114>
 8026e2a:	e113      	b.n	8027054 <encrypt_decrypt_init+0x33c>
                  KMS_Free(hSession, p_ctx);
 8026e2c:	4651      	mov	r1, sl
 8026e2e:	0020      	movs	r0, r4
 8026e30:	f000 fcb8 	bl	80277a4 <KMS_Free>
                  KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8026e34:	2324      	movs	r3, #36	; 0x24
 8026e36:	435e      	muls	r6, r3
 8026e38:	4b62      	ldr	r3, [pc, #392]	; (8026fc4 <encrypt_decrypt_init+0x2ac>)
 8026e3a:	199b      	adds	r3, r3, r6
 8026e3c:	2200      	movs	r2, #0
 8026e3e:	629a      	str	r2, [r3, #40]	; 0x28
                  e_ret_status = CKR_FUNCTION_FAILED;
 8026e40:	2706      	movs	r7, #6
 8026e42:	e151      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
                                            pMechanism->pParameter) == CA_AES_SUCCESS)
 8026e44:	686a      	ldr	r2, [r5, #4]
                if (CA_AES_CBC_Decrypt_Init(&(p_ctx->ca_ctx),
 8026e46:	4650      	mov	r0, sl
 8026e48:	3020      	adds	r0, #32
 8026e4a:	4651      	mov	r1, sl
 8026e4c:	f7ff f862 	bl	8025f14 <CA_AES_CBC_Decrypt_Init>
 8026e50:	2800      	cmp	r0, #0
 8026e52:	d100      	bne.n	8026e56 <encrypt_decrypt_init+0x13e>
 8026e54:	e0fe      	b.n	8027054 <encrypt_decrypt_init+0x33c>
                  KMS_Free(hSession, p_ctx);
 8026e56:	4651      	mov	r1, sl
 8026e58:	0020      	movs	r0, r4
 8026e5a:	f000 fca3 	bl	80277a4 <KMS_Free>
                  KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8026e5e:	2324      	movs	r3, #36	; 0x24
 8026e60:	435e      	muls	r6, r3
 8026e62:	4b58      	ldr	r3, [pc, #352]	; (8026fc4 <encrypt_decrypt_init+0x2ac>)
 8026e64:	199b      	adds	r3, r3, r6
 8026e66:	2200      	movs	r2, #0
 8026e68:	629a      	str	r2, [r3, #40]	; 0x28
                  e_ret_status = CKR_FUNCTION_FAILED;
 8026e6a:	2706      	movs	r7, #6
 8026e6c:	e13c      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
                e_ret_status = CKR_DEVICE_MEMORY;
 8026e6e:	2731      	movs	r7, #49	; 0x31
 8026e70:	e13a      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
      kms_obj_keyhead_t *pkms_object;
      kms_attr_t *P_pKeyAttribute;
      kms_aes_ecb_ec_ctx_t *p_ctx;

      /* Read the key value from the Key Handle                 */
      pkms_object = KMS_Objects_GetPointer(hKey);
 8026e72:	9800      	ldr	r0, [sp, #0]
 8026e74:	f001 fac4 	bl	8028400 <KMS_Objects_GetPointer>

      /* Check that hKey is valid:
       * - NULL_PTR value means not found key handle
       * - KMS_ABI_VERSION_CK_2_40 & KMS_ABI_CONFIG_KEYHEAD are magic in header of the key
       */
      if ((pkms_object != NULL_PTR) &&
 8026e78:	2800      	cmp	r0, #0
 8026e7a:	d005      	beq.n	8026e88 <encrypt_decrypt_init+0x170>
 8026e7c:	4b55      	ldr	r3, [pc, #340]	; (8026fd4 <encrypt_decrypt_init+0x2bc>)
 8026e7e:	6802      	ldr	r2, [r0, #0]
 8026e80:	429a      	cmp	r2, r3
 8026e82:	d003      	beq.n	8026e8c <encrypt_decrypt_init+0x174>
        }
      }
      else
      {
        /* Can not retrieve proper key handle */
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8026e84:	2782      	movs	r7, #130	; 0x82
 8026e86:	e12f      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
 8026e88:	2782      	movs	r7, #130	; 0x82
 8026e8a:	e12d      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
          (pkms_object->version == KMS_ABI_VERSION_CK_2_40) &&
 8026e8c:	4b52      	ldr	r3, [pc, #328]	; (8026fd8 <encrypt_decrypt_init+0x2c0>)
 8026e8e:	6842      	ldr	r2, [r0, #4]
 8026e90:	429a      	cmp	r2, r3
 8026e92:	d001      	beq.n	8026e98 <encrypt_decrypt_init+0x180>
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8026e94:	2782      	movs	r7, #130	; 0x82
 8026e96:	e127      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
        if ((pMechanism->pParameter == NULL_PTR) &&
 8026e98:	686b      	ldr	r3, [r5, #4]
 8026e9a:	2b00      	cmp	r3, #0
 8026e9c:	d001      	beq.n	8026ea2 <encrypt_decrypt_init+0x18a>
          e_ret_status = CKR_ARGUMENTS_BAD;
 8026e9e:	2707      	movs	r7, #7
 8026ea0:	e122      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
        if ((pMechanism->pParameter == NULL_PTR) &&
 8026ea2:	68ab      	ldr	r3, [r5, #8]
 8026ea4:	2b00      	cmp	r3, #0
 8026ea6:	d001      	beq.n	8026eac <encrypt_decrypt_init+0x194>
          e_ret_status = CKR_ARGUMENTS_BAD;
 8026ea8:	2707      	movs	r7, #7
 8026eaa:	e11d      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
          e_ret_status = KMS_Objects_SearchAttributes(CKA_VALUE, pkms_object, &P_pKeyAttribute);
 8026eac:	aa03      	add	r2, sp, #12
 8026eae:	0001      	movs	r1, r0
 8026eb0:	2011      	movs	r0, #17
 8026eb2:	f001 fb02 	bl	80284ba <KMS_Objects_SearchAttributes>
 8026eb6:	1e07      	subs	r7, r0, #0
          if (e_ret_status == CKR_OK)
 8026eb8:	d000      	beq.n	8026ebc <encrypt_decrypt_init+0x1a4>
 8026eba:	e0c9      	b.n	8027050 <encrypt_decrypt_init+0x338>
            if ((P_pKeyAttribute->size == CA_CRL_AES128_KEY) ||     /* 128 bits */
 8026ebc:	9b03      	ldr	r3, [sp, #12]
 8026ebe:	685b      	ldr	r3, [r3, #4]
 8026ec0:	2b10      	cmp	r3, #16
 8026ec2:	d005      	beq.n	8026ed0 <encrypt_decrypt_init+0x1b8>
 8026ec4:	2b18      	cmp	r3, #24
 8026ec6:	d003      	beq.n	8026ed0 <encrypt_decrypt_init+0x1b8>
                (P_pKeyAttribute->size == CA_CRL_AES192_KEY) ||     /* 192 bits */
 8026ec8:	2b20      	cmp	r3, #32
 8026eca:	d001      	beq.n	8026ed0 <encrypt_decrypt_init+0x1b8>
              e_ret_status = CKR_ARGUMENTS_BAD;
 8026ecc:	3707      	adds	r7, #7
 8026ece:	e10b      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
              p_ctx = KMS_Alloc(hSession, sizeof(kms_aes_ecb_ec_ctx_t));
 8026ed0:	21c4      	movs	r1, #196	; 0xc4
 8026ed2:	0049      	lsls	r1, r1, #1
 8026ed4:	0020      	movs	r0, r4
 8026ed6:	f000 fc3f 	bl	8027758 <KMS_Alloc>
 8026eda:	4682      	mov	sl, r0
              if (p_ctx == NULL_PTR)
 8026edc:	2800      	cmp	r0, #0
 8026ede:	d041      	beq.n	8026f64 <encrypt_decrypt_init+0x24c>
              KMS_GETSESSION(hSession).hKey = hKey;
 8026ee0:	2224      	movs	r2, #36	; 0x24
 8026ee2:	0011      	movs	r1, r2
 8026ee4:	4371      	muls	r1, r6
 8026ee6:	4b37      	ldr	r3, [pc, #220]	; (8026fc4 <encrypt_decrypt_init+0x2ac>)
 8026ee8:	185b      	adds	r3, r3, r1
 8026eea:	9900      	ldr	r1, [sp, #0]
 8026eec:	6259      	str	r1, [r3, #36]	; 0x24
              KMS_GETSESSION(hSession).Mechanism = pMechanism->mechanism;
 8026eee:	6829      	ldr	r1, [r5, #0]
 8026ef0:	6219      	str	r1, [r3, #32]
              KMS_GETSESSION(hSession).pCtx = p_ctx;
 8026ef2:	6298      	str	r0, [r3, #40]	; 0x28
              p_ctx->ca_ctx.mFlags = CA_E_SK_DEFAULT;
 8026ef4:	2300      	movs	r3, #0
 8026ef6:	5483      	strb	r3, [r0, r2]
              p_ctx->ca_ctx.mKeySize = (int32_t)P_pKeyAttribute->size ;
 8026ef8:	9b03      	ldr	r3, [sp, #12]
 8026efa:	0002      	movs	r2, r0
 8026efc:	6859      	ldr	r1, [r3, #4]
 8026efe:	6441      	str	r1, [r0, #68]	; 0x44
              KMS_Objects_BlobU32_2_u8ptr(&(P_pKeyAttribute->data[0]), P_pKeyAttribute->size, p_ctx->key);
 8026f00:	0018      	movs	r0, r3
 8026f02:	3008      	adds	r0, #8
 8026f04:	6859      	ldr	r1, [r3, #4]
 8026f06:	f001 fbbf 	bl	8028688 <KMS_Objects_BlobU32_2_u8ptr>
              if (encdec_flag == KMS_FLAG_ENCRYPT)
 8026f0a:	9b01      	ldr	r3, [sp, #4]
 8026f0c:	2b00      	cmp	r3, #0
 8026f0e:	d114      	bne.n	8026f3a <encrypt_decrypt_init+0x222>
                if (CA_AES_ECB_Encrypt_Init(&(p_ctx->ca_ctx),
 8026f10:	4650      	mov	r0, sl
 8026f12:	3020      	adds	r0, #32
 8026f14:	2200      	movs	r2, #0
 8026f16:	4651      	mov	r1, sl
 8026f18:	f7ff f974 	bl	8026204 <CA_AES_ECB_Encrypt_Init>
 8026f1c:	2800      	cmp	r0, #0
 8026f1e:	d100      	bne.n	8026f22 <encrypt_decrypt_init+0x20a>
 8026f20:	e098      	b.n	8027054 <encrypt_decrypt_init+0x33c>
                  KMS_Free(hSession, p_ctx);
 8026f22:	4651      	mov	r1, sl
 8026f24:	0020      	movs	r0, r4
 8026f26:	f000 fc3d 	bl	80277a4 <KMS_Free>
                  KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8026f2a:	2324      	movs	r3, #36	; 0x24
 8026f2c:	435e      	muls	r6, r3
 8026f2e:	4b25      	ldr	r3, [pc, #148]	; (8026fc4 <encrypt_decrypt_init+0x2ac>)
 8026f30:	199b      	adds	r3, r3, r6
 8026f32:	2200      	movs	r2, #0
 8026f34:	629a      	str	r2, [r3, #40]	; 0x28
                  e_ret_status = CKR_FUNCTION_FAILED;
 8026f36:	2706      	movs	r7, #6
 8026f38:	e0d6      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
                if (CA_AES_ECB_Decrypt_Init(&(p_ctx->ca_ctx),
 8026f3a:	4650      	mov	r0, sl
 8026f3c:	3020      	adds	r0, #32
 8026f3e:	2200      	movs	r2, #0
 8026f40:	4651      	mov	r1, sl
 8026f42:	f7ff fa15 	bl	8026370 <CA_AES_ECB_Decrypt_Init>
 8026f46:	2800      	cmp	r0, #0
 8026f48:	d100      	bne.n	8026f4c <encrypt_decrypt_init+0x234>
 8026f4a:	e083      	b.n	8027054 <encrypt_decrypt_init+0x33c>
                  KMS_Free(hSession, p_ctx);
 8026f4c:	4651      	mov	r1, sl
 8026f4e:	0020      	movs	r0, r4
 8026f50:	f000 fc28 	bl	80277a4 <KMS_Free>
                  KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8026f54:	2324      	movs	r3, #36	; 0x24
 8026f56:	435e      	muls	r6, r3
 8026f58:	4b1a      	ldr	r3, [pc, #104]	; (8026fc4 <encrypt_decrypt_init+0x2ac>)
 8026f5a:	199b      	adds	r3, r3, r6
 8026f5c:	2200      	movs	r2, #0
 8026f5e:	629a      	str	r2, [r3, #40]	; 0x28
                  e_ret_status = CKR_FUNCTION_FAILED;
 8026f60:	2706      	movs	r7, #6
 8026f62:	e0c1      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
                e_ret_status = CKR_DEVICE_MEMORY;
 8026f64:	2731      	movs	r7, #49	; 0x31
 8026f66:	e0bf      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
      kms_aes_gcm_ec_ctx_t *p_ctx;
      CK_GCM_PARAMS *pGCMParams;

      /* Read the key value from the Key Handle                 */
      /* Key Handle is the index to one of static or nvm        */
      pkms_object = KMS_Objects_GetPointer(hKey);
 8026f68:	9800      	ldr	r0, [sp, #0]
 8026f6a:	f001 fa49 	bl	8028400 <KMS_Objects_GetPointer>

      /* Check that hKey is valid:
       * - NULL_PTR value means not found key handle
       * - KMS_ABI_VERSION_CK_2_40 & KMS_ABI_CONFIG_KEYHEAD are magic in header of the key
       */
      if ((pkms_object != NULL_PTR) &&
 8026f6e:	2800      	cmp	r0, #0
 8026f70:	d005      	beq.n	8026f7e <encrypt_decrypt_init+0x266>
 8026f72:	4b18      	ldr	r3, [pc, #96]	; (8026fd4 <encrypt_decrypt_init+0x2bc>)
 8026f74:	6802      	ldr	r2, [r0, #0]
 8026f76:	429a      	cmp	r2, r3
 8026f78:	d003      	beq.n	8026f82 <encrypt_decrypt_init+0x26a>
        }
      }
      else
      {
        /* Can not retrieve proper key handle */
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8026f7a:	2782      	movs	r7, #130	; 0x82
 8026f7c:	e0b4      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
 8026f7e:	2782      	movs	r7, #130	; 0x82
 8026f80:	e0b2      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
          (pkms_object->version == KMS_ABI_VERSION_CK_2_40) &&
 8026f82:	4b15      	ldr	r3, [pc, #84]	; (8026fd8 <encrypt_decrypt_init+0x2c0>)
 8026f84:	6842      	ldr	r2, [r0, #4]
 8026f86:	429a      	cmp	r2, r3
 8026f88:	d001      	beq.n	8026f8e <encrypt_decrypt_init+0x276>
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8026f8a:	2782      	movs	r7, #130	; 0x82
 8026f8c:	e0ac      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
        if ((pMechanism->pParameter != NULL_PTR) &&
 8026f8e:	686b      	ldr	r3, [r5, #4]
 8026f90:	2b00      	cmp	r3, #0
 8026f92:	d004      	beq.n	8026f9e <encrypt_decrypt_init+0x286>
 8026f94:	68ab      	ldr	r3, [r5, #8]
 8026f96:	2b00      	cmp	r3, #0
 8026f98:	d103      	bne.n	8026fa2 <encrypt_decrypt_init+0x28a>
          e_ret_status = CKR_ARGUMENTS_BAD;
 8026f9a:	2707      	movs	r7, #7
 8026f9c:	e0a4      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
 8026f9e:	2707      	movs	r7, #7
 8026fa0:	e0a2      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
          e_ret_status = KMS_Objects_SearchAttributes(CKA_VALUE, pkms_object, &P_pKeyAttribute);
 8026fa2:	aa03      	add	r2, sp, #12
 8026fa4:	0001      	movs	r1, r0
 8026fa6:	2011      	movs	r0, #17
 8026fa8:	f001 fa87 	bl	80284ba <KMS_Objects_SearchAttributes>
 8026fac:	1e07      	subs	r7, r0, #0
          if (e_ret_status == CKR_OK)
 8026fae:	d14f      	bne.n	8027050 <encrypt_decrypt_init+0x338>
            if ((P_pKeyAttribute->size == CA_CRL_AES128_KEY) ||     /* 128 bits */
 8026fb0:	9b03      	ldr	r3, [sp, #12]
 8026fb2:	685b      	ldr	r3, [r3, #4]
 8026fb4:	2b10      	cmp	r3, #16
 8026fb6:	d011      	beq.n	8026fdc <encrypt_decrypt_init+0x2c4>
 8026fb8:	2b18      	cmp	r3, #24
 8026fba:	d00f      	beq.n	8026fdc <encrypt_decrypt_init+0x2c4>
                (P_pKeyAttribute->size == CA_CRL_AES192_KEY) ||     /* 192 bits */
 8026fbc:	2b20      	cmp	r3, #32
 8026fbe:	d00d      	beq.n	8026fdc <encrypt_decrypt_init+0x2c4>
              e_ret_status = CKR_ARGUMENTS_BAD;
 8026fc0:	3707      	adds	r7, #7
 8026fc2:	e091      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
 8026fc4:	2000b300 	.word	0x2000b300
 8026fc8:	00001082 	.word	0x00001082
 8026fcc:	00001087 	.word	0x00001087
 8026fd0:	00001081 	.word	0x00001081
 8026fd4:	b10b0240 	.word	0xb10b0240
 8026fd8:	b10b0003 	.word	0xb10b0003
              p_ctx = KMS_Alloc(hSession, sizeof(kms_aes_gcm_ec_ctx_t));
 8026fdc:	21ca      	movs	r1, #202	; 0xca
 8026fde:	0049      	lsls	r1, r1, #1
 8026fe0:	0020      	movs	r0, r4
 8026fe2:	f000 fbb9 	bl	8027758 <KMS_Alloc>
 8026fe6:	4682      	mov	sl, r0
              if (p_ctx == NULL_PTR)
 8026fe8:	2800      	cmp	r0, #0
 8026fea:	d071      	beq.n	80270d0 <encrypt_decrypt_init+0x3b8>
              KMS_GETSESSION(hSession).hKey = hKey;
 8026fec:	00f3      	lsls	r3, r6, #3
 8026fee:	199b      	adds	r3, r3, r6
 8026ff0:	009a      	lsls	r2, r3, #2
 8026ff2:	4b43      	ldr	r3, [pc, #268]	; (8027100 <encrypt_decrypt_init+0x3e8>)
 8026ff4:	189b      	adds	r3, r3, r2
 8026ff6:	9a00      	ldr	r2, [sp, #0]
 8026ff8:	625a      	str	r2, [r3, #36]	; 0x24
              KMS_GETSESSION(hSession).Mechanism = pMechanism->mechanism;
 8026ffa:	682a      	ldr	r2, [r5, #0]
 8026ffc:	621a      	str	r2, [r3, #32]
              KMS_GETSESSION(hSession).pCtx = p_ctx;
 8026ffe:	6298      	str	r0, [r3, #40]	; 0x28
              pGCMParams = (CK_GCM_PARAMS *)pMechanism->pParameter;
 8027000:	686d      	ldr	r5, [r5, #4]
              p_ctx->ca_ctx.mFlags = CA_E_SK_DEFAULT;
 8027002:	2324      	movs	r3, #36	; 0x24
 8027004:	2200      	movs	r2, #0
 8027006:	0001      	movs	r1, r0
 8027008:	54c2      	strb	r2, [r0, r3]
              p_ctx->ca_ctx.mKeySize = (int32_t)P_pKeyAttribute->size ;
 802700a:	9803      	ldr	r0, [sp, #12]
 802700c:	6842      	ldr	r2, [r0, #4]
 802700e:	644a      	str	r2, [r1, #68]	; 0x44
              KMS_Objects_BlobU32_2_u8ptr(&(P_pKeyAttribute->data[0]), P_pKeyAttribute->size, p_ctx->key);
 8027010:	6841      	ldr	r1, [r0, #4]
 8027012:	3008      	adds	r0, #8
 8027014:	4652      	mov	r2, sl
 8027016:	f001 fb37 	bl	8028688 <KMS_Objects_BlobU32_2_u8ptr>
              p_ctx->ca_ctx.pmKey = p_ctx->key;
 802701a:	4653      	mov	r3, sl
 802701c:	629b      	str	r3, [r3, #40]	; 0x28
              p_ctx->ca_ctx.mIvSize = (int32_t)pGCMParams->ulIvLen;
 802701e:	686a      	ldr	r2, [r5, #4]
 8027020:	631a      	str	r2, [r3, #48]	; 0x30
              p_ctx->ca_ctx.mTagSize = ((int32_t)(pGCMParams->ulTagBits) / 8L);
 8027022:	692a      	ldr	r2, [r5, #16]
 8027024:	17d1      	asrs	r1, r2, #31
 8027026:	2307      	movs	r3, #7
 8027028:	400b      	ands	r3, r1
 802702a:	189b      	adds	r3, r3, r2
 802702c:	10db      	asrs	r3, r3, #3
 802702e:	4652      	mov	r2, sl
 8027030:	64d3      	str	r3, [r2, #76]	; 0x4c
              if (encdec_flag == KMS_FLAG_ENCRYPT)
 8027032:	9b01      	ldr	r3, [sp, #4]
 8027034:	2b00      	cmp	r3, #0
 8027036:	d124      	bne.n	8027082 <encrypt_decrypt_init+0x36a>
                if (CA_AES_GCM_Encrypt_Init(&(p_ctx->ca_ctx),
 8027038:	4650      	mov	r0, sl
 802703a:	3020      	adds	r0, #32
 802703c:	682a      	ldr	r2, [r5, #0]
 802703e:	4651      	mov	r1, sl
 8027040:	f7ff fa0e 	bl	8026460 <CA_AES_GCM_Encrypt_Init>
 8027044:	2800      	cmp	r0, #0
 8027046:	d110      	bne.n	802706a <encrypt_decrypt_init+0x352>
              if ((e_ret_status == CKR_OK) && (pGCMParams->ulAADLen != 0UL))
 8027048:	68ea      	ldr	r2, [r5, #12]
 802704a:	2a00      	cmp	r2, #0
 802704c:	d12d      	bne.n	80270aa <encrypt_decrypt_init+0x392>
 802704e:	0017      	movs	r7, r2
    {
      e_ret_status = CKR_MECHANISM_INVALID;
      break;
    }
  }
  if (e_ret_status == CKR_OK)
 8027050:	2f00      	cmp	r7, #0
 8027052:	d149      	bne.n	80270e8 <encrypt_decrypt_init+0x3d0>
  {
    /* If successful, set processing state of the session */
    if (encdec_flag == KMS_FLAG_ENCRYPT)
 8027054:	9b01      	ldr	r3, [sp, #4]
 8027056:	2b00      	cmp	r3, #0
 8027058:	d13c      	bne.n	80270d4 <encrypt_decrypt_init+0x3bc>
    {
      KMS_GETSESSION(hSession).state = KMS_SESSION_ENCRYPT;
 802705a:	00f3      	lsls	r3, r6, #3
 802705c:	199b      	adds	r3, r3, r6
 802705e:	009b      	lsls	r3, r3, #2
 8027060:	4a27      	ldr	r2, [pc, #156]	; (8027100 <encrypt_decrypt_init+0x3e8>)
 8027062:	18d3      	adds	r3, r2, r3
 8027064:	2202      	movs	r2, #2
 8027066:	60da      	str	r2, [r3, #12]
 8027068:	e03e      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
                  KMS_Free(hSession, p_ctx);
 802706a:	4651      	mov	r1, sl
 802706c:	0020      	movs	r0, r4
 802706e:	f000 fb99 	bl	80277a4 <KMS_Free>
                  KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8027072:	2224      	movs	r2, #36	; 0x24
 8027074:	4372      	muls	r2, r6
 8027076:	4b22      	ldr	r3, [pc, #136]	; (8027100 <encrypt_decrypt_init+0x3e8>)
 8027078:	189b      	adds	r3, r3, r2
 802707a:	2200      	movs	r2, #0
 802707c:	629a      	str	r2, [r3, #40]	; 0x28
                  e_ret_status = CKR_FUNCTION_FAILED;
 802707e:	2706      	movs	r7, #6
 8027080:	e7e6      	b.n	8027050 <encrypt_decrypt_init+0x338>
                if (CA_AES_GCM_Decrypt_Init(&(p_ctx->ca_ctx),
 8027082:	4650      	mov	r0, sl
 8027084:	3020      	adds	r0, #32
 8027086:	682a      	ldr	r2, [r5, #0]
 8027088:	4651      	mov	r1, sl
 802708a:	f7ff fb1f 	bl	80266cc <CA_AES_GCM_Decrypt_Init>
 802708e:	2800      	cmp	r0, #0
 8027090:	d0da      	beq.n	8027048 <encrypt_decrypt_init+0x330>
                  KMS_Free(hSession, p_ctx);
 8027092:	4651      	mov	r1, sl
 8027094:	0020      	movs	r0, r4
 8027096:	f000 fb85 	bl	80277a4 <KMS_Free>
                  KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 802709a:	2224      	movs	r2, #36	; 0x24
 802709c:	4372      	muls	r2, r6
 802709e:	4b18      	ldr	r3, [pc, #96]	; (8027100 <encrypt_decrypt_init+0x3e8>)
 80270a0:	189b      	adds	r3, r3, r2
 80270a2:	2200      	movs	r2, #0
 80270a4:	629a      	str	r2, [r3, #40]	; 0x28
                  e_ret_status = CKR_FUNCTION_FAILED;
 80270a6:	2706      	movs	r7, #6
 80270a8:	e7d2      	b.n	8027050 <encrypt_decrypt_init+0x338>
                                             pGCMParams->pAAD,
 80270aa:	68a9      	ldr	r1, [r5, #8]
                if (CA_AES_GCM_Header_Append(&(p_ctx->ca_ctx),
 80270ac:	4650      	mov	r0, sl
 80270ae:	3020      	adds	r0, #32
 80270b0:	f7ff fbce 	bl	8026850 <CA_AES_GCM_Header_Append>
 80270b4:	2800      	cmp	r0, #0
 80270b6:	d0cd      	beq.n	8027054 <encrypt_decrypt_init+0x33c>
                  KMS_Free(hSession, p_ctx);
 80270b8:	4651      	mov	r1, sl
 80270ba:	0020      	movs	r0, r4
 80270bc:	f000 fb72 	bl	80277a4 <KMS_Free>
                  KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 80270c0:	2324      	movs	r3, #36	; 0x24
 80270c2:	435e      	muls	r6, r3
 80270c4:	4b0e      	ldr	r3, [pc, #56]	; (8027100 <encrypt_decrypt_init+0x3e8>)
 80270c6:	199b      	adds	r3, r3, r6
 80270c8:	2200      	movs	r2, #0
 80270ca:	629a      	str	r2, [r3, #40]	; 0x28
                  e_ret_status = CKR_FUNCTION_FAILED;
 80270cc:	2706      	movs	r7, #6
 80270ce:	e00b      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
                e_ret_status = CKR_DEVICE_MEMORY;
 80270d0:	2731      	movs	r7, #49	; 0x31
 80270d2:	e009      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
    }
    else
    {
      KMS_GETSESSION(hSession).state = KMS_SESSION_DECRYPT;
 80270d4:	00f3      	lsls	r3, r6, #3
 80270d6:	199b      	adds	r3, r3, r6
 80270d8:	009b      	lsls	r3, r3, #2
 80270da:	4a09      	ldr	r2, [pc, #36]	; (8027100 <encrypt_decrypt_init+0x3e8>)
 80270dc:	18d3      	adds	r3, r2, r3
 80270de:	2203      	movs	r2, #3
 80270e0:	60da      	str	r2, [r3, #12]
 80270e2:	e001      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 80270e4:	27c8      	movs	r7, #200	; 0xc8
 80270e6:	007f      	lsls	r7, r7, #1
    }
  }

  return e_ret_status;
}
 80270e8:	0038      	movs	r0, r7
 80270ea:	b004      	add	sp, #16
 80270ec:	bc80      	pop	{r7}
 80270ee:	46ba      	mov	sl, r7
 80270f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 80270f2:	27b3      	movs	r7, #179	; 0xb3
 80270f4:	e7f8      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
    return CKR_SESSION_HANDLE_INVALID;
 80270f6:	27b3      	movs	r7, #179	; 0xb3
 80270f8:	e7f6      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
    return CKR_ARGUMENTS_BAD;
 80270fa:	2707      	movs	r7, #7
 80270fc:	e7f4      	b.n	80270e8 <encrypt_decrypt_init+0x3d0>
 80270fe:	46c0      	nop			; (mov r8, r8)
 8027100:	2000b300 	.word	0x2000b300

08027104 <KMS_EncryptInit>:
  *         CKR_FUNCTION_NOT_SUPPORTED
  *         @ref encrypt_decrypt_init returned values
  */
CK_RV          KMS_EncryptInit(CK_SESSION_HANDLE hSession,
                               CK_MECHANISM_PTR pMechanism, CK_OBJECT_HANDLE hKey)
{
 8027104:	b510      	push	{r4, lr}
#if defined(KMS_ENCRYPT)
  CK_RV e_ret_status;

  /* We reuse similar code between Encrypt & Decrypt Init */
  e_ret_status = encrypt_decrypt_init(hSession, pMechanism, hKey, KMS_FLAG_ENCRYPT);
 8027106:	2300      	movs	r3, #0
 8027108:	f7ff fe06 	bl	8026d18 <encrypt_decrypt_init>

  return (e_ret_status) ;
#else /* KMS_ENCRYPT */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_ENCRYPT */
}
 802710c:	bd10      	pop	{r4, pc}
	...

08027110 <KMS_EncryptUpdate>:
  */
CK_RV          KMS_EncryptUpdate(CK_SESSION_HANDLE hSession,
                                 CK_BYTE_PTR pPart, CK_ULONG ulPartLen,
                                 CK_BYTE_PTR pEncryptedPart,
                                 CK_ULONG_PTR pulEncryptedPartLen)
{
 8027110:	b5f0      	push	{r4, r5, r6, r7, lr}
 8027112:	b089      	sub	sp, #36	; 0x24
 8027114:	0007      	movs	r7, r0
 8027116:	9104      	str	r1, [sp, #16]
 8027118:	0015      	movs	r5, r2
 802711a:	9303      	str	r3, [sp, #12]
#if defined(KMS_ENCRYPT)
  CK_RV e_ret_status = CKR_FUNCTION_FAILED;
  int32_t lEncryptPartLen = 0;
 802711c:	2300      	movs	r3, #0
 802711e:	9307      	str	r3, [sp, #28]

  if (!KMS_IS_INITIALIZED())
 8027120:	4b48      	ldr	r3, [pc, #288]	; (8027244 <KMS_EncryptUpdate+0x134>)
 8027122:	781b      	ldrb	r3, [r3, #0]
 8027124:	2b00      	cmp	r3, #0
 8027126:	d100      	bne.n	802712a <KMS_EncryptUpdate+0x1a>
 8027128:	e082      	b.n	8027230 <KMS_EncryptUpdate+0x120>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 802712a:	f000 f9bf 	bl	80274ac <KMS_CheckSessionHdle>
 802712e:	1e04      	subs	r4, r0, #0
 8027130:	d000      	beq.n	8027134 <KMS_EncryptUpdate+0x24>
 8027132:	e082      	b.n	802723a <KMS_EncryptUpdate+0x12a>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* Check if DigestInit has been called previously */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_ENCRYPT)
 8027134:	1e7e      	subs	r6, r7, #1
 8027136:	00f3      	lsls	r3, r6, #3
 8027138:	199b      	adds	r3, r3, r6
 802713a:	009b      	lsls	r3, r3, #2
 802713c:	4a41      	ldr	r2, [pc, #260]	; (8027244 <KMS_EncryptUpdate+0x134>)
 802713e:	18d3      	adds	r3, r2, r3
 8027140:	68db      	ldr	r3, [r3, #12]
 8027142:	2b02      	cmp	r3, #2
 8027144:	d000      	beq.n	8027148 <KMS_EncryptUpdate+0x38>
 8027146:	e07a      	b.n	802723e <KMS_EncryptUpdate+0x12e>
  {
    return CKR_OPERATION_NOT_INITIALIZED;
  }

  KMS_CHECK_BUFFER_SECTION5_2(pEncryptedPart, pulEncryptedPartLen, ulPartLen);
 8027148:	9b03      	ldr	r3, [sp, #12]
 802714a:	2b00      	cmp	r3, #0
 802714c:	d02e      	beq.n	80271ac <KMS_EncryptUpdate+0x9c>
 802714e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8027150:	681b      	ldr	r3, [r3, #0]
 8027152:	9305      	str	r3, [sp, #20]
 8027154:	42ab      	cmp	r3, r5
 8027156:	d32c      	bcc.n	80271b2 <KMS_EncryptUpdate+0xa2>

  switch (KMS_GETSESSION(hSession).Mechanism)
 8027158:	00f3      	lsls	r3, r6, #3
 802715a:	199b      	adds	r3, r3, r6
 802715c:	009b      	lsls	r3, r3, #2
 802715e:	4a39      	ldr	r2, [pc, #228]	; (8027244 <KMS_EncryptUpdate+0x134>)
 8027160:	18d3      	adds	r3, r2, r3
 8027162:	6a1b      	ldr	r3, [r3, #32]
 8027164:	4a38      	ldr	r2, [pc, #224]	; (8027248 <KMS_EncryptUpdate+0x138>)
 8027166:	4293      	cmp	r3, r2
 8027168:	d028      	beq.n	80271bc <KMS_EncryptUpdate+0xac>
 802716a:	4a38      	ldr	r2, [pc, #224]	; (802724c <KMS_EncryptUpdate+0x13c>)
 802716c:	4293      	cmp	r3, r2
 802716e:	d049      	beq.n	8027204 <KMS_EncryptUpdate+0xf4>
 8027170:	4a37      	ldr	r2, [pc, #220]	; (8027250 <KMS_EncryptUpdate+0x140>)
 8027172:	4293      	cmp	r3, r2
 8027174:	d034      	beq.n	80271e0 <KMS_EncryptUpdate+0xd0>
 8027176:	2470      	movs	r4, #112	; 0x70
    *pulEncryptedPartLen = (uint32_t)lEncryptPartLen;
  }
  else
  {
    /* Return a 0-length value to upper layer */
    *pulEncryptedPartLen = 0UL;
 8027178:	2100      	movs	r1, #0
 802717a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802717c:	6019      	str	r1, [r3, #0]
    /* In case of error:
     * - free the allocated context
     * - release the session
     */
    KMS_GETSESSION(hSession).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 802717e:	00f3      	lsls	r3, r6, #3
 8027180:	199b      	adds	r3, r3, r6
 8027182:	009b      	lsls	r3, r3, #2
 8027184:	4a2f      	ldr	r2, [pc, #188]	; (8027244 <KMS_EncryptUpdate+0x134>)
 8027186:	18d3      	adds	r3, r2, r3
 8027188:	6259      	str	r1, [r3, #36]	; 0x24
    if (KMS_GETSESSION(hSession).pCtx != NULL_PTR)
 802718a:	6a99      	ldr	r1, [r3, #40]	; 0x28
 802718c:	2900      	cmp	r1, #0
 802718e:	d009      	beq.n	80271a4 <KMS_EncryptUpdate+0x94>
    {
      KMS_Free(hSession, KMS_GETSESSION(hSession).pCtx);
 8027190:	0038      	movs	r0, r7
 8027192:	f000 fb07 	bl	80277a4 <KMS_Free>
      KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8027196:	00f3      	lsls	r3, r6, #3
 8027198:	199b      	adds	r3, r3, r6
 802719a:	009b      	lsls	r3, r3, #2
 802719c:	4a29      	ldr	r2, [pc, #164]	; (8027244 <KMS_EncryptUpdate+0x134>)
 802719e:	18d3      	adds	r3, r2, r3
 80271a0:	2200      	movs	r2, #0
 80271a2:	629a      	str	r2, [r3, #40]	; 0x28
    }
    KMS_SetStateIdle(hSession);
 80271a4:	0038      	movs	r0, r7
 80271a6:	f000 f9c9 	bl	802753c <KMS_SetStateIdle>
 80271aa:	e043      	b.n	8027234 <KMS_EncryptUpdate+0x124>
  KMS_CHECK_BUFFER_SECTION5_2(pEncryptedPart, pulEncryptedPartLen, ulPartLen);
 80271ac:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80271ae:	601d      	str	r5, [r3, #0]
 80271b0:	e040      	b.n	8027234 <KMS_EncryptUpdate+0x124>
 80271b2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80271b4:	601d      	str	r5, [r3, #0]
 80271b6:	24a8      	movs	r4, #168	; 0xa8
 80271b8:	0064      	lsls	r4, r4, #1
 80271ba:	e03b      	b.n	8027234 <KMS_EncryptUpdate+0x124>
      kms_aes_cbc_ec_ctx_t *p_ctx = KMS_GETSESSION(hSession).pCtx;
 80271bc:	00f3      	lsls	r3, r6, #3
 80271be:	199b      	adds	r3, r3, r6
 80271c0:	009b      	lsls	r3, r3, #2
 80271c2:	4a20      	ldr	r2, [pc, #128]	; (8027244 <KMS_EncryptUpdate+0x134>)
 80271c4:	18d3      	adds	r3, r2, r3
 80271c6:	6a98      	ldr	r0, [r3, #40]	; 0x28
      if (CA_AES_CBC_Encrypt_Append(&(p_ctx->ca_ctx),
 80271c8:	3020      	adds	r0, #32
 80271ca:	ab07      	add	r3, sp, #28
 80271cc:	9300      	str	r3, [sp, #0]
 80271ce:	9b03      	ldr	r3, [sp, #12]
 80271d0:	002a      	movs	r2, r5
 80271d2:	9904      	ldr	r1, [sp, #16]
 80271d4:	f7fe fe60 	bl	8025e98 <CA_AES_CBC_Encrypt_Append>
 80271d8:	2800      	cmp	r0, #0
 80271da:	d023      	beq.n	8027224 <KMS_EncryptUpdate+0x114>
        e_ret_status = CKR_FUNCTION_FAILED;
 80271dc:	2406      	movs	r4, #6
 80271de:	e7cb      	b.n	8027178 <KMS_EncryptUpdate+0x68>
      kms_aes_ecb_ec_ctx_t *p_ctx = KMS_GETSESSION(hSession).pCtx;
 80271e0:	00f3      	lsls	r3, r6, #3
 80271e2:	199b      	adds	r3, r3, r6
 80271e4:	009b      	lsls	r3, r3, #2
 80271e6:	4a17      	ldr	r2, [pc, #92]	; (8027244 <KMS_EncryptUpdate+0x134>)
 80271e8:	18d3      	adds	r3, r2, r3
 80271ea:	6a98      	ldr	r0, [r3, #40]	; 0x28
      if (CA_AES_ECB_Encrypt_Append(&(p_ctx->ca_ctx),
 80271ec:	3020      	adds	r0, #32
 80271ee:	ab07      	add	r3, sp, #28
 80271f0:	9300      	str	r3, [sp, #0]
 80271f2:	9b03      	ldr	r3, [sp, #12]
 80271f4:	002a      	movs	r2, r5
 80271f6:	9904      	ldr	r1, [sp, #16]
 80271f8:	f7ff f87c 	bl	80262f4 <CA_AES_ECB_Encrypt_Append>
 80271fc:	2800      	cmp	r0, #0
 80271fe:	d011      	beq.n	8027224 <KMS_EncryptUpdate+0x114>
        e_ret_status = CKR_FUNCTION_FAILED;
 8027200:	2406      	movs	r4, #6
 8027202:	e7b9      	b.n	8027178 <KMS_EncryptUpdate+0x68>
      kms_aes_gcm_ec_ctx_t *p_ctx = KMS_GETSESSION(hSession).pCtx;
 8027204:	00f3      	lsls	r3, r6, #3
 8027206:	199b      	adds	r3, r3, r6
 8027208:	009b      	lsls	r3, r3, #2
 802720a:	4a0e      	ldr	r2, [pc, #56]	; (8027244 <KMS_EncryptUpdate+0x134>)
 802720c:	18d3      	adds	r3, r2, r3
 802720e:	6a98      	ldr	r0, [r3, #40]	; 0x28
      if (CA_AES_GCM_Encrypt_Append(&(p_ctx->ca_ctx),
 8027210:	3020      	adds	r0, #32
 8027212:	ab07      	add	r3, sp, #28
 8027214:	9300      	str	r3, [sp, #0]
 8027216:	9b03      	ldr	r3, [sp, #12]
 8027218:	002a      	movs	r2, r5
 802721a:	9904      	ldr	r1, [sp, #16]
 802721c:	f7ff f9e2 	bl	80265e4 <CA_AES_GCM_Encrypt_Append>
 8027220:	2800      	cmp	r0, #0
 8027222:	d103      	bne.n	802722c <KMS_EncryptUpdate+0x11c>
    *pulEncryptedPartLen = (uint32_t)lEncryptPartLen;
 8027224:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8027226:	9a07      	ldr	r2, [sp, #28]
 8027228:	601a      	str	r2, [r3, #0]
 802722a:	e003      	b.n	8027234 <KMS_EncryptUpdate+0x124>
        e_ret_status = CKR_FUNCTION_FAILED;
 802722c:	2406      	movs	r4, #6
 802722e:	e7a3      	b.n	8027178 <KMS_EncryptUpdate+0x68>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8027230:	24c8      	movs	r4, #200	; 0xc8
 8027232:	0064      	lsls	r4, r4, #1

  return e_ret_status;
#else /* KMS_ENCRYPT */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_ENCRYPT */
}
 8027234:	0020      	movs	r0, r4
 8027236:	b009      	add	sp, #36	; 0x24
 8027238:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 802723a:	24b3      	movs	r4, #179	; 0xb3
 802723c:	e7fa      	b.n	8027234 <KMS_EncryptUpdate+0x124>
    return CKR_OPERATION_NOT_INITIALIZED;
 802723e:	2491      	movs	r4, #145	; 0x91
 8027240:	e7f8      	b.n	8027234 <KMS_EncryptUpdate+0x124>
 8027242:	46c0      	nop			; (mov r8, r8)
 8027244:	2000b300 	.word	0x2000b300
 8027248:	00001082 	.word	0x00001082
 802724c:	00001087 	.word	0x00001087
 8027250:	00001081 	.word	0x00001081

08027254 <KMS_Encrypt>:
{
 8027254:	b570      	push	{r4, r5, r6, lr}
 8027256:	b082      	sub	sp, #8
 8027258:	0004      	movs	r4, r0
  e_ret_status = KMS_EncryptUpdate(hSession, pData, ulDataLen, pEncryptedData,
 802725a:	9806      	ldr	r0, [sp, #24]
 802725c:	9000      	str	r0, [sp, #0]
 802725e:	0020      	movs	r0, r4
 8027260:	f7ff ff56 	bl	8027110 <KMS_EncryptUpdate>
 8027264:	0006      	movs	r6, r0
  KMS_GETSESSION(hSession).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 8027266:	1e65      	subs	r5, r4, #1
 8027268:	00eb      	lsls	r3, r5, #3
 802726a:	195b      	adds	r3, r3, r5
 802726c:	009b      	lsls	r3, r3, #2
 802726e:	4a0b      	ldr	r2, [pc, #44]	; (802729c <KMS_Encrypt+0x48>)
 8027270:	18d3      	adds	r3, r2, r3
 8027272:	2200      	movs	r2, #0
 8027274:	625a      	str	r2, [r3, #36]	; 0x24
  if (KMS_GETSESSION(hSession).pCtx != NULL_PTR)
 8027276:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8027278:	2900      	cmp	r1, #0
 802727a:	d009      	beq.n	8027290 <KMS_Encrypt+0x3c>
    KMS_Free(hSession, KMS_GETSESSION(hSession).pCtx);
 802727c:	0020      	movs	r0, r4
 802727e:	f000 fa91 	bl	80277a4 <KMS_Free>
    KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8027282:	00eb      	lsls	r3, r5, #3
 8027284:	195d      	adds	r5, r3, r5
 8027286:	00ad      	lsls	r5, r5, #2
 8027288:	4b04      	ldr	r3, [pc, #16]	; (802729c <KMS_Encrypt+0x48>)
 802728a:	195d      	adds	r5, r3, r5
 802728c:	2300      	movs	r3, #0
 802728e:	62ab      	str	r3, [r5, #40]	; 0x28
  KMS_SetStateIdle(hSession);
 8027290:	0020      	movs	r0, r4
 8027292:	f000 f953 	bl	802753c <KMS_SetStateIdle>
}
 8027296:	0030      	movs	r0, r6
 8027298:	b002      	add	sp, #8
 802729a:	bd70      	pop	{r4, r5, r6, pc}
 802729c:	2000b300 	.word	0x2000b300

080272a0 <KMS_EncryptFinal>:
  *         CKR_OPERATION_NOT_INITIALIZED
  *         CKR_SESSION_HANDLE_INVALID
  */
CK_RV          KMS_EncryptFinal(CK_SESSION_HANDLE hSession, CK_BYTE_PTR pLastEncryptedPart,
                                CK_ULONG_PTR pulLastEncryptedPartLen)
{
 80272a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80272a2:	b085      	sub	sp, #20
 80272a4:	0004      	movs	r4, r0
 80272a6:	9101      	str	r1, [sp, #4]
 80272a8:	0017      	movs	r7, r2
#if defined(KMS_ENCRYPT)
  CK_RV e_ret_status = CKR_FUNCTION_FAILED;
  int32_t lEncryptPartLen = 0;
 80272aa:	2300      	movs	r3, #0
 80272ac:	9303      	str	r3, [sp, #12]

  if (!KMS_IS_INITIALIZED())
 80272ae:	4b40      	ldr	r3, [pc, #256]	; (80273b0 <KMS_EncryptFinal+0x110>)
 80272b0:	781b      	ldrb	r3, [r3, #0]
 80272b2:	2b00      	cmp	r3, #0
 80272b4:	d073      	beq.n	802739e <KMS_EncryptFinal+0xfe>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 80272b6:	f000 f8f9 	bl	80274ac <KMS_CheckSessionHdle>
 80272ba:	1e05      	subs	r5, r0, #0
 80272bc:	d000      	beq.n	80272c0 <KMS_EncryptFinal+0x20>
 80272be:	e073      	b.n	80273a8 <KMS_EncryptFinal+0x108>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* Check if DigestInit has been called previously */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_ENCRYPT)
 80272c0:	1e66      	subs	r6, r4, #1
 80272c2:	00f3      	lsls	r3, r6, #3
 80272c4:	199b      	adds	r3, r3, r6
 80272c6:	009b      	lsls	r3, r3, #2
 80272c8:	4a39      	ldr	r2, [pc, #228]	; (80273b0 <KMS_EncryptFinal+0x110>)
 80272ca:	18d3      	adds	r3, r2, r3
 80272cc:	68db      	ldr	r3, [r3, #12]
 80272ce:	2b02      	cmp	r3, #2
 80272d0:	d000      	beq.n	80272d4 <KMS_EncryptFinal+0x34>
 80272d2:	e06b      	b.n	80273ac <KMS_EncryptFinal+0x10c>
  {
    return CKR_OPERATION_NOT_INITIALIZED;
  }

  switch (KMS_GETSESSION(hSession).Mechanism)
 80272d4:	00f3      	lsls	r3, r6, #3
 80272d6:	199b      	adds	r3, r3, r6
 80272d8:	009b      	lsls	r3, r3, #2
 80272da:	18d3      	adds	r3, r2, r3
 80272dc:	6a1b      	ldr	r3, [r3, #32]
 80272de:	4a35      	ldr	r2, [pc, #212]	; (80273b4 <KMS_EncryptFinal+0x114>)
 80272e0:	4293      	cmp	r3, r2
 80272e2:	d01e      	beq.n	8027322 <KMS_EncryptFinal+0x82>
 80272e4:	4a34      	ldr	r2, [pc, #208]	; (80273b8 <KMS_EncryptFinal+0x118>)
 80272e6:	4293      	cmp	r3, r2
 80272e8:	d039      	beq.n	802735e <KMS_EncryptFinal+0xbe>
 80272ea:	4a34      	ldr	r2, [pc, #208]	; (80273bc <KMS_EncryptFinal+0x11c>)
 80272ec:	4293      	cmp	r3, r2
 80272ee:	d027      	beq.n	8027340 <KMS_EncryptFinal+0xa0>
 80272f0:	3570      	adds	r5, #112	; 0x70

  /* Upon completion:
   * - free the allocated context
   * - release the session
   */
  KMS_GETSESSION(hSession).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 80272f2:	00f3      	lsls	r3, r6, #3
 80272f4:	199b      	adds	r3, r3, r6
 80272f6:	009b      	lsls	r3, r3, #2
 80272f8:	4a2d      	ldr	r2, [pc, #180]	; (80273b0 <KMS_EncryptFinal+0x110>)
 80272fa:	18d3      	adds	r3, r2, r3
 80272fc:	2200      	movs	r2, #0
 80272fe:	625a      	str	r2, [r3, #36]	; 0x24
  if (KMS_GETSESSION(hSession).pCtx != NULL_PTR)
 8027300:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8027302:	2900      	cmp	r1, #0
 8027304:	d009      	beq.n	802731a <KMS_EncryptFinal+0x7a>
  {
    KMS_Free(hSession, KMS_GETSESSION(hSession).pCtx);
 8027306:	0020      	movs	r0, r4
 8027308:	f000 fa4c 	bl	80277a4 <KMS_Free>
    KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 802730c:	00f3      	lsls	r3, r6, #3
 802730e:	199b      	adds	r3, r3, r6
 8027310:	009b      	lsls	r3, r3, #2
 8027312:	4a27      	ldr	r2, [pc, #156]	; (80273b0 <KMS_EncryptFinal+0x110>)
 8027314:	18d3      	adds	r3, r2, r3
 8027316:	2200      	movs	r2, #0
 8027318:	629a      	str	r2, [r3, #40]	; 0x28
  }

  KMS_SetStateIdle(hSession);
 802731a:	0020      	movs	r0, r4
 802731c:	f000 f90e 	bl	802753c <KMS_SetStateIdle>

  return e_ret_status;
 8027320:	e03f      	b.n	80273a2 <KMS_EncryptFinal+0x102>
      kms_aes_cbc_ec_ctx_t *p_ctx = KMS_GETSESSION(hSession).pCtx;
 8027322:	00f3      	lsls	r3, r6, #3
 8027324:	199b      	adds	r3, r3, r6
 8027326:	009b      	lsls	r3, r3, #2
 8027328:	4a21      	ldr	r2, [pc, #132]	; (80273b0 <KMS_EncryptFinal+0x110>)
 802732a:	18d3      	adds	r3, r2, r3
 802732c:	6a98      	ldr	r0, [r3, #40]	; 0x28
      if (CA_AES_CBC_Encrypt_Finish(&(p_ctx->ca_ctx),
 802732e:	3020      	adds	r0, #32
 8027330:	aa03      	add	r2, sp, #12
 8027332:	9901      	ldr	r1, [sp, #4]
 8027334:	f7fe fdde 	bl	8025ef4 <CA_AES_CBC_Encrypt_Finish>
 8027338:	2800      	cmp	r0, #0
 802733a:	d0da      	beq.n	80272f2 <KMS_EncryptFinal+0x52>
        e_ret_status = CKR_FUNCTION_FAILED;
 802733c:	2506      	movs	r5, #6
 802733e:	e7d8      	b.n	80272f2 <KMS_EncryptFinal+0x52>
      kms_aes_ecb_ec_ctx_t *p_ctx = KMS_GETSESSION(hSession).pCtx;
 8027340:	00f3      	lsls	r3, r6, #3
 8027342:	199b      	adds	r3, r3, r6
 8027344:	009b      	lsls	r3, r3, #2
 8027346:	4a1a      	ldr	r2, [pc, #104]	; (80273b0 <KMS_EncryptFinal+0x110>)
 8027348:	18d3      	adds	r3, r2, r3
 802734a:	6a98      	ldr	r0, [r3, #40]	; 0x28
      if (CA_AES_ECB_Encrypt_Finish(&(p_ctx->ca_ctx),
 802734c:	3020      	adds	r0, #32
 802734e:	aa03      	add	r2, sp, #12
 8027350:	9901      	ldr	r1, [sp, #4]
 8027352:	f7fe fffd 	bl	8026350 <CA_AES_ECB_Encrypt_Finish>
 8027356:	2800      	cmp	r0, #0
 8027358:	d0cb      	beq.n	80272f2 <KMS_EncryptFinal+0x52>
        e_ret_status = CKR_FUNCTION_FAILED;
 802735a:	2506      	movs	r5, #6
 802735c:	e7c9      	b.n	80272f2 <KMS_EncryptFinal+0x52>
      kms_aes_gcm_ec_ctx_t *p_ctx = KMS_GETSESSION(hSession).pCtx;
 802735e:	00f3      	lsls	r3, r6, #3
 8027360:	199b      	adds	r3, r3, r6
 8027362:	009b      	lsls	r3, r3, #2
 8027364:	4a12      	ldr	r2, [pc, #72]	; (80273b0 <KMS_EncryptFinal+0x110>)
 8027366:	18d3      	adds	r3, r2, r3
 8027368:	6a98      	ldr	r0, [r3, #40]	; 0x28
      KMS_CHECK_BUFFER_SECTION5_2(pLastEncryptedPart, pulLastEncryptedPartLen, (uint32_t)(p_ctx->ca_ctx.mTagSize));
 802736a:	9b01      	ldr	r3, [sp, #4]
 802736c:	2b00      	cmp	r3, #0
 802736e:	d00d      	beq.n	802738c <KMS_EncryptFinal+0xec>
 8027370:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8027372:	683a      	ldr	r2, [r7, #0]
 8027374:	429a      	cmp	r2, r3
 8027376:	d30c      	bcc.n	8027392 <KMS_EncryptFinal+0xf2>
      if (CA_AES_GCM_Encrypt_Finish(&(p_ctx->ca_ctx),
 8027378:	3020      	adds	r0, #32
 802737a:	aa03      	add	r2, sp, #12
 802737c:	9901      	ldr	r1, [sp, #4]
 802737e:	f7ff f973 	bl	8026668 <CA_AES_GCM_Encrypt_Finish>
 8027382:	2800      	cmp	r0, #0
 8027384:	d109      	bne.n	802739a <KMS_EncryptFinal+0xfa>
        *pulLastEncryptedPartLen = (uint32_t)lEncryptPartLen;
 8027386:	9b03      	ldr	r3, [sp, #12]
 8027388:	603b      	str	r3, [r7, #0]
        e_ret_status = CKR_OK;
 802738a:	e7b2      	b.n	80272f2 <KMS_EncryptFinal+0x52>
      KMS_CHECK_BUFFER_SECTION5_2(pLastEncryptedPart, pulLastEncryptedPartLen, (uint32_t)(p_ctx->ca_ctx.mTagSize));
 802738c:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 802738e:	603b      	str	r3, [r7, #0]
 8027390:	e007      	b.n	80273a2 <KMS_EncryptFinal+0x102>
 8027392:	603b      	str	r3, [r7, #0]
 8027394:	25a8      	movs	r5, #168	; 0xa8
 8027396:	006d      	lsls	r5, r5, #1
 8027398:	e003      	b.n	80273a2 <KMS_EncryptFinal+0x102>
        e_ret_status = CKR_FUNCTION_FAILED;
 802739a:	2506      	movs	r5, #6
 802739c:	e7a9      	b.n	80272f2 <KMS_EncryptFinal+0x52>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 802739e:	25c8      	movs	r5, #200	; 0xc8
 80273a0:	006d      	lsls	r5, r5, #1
#else /* KMS_ENCRYPT */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_ENCRYPT */
}
 80273a2:	0028      	movs	r0, r5
 80273a4:	b005      	add	sp, #20
 80273a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 80273a8:	25b3      	movs	r5, #179	; 0xb3
 80273aa:	e7fa      	b.n	80273a2 <KMS_EncryptFinal+0x102>
    return CKR_OPERATION_NOT_INITIALIZED;
 80273ac:	2591      	movs	r5, #145	; 0x91
 80273ae:	e7f8      	b.n	80273a2 <KMS_EncryptFinal+0x102>
 80273b0:	2000b300 	.word	0x2000b300
 80273b4:	00001082 	.word	0x00001082
 80273b8:	00001087 	.word	0x00001087
 80273bc:	00001081 	.word	0x00001081

080273c0 <KMS_Initialize>:
  *         CKR_CANT_LOCK
  *         CKR_CRYPTOKI_ALREADY_INITIALIZED
  *         CKR_FUNCTION_FAILED
  */
CK_RV  KMS_Initialize(CK_VOID_PTR pInitArgs)
{
 80273c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  CK_RV e_ret_status;

  /* Check parameters */
  if (pInitArgs != NULL)
 80273c2:	2800      	cmp	r0, #0
 80273c4:	d13d      	bne.n	8027442 <KMS_Initialize+0x82>
    return CKR_ARGUMENTS_BAD;
#endif /* KMS_PKCS11_COMPLIANCE */
  }

  /* Check if PKCS11 module has already been initialized */
  if (KMS_Manager.initialized == 0xFFU) /* Ensure C_Initialize is not called too many times */
 80273c6:	4b21      	ldr	r3, [pc, #132]	; (802744c <KMS_Initialize+0x8c>)
 80273c8:	781b      	ldrb	r3, [r3, #0]
 80273ca:	2bff      	cmp	r3, #255	; 0xff
 80273cc:	d03c      	beq.n	8027448 <KMS_Initialize+0x88>
  {
    e_ret_status = CKR_FUNCTION_FAILED;
  }
  else if (KMS_Manager.initialized > 0U)
 80273ce:	2b00      	cmp	r3, #0
 80273d0:	d005      	beq.n	80273de <KMS_Initialize+0x1e>
  {
    KMS_Manager.initialized++;  /* Increase initialization counter to reflect number of C_Initialize calls */
 80273d2:	3301      	adds	r3, #1
 80273d4:	4a1d      	ldr	r2, [pc, #116]	; (802744c <KMS_Initialize+0x8c>)
 80273d6:	7013      	strb	r3, [r2, #0]
    e_ret_status = CKR_CRYPTOKI_ALREADY_INITIALIZED;
 80273d8:	2492      	movs	r4, #146	; 0x92
 80273da:	34ff      	adds	r4, #255	; 0xff
 80273dc:	e032      	b.n	8027444 <KMS_Initialize+0x84>
  }
  else
  {
    /* Initialize KMS */
    KMS_Manager.sessionNb = 0;
 80273de:	4b1b      	ldr	r3, [pc, #108]	; (802744c <KMS_Initialize+0x8c>)
 80273e0:	2200      	movs	r2, #0
 80273e2:	605a      	str	r2, [r3, #4]

    /* Initialize SessionList */
    for (uint32_t i = 1 ; i <= KMS_NB_SESSIONS_MAX; i++)
 80273e4:	2501      	movs	r5, #1
 80273e6:	2d01      	cmp	r5, #1
 80273e8:	d90d      	bls.n	8027406 <KMS_Initialize+0x46>
      KMS_GETSESSION(i).state = KMS_SESSION_NOT_USED;
      KMS_GETSESSION(i).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
    }

    /* This is to initialize the memory manager */
    KMS_MemInit();
 80273ea:	f000 f99d 	bl	8027728 <KMS_MemInit>
    /* This is to initialize the crypto api */
    (void)CA_Init();
 80273ee:	f7ff fa6d 	bl	80268cc <CA_Init>

    /* Call the Platform Init function */
    KMS_PlatfObjects_Init();
 80273f2:	f001 fb39 	bl	8028a68 <KMS_PlatfObjects_Init>

    /* Call the Low Level Init function */
    e_ret_status = KMS_LL_Initialize();
 80273f6:	f7fa f93d 	bl	8021674 <KMS_LL_Initialize>
 80273fa:	1e04      	subs	r4, r0, #0
        KMS_Manager.key_initialized = 0xFFU;
      }
    }
#endif /* KMS_ENCRYPT_DECRYPT_BLOB */

    if (e_ret_status ==  CKR_OK)
 80273fc:	d119      	bne.n	8027432 <KMS_Initialize+0x72>
    {
      /* Marking module as initialized */
      KMS_Manager.initialized = 1U;
 80273fe:	4b13      	ldr	r3, [pc, #76]	; (802744c <KMS_Initialize+0x8c>)
 8027400:	2201      	movs	r2, #1
 8027402:	701a      	strb	r2, [r3, #0]
 8027404:	e01e      	b.n	8027444 <KMS_Initialize+0x84>
      (void)memset((void *) & (KMS_GETSESSION(i)), 0, sizeof(kms_session_desc_t));
 8027406:	1e6f      	subs	r7, r5, #1
 8027408:	4e10      	ldr	r6, [pc, #64]	; (802744c <KMS_Initialize+0x8c>)
 802740a:	00fc      	lsls	r4, r7, #3
 802740c:	19e0      	adds	r0, r4, r7
 802740e:	0080      	lsls	r0, r0, #2
 8027410:	3008      	adds	r0, #8
 8027412:	1830      	adds	r0, r6, r0
 8027414:	2224      	movs	r2, #36	; 0x24
 8027416:	2100      	movs	r1, #0
 8027418:	f00d fb8d 	bl	8034b36 <memset>
      KMS_GETSESSION(i).state = KMS_SESSION_NOT_USED;
 802741c:	19e3      	adds	r3, r4, r7
 802741e:	009b      	lsls	r3, r3, #2
 8027420:	18f3      	adds	r3, r6, r3
 8027422:	2201      	movs	r2, #1
 8027424:	4252      	negs	r2, r2
 8027426:	60da      	str	r2, [r3, #12]
      KMS_GETSESSION(i).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 8027428:	001c      	movs	r4, r3
 802742a:	2300      	movs	r3, #0
 802742c:	6263      	str	r3, [r4, #36]	; 0x24
    for (uint32_t i = 1 ; i <= KMS_NB_SESSIONS_MAX; i++)
 802742e:	3501      	adds	r5, #1
 8027430:	e7d9      	b.n	80273e6 <KMS_Initialize+0x26>
    }
    else
    {
      /* Call the Platform Finalize function */
      KMS_PlatfObjects_Finalize();
 8027432:	f001 fb2b 	bl	8028a8c <KMS_PlatfObjects_Finalize>

      /* Marking module as not initialized */
      KMS_Manager.initialized = 0U;
 8027436:	4b05      	ldr	r3, [pc, #20]	; (802744c <KMS_Initialize+0x8c>)
 8027438:	2200      	movs	r2, #0
 802743a:	701a      	strb	r2, [r3, #0]

      /* This is to deinitialize the crypto api */
      (void)CA_DeInit();
 802743c:	f7ff fa48 	bl	80268d0 <CA_DeInit>
 8027440:	e000      	b.n	8027444 <KMS_Initialize+0x84>
    return CKR_ARGUMENTS_BAD;
 8027442:	2407      	movs	r4, #7
    }
  }

  return e_ret_status;
}
 8027444:	0020      	movs	r0, r4
 8027446:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e_ret_status = CKR_FUNCTION_FAILED;
 8027448:	2406      	movs	r4, #6
 802744a:	e7fb      	b.n	8027444 <KMS_Initialize+0x84>
 802744c:	2000b300 	.word	0x2000b300

08027450 <KMS_OpenSession>:
  *         CKR_SESSION_PARALLEL_NOT_SUPPORTED
  */
CK_RV KMS_OpenSession(CK_SLOT_ID slotID, CK_FLAGS flags,
                      CK_VOID_PTR pApplication, CK_NOTIFY Notify,
                      CK_SESSION_HANDLE_PTR phSession)
{
 8027450:	b570      	push	{r4, r5, r6, lr}
 8027452:	0004      	movs	r4, r0

  /* As defined in PKCS11 spec: For legacy reasons, the CKF_SERIAL_SESSION bit MUST
     always be set; if a call to C_OpenSession does not have this bit set, the call
     should return unsuccessfully with the error code CKR_SESSION_PARALLEL_NOT_SUPPORTED.
  */
  if ((flags & CKF_SERIAL_SESSION) == 0UL)
 8027454:	0748      	lsls	r0, r1, #29
 8027456:	d51f      	bpl.n	8027498 <KMS_OpenSession+0x48>
  {
    e_ret_status = CKR_SESSION_PARALLEL_NOT_SUPPORTED;
  }
  else if (!KMS_IS_INITIALIZED())
 8027458:	4813      	ldr	r0, [pc, #76]	; (80274a8 <KMS_OpenSession+0x58>)
 802745a:	7800      	ldrb	r0, [r0, #0]
 802745c:	2800      	cmp	r0, #0
 802745e:	d01d      	beq.n	802749c <KMS_OpenSession+0x4c>
  {
    e_ret_status = CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  /* We reach the max number of opened sessions */
  else if (KMS_Manager.sessionNb >=  KMS_NB_SESSIONS_MAX)
 8027460:	4811      	ldr	r0, [pc, #68]	; (80274a8 <KMS_OpenSession+0x58>)
 8027462:	6840      	ldr	r0, [r0, #4]
 8027464:	2800      	cmp	r0, #0
 8027466:	d11c      	bne.n	80274a2 <KMS_OpenSession+0x52>
  {
    /* Find a slot for a Session */
    session_index = 1;
    do
    {
      if (KMS_GETSESSION(session_index).state == KMS_SESSION_NOT_USED)
 8027468:	4d0f      	ldr	r5, [pc, #60]	; (80274a8 <KMS_OpenSession+0x58>)
 802746a:	68ed      	ldr	r5, [r5, #12]
 802746c:	3501      	adds	r5, #1
 802746e:	d001      	beq.n	8027474 <KMS_OpenSession+0x24>
 8027470:	2006      	movs	r0, #6
    } while ((e_ret_status != CKR_OK)
             && (session_index <= KMS_NB_SESSIONS_MAX)); /* Session index are going from 1 to KMS_NB_SESSIONS_MAX */
  }

  /* All sessions are in used */
  return e_ret_status;
 8027472:	e012      	b.n	802749a <KMS_OpenSession+0x4a>
        *phSession = session_index;
 8027474:	9d04      	ldr	r5, [sp, #16]
 8027476:	2601      	movs	r6, #1
 8027478:	602e      	str	r6, [r5, #0]
        KMS_GETSESSION(session_index).slotID = slotID;
 802747a:	4d0b      	ldr	r5, [pc, #44]	; (80274a8 <KMS_OpenSession+0x58>)
 802747c:	60ac      	str	r4, [r5, #8]
        KMS_GETSESSION(session_index).state = KMS_SESSION_IDLE;      /* Initialized */
 802747e:	2400      	movs	r4, #0
 8027480:	60ec      	str	r4, [r5, #12]
        KMS_GETSESSION(session_index).flags = flags;
 8027482:	6129      	str	r1, [r5, #16]
        KMS_GETSESSION(session_index).pApplication = pApplication;
 8027484:	61aa      	str	r2, [r5, #24]
        KMS_GETSESSION(session_index).Notify = Notify;
 8027486:	61eb      	str	r3, [r5, #28]
        KMS_GETSESSION(session_index).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 8027488:	626c      	str	r4, [r5, #36]	; 0x24
        KMS_GETSESSION(session_index).Mechanism = CKM_VENDOR_DEFINED;
 802748a:	2380      	movs	r3, #128	; 0x80
 802748c:	061b      	lsls	r3, r3, #24
 802748e:	622b      	str	r3, [r5, #32]
        KMS_Manager.sessionNb++;
 8027490:	686b      	ldr	r3, [r5, #4]
 8027492:	3301      	adds	r3, #1
 8027494:	606b      	str	r3, [r5, #4]
        e_ret_status = CKR_OK;
 8027496:	e000      	b.n	802749a <KMS_OpenSession+0x4a>
    e_ret_status = CKR_SESSION_PARALLEL_NOT_SUPPORTED;
 8027498:	20b4      	movs	r0, #180	; 0xb4
}
 802749a:	bd70      	pop	{r4, r5, r6, pc}
    e_ret_status = CKR_CRYPTOKI_NOT_INITIALIZED;
 802749c:	20c8      	movs	r0, #200	; 0xc8
 802749e:	0040      	lsls	r0, r0, #1
 80274a0:	e7fb      	b.n	802749a <KMS_OpenSession+0x4a>
    e_ret_status = CKR_SESSION_COUNT;
 80274a2:	20b1      	movs	r0, #177	; 0xb1
 80274a4:	e7f9      	b.n	802749a <KMS_OpenSession+0x4a>
 80274a6:	46c0      	nop			; (mov r8, r8)
 80274a8:	2000b300 	.word	0x2000b300

080274ac <KMS_CheckSessionHdle>:
  */
CK_RV     KMS_CheckSessionHdle(CK_SESSION_HANDLE hSession)
{
  CK_RV e_ret_status = CKR_SESSION_HANDLE_INVALID;

  if ((hSession >= 1UL) &&
 80274ac:	2801      	cmp	r0, #1
 80274ae:	d001      	beq.n	80274b4 <KMS_CheckSessionHdle+0x8>
  CK_RV e_ret_status = CKR_SESSION_HANDLE_INVALID;
 80274b0:	20b3      	movs	r0, #179	; 0xb3
      (KMS_GETSESSION(hSession).state != KMS_SESSION_NOT_USED))
  {
    e_ret_status = CKR_OK;
  }
  return e_ret_status;
}
 80274b2:	4770      	bx	lr
      (KMS_GETSESSION(hSession).state != KMS_SESSION_NOT_USED))
 80274b4:	3801      	subs	r0, #1
 80274b6:	00c3      	lsls	r3, r0, #3
 80274b8:	1818      	adds	r0, r3, r0
 80274ba:	0080      	lsls	r0, r0, #2
 80274bc:	4b04      	ldr	r3, [pc, #16]	; (80274d0 <KMS_CheckSessionHdle+0x24>)
 80274be:	1818      	adds	r0, r3, r0
 80274c0:	68c3      	ldr	r3, [r0, #12]
      (hSession <= KMS_NB_SESSIONS_MAX) &&
 80274c2:	3301      	adds	r3, #1
 80274c4:	d001      	beq.n	80274ca <KMS_CheckSessionHdle+0x1e>
    e_ret_status = CKR_OK;
 80274c6:	2000      	movs	r0, #0
  return e_ret_status;
 80274c8:	e7f3      	b.n	80274b2 <KMS_CheckSessionHdle+0x6>
  CK_RV e_ret_status = CKR_SESSION_HANDLE_INVALID;
 80274ca:	20b3      	movs	r0, #179	; 0xb3
 80274cc:	e7f1      	b.n	80274b2 <KMS_CheckSessionHdle+0x6>
 80274ce:	46c0      	nop			; (mov r8, r8)
 80274d0:	2000b300 	.word	0x2000b300

080274d4 <KMS_CloseSession>:
{
 80274d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80274d6:	0004      	movs	r4, r0
  if (!KMS_IS_INITIALIZED())
 80274d8:	4b17      	ldr	r3, [pc, #92]	; (8027538 <KMS_CloseSession+0x64>)
 80274da:	781b      	ldrb	r3, [r3, #0]
 80274dc:	2b00      	cmp	r3, #0
 80274de:	d025      	beq.n	802752c <KMS_CloseSession+0x58>
  else if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 80274e0:	f7ff ffe4 	bl	80274ac <KMS_CheckSessionHdle>
 80274e4:	2800      	cmp	r0, #0
 80274e6:	d125      	bne.n	8027534 <KMS_CloseSession+0x60>
  else if (KMS_GETSESSION(hSession).state != KMS_SESSION_IDLE)
 80274e8:	3c01      	subs	r4, #1
 80274ea:	00e3      	lsls	r3, r4, #3
 80274ec:	191b      	adds	r3, r3, r4
 80274ee:	009b      	lsls	r3, r3, #2
 80274f0:	4a11      	ldr	r2, [pc, #68]	; (8027538 <KMS_CloseSession+0x64>)
 80274f2:	18d3      	adds	r3, r2, r3
 80274f4:	68dd      	ldr	r5, [r3, #12]
 80274f6:	2d00      	cmp	r5, #0
 80274f8:	d001      	beq.n	80274fe <KMS_CloseSession+0x2a>
    e_ret_status = CKR_SESSION_HANDLE_INVALID;
 80274fa:	25b3      	movs	r5, #179	; 0xb3
  return e_ret_status;
 80274fc:	e018      	b.n	8027530 <KMS_CloseSession+0x5c>
    (void)memset((void *) & (KMS_GETSESSION(hSession)), 0, sizeof(kms_session_desc_t));
 80274fe:	0017      	movs	r7, r2
 8027500:	00e6      	lsls	r6, r4, #3
 8027502:	1930      	adds	r0, r6, r4
 8027504:	0080      	lsls	r0, r0, #2
 8027506:	3008      	adds	r0, #8
 8027508:	1810      	adds	r0, r2, r0
 802750a:	2224      	movs	r2, #36	; 0x24
 802750c:	2100      	movs	r1, #0
 802750e:	f00d fb12 	bl	8034b36 <memset>
    KMS_GETSESSION(hSession).state = KMS_SESSION_NOT_USED;
 8027512:	1933      	adds	r3, r6, r4
 8027514:	009b      	lsls	r3, r3, #2
 8027516:	18fb      	adds	r3, r7, r3
 8027518:	2201      	movs	r2, #1
 802751a:	4252      	negs	r2, r2
 802751c:	60da      	str	r2, [r3, #12]
    KMS_GETSESSION(hSession).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 802751e:	001c      	movs	r4, r3
 8027520:	2300      	movs	r3, #0
 8027522:	6263      	str	r3, [r4, #36]	; 0x24
    KMS_Manager.sessionNb--;
 8027524:	687b      	ldr	r3, [r7, #4]
 8027526:	189b      	adds	r3, r3, r2
 8027528:	607b      	str	r3, [r7, #4]
    e_ret_status = CKR_OK;
 802752a:	e001      	b.n	8027530 <KMS_CloseSession+0x5c>
    e_ret_status = CKR_CRYPTOKI_NOT_INITIALIZED;
 802752c:	25c8      	movs	r5, #200	; 0xc8
 802752e:	006d      	lsls	r5, r5, #1
}
 8027530:	0028      	movs	r0, r5
 8027532:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e_ret_status = CKR_SESSION_HANDLE_INVALID;
 8027534:	25b3      	movs	r5, #179	; 0xb3
 8027536:	e7fb      	b.n	8027530 <KMS_CloseSession+0x5c>
 8027538:	2000b300 	.word	0x2000b300

0802753c <KMS_SetStateIdle>:
  * @param  hSession session handle
  * @retval None
  */
void     KMS_SetStateIdle(CK_SESSION_HANDLE hSession)
{
  KMS_GETSESSION(hSession).state = KMS_SESSION_IDLE;
 802753c:	1e43      	subs	r3, r0, #1
 802753e:	00d8      	lsls	r0, r3, #3
 8027540:	18c0      	adds	r0, r0, r3
 8027542:	0080      	lsls	r0, r0, #2
 8027544:	4b02      	ldr	r3, [pc, #8]	; (8027550 <KMS_SetStateIdle+0x14>)
 8027546:	1818      	adds	r0, r3, r0
 8027548:	2300      	movs	r3, #0
 802754a:	60c3      	str	r3, [r0, #12]
}
 802754c:	4770      	bx	lr
 802754e:	46c0      	nop			; (mov r8, r8)
 8027550:	2000b300 	.word	0x2000b300

08027554 <KMS_DeriveKey>:
  *         @ref KMS_ECC_LoadCurve returned values
  */
CK_RV          KMS_DeriveKey(CK_SESSION_HANDLE hSession, CK_MECHANISM_PTR pMechanism,
                             CK_OBJECT_HANDLE hBaseKey, CK_ATTRIBUTE_PTR  pTemplate,
                             CK_ULONG  ulAttributeCount, CK_OBJECT_HANDLE_PTR  phKey)
{
 8027554:	b5f0      	push	{r4, r5, r6, r7, lr}
 8027556:	46d6      	mov	lr, sl
 8027558:	b500      	push	{lr}
 802755a:	b08a      	sub	sp, #40	; 0x28
 802755c:	0004      	movs	r4, r0
 802755e:	000d      	movs	r5, r1
 8027560:	9202      	str	r2, [sp, #8]
 8027562:	9303      	str	r3, [sp, #12]
#if defined(KMS_ENCRYPT_DECRYPT_BLOB)
  kms_obj_keyhead_t *pkms_object = NULL;
#else /* KMS_ENCRYPT_DECRYPT_BLOB */
  kms_obj_keyhead_t *pkms_object;
#endif /* KMS_ENCRYPT_DECRYPT_BLOB */
  kms_attr_t *P_pKeyAttribute = NULL;
 8027564:	2300      	movs	r3, #0
 8027566:	9309      	str	r3, [sp, #36]	; 0x24

  if (!KMS_IS_INITIALIZED())
 8027568:	4b55      	ldr	r3, [pc, #340]	; (80276c0 <KMS_DeriveKey+0x16c>)
 802756a:	781b      	ldrb	r3, [r3, #0]
 802756c:	2b00      	cmp	r3, #0
 802756e:	d100      	bne.n	8027572 <KMS_DeriveKey+0x1e>
 8027570:	e099      	b.n	80276a6 <KMS_DeriveKey+0x152>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 8027572:	f7ff ff9b 	bl	80274ac <KMS_CheckSessionHdle>
 8027576:	2800      	cmp	r0, #0
 8027578:	d000      	beq.n	802757c <KMS_DeriveKey+0x28>
 802757a:	e09b      	b.n	80276b4 <KMS_DeriveKey+0x160>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_IDLE)
 802757c:	1e66      	subs	r6, r4, #1
 802757e:	00f3      	lsls	r3, r6, #3
 8027580:	199b      	adds	r3, r3, r6
 8027582:	009b      	lsls	r3, r3, #2
 8027584:	4a4e      	ldr	r2, [pc, #312]	; (80276c0 <KMS_DeriveKey+0x16c>)
 8027586:	18d3      	adds	r3, r2, r3
 8027588:	68db      	ldr	r3, [r3, #12]
 802758a:	2b00      	cmp	r3, #0
 802758c:	d000      	beq.n	8027590 <KMS_DeriveKey+0x3c>
 802758e:	e093      	b.n	80276b8 <KMS_DeriveKey+0x164>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  if (pMechanism == NULL_PTR)
 8027590:	2d00      	cmp	r5, #0
 8027592:	d100      	bne.n	8027596 <KMS_DeriveKey+0x42>
 8027594:	e092      	b.n	80276bc <KMS_DeriveKey+0x168>
  {
    return CKR_ARGUMENTS_BAD;
  }
  switch (pMechanism->mechanism)
 8027596:	4b4b      	ldr	r3, [pc, #300]	; (80276c4 <KMS_DeriveKey+0x170>)
 8027598:	682a      	ldr	r2, [r5, #0]
 802759a:	429a      	cmp	r2, r3
 802759c:	d001      	beq.n	80275a2 <KMS_DeriveKey+0x4e>
      break;
    }
#endif /* KMS_ECDSA & KMS_FCT_DERIVE_KEY */

    default:
      e_ret_status = CKR_MECHANISM_INVALID;
 802759e:	2770      	movs	r7, #112	; 0x70
 80275a0:	e083      	b.n	80276aa <KMS_DeriveKey+0x156>
      CK_MECHANISM aes_ecb_mechanism = { CKM_AES_ECB, NULL, 0 };
 80275a2:	4b49      	ldr	r3, [pc, #292]	; (80276c8 <KMS_DeriveKey+0x174>)
 80275a4:	9306      	str	r3, [sp, #24]
 80275a6:	2300      	movs	r3, #0
 80275a8:	9307      	str	r3, [sp, #28]
 80275aa:	9308      	str	r3, [sp, #32]
      if ((pMechanism->pParameter == NULL) ||
 80275ac:	686b      	ldr	r3, [r5, #4]
 80275ae:	2b00      	cmp	r3, #0
 80275b0:	d075      	beq.n	802769e <KMS_DeriveKey+0x14a>
          (pMechanism->ulParameterLen == 0UL))
 80275b2:	68ab      	ldr	r3, [r5, #8]
      if ((pMechanism->pParameter == NULL) ||
 80275b4:	2b00      	cmp	r3, #0
 80275b6:	d074      	beq.n	80276a2 <KMS_DeriveKey+0x14e>
      if ((pMechanism->ulParameterLen != CA_CRL_AES128_KEY)
 80275b8:	2b10      	cmp	r3, #16
 80275ba:	d005      	beq.n	80275c8 <KMS_DeriveKey+0x74>
          && (pMechanism->ulParameterLen != CA_CRL_AES192_KEY)
 80275bc:	2b18      	cmp	r3, #24
 80275be:	d003      	beq.n	80275c8 <KMS_DeriveKey+0x74>
          && (pMechanism->ulParameterLen != CA_CRL_AES256_KEY))
 80275c0:	2b20      	cmp	r3, #32
 80275c2:	d001      	beq.n	80275c8 <KMS_DeriveKey+0x74>
        e_ret_status = CKR_MECHANISM_PARAM_INVALID;
 80275c4:	2771      	movs	r7, #113	; 0x71
 80275c6:	e070      	b.n	80276aa <KMS_DeriveKey+0x156>
      pkms_object = KMS_Objects_GetPointer(hBaseKey);
 80275c8:	9802      	ldr	r0, [sp, #8]
 80275ca:	f000 ff19 	bl	8028400 <KMS_Objects_GetPointer>
 80275ce:	4682      	mov	sl, r0
      if ((pkms_object != NULL) &&
 80275d0:	2800      	cmp	r0, #0
 80275d2:	d062      	beq.n	802769a <KMS_DeriveKey+0x146>
 80275d4:	4b3d      	ldr	r3, [pc, #244]	; (80276cc <KMS_DeriveKey+0x178>)
 80275d6:	6802      	ldr	r2, [r0, #0]
 80275d8:	429a      	cmp	r2, r3
 80275da:	d008      	beq.n	80275ee <KMS_DeriveKey+0x9a>
        e_ret_status = CKR_KEY_HANDLE_INVALID;
 80275dc:	2760      	movs	r7, #96	; 0x60
      KMS_GETSESSION(hSession).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 80275de:	00f3      	lsls	r3, r6, #3
 80275e0:	199b      	adds	r3, r3, r6
 80275e2:	009b      	lsls	r3, r3, #2
 80275e4:	4a36      	ldr	r2, [pc, #216]	; (80276c0 <KMS_DeriveKey+0x16c>)
 80275e6:	18d3      	adds	r3, r2, r3
 80275e8:	2200      	movs	r2, #0
 80275ea:	625a      	str	r2, [r3, #36]	; 0x24
      break;
 80275ec:	e05d      	b.n	80276aa <KMS_DeriveKey+0x156>
          (pkms_object->version == KMS_ABI_VERSION_CK_2_40) &&
 80275ee:	4b38      	ldr	r3, [pc, #224]	; (80276d0 <KMS_DeriveKey+0x17c>)
 80275f0:	6842      	ldr	r2, [r0, #4]
 80275f2:	429a      	cmp	r2, r3
 80275f4:	d001      	beq.n	80275fa <KMS_DeriveKey+0xa6>
        e_ret_status = CKR_KEY_HANDLE_INVALID;
 80275f6:	2760      	movs	r7, #96	; 0x60
 80275f8:	e7f1      	b.n	80275de <KMS_DeriveKey+0x8a>
        e_ret_status = KMS_Objects_SearchAttributes(CKA_VALUE, pkms_object, &P_pKeyAttribute);
 80275fa:	aa09      	add	r2, sp, #36	; 0x24
 80275fc:	0001      	movs	r1, r0
 80275fe:	2011      	movs	r0, #17
 8027600:	f000 ff5b 	bl	80284ba <KMS_Objects_SearchAttributes>
 8027604:	1e07      	subs	r7, r0, #0
        if (e_ret_status == CKR_OK)
 8027606:	d1ea      	bne.n	80275de <KMS_DeriveKey+0x8a>
          e_ret_status = KMS_Objects_SearchAttributes(CKA_DERIVE, pkms_object, &pDeriveAttribute);
 8027608:	2086      	movs	r0, #134	; 0x86
 802760a:	aa05      	add	r2, sp, #20
 802760c:	4651      	mov	r1, sl
 802760e:	0040      	lsls	r0, r0, #1
 8027610:	f000 ff53 	bl	80284ba <KMS_Objects_SearchAttributes>
          if (e_ret_status == CKR_OK)
 8027614:	2800      	cmp	r0, #0
 8027616:	d105      	bne.n	8027624 <KMS_DeriveKey+0xd0>
            if (*pDeriveAttribute->data != CK_TRUE)
 8027618:	9b05      	ldr	r3, [sp, #20]
 802761a:	689b      	ldr	r3, [r3, #8]
 802761c:	2b01      	cmp	r3, #1
 802761e:	d001      	beq.n	8027624 <KMS_DeriveKey+0xd0>
              e_ret_status = CKR_ACTION_PROHIBITED;
 8027620:	271b      	movs	r7, #27
 8027622:	e042      	b.n	80276aa <KMS_DeriveKey+0x156>
          if ((P_pKeyAttribute->size == CA_CRL_AES128_KEY) ||    /* 128 bits */
 8027624:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8027626:	685b      	ldr	r3, [r3, #4]
 8027628:	2b10      	cmp	r3, #16
 802762a:	d005      	beq.n	8027638 <KMS_DeriveKey+0xe4>
 802762c:	2b18      	cmp	r3, #24
 802762e:	d003      	beq.n	8027638 <KMS_DeriveKey+0xe4>
              (P_pKeyAttribute->size == CA_CRL_AES192_KEY) ||     /* 192 bits */
 8027630:	2b20      	cmp	r3, #32
 8027632:	d001      	beq.n	8027638 <KMS_DeriveKey+0xe4>
            e_ret_status = CKR_ATTRIBUTE_VALUE_INVALID;
 8027634:	2713      	movs	r7, #19
 8027636:	e038      	b.n	80276aa <KMS_DeriveKey+0x156>
            pKeyBuffer = (uint8_t *)KMS_Alloc(hSession, pMechanism->ulParameterLen);
 8027638:	68a9      	ldr	r1, [r5, #8]
 802763a:	0020      	movs	r0, r4
 802763c:	f000 f88c 	bl	8027758 <KMS_Alloc>
 8027640:	4682      	mov	sl, r0
            if (pKeyBuffer == NULL)
 8027642:	2800      	cmp	r0, #0
 8027644:	d027      	beq.n	8027696 <KMS_DeriveKey+0x142>
          e_ret_status = KMS_EncryptInit(hSession, &aes_ecb_mechanism, hBaseKey);
 8027646:	9a02      	ldr	r2, [sp, #8]
 8027648:	a906      	add	r1, sp, #24
 802764a:	0020      	movs	r0, r4
 802764c:	f7ff fd5a 	bl	8027104 <KMS_EncryptInit>
 8027650:	1e07      	subs	r7, r0, #0
          if (e_ret_status != CKR_OK)
 8027652:	d004      	beq.n	802765e <KMS_DeriveKey+0x10a>
            KMS_Free(hSession, pKeyBuffer);
 8027654:	4651      	mov	r1, sl
 8027656:	0020      	movs	r0, r4
 8027658:	f000 f8a4 	bl	80277a4 <KMS_Free>
            break;
 802765c:	e025      	b.n	80276aa <KMS_DeriveKey+0x156>
          EncryptedLen = pMechanism->ulParameterLen;
 802765e:	68aa      	ldr	r2, [r5, #8]
 8027660:	9204      	str	r2, [sp, #16]
          e_ret_status = KMS_Encrypt(hSession, pMechanism->pParameter,
 8027662:	6869      	ldr	r1, [r5, #4]
 8027664:	ab04      	add	r3, sp, #16
 8027666:	9300      	str	r3, [sp, #0]
 8027668:	4653      	mov	r3, sl
 802766a:	0020      	movs	r0, r4
 802766c:	f7ff fdf2 	bl	8027254 <KMS_Encrypt>
 8027670:	1e07      	subs	r7, r0, #0
          if (e_ret_status == CKR_OK)
 8027672:	d004      	beq.n	802767e <KMS_DeriveKey+0x12a>
            KMS_Free(hSession, pKeyBuffer);
 8027674:	4651      	mov	r1, sl
 8027676:	0020      	movs	r0, r4
 8027678:	f000 f894 	bl	80277a4 <KMS_Free>
 802767c:	e7af      	b.n	80275de <KMS_DeriveKey+0x8a>
            e_ret_status = KMS_Objects_CreateNStoreBlobForAES(hSession,
 802767e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8027680:	9301      	str	r3, [sp, #4]
 8027682:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8027684:	9300      	str	r3, [sp, #0]
 8027686:	9b03      	ldr	r3, [sp, #12]
 8027688:	9a04      	ldr	r2, [sp, #16]
 802768a:	4651      	mov	r1, sl
 802768c:	0020      	movs	r0, r4
 802768e:	f001 f921 	bl	80288d4 <KMS_Objects_CreateNStoreBlobForAES>
 8027692:	0007      	movs	r7, r0
 8027694:	e7ee      	b.n	8027674 <KMS_DeriveKey+0x120>
              e_ret_status = CKR_DEVICE_MEMORY;
 8027696:	2731      	movs	r7, #49	; 0x31
 8027698:	e007      	b.n	80276aa <KMS_DeriveKey+0x156>
        e_ret_status = CKR_KEY_HANDLE_INVALID;
 802769a:	2760      	movs	r7, #96	; 0x60
 802769c:	e79f      	b.n	80275de <KMS_DeriveKey+0x8a>
        e_ret_status = CKR_MECHANISM_PARAM_INVALID;
 802769e:	2771      	movs	r7, #113	; 0x71
 80276a0:	e003      	b.n	80276aa <KMS_DeriveKey+0x156>
 80276a2:	2771      	movs	r7, #113	; 0x71
 80276a4:	e001      	b.n	80276aa <KMS_DeriveKey+0x156>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 80276a6:	27c8      	movs	r7, #200	; 0xc8
 80276a8:	007f      	lsls	r7, r7, #1

  return e_ret_status;
#else /* KMS_DERIVE_KEY */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_DERIVE_KEY */
}
 80276aa:	0038      	movs	r0, r7
 80276ac:	b00a      	add	sp, #40	; 0x28
 80276ae:	bc80      	pop	{r7}
 80276b0:	46ba      	mov	sl, r7
 80276b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 80276b4:	27b3      	movs	r7, #179	; 0xb3
 80276b6:	e7f8      	b.n	80276aa <KMS_DeriveKey+0x156>
    return CKR_SESSION_HANDLE_INVALID;
 80276b8:	27b3      	movs	r7, #179	; 0xb3
 80276ba:	e7f6      	b.n	80276aa <KMS_DeriveKey+0x156>
    return CKR_ARGUMENTS_BAD;
 80276bc:	2707      	movs	r7, #7
 80276be:	e7f4      	b.n	80276aa <KMS_DeriveKey+0x156>
 80276c0:	2000b300 	.word	0x2000b300
 80276c4:	00001104 	.word	0x00001104
 80276c8:	00001081 	.word	0x00001081
 80276cc:	b10b0240 	.word	0xb10b0240
 80276d0:	b10b0003 	.word	0xb10b0003

080276d4 <mempool_init>:
/**
  * @brief  Memory pool initialization
  * @retval None
  */
static void mempool_init(kms_mem_pool_header_t *pHead, uint32_t size)
{
 80276d4:	b570      	push	{r4, r5, r6, lr}
 80276d6:	0003      	movs	r3, r0
 80276d8:	000a      	movs	r2, r1
  uint8_t *ptr;
  kms_mem_pool_footer_t *p_foot;

  ptr = (uint8_t *)(((uint32_t)pHead) + sizeof(kms_mem_pool_header_t));
 80276da:	3020      	adds	r0, #32
  p_foot = (kms_mem_pool_footer_t *)(((uint32_t)pHead) + sizeof(kms_mem_pool_header_t) + size + (4UL - (size & 0x3UL)));
 80276dc:	1859      	adds	r1, r3, r1
 80276de:	2503      	movs	r5, #3
 80276e0:	4015      	ands	r5, r2
 80276e2:	1b4d      	subs	r5, r1, r5
 80276e4:	3524      	adds	r5, #36	; 0x24
  /* Initialize header with canaries and controls */
  for (uint32_t i = 0; i < (sizeof(pHead->canaries) / sizeof(pHead->canaries[0])); i++)
 80276e6:	2400      	movs	r4, #0
 80276e8:	2c01      	cmp	r4, #1
 80276ea:	d805      	bhi.n	80276f8 <mempool_init+0x24>
  {
    pHead->canaries[i] = normalizedHeader[i];
 80276ec:	00a1      	lsls	r1, r4, #2
 80276ee:	4e0c      	ldr	r6, [pc, #48]	; (8027720 <mempool_init+0x4c>)
 80276f0:	598e      	ldr	r6, [r1, r6]
 80276f2:	50ce      	str	r6, [r1, r3]
  for (uint32_t i = 0; i < (sizeof(pHead->canaries) / sizeof(pHead->canaries[0])); i++)
 80276f4:	3401      	adds	r4, #1
 80276f6:	e7f7      	b.n	80276e8 <mempool_init+0x14>
  }
  pHead->size = size;
 80276f8:	609a      	str	r2, [r3, #8]
  pHead->used = 0;
 80276fa:	2100      	movs	r1, #0
 80276fc:	60d9      	str	r1, [r3, #12]
#if defined(KMS_MEM_DEBUGGING)
  pHead->session = KMS_SESSION_ID_INVALID;
 80276fe:	6119      	str	r1, [r3, #16]
  pHead->caller = 0;
 8027700:	6159      	str	r1, [r3, #20]
  pHead->reqSize = 0;
 8027702:	6199      	str	r1, [r3, #24]
  pHead->reserved = 0;
 8027704:	61d9      	str	r1, [r3, #28]
#endif /* KMS_MEM_DEBUGGING */
  (void)memset(ptr, 0, size);   /* Initialize pool buffer contents to 0 */
 8027706:	f00d fa16 	bl	8034b36 <memset>
  /* Initialize footer with canaries */
  for (uint32_t i = 0; i < (sizeof(p_foot->canaries) / sizeof(p_foot->canaries[0])); i++)
 802770a:	2300      	movs	r3, #0
 802770c:	e004      	b.n	8027718 <mempool_init+0x44>
  {
    p_foot->canaries[i] = normalizedFooter.canaries[i];
 802770e:	009a      	lsls	r2, r3, #2
 8027710:	4904      	ldr	r1, [pc, #16]	; (8027724 <mempool_init+0x50>)
 8027712:	5851      	ldr	r1, [r2, r1]
 8027714:	5151      	str	r1, [r2, r5]
  for (uint32_t i = 0; i < (sizeof(p_foot->canaries) / sizeof(p_foot->canaries[0])); i++)
 8027716:	3301      	adds	r3, #1
 8027718:	2b03      	cmp	r3, #3
 802771a:	d9f8      	bls.n	802770e <mempool_init+0x3a>
  }
}
 802771c:	bd70      	pop	{r4, r5, r6, pc}
 802771e:	46c0      	nop			; (mov r8, r8)
 8027720:	08035090 	.word	0x08035090
 8027724:	08035080 	.word	0x08035080

08027728 <KMS_MemInit>:
  * @brief  Initialize memory management structure
  * @retval None
  */
#if !defined(KMS_MEM_USE_CUSTOM_ALLOCATOR)
void KMS_MemInit(void)
{
 8027728:	b570      	push	{r4, r5, r6, lr}
 * - Pool #2 is a 256 Bytes pool
 * - Pool #3 is a 512 Bytes pool
 */
/* USER CODE BEGIN KMS_MEM_POOL_Declare */
KMS_MEM_DECLARE_POOL_START()
KMS_MEM_DECLARE_POOL_ENTRY(1,256)
 802772a:	2580      	movs	r5, #128	; 0x80
 802772c:	006d      	lsls	r5, r5, #1
 802772e:	4c09      	ldr	r4, [pc, #36]	; (8027754 <KMS_MemInit+0x2c>)
 8027730:	0029      	movs	r1, r5
 8027732:	0020      	movs	r0, r4
 8027734:	f7ff ffce 	bl	80276d4 <mempool_init>
KMS_MEM_DECLARE_POOL_ENTRY(2,256)
 8027738:	0020      	movs	r0, r4
 802773a:	3035      	adds	r0, #53	; 0x35
 802773c:	30ff      	adds	r0, #255	; 0xff
 802773e:	0029      	movs	r1, r5
 8027740:	f7ff ffc8 	bl	80276d4 <mempool_init>
KMS_MEM_DECLARE_POOL_ENTRY(3,512)
 8027744:	2180      	movs	r1, #128	; 0x80
 8027746:	239a      	movs	r3, #154	; 0x9a
 8027748:	009b      	lsls	r3, r3, #2
 802774a:	18e0      	adds	r0, r4, r3
 802774c:	0089      	lsls	r1, r1, #2
 802774e:	f7ff ffc1 	bl	80276d4 <mempool_init>

#endif /* KMS_MEM_USE_POOL_ALLOCATOR */
#if defined(KMS_MEM_LOGGING)
  KMS_LL_ReportMemInit();
#endif /* KMS_MEM_LOGGING */
}
 8027752:	bd70      	pop	{r4, r5, r6, pc}
 8027754:	2000b32c 	.word	0x2000b32c

08027758 <KMS_Alloc>:
  * @param  Size Size of the memory to allocate
  * @retval Allocated pointer if successful to allocate, NULL_PTR if failed
  */
#if !defined(KMS_MEM_USE_CUSTOM_ALLOCATOR)
CK_VOID_PTR KMS_Alloc(CK_SESSION_HANDLE Session, size_t Size)
{
 8027758:	b570      	push	{r4, r5, r6, lr}
    }
  }
#endif /* KMS_MEM_DEBUGGING */
#endif /* KMS_MEM_USE_HEAP_ALLOCATOR */
#if defined(KMS_MEM_USE_POOL_ALLOCATOR)
  for (uint32_t i = 0; (i < (sizeof(kms_mem_pool_tab) / sizeof(kms_mem_pool_header_t *))) && (ptr == NULL_PTR); i++)
 802775a:	2300      	movs	r3, #0
  void *ptr = NULL_PTR;
 802775c:	2400      	movs	r4, #0
  for (uint32_t i = 0; (i < (sizeof(kms_mem_pool_tab) / sizeof(kms_mem_pool_header_t *))) && (ptr == NULL_PTR); i++)
 802775e:	e000      	b.n	8027762 <KMS_Alloc+0xa>
 8027760:	3301      	adds	r3, #1
 8027762:	2b02      	cmp	r3, #2
 8027764:	d813      	bhi.n	802778e <KMS_Alloc+0x36>
 8027766:	2c00      	cmp	r4, #0
 8027768:	d111      	bne.n	802778e <KMS_Alloc+0x36>
  {
    if ((kms_mem_pool_tab[i]->used == 0UL) && (kms_mem_pool_tab[i]->size >= Size))
 802776a:	009a      	lsls	r2, r3, #2
 802776c:	4d0c      	ldr	r5, [pc, #48]	; (80277a0 <KMS_Alloc+0x48>)
 802776e:	5952      	ldr	r2, [r2, r5]
 8027770:	68d5      	ldr	r5, [r2, #12]
 8027772:	2d00      	cmp	r5, #0
 8027774:	d1f4      	bne.n	8027760 <KMS_Alloc+0x8>
 8027776:	6895      	ldr	r5, [r2, #8]
 8027778:	428d      	cmp	r5, r1
 802777a:	d3f1      	bcc.n	8027760 <KMS_Alloc+0x8>
    {
      kms_mem_pool_tab[i]->used = 1;
 802777c:	2401      	movs	r4, #1
 802777e:	60d4      	str	r4, [r2, #12]
#if defined(KMS_MEM_DEBUGGING)
      kms_mem_pool_tab[i]->session = Session;
 8027780:	6110      	str	r0, [r2, #16]
      kms_mem_pool_tab[i]->caller = LR;
 8027782:	2400      	movs	r4, #0
 8027784:	6154      	str	r4, [r2, #20]
      kms_mem_pool_tab[i]->reqSize = Size;
 8027786:	6191      	str	r1, [r2, #24]
#endif /* KMS_MEM_DEBUGGING */
      ptr = (void *)(uint32_t *)((uint32_t)(kms_mem_pool_tab[i]) + sizeof(kms_mem_pool_header_t));
 8027788:	3220      	adds	r2, #32
 802778a:	0014      	movs	r4, r2
 802778c:	e7e8      	b.n	8027760 <KMS_Alloc+0x8>
    }
  }
#endif /* KMS_MEM_USE_POOL_ALLOCATOR */
  if (ptr == NULL_PTR)
 802778e:	2c00      	cmp	r4, #0
 8027790:	d001      	beq.n	8027796 <KMS_Alloc+0x3e>
  {
    KMS_LL_ReportMemAlloc(Size, ptr);
  }
#endif /* KMS_MEM_LOGGING */
  return ptr;
}
 8027792:	0020      	movs	r0, r4
 8027794:	bd70      	pop	{r4, r5, r6, pc}
    KMS_LL_ReportError(KMS_LL_ERROR_MEM_ALLOC_FAILURE);
 8027796:	2001      	movs	r0, #1
 8027798:	f7f9 ff6e 	bl	8021678 <KMS_LL_ReportError>
  return ptr;
 802779c:	e7f9      	b.n	8027792 <KMS_Alloc+0x3a>
 802779e:	46c0      	nop			; (mov r8, r8)
 80277a0:	08035074 	.word	0x08035074

080277a4 <KMS_Free>:
  * @param  Ptr     Pointer to the memory to free
  * @retval None
  */
#if !defined(KMS_MEM_USE_CUSTOM_ALLOCATOR)
void KMS_Free(CK_SESSION_HANDLE Session, CK_VOID_PTR Ptr)
{
 80277a4:	b570      	push	{r4, r5, r6, lr}
 80277a6:	1e0d      	subs	r5, r1, #0
  uint32_t i;

  (void)Session;

  if (Ptr == NULL_PTR)
 80277a8:	d01f      	beq.n	80277ea <KMS_Free+0x46>
#if defined(KMS_MEM_USE_POOL_ALLOCATOR)
    kms_mem_pool_header_t *phead;
    kms_mem_pool_footer_t *pfoot;
    uint32_t tmp_ptr = (uint32_t)Ptr;

    phead = (kms_mem_pool_header_t *)(tmp_ptr - sizeof(kms_mem_pool_header_t));
 80277aa:	000e      	movs	r6, r1
 80277ac:	3e20      	subs	r6, #32
    pfoot = (kms_mem_pool_footer_t *)(tmp_ptr + phead->size + 4UL - (phead->size & 0x3UL));
 80277ae:	68b2      	ldr	r2, [r6, #8]
 80277b0:	1853      	adds	r3, r2, r1
 80277b2:	2403      	movs	r4, #3
 80277b4:	4014      	ands	r4, r2
 80277b6:	1b1c      	subs	r4, r3, r4
 80277b8:	3404      	adds	r4, #4
    /* Check canaries */
    if (memcmp((void *)phead, &normalizedHeader, sizeof(normalizedHeader)) != 0)
 80277ba:	2208      	movs	r2, #8
 80277bc:	4919      	ldr	r1, [pc, #100]	; (8027824 <KMS_Free+0x80>)
 80277be:	0030      	movs	r0, r6
 80277c0:	f00d f9a2 	bl	8034b08 <memcmp>
 80277c4:	2800      	cmp	r0, #0
 80277c6:	d114      	bne.n	80277f2 <KMS_Free+0x4e>
    {
      KMS_LL_ReportError(KMS_LL_ERROR_MEM_FREE_CANARY);
    }
    if (memcmp((void *)pfoot, &normalizedFooter, sizeof(normalizedFooter)) != 0)
 80277c8:	2210      	movs	r2, #16
 80277ca:	4917      	ldr	r1, [pc, #92]	; (8027828 <KMS_Free+0x84>)
 80277cc:	0020      	movs	r0, r4
 80277ce:	f00d f99b 	bl	8034b08 <memcmp>
 80277d2:	2800      	cmp	r0, #0
 80277d4:	d111      	bne.n	80277fa <KMS_Free+0x56>
    {
      KMS_LL_ReportError(KMS_LL_ERROR_MEM_FREE_CANARY);
    }
    for (i = 0; i < (sizeof(kms_mem_pool_tab) / sizeof(kms_mem_pool_header_t *)); i++)
 80277d6:	2400      	movs	r4, #0
 80277d8:	2c02      	cmp	r4, #2
 80277da:	d81c      	bhi.n	8027816 <KMS_Free+0x72>
    {
      if (phead == kms_mem_pool_tab[i])
 80277dc:	00a3      	lsls	r3, r4, #2
 80277de:	4a13      	ldr	r2, [pc, #76]	; (802782c <KMS_Free+0x88>)
 80277e0:	589b      	ldr	r3, [r3, r2]
 80277e2:	42b3      	cmp	r3, r6
 80277e4:	d00d      	beq.n	8027802 <KMS_Free+0x5e>
    for (i = 0; i < (sizeof(kms_mem_pool_tab) / sizeof(kms_mem_pool_header_t *)); i++)
 80277e6:	3401      	adds	r4, #1
 80277e8:	e7f6      	b.n	80277d8 <KMS_Free+0x34>
    KMS_LL_ReportError(KMS_LL_ERROR_MEM_FREE_NULL_PTR);
 80277ea:	2003      	movs	r0, #3
 80277ec:	f7f9 ff44 	bl	8021678 <KMS_LL_ReportError>
 80277f0:	e013      	b.n	802781a <KMS_Free+0x76>
      KMS_LL_ReportError(KMS_LL_ERROR_MEM_FREE_CANARY);
 80277f2:	2002      	movs	r0, #2
 80277f4:	f7f9 ff40 	bl	8021678 <KMS_LL_ReportError>
 80277f8:	e7e6      	b.n	80277c8 <KMS_Free+0x24>
      KMS_LL_ReportError(KMS_LL_ERROR_MEM_FREE_CANARY);
 80277fa:	2002      	movs	r0, #2
 80277fc:	f7f9 ff3c 	bl	8021678 <KMS_LL_ReportError>
 8027800:	e7e9      	b.n	80277d6 <KMS_Free+0x32>
      {
        phead->used = 0;
 8027802:	2300      	movs	r3, #0
 8027804:	60f3      	str	r3, [r6, #12]
#if defined(KMS_MEM_DEBUGGING)
        phead->session = KMS_SESSION_ID_INVALID;
 8027806:	6133      	str	r3, [r6, #16]
        phead->caller = 0;
 8027808:	6173      	str	r3, [r6, #20]
        phead->reqSize = 0;
 802780a:	61b3      	str	r3, [r6, #24]
#endif /* KMS_MEM_DEBUGGING */
#if defined(KMS_MEM_CLEANING)
        (void)memset(Ptr, 0, phead->size);
 802780c:	68b2      	ldr	r2, [r6, #8]
 802780e:	2100      	movs	r1, #0
 8027810:	0028      	movs	r0, r5
 8027812:	f00d f990 	bl	8034b36 <memset>
#endif /* KMS_MEM_CLEANING */
        break;
      }
    }
    if (i >= (sizeof(kms_mem_pool_tab) / sizeof(kms_mem_pool_header_t *)))
 8027816:	2c02      	cmp	r4, #2
 8027818:	d800      	bhi.n	802781c <KMS_Free+0x78>
    {
      KMS_LL_ReportError(KMS_LL_ERROR_MEM_FREE_UNKNOWN);
    }
#endif /* KMS_MEM_USE_POOL_ALLOCATOR */
  } /* (Ptr == NULL_PTR) */
}
 802781a:	bd70      	pop	{r4, r5, r6, pc}
      KMS_LL_ReportError(KMS_LL_ERROR_MEM_FREE_UNKNOWN);
 802781c:	2004      	movs	r0, #4
 802781e:	f7f9 ff2b 	bl	8021678 <KMS_LL_ReportError>
}
 8027822:	e7fa      	b.n	802781a <KMS_Free+0x76>
 8027824:	08035090 	.word	0x08035090
 8027828:	08035080 	.word	0x08035080
 802782c:	08035074 	.word	0x08035074

08027830 <reset>:
  */
static void reset(void)
{
  uint32_t i;

  nvm.header = NULL;
 8027830:	4b0a      	ldr	r3, [pc, #40]	; (802785c <reset+0x2c>)
 8027832:	2200      	movs	r2, #0
 8027834:	601a      	str	r2, [r3, #0]
  nvm.block = NVMS_BLOCK0;
 8027836:	711a      	strb	r2, [r3, #4]
  for (i = 0; i < NVMS_CFG_NUM_SLOTS; i++)
 8027838:	2300      	movs	r3, #0
 802783a:	e005      	b.n	8027848 <reset+0x18>
  {
    nvm.slots[i] = NULL;
 802783c:	1c9a      	adds	r2, r3, #2
 802783e:	0092      	lsls	r2, r2, #2
 8027840:	4906      	ldr	r1, [pc, #24]	; (802785c <reset+0x2c>)
 8027842:	2000      	movs	r0, #0
 8027844:	5050      	str	r0, [r2, r1]
  for (i = 0; i < NVMS_CFG_NUM_SLOTS; i++)
 8027846:	3301      	adds	r3, #1
 8027848:	2b31      	cmp	r3, #49	; 0x31
 802784a:	d9f7      	bls.n	802783c <reset+0xc>
  }
  nvm.free_next = NULL;
 802784c:	4b03      	ldr	r3, [pc, #12]	; (802785c <reset+0x2c>)
 802784e:	2200      	movs	r2, #0
 8027850:	21d0      	movs	r1, #208	; 0xd0
 8027852:	505a      	str	r2, [r3, r1]
  nvm.used_size = 0;
 8027854:	3104      	adds	r1, #4
 8027856:	505a      	str	r2, [r3, r1]
}
 8027858:	4770      	bx	lr
 802785a:	46c0      	nop			; (mov r8, r8)
 802785c:	2000b7c8 	.word	0x2000b7c8

08027860 <do_checksum>:
  * @param[in] data_p        pointer to the data buffer
  * @param[in] size          size of the data buffer
  * @return                  The checksum.
  */
static uint32_t do_checksum(const uint8_t *data_p, size_t size)
{
 8027860:	0003      	movs	r3, r0
  uint32_t checksum;
  const uint8_t *p = data_p;
  size_t n = size;

  checksum = 0;
 8027862:	2000      	movs	r0, #0
  while (n != 0UL)
 8027864:	e003      	b.n	802786e <do_checksum+0xe>
  {
    checksum += *p;
 8027866:	781a      	ldrb	r2, [r3, #0]
 8027868:	1880      	adds	r0, r0, r2
    p++;
 802786a:	3301      	adds	r3, #1
    n--;
 802786c:	3901      	subs	r1, #1
  while (n != 0UL)
 802786e:	2900      	cmp	r1, #0
 8027870:	d1f9      	bne.n	8027866 <do_checksum+0x6>
  }
  return checksum;
}
 8027872:	4770      	bx	lr

08027874 <check_slot_instance>:
  * @retval NVMS_SLOT_STATUS_CRC     if the slot does not match the CRC.
  * @retval NVMS_SLOT_STATUS_BROKEN if the header is corrupt.
  */
static nvms_slot_status_t check_slot_instance(nvms_block_t block,
                                              nvms_data_header_t *hdrp)
{
 8027874:	b510      	push	{r4, lr}
 8027876:	000c      	movs	r4, r1
  const uint8_t *endp;
  uint32_t checksum;
  uint8_t i;

  /* First check for an header in erased state */
  for (i = 0; i < 8U; i++)
 8027878:	2300      	movs	r3, #0
 802787a:	2b07      	cmp	r3, #7
 802787c:	d833      	bhi.n	80278e6 <check_slot_instance+0x72>
  {

    /* If the header is not in erased state then it must be checked for
       validity */
    if (hdrp->hdr32[i] != NVMS_LL_ERASED)
 802787e:	009a      	lsls	r2, r3, #2
 8027880:	5912      	ldr	r2, [r2, r4]
 8027882:	3201      	adds	r2, #1
 8027884:	d102      	bne.n	802788c <check_slot_instance+0x18>
  for (i = 0; i < 8U; i++)
 8027886:	3301      	adds	r3, #1
 8027888:	b2db      	uxtb	r3, r3
 802788a:	e7f6      	b.n	802787a <check_slot_instance+0x6>
    {
      /* Check on the pointer to the next block, it must be aligned to an
         header boundary */
      if (((uint32_t)hdrp->fields.next & (NVMS_LL_PAGE_SIZE - 1UL)) != 0UL)
 802788c:	6923      	ldr	r3, [r4, #16]
 802788e:	075a      	lsls	r2, r3, #29
 8027890:	d12b      	bne.n	80278ea <check_slot_instance+0x76>
  */
/* Template version */
static inline uint32_t NVMS_LL_GetBlockAddress(nvms_block_t block)
{
  /* USER CODE BEGIN NVMS_LL_GetBlockAddress */
  if (block == NVMS_BLOCK0)
 8027892:	2800      	cmp	r0, #0
 8027894:	d025      	beq.n	80278e2 <check_slot_instance+0x6e>
  {
    return (uint32_t)NVMS_LL_BLOCK0_ADDRESS;
  }
  return (uint32_t)NVMS_LL_BLOCK1_ADDRESS;
 8027896:	4a1e      	ldr	r2, [pc, #120]	; (8027910 <check_slot_instance+0x9c>)
      }

      /* Checks on the pointer to the next block, the address must be comprised
         between the next header position and the end of the flash array */
      startp = (uint8_t *)NVMS_LL_GetBlockAddress(block);
      endp = &startp[NVMS_LL_GetBlockSize()];
 8027898:	2180      	movs	r1, #128	; 0x80
 802789a:	0109      	lsls	r1, r1, #4
 802789c:	468c      	mov	ip, r1
 802789e:	4462      	add	r2, ip
      if ((hdrp->fields.next->hdr8 < (hdrp->hdr8 + sizeof(nvms_data_header_t))) ||
 80278a0:	0020      	movs	r0, r4
 80278a2:	3020      	adds	r0, #32
 80278a4:	4283      	cmp	r3, r0
 80278a6:	d322      	bcc.n	80278ee <check_slot_instance+0x7a>
 80278a8:	4293      	cmp	r3, r2
 80278aa:	d822      	bhi.n	80278f2 <check_slot_instance+0x7e>
      {
        return NVMS_SLOT_STATUS_BROKEN;
      }

      /* Check on the magic numbers */
      if ((hdrp->fields.magic1 != NVMS_HEADER_MAGIC1) ||
 80278ac:	4a19      	ldr	r2, [pc, #100]	; (8027914 <check_slot_instance+0xa0>)
 80278ae:	6821      	ldr	r1, [r4, #0]
 80278b0:	4291      	cmp	r1, r2
 80278b2:	d120      	bne.n	80278f6 <check_slot_instance+0x82>
 80278b4:	4a18      	ldr	r2, [pc, #96]	; (8027918 <check_slot_instance+0xa4>)
 80278b6:	6861      	ldr	r1, [r4, #4]
 80278b8:	4291      	cmp	r1, r2
 80278ba:	d11e      	bne.n	80278fa <check_slot_instance+0x86>
      {
        return NVMS_SLOT_STATUS_BROKEN;
      }

      /* Check on slot identifier */
      if (hdrp->fields.slot >= NVMS_CFG_NUM_SLOTS)
 80278bc:	68a2      	ldr	r2, [r4, #8]
 80278be:	2a31      	cmp	r2, #49	; 0x31
 80278c0:	d81d      	bhi.n	80278fe <check_slot_instance+0x8a>
      {
        return NVMS_SLOT_STATUS_BROKEN;
      }

      /* Check on the instance field */
      if (hdrp->fields.instance == NVMS_LL_ERASED)
 80278c2:	68e2      	ldr	r2, [r4, #12]
 80278c4:	3201      	adds	r2, #1
 80278c6:	d01c      	beq.n	8027902 <check_slot_instance+0x8e>
      {
        return NVMS_SLOT_STATUS_BROKEN;
      }

      /* Checks on the data size */
      if ((hdrp->hdr8 + sizeof(nvms_data_header_t) + hdrp->fields.data_size) >
 80278c8:	69a1      	ldr	r1, [r4, #24]
 80278ca:	000a      	movs	r2, r1
 80278cc:	3220      	adds	r2, #32
 80278ce:	18a2      	adds	r2, r4, r2
 80278d0:	4293      	cmp	r3, r2
 80278d2:	d318      	bcc.n	8027906 <check_slot_instance+0x92>
      {
        return NVMS_SLOT_STATUS_BROKEN;
      }

      /* Payload checksum */
      checksum = do_checksum(hdrp->hdr8 + sizeof(nvms_data_header_t),
 80278d4:	f7ff ffc4 	bl	8027860 <do_checksum>
                             hdrp->fields.data_size);
      if (checksum != hdrp->fields.data_checksum)
 80278d8:	69e3      	ldr	r3, [r4, #28]
 80278da:	4283      	cmp	r3, r0
 80278dc:	d015      	beq.n	802790a <check_slot_instance+0x96>
      {
        return NVMS_SLOT_STATUS_CRC;
 80278de:	2002      	movs	r0, #2
 80278e0:	e002      	b.n	80278e8 <check_slot_instance+0x74>
    return (uint32_t)NVMS_LL_BLOCK0_ADDRESS;
 80278e2:	4a0e      	ldr	r2, [pc, #56]	; (802791c <check_slot_instance+0xa8>)
 80278e4:	e7d8      	b.n	8027898 <check_slot_instance+0x24>

      return NVMS_SLOT_STATUS_OK;
    }
  }

  return NVMS_SLOT_STATUS_ERASED;
 80278e6:	2000      	movs	r0, #0
}
 80278e8:	bd10      	pop	{r4, pc}
        return NVMS_SLOT_STATUS_BROKEN;
 80278ea:	2003      	movs	r0, #3
 80278ec:	e7fc      	b.n	80278e8 <check_slot_instance+0x74>
        return NVMS_SLOT_STATUS_BROKEN;
 80278ee:	2003      	movs	r0, #3
 80278f0:	e7fa      	b.n	80278e8 <check_slot_instance+0x74>
 80278f2:	2003      	movs	r0, #3
 80278f4:	e7f8      	b.n	80278e8 <check_slot_instance+0x74>
        return NVMS_SLOT_STATUS_BROKEN;
 80278f6:	2003      	movs	r0, #3
 80278f8:	e7f6      	b.n	80278e8 <check_slot_instance+0x74>
 80278fa:	2003      	movs	r0, #3
 80278fc:	e7f4      	b.n	80278e8 <check_slot_instance+0x74>
        return NVMS_SLOT_STATUS_BROKEN;
 80278fe:	2003      	movs	r0, #3
 8027900:	e7f2      	b.n	80278e8 <check_slot_instance+0x74>
        return NVMS_SLOT_STATUS_BROKEN;
 8027902:	2003      	movs	r0, #3
 8027904:	e7f0      	b.n	80278e8 <check_slot_instance+0x74>
        return NVMS_SLOT_STATUS_BROKEN;
 8027906:	2003      	movs	r0, #3
 8027908:	e7ee      	b.n	80278e8 <check_slot_instance+0x74>
      return NVMS_SLOT_STATUS_OK;
 802790a:	2001      	movs	r0, #1
 802790c:	e7ec      	b.n	80278e8 <check_slot_instance+0x74>
 802790e:	46c0      	nop			; (mov r8, r8)
 8027910:	0803d800 	.word	0x0803d800
 8027914:	5aa5f731 	.word	0x5aa5f731
 8027918:	137fa55a 	.word	0x137fa55a
 802791c:	0803d000 	.word	0x0803d000

08027920 <scan_slots>:
  *                          case.
  */
static nvms_block_status_t scan_slots(nvms_block_t block,
                                      nvms_found_slot_t slotcallback,
                                      nvms_end_slot_t endcallback)
{
 8027920:	b5f0      	push	{r4, r5, r6, r7, lr}
 8027922:	46de      	mov	lr, fp
 8027924:	4657      	mov	r7, sl
 8027926:	464e      	mov	r6, r9
 8027928:	4645      	mov	r5, r8
 802792a:	b5e0      	push	{r5, r6, r7, lr}
 802792c:	b083      	sub	sp, #12
 802792e:	1e05      	subs	r5, r0, #0
 8027930:	4688      	mov	r8, r1
 8027932:	4691      	mov	r9, r2
  if (block == NVMS_BLOCK0)
 8027934:	d011      	beq.n	802795a <scan_slots+0x3a>
  return (uint32_t)NVMS_LL_BLOCK1_ADDRESS;
 8027936:	4929      	ldr	r1, [pc, #164]	; (80279dc <scan_slots+0xbc>)
  bool warning = false;
  nvms_block_status_t status = NVMS_STATUS_BROKEN;
  bool status_found = false;

  /* Limits */
  startp = (uint8_t *)NVMS_LL_GetBlockAddress(block);
 8027938:	000c      	movs	r4, r1
  endp = &startp[NVMS_LL_GetBlockSize()];
 802793a:	2380      	movs	r3, #128	; 0x80
 802793c:	011b      	lsls	r3, r3, #4
 802793e:	18cf      	adds	r7, r1, r3

  /* Checking the main header */
  hdrp = (nvms_data_header_t *)(uint32_t)startp;
  slotsts = check_slot_instance(block, hdrp);
 8027940:	0028      	movs	r0, r5
 8027942:	f7ff ff97 	bl	8027874 <check_slot_instance>
 8027946:	0003      	movs	r3, r0
 8027948:	9001      	str	r0, [sp, #4]
  if (slotsts != NVMS_SLOT_STATUS_OK)
 802794a:	2801      	cmp	r0, #1
 802794c:	d13c      	bne.n	80279c8 <scan_slots+0xa8>
  bool status_found = false;
 802794e:	2600      	movs	r6, #0
  nvms_block_status_t status = NVMS_STATUS_BROKEN;
 8027950:	3302      	adds	r3, #2
 8027952:	469a      	mov	sl, r3
  bool warning = false;
 8027954:	2300      	movs	r3, #0
 8027956:	469b      	mov	fp, r3
 8027958:	e013      	b.n	8027982 <scan_slots+0x62>
    return (uint32_t)NVMS_LL_BLOCK0_ADDRESS;
 802795a:	4921      	ldr	r1, [pc, #132]	; (80279e0 <scan_slots+0xc0>)
 802795c:	e7ec      	b.n	8027938 <scan_slots+0x18>

    /* Special case end-of-chain */
    if (hdrp->hdr8 == endp)
    {
      /* Calling end-of-scan callback if defined */
      endcallback(hdrp);
 802795e:	0020      	movs	r0, r4
 8027960:	47c8      	blx	r9
      if (warning)
 8027962:	465b      	mov	r3, fp
 8027964:	2b00      	cmp	r3, #0
 8027966:	d102      	bne.n	802796e <scan_slots+0x4e>
      {
        return NVMS_STATUS_PARTIAL;
      }
      else
      {
        return NVMS_STATUS_NORMAL;
 8027968:	9b01      	ldr	r3, [sp, #4]
 802796a:	469a      	mov	sl, r3
 802796c:	e02e      	b.n	80279cc <scan_slots+0xac>
        return NVMS_STATUS_PARTIAL;
 802796e:	2302      	movs	r3, #2
 8027970:	469a      	mov	sl, r3
 8027972:	e02b      	b.n	80279cc <scan_slots+0xac>
      }
    }

    /* Header check */
    slotsts = check_slot_instance(block, hdrp);
    switch (slotsts)
 8027974:	2803      	cmp	r0, #3
 8027976:	d104      	bne.n	8027982 <scan_slots+0x62>
#endif /* KMS_DEBUG_MODE */
        break;

      case NVMS_SLOT_STATUS_BROKEN:
        /* Calling end-of-scan callback if defined */
        endcallback(hdrp);
 8027978:	0020      	movs	r0, r4
 802797a:	47c8      	blx	r9

        /* Problems, stopping the scan here */
        status = NVMS_STATUS_PARTIAL;
        status_found = true;
 802797c:	2601      	movs	r6, #1
        status = NVMS_STATUS_PARTIAL;
 802797e:	2302      	movs	r3, #2
 8027980:	469a      	mov	sl, r3
  while (!status_found)
 8027982:	2e00      	cmp	r6, #0
 8027984:	d122      	bne.n	80279cc <scan_slots+0xac>
    hdrp = (nvms_data_header_t *)hdrp->fields.next;
 8027986:	6924      	ldr	r4, [r4, #16]
    if (hdrp->hdr8 == endp)
 8027988:	42bc      	cmp	r4, r7
 802798a:	d0e8      	beq.n	802795e <scan_slots+0x3e>
    slotsts = check_slot_instance(block, hdrp);
 802798c:	0021      	movs	r1, r4
 802798e:	0028      	movs	r0, r5
 8027990:	f7ff ff70 	bl	8027874 <check_slot_instance>
    switch (slotsts)
 8027994:	2802      	cmp	r0, #2
 8027996:	d010      	beq.n	80279ba <scan_slots+0x9a>
 8027998:	d8ec      	bhi.n	8027974 <scan_slots+0x54>
 802799a:	2800      	cmp	r0, #0
 802799c:	d004      	beq.n	80279a8 <scan_slots+0x88>
 802799e:	2801      	cmp	r0, #1
 80279a0:	d1ef      	bne.n	8027982 <scan_slots+0x62>
        slotcallback(hdrp);
 80279a2:	0020      	movs	r0, r4
 80279a4:	47c0      	blx	r8
        break;
 80279a6:	e7ec      	b.n	8027982 <scan_slots+0x62>
        endcallback(hdrp);
 80279a8:	0020      	movs	r0, r4
 80279aa:	47c8      	blx	r9
        if (warning)
 80279ac:	465b      	mov	r3, fp
 80279ae:	2b00      	cmp	r3, #0
 80279b0:	d006      	beq.n	80279c0 <scan_slots+0xa0>
          status_found = true;
 80279b2:	465e      	mov	r6, fp
          status = NVMS_STATUS_PARTIAL;
 80279b4:	2302      	movs	r3, #2
 80279b6:	469a      	mov	sl, r3
 80279b8:	e7e3      	b.n	8027982 <scan_slots+0x62>
        warning = true;
 80279ba:	2301      	movs	r3, #1
 80279bc:	469b      	mov	fp, r3
 80279be:	e7e0      	b.n	8027982 <scan_slots+0x62>
          status = NVMS_STATUS_NORMAL;
 80279c0:	9b01      	ldr	r3, [sp, #4]
 80279c2:	469a      	mov	sl, r3
          status_found = true;
 80279c4:	2601      	movs	r6, #1
 80279c6:	e7dc      	b.n	8027982 <scan_slots+0x62>
    return NVMS_STATUS_BROKEN;
 80279c8:	2303      	movs	r3, #3
 80279ca:	469a      	mov	sl, r3
        /* No action */
        break;
    }
  }
  return status;
}
 80279cc:	4650      	mov	r0, sl
 80279ce:	b003      	add	sp, #12
 80279d0:	bcf0      	pop	{r4, r5, r6, r7}
 80279d2:	46bb      	mov	fp, r7
 80279d4:	46b2      	mov	sl, r6
 80279d6:	46a9      	mov	r9, r5
 80279d8:	46a0      	mov	r8, r4
 80279da:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80279dc:	0803d800 	.word	0x0803d800
 80279e0:	0803d000 	.word	0x0803d000

080279e4 <find_slot>:
  * @retval NVMS_DATA_NOT_FOUND if the slot does not exists in the block.
  */
static nvms_error_t find_slot(nvms_block_t block,
                              uint32_t slot,
                              nvms_data_header_t **hdrpp)
{
 80279e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80279e6:	46de      	mov	lr, fp
 80279e8:	4657      	mov	r7, sl
 80279ea:	464e      	mov	r6, r9
 80279ec:	4645      	mov	r5, r8
 80279ee:	b5e0      	push	{r5, r6, r7, lr}
 80279f0:	b083      	sub	sp, #12
 80279f2:	1e07      	subs	r7, r0, #0
 80279f4:	4689      	mov	r9, r1
 80279f6:	4692      	mov	sl, r2
  if (block == NVMS_BLOCK0)
 80279f8:	d00c      	beq.n	8027a14 <find_slot+0x30>
  return (uint32_t)NVMS_LL_BLOCK1_ADDRESS;
 80279fa:	4d2f      	ldr	r5, [pc, #188]	; (8027ab8 <find_slot+0xd4>)
  bool crcerr;
  bool status_found = false;
  nvms_error_t status = NVMS_INTERNAL;

  /* Limits */
  startp = (uint8_t *)NVMS_LL_GetBlockAddress(block);
 80279fc:	002c      	movs	r4, r5
  endp = &startp[NVMS_LL_GetBlockSize()];
 80279fe:	2380      	movs	r3, #128	; 0x80
 8027a00:	011b      	lsls	r3, r3, #4
 8027a02:	469c      	mov	ip, r3
 8027a04:	4465      	add	r5, ip
  nvms_error_t status = NVMS_INTERNAL;
 8027a06:	2308      	movs	r3, #8
 8027a08:	469b      	mov	fp, r3
  bool status_found = false;
 8027a0a:	2600      	movs	r6, #0

  /* Scanning the slots chain */
  hdrp = (nvms_data_header_t *)(uint32_t)startp;
  slotp = NULL;
  crcerr = false;
 8027a0c:	2300      	movs	r3, #0
 8027a0e:	9301      	str	r3, [sp, #4]
  slotp = NULL;
 8027a10:	4698      	mov	r8, r3
  while (!status_found)
 8027a12:	e028      	b.n	8027a66 <find_slot+0x82>
    return (uint32_t)NVMS_LL_BLOCK0_ADDRESS;
 8027a14:	4d29      	ldr	r5, [pc, #164]	; (8027abc <find_slot+0xd8>)
 8027a16:	e7f1      	b.n	80279fc <find_slot+0x18>
    hdrp = (nvms_data_header_t *)hdrp->fields.next;

    /* Special case end-of-chain */
    if ((hdrp->hdr8 == endp) || (hdrp->hdr8 + sizeof(nvms_data_header_t) >= endp))
    {
      if (slotp == NULL)
 8027a18:	4643      	mov	r3, r8
 8027a1a:	2b00      	cmp	r3, #0
 8027a1c:	d049      	beq.n	8027ab2 <find_slot+0xce>
      {
        return NVMS_DATA_NOT_FOUND;
      }
      *hdrpp = slotp;
 8027a1e:	4653      	mov	r3, sl
 8027a20:	4642      	mov	r2, r8
 8027a22:	601a      	str	r2, [r3, #0]
      if (crcerr)
 8027a24:	9b01      	ldr	r3, [sp, #4]
 8027a26:	2b00      	cmp	r3, #0
 8027a28:	d109      	bne.n	8027a3e <find_slot+0x5a>
      {
        return NVMS_CRC;
      }
      else
      {
        return NVMS_NOERROR;
 8027a2a:	2300      	movs	r3, #0
 8027a2c:	469b      	mov	fp, r3
        /* No action */
        break;
    }
  }
  return status;
}
 8027a2e:	4658      	mov	r0, fp
 8027a30:	b003      	add	sp, #12
 8027a32:	bcf0      	pop	{r4, r5, r6, r7}
 8027a34:	46bb      	mov	fp, r7
 8027a36:	46b2      	mov	sl, r6
 8027a38:	46a9      	mov	r9, r5
 8027a3a:	46a0      	mov	r8, r4
 8027a3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return NVMS_CRC;
 8027a3e:	2306      	movs	r3, #6
 8027a40:	469b      	mov	fp, r3
 8027a42:	e7f4      	b.n	8027a2e <find_slot+0x4a>
    switch (slotsts)
 8027a44:	2803      	cmp	r0, #3
 8027a46:	d10e      	bne.n	8027a66 <find_slot+0x82>
        if (slotp == NULL)
 8027a48:	4643      	mov	r3, r8
 8027a4a:	2b00      	cmp	r3, #0
 8027a4c:	d025      	beq.n	8027a9a <find_slot+0xb6>
          *hdrpp = slotp;
 8027a4e:	4653      	mov	r3, sl
 8027a50:	4642      	mov	r2, r8
 8027a52:	601a      	str	r2, [r3, #0]
          if (crcerr)
 8027a54:	9e01      	ldr	r6, [sp, #4]
 8027a56:	2e00      	cmp	r6, #0
 8027a58:	d023      	beq.n	8027aa2 <find_slot+0xbe>
            status = NVMS_CRC;
 8027a5a:	2306      	movs	r3, #6
 8027a5c:	469b      	mov	fp, r3
 8027a5e:	e002      	b.n	8027a66 <find_slot+0x82>
        if (hdrp->fields.slot == slot)
 8027a60:	68a3      	ldr	r3, [r4, #8]
 8027a62:	454b      	cmp	r3, r9
 8027a64:	d021      	beq.n	8027aaa <find_slot+0xc6>
  while (!status_found)
 8027a66:	2e00      	cmp	r6, #0
 8027a68:	d1e1      	bne.n	8027a2e <find_slot+0x4a>
    hdrp = (nvms_data_header_t *)hdrp->fields.next;
 8027a6a:	6924      	ldr	r4, [r4, #16]
    if ((hdrp->hdr8 == endp) || (hdrp->hdr8 + sizeof(nvms_data_header_t) >= endp))
 8027a6c:	42ac      	cmp	r4, r5
 8027a6e:	d0d3      	beq.n	8027a18 <find_slot+0x34>
 8027a70:	0023      	movs	r3, r4
 8027a72:	3320      	adds	r3, #32
 8027a74:	42ab      	cmp	r3, r5
 8027a76:	d2cf      	bcs.n	8027a18 <find_slot+0x34>
    slotsts = check_slot_instance(block, hdrp);
 8027a78:	0021      	movs	r1, r4
 8027a7a:	0038      	movs	r0, r7
 8027a7c:	f7ff fefa 	bl	8027874 <check_slot_instance>
    switch (slotsts)
 8027a80:	2802      	cmp	r0, #2
 8027a82:	d0ed      	beq.n	8027a60 <find_slot+0x7c>
 8027a84:	d8de      	bhi.n	8027a44 <find_slot+0x60>
 8027a86:	2800      	cmp	r0, #0
 8027a88:	d0de      	beq.n	8027a48 <find_slot+0x64>
 8027a8a:	2801      	cmp	r0, #1
 8027a8c:	d1eb      	bne.n	8027a66 <find_slot+0x82>
        if (hdrp->fields.slot == slot)
 8027a8e:	68a3      	ldr	r3, [r4, #8]
 8027a90:	454b      	cmp	r3, r9
 8027a92:	d1e8      	bne.n	8027a66 <find_slot+0x82>
          crcerr = false;
 8027a94:	9601      	str	r6, [sp, #4]
          slotp = hdrp;
 8027a96:	46a0      	mov	r8, r4
 8027a98:	e7e5      	b.n	8027a66 <find_slot+0x82>
          status = NVMS_DATA_NOT_FOUND;
 8027a9a:	2305      	movs	r3, #5
 8027a9c:	469b      	mov	fp, r3
        status_found = true;
 8027a9e:	2601      	movs	r6, #1
 8027aa0:	e7e1      	b.n	8027a66 <find_slot+0x82>
            status = NVMS_NOERROR;
 8027aa2:	2300      	movs	r3, #0
 8027aa4:	469b      	mov	fp, r3
        status_found = true;
 8027aa6:	2601      	movs	r6, #1
 8027aa8:	e7dd      	b.n	8027a66 <find_slot+0x82>
          slotp = hdrp;
 8027aaa:	46a0      	mov	r8, r4
          crcerr = true;
 8027aac:	2301      	movs	r3, #1
 8027aae:	9301      	str	r3, [sp, #4]
 8027ab0:	e7d9      	b.n	8027a66 <find_slot+0x82>
        return NVMS_DATA_NOT_FOUND;
 8027ab2:	2305      	movs	r3, #5
 8027ab4:	469b      	mov	fp, r3
 8027ab6:	e7ba      	b.n	8027a2e <find_slot+0x4a>
 8027ab8:	0803d800 	.word	0x0803d800
 8027abc:	0803d000 	.word	0x0803d000

08027ac0 <null_callback>:
  */
static void null_callback(nvms_data_header_t *hdrp)
{

  (void)(hdrp);
}
 8027ac0:	4770      	bx	lr
	...

08027ac4 <use_slot_callback>:
  * @brief   Private callback of @p use().
  */
static void use_slot_callback(nvms_data_header_t *hdrp)
{

  nvm.slots[hdrp->fields.slot] = hdrp;
 8027ac4:	6883      	ldr	r3, [r0, #8]
 8027ac6:	3302      	adds	r3, #2
 8027ac8:	009b      	lsls	r3, r3, #2
 8027aca:	4a01      	ldr	r2, [pc, #4]	; (8027ad0 <use_slot_callback+0xc>)
 8027acc:	5098      	str	r0, [r3, r2]
}
 8027ace:	4770      	bx	lr
 8027ad0:	2000b7c8 	.word	0x2000b7c8

08027ad4 <use_end_callback>:
  * @brief   Private callback of @p use().
  */
static void use_end_callback(nvms_data_header_t *hdrp)
{

  nvm.free_next = hdrp;
 8027ad4:	4a01      	ldr	r2, [pc, #4]	; (8027adc <use_end_callback+0x8>)
 8027ad6:	23d0      	movs	r3, #208	; 0xd0
 8027ad8:	50d0      	str	r0, [r2, r3]
}
 8027ada:	4770      	bx	lr
 8027adc:	2000b7c8 	.word	0x2000b7c8

08027ae0 <use>:
  * @return                    The operation status.
  * @retval NVMS_NOERROR       if the operation has been successfully completed.
  * @retval NVMS_INTERNAL      if an internal error occurred.
  */
static nvms_error_t use(nvms_block_t block)
{
 8027ae0:	b570      	push	{r4, r5, r6, lr}
 8027ae2:	1e04      	subs	r4, r0, #0
  if (block == NVMS_BLOCK0)
 8027ae4:	d014      	beq.n	8027b10 <use+0x30>
  return (uint32_t)NVMS_LL_BLOCK1_ADDRESS;
 8027ae6:	4d1c      	ldr	r5, [pc, #112]	; (8027b58 <use+0x78>)
  uint32_t i;
  nvms_block_status_t status;
  nvms_data_header_t *hdrp = (nvms_data_header_t *)NVMS_LL_GetBlockAddress(block);

  /* Resetting state */
  reset();
 8027ae8:	f7ff fea2 	bl	8027830 <reset>

  /* Global info */
  nvm.header    = hdrp;
 8027aec:	4b1b      	ldr	r3, [pc, #108]	; (8027b5c <use+0x7c>)
 8027aee:	601d      	str	r5, [r3, #0]
  nvm.block     = block;
 8027af0:	711c      	strb	r4, [r3, #4]
  nvm.used_size = sizeof(nvms_data_header_t);
 8027af2:	22d4      	movs	r2, #212	; 0xd4
 8027af4:	2120      	movs	r1, #32
 8027af6:	5099      	str	r1, [r3, r2]
  nvm.free_next = &hdrp[1];
 8027af8:	3520      	adds	r5, #32
 8027afa:	3a04      	subs	r2, #4
 8027afc:	509d      	str	r5, [r3, r2]

  /* The block should have been checked before calling use() so any
     kind of anomaly in the block is considered an internal error */
  status = scan_slots(block, use_slot_callback, use_end_callback);
 8027afe:	4a18      	ldr	r2, [pc, #96]	; (8027b60 <use+0x80>)
 8027b00:	4918      	ldr	r1, [pc, #96]	; (8027b64 <use+0x84>)
 8027b02:	0020      	movs	r0, r4
 8027b04:	f7ff ff0c 	bl	8027920 <scan_slots>
  if (status != NVMS_STATUS_NORMAL)
 8027b08:	2801      	cmp	r0, #1
 8027b0a:	d103      	bne.n	8027b14 <use+0x34>
    reset();
    return NVMS_INTERNAL;
  }

  /* Scanning found slots */
  for (i = 0; i < NVMS_CFG_NUM_SLOTS; i++)
 8027b0c:	2300      	movs	r3, #0
 8027b0e:	e00c      	b.n	8027b2a <use+0x4a>
    return (uint32_t)NVMS_LL_BLOCK0_ADDRESS;
 8027b10:	4d15      	ldr	r5, [pc, #84]	; (8027b68 <use+0x88>)
 8027b12:	e7e9      	b.n	8027ae8 <use+0x8>
    reset();
 8027b14:	f7ff fe8c 	bl	8027830 <reset>
    return NVMS_INTERNAL;
 8027b18:	2008      	movs	r0, #8
 8027b1a:	e01b      	b.n	8027b54 <use+0x74>
    {
      /* Zero sized slots are discarded because indicate that the slot
         has been erased */
      if (hdrp->fields.data_size == 0UL)
      {
        nvm.slots[hdrp->fields.slot] = NULL;
 8027b1c:	6892      	ldr	r2, [r2, #8]
 8027b1e:	3202      	adds	r2, #2
 8027b20:	0092      	lsls	r2, r2, #2
 8027b22:	490e      	ldr	r1, [pc, #56]	; (8027b5c <use+0x7c>)
 8027b24:	2000      	movs	r0, #0
 8027b26:	5050      	str	r0, [r2, r1]
  for (i = 0; i < NVMS_CFG_NUM_SLOTS; i++)
 8027b28:	3301      	adds	r3, #1
 8027b2a:	2b31      	cmp	r3, #49	; 0x31
 8027b2c:	d811      	bhi.n	8027b52 <use+0x72>
    hdrp = nvm.slots[i];
 8027b2e:	1c9a      	adds	r2, r3, #2
 8027b30:	0092      	lsls	r2, r2, #2
 8027b32:	490a      	ldr	r1, [pc, #40]	; (8027b5c <use+0x7c>)
 8027b34:	5852      	ldr	r2, [r2, r1]
    if (hdrp != NULL)
 8027b36:	2a00      	cmp	r2, #0
 8027b38:	d0f6      	beq.n	8027b28 <use+0x48>
      if (hdrp->fields.data_size == 0UL)
 8027b3a:	6991      	ldr	r1, [r2, #24]
 8027b3c:	2900      	cmp	r1, #0
 8027b3e:	d0ed      	beq.n	8027b1c <use+0x3c>
        continue;
      }

      /* Adding the slot used space to the total */
      nvm.used_size += hdrp->fields.next->hdr8 - hdrp->hdr8;
 8027b40:	6911      	ldr	r1, [r2, #16]
 8027b42:	1a8a      	subs	r2, r1, r2
 8027b44:	4805      	ldr	r0, [pc, #20]	; (8027b5c <use+0x7c>)
 8027b46:	21d4      	movs	r1, #212	; 0xd4
 8027b48:	5844      	ldr	r4, [r0, r1]
 8027b4a:	46a4      	mov	ip, r4
 8027b4c:	4462      	add	r2, ip
 8027b4e:	5042      	str	r2, [r0, r1]
 8027b50:	e7ea      	b.n	8027b28 <use+0x48>
    }
  }

  return NVMS_NOERROR;
 8027b52:	2000      	movs	r0, #0
}
 8027b54:	bd70      	pop	{r4, r5, r6, pc}
 8027b56:	46c0      	nop			; (mov r8, r8)
 8027b58:	0803d800 	.word	0x0803d800
 8027b5c:	2000b7c8 	.word	0x2000b7c8
 8027b60:	08027ad5 	.word	0x08027ad5
 8027b64:	08027ac5 	.word	0x08027ac5
 8027b68:	0803d000 	.word	0x0803d000

08027b6c <determine_block_state>:
  *                               readable.
  * @retval NVMS_STATUS_BROKEN    if the block contains unreadable garbage.
  */
static nvms_block_status_t determine_block_state(nvms_block_t block,
                                                 uint32_t *instance)
{
 8027b6c:	b570      	push	{r4, r5, r6, lr}
 8027b6e:	0004      	movs	r4, r0
 8027b70:	000d      	movs	r5, r1
  /* Special case where the block is fully erased */
  if (NVMS_LL_IsBlockErased(block))
 8027b72:	f7f9 fddf 	bl	8021734 <NVMS_LL_IsBlockErased>
 8027b76:	2800      	cmp	r0, #0
 8027b78:	d10c      	bne.n	8027b94 <determine_block_state+0x28>
  if (block == NVMS_BLOCK0)
 8027b7a:	2c00      	cmp	r4, #0
 8027b7c:	d008      	beq.n	8027b90 <determine_block_state+0x24>
  return (uint32_t)NVMS_LL_BLOCK1_ADDRESS;
 8027b7e:	4b06      	ldr	r3, [pc, #24]	; (8027b98 <determine_block_state+0x2c>)
  {
    return NVMS_STATUS_ERASED;
  }

  /* Returning the block instance number */
  *instance = ((nvms_data_header_t *)NVMS_LL_GetBlockAddress(block))->fields.instance;
 8027b80:	68db      	ldr	r3, [r3, #12]
 8027b82:	602b      	str	r3, [r5, #0]

  /* Checking block integrity by just scanning it */
  return scan_slots(block, null_callback, null_callback);
 8027b84:	4905      	ldr	r1, [pc, #20]	; (8027b9c <determine_block_state+0x30>)
 8027b86:	000a      	movs	r2, r1
 8027b88:	0020      	movs	r0, r4
 8027b8a:	f7ff fec9 	bl	8027920 <scan_slots>
}
 8027b8e:	bd70      	pop	{r4, r5, r6, pc}
    return (uint32_t)NVMS_LL_BLOCK0_ADDRESS;
 8027b90:	4b03      	ldr	r3, [pc, #12]	; (8027ba0 <determine_block_state+0x34>)
 8027b92:	e7f5      	b.n	8027b80 <determine_block_state+0x14>
    return NVMS_STATUS_ERASED;
 8027b94:	2000      	movs	r0, #0
 8027b96:	e7fa      	b.n	8027b8e <determine_block_state+0x22>
 8027b98:	0803d800 	.word	0x0803d800
 8027b9c:	08027ac1 	.word	0x08027ac1
 8027ba0:	0803d000 	.word	0x0803d000

08027ba4 <copy_slot>:
{
 8027ba4:	b570      	push	{r4, r5, r6, lr}
 8027ba6:	b088      	sub	sp, #32
 8027ba8:	0004      	movs	r4, r0
 8027baa:	000d      	movs	r5, r1
  size = rhdrp->fields.data_size;
 8027bac:	6986      	ldr	r6, [r0, #24]
  p_free = &p_next[(((sizeof(nvms_data_header_t) + size - 1UL) | (NVMS_LL_PAGE_SIZE - 1UL)) + 1UL)];
 8027bae:	0033      	movs	r3, r6
 8027bb0:	331f      	adds	r3, #31
 8027bb2:	2207      	movs	r2, #7
 8027bb4:	4313      	orrs	r3, r2
 8027bb6:	3301      	adds	r3, #1
 8027bb8:	18cb      	adds	r3, r1, r3
  hdr.fields.magic1             = NVMS_LL_ERASED;
 8027bba:	3a08      	subs	r2, #8
 8027bbc:	9200      	str	r2, [sp, #0]
  hdr.fields.magic2             = NVMS_LL_ERASED;
 8027bbe:	9201      	str	r2, [sp, #4]
  hdr.fields.slot                = rhdrp->fields.slot;
 8027bc0:	6882      	ldr	r2, [r0, #8]
 8027bc2:	9202      	str	r2, [sp, #8]
  hdr.fields.instance           = 1;    /* Resetting instance number */
 8027bc4:	2201      	movs	r2, #1
 8027bc6:	9203      	str	r2, [sp, #12]
  hdr.fields.next               = (nvms_data_header_t *)(uint32_t)p_free;
 8027bc8:	9304      	str	r3, [sp, #16]
  hdr.fields.data_type       = rhdrp->fields.data_type;
 8027bca:	6943      	ldr	r3, [r0, #20]
 8027bcc:	9305      	str	r3, [sp, #20]
  hdr.fields.data_size       = size;
 8027bce:	9606      	str	r6, [sp, #24]
  hdr.fields.data_checksum   = rhdrp->fields.data_checksum;
 8027bd0:	69c3      	ldr	r3, [r0, #28]
 8027bd2:	9307      	str	r3, [sp, #28]
  result = NVMS_LL_Write(&((const uint8_t *)&hdr)[8], &p_next[8], sizeof(nvms_data_header_t) - 8UL);
 8027bd4:	3108      	adds	r1, #8
 8027bd6:	3217      	adds	r2, #23
 8027bd8:	a802      	add	r0, sp, #8
 8027bda:	f7f9 fde9 	bl	80217b0 <NVMS_LL_Write>
  if (result)
 8027bde:	2800      	cmp	r0, #0
 8027be0:	d115      	bne.n	8027c0e <copy_slot+0x6a>
  result = NVMS_LL_Write(rhdrp->hdr8 + sizeof(nvms_data_header_t),
 8027be2:	0029      	movs	r1, r5
 8027be4:	3120      	adds	r1, #32
 8027be6:	0020      	movs	r0, r4
 8027be8:	3020      	adds	r0, #32
 8027bea:	0032      	movs	r2, r6
 8027bec:	f7f9 fde0 	bl	80217b0 <NVMS_LL_Write>
  if (result)
 8027bf0:	2800      	cmp	r0, #0
 8027bf2:	d10f      	bne.n	8027c14 <copy_slot+0x70>
  hdr.fields.magic1 = NVMS_HEADER_MAGIC1;
 8027bf4:	4b08      	ldr	r3, [pc, #32]	; (8027c18 <copy_slot+0x74>)
 8027bf6:	9300      	str	r3, [sp, #0]
  hdr.fields.magic2 = NVMS_HEADER_MAGIC2;
 8027bf8:	4b08      	ldr	r3, [pc, #32]	; (8027c1c <copy_slot+0x78>)
 8027bfa:	9301      	str	r3, [sp, #4]
  result = NVMS_LL_Write((const uint8_t *)&hdr, p_next, sizeof(uint32_t) * 2UL);
 8027bfc:	2208      	movs	r2, #8
 8027bfe:	0029      	movs	r1, r5
 8027c00:	4668      	mov	r0, sp
 8027c02:	f7f9 fdd5 	bl	80217b0 <NVMS_LL_Write>
  if (result)
 8027c06:	2800      	cmp	r0, #0
 8027c08:	d002      	beq.n	8027c10 <copy_slot+0x6c>
    return NVMS_FLASH_FAILURE;
 8027c0a:	2003      	movs	r0, #3
 8027c0c:	e000      	b.n	8027c10 <copy_slot+0x6c>
    return NVMS_FLASH_FAILURE;
 8027c0e:	2003      	movs	r0, #3
}
 8027c10:	b008      	add	sp, #32
 8027c12:	bd70      	pop	{r4, r5, r6, pc}
    return NVMS_FLASH_FAILURE;
 8027c14:	2003      	movs	r0, #3
 8027c16:	e7fb      	b.n	8027c10 <copy_slot+0x6c>
 8027c18:	5aa5f731 	.word	0x5aa5f731
 8027c1c:	137fa55a 	.word	0x137fa55a

08027c20 <copy_slots>:
{
 8027c20:	b570      	push	{r4, r5, r6, lr}
 8027c22:	b082      	sub	sp, #8
 8027c24:	0005      	movs	r5, r0
  if (block == NVMS_BLOCK0)
 8027c26:	2900      	cmp	r1, #0
 8027c28:	d003      	beq.n	8027c32 <copy_slots+0x12>
  return (uint32_t)NVMS_LL_BLOCK1_ADDRESS;
 8027c2a:	4e0f      	ldr	r6, [pc, #60]	; (8027c68 <copy_slots+0x48>)
  whdrp = (nvms_data_header_t *)NVMS_LL_GetBlockAddress(dest_block) + 1;
 8027c2c:	3620      	adds	r6, #32
  for (slot = 0; slot < NVMS_CFG_NUM_SLOTS; slot++)
 8027c2e:	2400      	movs	r4, #0
 8027c30:	e002      	b.n	8027c38 <copy_slots+0x18>
    return (uint32_t)NVMS_LL_BLOCK0_ADDRESS;
 8027c32:	4e0e      	ldr	r6, [pc, #56]	; (8027c6c <copy_slots+0x4c>)
 8027c34:	e7fa      	b.n	8027c2c <copy_slots+0xc>
 8027c36:	3401      	adds	r4, #1
 8027c38:	2c31      	cmp	r4, #49	; 0x31
 8027c3a:	d811      	bhi.n	8027c60 <copy_slots+0x40>
    err = find_slot(source_block, slot, &rhdrp);
 8027c3c:	aa01      	add	r2, sp, #4
 8027c3e:	0021      	movs	r1, r4
 8027c40:	0028      	movs	r0, r5
 8027c42:	f7ff fecf 	bl	80279e4 <find_slot>
    if ((err == NVMS_NOERROR) && (rhdrp->fields.data_size > 0UL))
 8027c46:	2800      	cmp	r0, #0
 8027c48:	d1f5      	bne.n	8027c36 <copy_slots+0x16>
 8027c4a:	9801      	ldr	r0, [sp, #4]
 8027c4c:	6983      	ldr	r3, [r0, #24]
 8027c4e:	2b00      	cmp	r3, #0
 8027c50:	d0f1      	beq.n	8027c36 <copy_slots+0x16>
      err = copy_slot(rhdrp, whdrp);
 8027c52:	0031      	movs	r1, r6
 8027c54:	f7ff ffa6 	bl	8027ba4 <copy_slot>
      if (err != NVMS_NOERROR)
 8027c58:	2800      	cmp	r0, #0
 8027c5a:	d102      	bne.n	8027c62 <copy_slots+0x42>
      whdrp = (nvms_data_header_t *)whdrp->fields.next;
 8027c5c:	6936      	ldr	r6, [r6, #16]
 8027c5e:	e7ea      	b.n	8027c36 <copy_slots+0x16>
  return NVMS_NOERROR;
 8027c60:	2000      	movs	r0, #0
}
 8027c62:	b002      	add	sp, #8
 8027c64:	bd70      	pop	{r4, r5, r6, pc}
 8027c66:	46c0      	nop			; (mov r8, r8)
 8027c68:	0803d800 	.word	0x0803d800
 8027c6c:	0803d000 	.word	0x0803d000

08027c70 <validate>:
{
 8027c70:	b510      	push	{r4, lr}
 8027c72:	b088      	sub	sp, #32
  if (block == NVMS_BLOCK0)
 8027c74:	2800      	cmp	r0, #0
 8027c76:	d021      	beq.n	8027cbc <validate+0x4c>
  return (uint32_t)NVMS_LL_BLOCK1_ADDRESS;
 8027c78:	4c13      	ldr	r4, [pc, #76]	; (8027cc8 <validate+0x58>)
  hdr.fields.magic1             = NVMS_LL_ERASED;
 8027c7a:	2201      	movs	r2, #1
 8027c7c:	4252      	negs	r2, r2
 8027c7e:	9200      	str	r2, [sp, #0]
  hdr.fields.magic2             = NVMS_LL_ERASED;
 8027c80:	9201      	str	r2, [sp, #4]
  hdr.fields.slot               = NVMS_SLOT_MAIN_HEADER;
 8027c82:	2300      	movs	r3, #0
 8027c84:	9302      	str	r3, [sp, #8]
  hdr.fields.instance           = instance;
 8027c86:	9103      	str	r1, [sp, #12]
  hdr.fields.next               = &((nvms_data_header_t *)(uint32_t)dp)[1];
 8027c88:	0021      	movs	r1, r4
 8027c8a:	3120      	adds	r1, #32
 8027c8c:	9104      	str	r1, [sp, #16]
  hdr.fields.data_type       = NVMS_LL_ERASED;
 8027c8e:	9205      	str	r2, [sp, #20]
  hdr.fields.data_size       = 0;
 8027c90:	9306      	str	r3, [sp, #24]
  hdr.fields.data_checksum   = 0;
 8027c92:	9307      	str	r3, [sp, #28]
  result = NVMS_LL_Write(&hdr.hdr8[8], &dp[8], sizeof(nvms_data_header_t) - 8UL);
 8027c94:	3918      	subs	r1, #24
 8027c96:	3219      	adds	r2, #25
 8027c98:	a802      	add	r0, sp, #8
 8027c9a:	f7f9 fd89 	bl	80217b0 <NVMS_LL_Write>
  if (result)
 8027c9e:	2800      	cmp	r0, #0
 8027ca0:	d10e      	bne.n	8027cc0 <validate+0x50>
  hdr.fields.magic1 = NVMS_HEADER_MAGIC1;
 8027ca2:	4b0a      	ldr	r3, [pc, #40]	; (8027ccc <validate+0x5c>)
 8027ca4:	9300      	str	r3, [sp, #0]
  hdr.fields.magic2 = NVMS_HEADER_MAGIC2;
 8027ca6:	4b0a      	ldr	r3, [pc, #40]	; (8027cd0 <validate+0x60>)
 8027ca8:	9301      	str	r3, [sp, #4]
  result = NVMS_LL_Write(hdr.hdr8, dp, sizeof(uint32_t) * 2UL);
 8027caa:	2208      	movs	r2, #8
 8027cac:	0021      	movs	r1, r4
 8027cae:	4668      	mov	r0, sp
 8027cb0:	f7f9 fd7e 	bl	80217b0 <NVMS_LL_Write>
  if (result)
 8027cb4:	2800      	cmp	r0, #0
 8027cb6:	d105      	bne.n	8027cc4 <validate+0x54>
}
 8027cb8:	b008      	add	sp, #32
 8027cba:	bd10      	pop	{r4, pc}
    return (uint32_t)NVMS_LL_BLOCK0_ADDRESS;
 8027cbc:	4c05      	ldr	r4, [pc, #20]	; (8027cd4 <validate+0x64>)
 8027cbe:	e7dc      	b.n	8027c7a <validate+0xa>
    return NVMS_FLASH_FAILURE;
 8027cc0:	2003      	movs	r0, #3
 8027cc2:	e7f9      	b.n	8027cb8 <validate+0x48>
    return NVMS_FLASH_FAILURE;
 8027cc4:	2003      	movs	r0, #3
 8027cc6:	e7f7      	b.n	8027cb8 <validate+0x48>
 8027cc8:	0803d800 	.word	0x0803d800
 8027ccc:	5aa5f731 	.word	0x5aa5f731
 8027cd0:	137fa55a 	.word	0x137fa55a
 8027cd4:	0803d000 	.word	0x0803d000

08027cd8 <append_slot>:
  * @retval NVMS_FLASH_FAILURE if the flash memory is unusable because HW
  *                            failures.
  */
static nvms_error_t append_slot(nvms_slot_t slot, size_t size, nvms_data_type_t type,
                                const uint8_t *slotp, uint32_t instance)
{
 8027cd8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8027cda:	b089      	sub	sp, #36	; 0x24
 8027cdc:	000d      	movs	r5, r1
 8027cde:	001e      	movs	r6, r3
  bool result;
  nvms_data_header_t hdr;
  uint8_t *p_next;
  uint8_t *p_free;

  p_next = nvm.free_next->hdr8;
 8027ce0:	4920      	ldr	r1, [pc, #128]	; (8027d64 <append_slot+0x8c>)
 8027ce2:	23d0      	movs	r3, #208	; 0xd0
 8027ce4:	58cf      	ldr	r7, [r1, r3]
  p_free = &p_next[(((sizeof(nvms_data_header_t) + size - 1UL) | (NVMS_LL_PAGE_SIZE - 1UL)) + 1UL)];
 8027ce6:	002c      	movs	r4, r5
 8027ce8:	341f      	adds	r4, #31
 8027cea:	3bc9      	subs	r3, #201	; 0xc9
 8027cec:	431c      	orrs	r4, r3
 8027cee:	3401      	adds	r4, #1
 8027cf0:	193c      	adds	r4, r7, r4

  /* Writing the header without the magic numbers, this way it is
     not yet validated but the write is tested */
  hdr.fields.magic1             = NVMS_LL_ERASED;
 8027cf2:	3b08      	subs	r3, #8
 8027cf4:	9300      	str	r3, [sp, #0]
  hdr.fields.magic2             = NVMS_LL_ERASED;
 8027cf6:	9301      	str	r3, [sp, #4]
  hdr.fields.slot               = slot;
 8027cf8:	9002      	str	r0, [sp, #8]
  hdr.fields.instance           = instance;
 8027cfa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8027cfc:	9303      	str	r3, [sp, #12]
  hdr.fields.next               = (nvms_data_header_t *)(uint32_t)p_free;
 8027cfe:	9404      	str	r4, [sp, #16]
  hdr.fields.data_type          = type;
 8027d00:	9205      	str	r2, [sp, #20]
  hdr.fields.data_size          = size;
 8027d02:	9506      	str	r5, [sp, #24]
  hdr.fields.data_checksum      = do_checksum(slotp, size);
 8027d04:	0029      	movs	r1, r5
 8027d06:	0030      	movs	r0, r6
 8027d08:	f7ff fdaa 	bl	8027860 <do_checksum>
 8027d0c:	9007      	str	r0, [sp, #28]

  /* Do not write the full structure (including the 2 initial words set to the ERASED FLASH value), but only the
  meaningful data
  Rationale : writing the erased_default value on some platform prevent any further update of the flash
  */
  result = NVMS_LL_Write(&((const uint8_t *)&hdr)[8], &p_next[8], sizeof(nvms_data_header_t) - 8UL);
 8027d0e:	0039      	movs	r1, r7
 8027d10:	3108      	adds	r1, #8
 8027d12:	2218      	movs	r2, #24
 8027d14:	a802      	add	r0, sp, #8
 8027d16:	f7f9 fd4b 	bl	80217b0 <NVMS_LL_Write>
  if (result)
 8027d1a:	2800      	cmp	r0, #0
 8027d1c:	d11b      	bne.n	8027d56 <append_slot+0x7e>
  {
    return NVMS_FLASH_FAILURE;
  }

  /* Writing data */
  if (size > 0UL)
 8027d1e:	2d00      	cmp	r5, #0
 8027d20:	d007      	beq.n	8027d32 <append_slot+0x5a>
  {
    result = NVMS_LL_Write(slotp, &p_next[sizeof(nvms_data_header_t)], size);
 8027d22:	0039      	movs	r1, r7
 8027d24:	3120      	adds	r1, #32
 8027d26:	002a      	movs	r2, r5
 8027d28:	0030      	movs	r0, r6
 8027d2a:	f7f9 fd41 	bl	80217b0 <NVMS_LL_Write>
    if (result)
 8027d2e:	2800      	cmp	r0, #0
 8027d30:	d113      	bne.n	8027d5a <append_slot+0x82>
      return NVMS_FLASH_FAILURE;
    }
  }

  /* Writing the magic numbers validates the header */
  hdr.fields.magic1 = NVMS_HEADER_MAGIC1;
 8027d32:	4b0d      	ldr	r3, [pc, #52]	; (8027d68 <append_slot+0x90>)
 8027d34:	9300      	str	r3, [sp, #0]
  hdr.fields.magic2 = NVMS_HEADER_MAGIC2;
 8027d36:	4b0d      	ldr	r3, [pc, #52]	; (8027d6c <append_slot+0x94>)
 8027d38:	9301      	str	r3, [sp, #4]
  result = NVMS_LL_Write((const uint8_t *)&hdr,
                         nvm.free_next->hdr8,
 8027d3a:	4a0a      	ldr	r2, [pc, #40]	; (8027d64 <append_slot+0x8c>)
 8027d3c:	23d0      	movs	r3, #208	; 0xd0
 8027d3e:	58d1      	ldr	r1, [r2, r3]
  result = NVMS_LL_Write((const uint8_t *)&hdr,
 8027d40:	2208      	movs	r2, #8
 8027d42:	4668      	mov	r0, sp
 8027d44:	f7f9 fd34 	bl	80217b0 <NVMS_LL_Write>
                         sizeof(uint32_t) * 2UL);
  if (result)
 8027d48:	2800      	cmp	r0, #0
 8027d4a:	d108      	bne.n	8027d5e <append_slot+0x86>
  {
    return NVMS_FLASH_FAILURE;
  }
  /* Updating the global pointer */
  nvm.free_next = (nvms_data_header_t *)(uint32_t)p_free;
 8027d4c:	4a05      	ldr	r2, [pc, #20]	; (8027d64 <append_slot+0x8c>)
 8027d4e:	23d0      	movs	r3, #208	; 0xd0
 8027d50:	50d4      	str	r4, [r2, r3]

  return NVMS_NOERROR;
}
 8027d52:	b009      	add	sp, #36	; 0x24
 8027d54:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return NVMS_FLASH_FAILURE;
 8027d56:	2003      	movs	r0, #3
 8027d58:	e7fb      	b.n	8027d52 <append_slot+0x7a>
      return NVMS_FLASH_FAILURE;
 8027d5a:	2003      	movs	r0, #3
 8027d5c:	e7f9      	b.n	8027d52 <append_slot+0x7a>
    return NVMS_FLASH_FAILURE;
 8027d5e:	2003      	movs	r0, #3
 8027d60:	e7f7      	b.n	8027d52 <append_slot+0x7a>
 8027d62:	46c0      	nop			; (mov r8, r8)
 8027d64:	2000b7c8 	.word	0x2000b7c8
 8027d68:	5aa5f731 	.word	0x5aa5f731
 8027d6c:	137fa55a 	.word	0x137fa55a

08027d70 <block_erase>:
{
 8027d70:	b510      	push	{r4, lr}
  result = NVMS_LL_BlockErase(block);
 8027d72:	f7f9 fcf7 	bl	8021764 <NVMS_LL_BlockErase>
  if (result)
 8027d76:	2800      	cmp	r0, #0
 8027d78:	d100      	bne.n	8027d7c <block_erase+0xc>
}
 8027d7a:	bd10      	pop	{r4, pc}
    return NVMS_FLASH_FAILURE;
 8027d7c:	2003      	movs	r0, #3
 8027d7e:	e7fc      	b.n	8027d7a <block_erase+0xa>

08027d80 <try_boot>:
  * @retval NVMS_FLASH_FAILURE if the flash memory is unusable because HW
  *                            failures.
  * @retval NVMS_INTERNAL      if an internal error occurred.
  */
static nvms_error_t try_boot(void)
{
 8027d80:	b570      	push	{r4, r5, r6, lr}
 8027d82:	b082      	sub	sp, #8
  nvms_block_status_t sts0;
  nvms_block_status_t sts1;
  uint32_t seq0 = 0;
 8027d84:	2300      	movs	r3, #0
 8027d86:	9301      	str	r3, [sp, #4]
  uint32_t seq1 = 0;
 8027d88:	9300      	str	r3, [sp, #0]

  sts0 = determine_block_state(NVMS_BLOCK0, &seq0);
 8027d8a:	a901      	add	r1, sp, #4
 8027d8c:	2000      	movs	r0, #0
 8027d8e:	f7ff feed 	bl	8027b6c <determine_block_state>
 8027d92:	0005      	movs	r5, r0
 8027d94:	0006      	movs	r6, r0
  sts1 = determine_block_state(NVMS_BLOCK1, &seq1);
 8027d96:	4669      	mov	r1, sp
 8027d98:	2001      	movs	r0, #1
 8027d9a:	f7ff fee7 	bl	8027b6c <determine_block_state>
 8027d9e:	0004      	movs	r4, r0
 8027da0:	0002      	movs	r2, r0

  /* Case 1 - Both block erased, performs an initialization of block zero
     and starts using it */
  if ((sts0 == NVMS_STATUS_ERASED) && (sts1 == NVMS_STATUS_ERASED))
 8027da2:	002b      	movs	r3, r5
 8027da4:	4303      	orrs	r3, r0
 8027da6:	b2db      	uxtb	r3, r3
 8027da8:	2b00      	cmp	r3, #0
 8027daa:	d015      	beq.n	8027dd8 <try_boot+0x58>

    return NVMS_NOERROR;
  }

  /* Cases 2, 3, 4 - Block zero is erased */
  if (sts0 == NVMS_STATUS_ERASED)
 8027dac:	2d00      	cmp	r5, #0
 8027dae:	d139      	bne.n	8027e24 <try_boot+0xa4>
  {

    /* Case 2 - Block zero is erased, block one is normal */
    if (sts1 == NVMS_STATUS_NORMAL)
 8027db0:	2801      	cmp	r0, #1
 8027db2:	d01c      	beq.n	8027dee <try_boot+0x6e>

      return NVMS_NOERROR;
    }

    /* Case 3 - Block zero is erased, block one is partially corrupted */
    if (sts1 == NVMS_STATUS_PARTIAL)
 8027db4:	2802      	cmp	r0, #2
 8027db6:	d01e      	beq.n	8027df6 <try_boot+0x76>
      return NVMS_WARNING;
    }

    /* Case 4 - Block zero is erased, block one is broken. Note, the
       variable "sts1" is assumed to have value "NVMS_STATUS_BROKEN" */
    CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027db8:	2001      	movs	r0, #1
 8027dba:	f7ff ffd9 	bl	8027d70 <block_erase>
 8027dbe:	2800      	cmp	r0, #0
 8027dc0:	d110      	bne.n	8027de4 <try_boot+0x64>
    CHECK_ERROR(validate(NVMS_BLOCK0, 1));
 8027dc2:	2101      	movs	r1, #1
 8027dc4:	f7ff ff54 	bl	8027c70 <validate>
 8027dc8:	2800      	cmp	r0, #0
 8027dca:	d10b      	bne.n	8027de4 <try_boot+0x64>
    CHECK_ERROR(use(NVMS_BLOCK0));
 8027dcc:	f7ff fe88 	bl	8027ae0 <use>
 8027dd0:	2800      	cmp	r0, #0
 8027dd2:	d107      	bne.n	8027de4 <try_boot+0x64>

#if defined(KMS_DEBUG_MODE)
    latest_warning = NVMS_WARNING_ONE_BLOCK_BROKEN;
#endif /* KMS_DEBUG_MODE */
    return NVMS_WARNING;
 8027dd4:	2002      	movs	r0, #2
 8027dd6:	e005      	b.n	8027de4 <try_boot+0x64>
    CHECK_ERROR(validate(NVMS_BLOCK0, 1));
 8027dd8:	2101      	movs	r1, #1
 8027dda:	2000      	movs	r0, #0
 8027ddc:	f7ff ff48 	bl	8027c70 <validate>
 8027de0:	2800      	cmp	r0, #0
 8027de2:	d001      	beq.n	8027de8 <try_boot+0x68>
#if defined(KMS_DEBUG_MODE)
  latest_warning = NVMS_WARNING_TWO_BLOCKS_BROKEN;
#endif /* KMS_DEBUG_MODE */

  return NVMS_WARNING;
}
 8027de4:	b002      	add	sp, #8
 8027de6:	bd70      	pop	{r4, r5, r6, pc}
    CHECK_ERROR(use(NVMS_BLOCK0));
 8027de8:	f7ff fe7a 	bl	8027ae0 <use>
 8027dec:	e7fa      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK1));
 8027dee:	2001      	movs	r0, #1
 8027df0:	f7ff fe76 	bl	8027ae0 <use>
 8027df4:	e7f6      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(copy_slots(NVMS_BLOCK1, NVMS_BLOCK0));
 8027df6:	2100      	movs	r1, #0
 8027df8:	2001      	movs	r0, #1
 8027dfa:	f7ff ff11 	bl	8027c20 <copy_slots>
 8027dfe:	2800      	cmp	r0, #0
 8027e00:	d1f0      	bne.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(validate(NVMS_BLOCK0, seq1 + 1UL));
 8027e02:	9b00      	ldr	r3, [sp, #0]
 8027e04:	1c59      	adds	r1, r3, #1
 8027e06:	f7ff ff33 	bl	8027c70 <validate>
 8027e0a:	2800      	cmp	r0, #0
 8027e0c:	d1ea      	bne.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027e0e:	3001      	adds	r0, #1
 8027e10:	f7ff ffae 	bl	8027d70 <block_erase>
 8027e14:	2800      	cmp	r0, #0
 8027e16:	d1e5      	bne.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK0));
 8027e18:	f7ff fe62 	bl	8027ae0 <use>
 8027e1c:	2800      	cmp	r0, #0
 8027e1e:	d1e1      	bne.n	8027de4 <try_boot+0x64>
      return NVMS_WARNING;
 8027e20:	0020      	movs	r0, r4
 8027e22:	e7df      	b.n	8027de4 <try_boot+0x64>
  if (sts1 == NVMS_STATUS_ERASED)
 8027e24:	2800      	cmp	r0, #0
 8027e26:	d105      	bne.n	8027e34 <try_boot+0xb4>
    if (sts0 == NVMS_STATUS_NORMAL)
 8027e28:	2d01      	cmp	r5, #1
 8027e2a:	d02a      	beq.n	8027e82 <try_boot+0x102>
    if (sts0 == NVMS_STATUS_PARTIAL)
 8027e2c:	2d02      	cmp	r5, #2
 8027e2e:	d02c      	beq.n	8027e8a <try_boot+0x10a>
    if (sts0 == NVMS_STATUS_BROKEN)
 8027e30:	2d03      	cmp	r5, #3
 8027e32:	d042      	beq.n	8027eba <try_boot+0x13a>
  if ((sts0 == NVMS_STATUS_NORMAL) && (sts1 == NVMS_STATUS_NORMAL))
 8027e34:	2e01      	cmp	r6, #1
 8027e36:	d055      	beq.n	8027ee4 <try_boot+0x164>
  if ((sts0 == NVMS_STATUS_PARTIAL) && (sts1 == NVMS_STATUS_PARTIAL))
 8027e38:	2e02      	cmp	r6, #2
 8027e3a:	d074      	beq.n	8027f26 <try_boot+0x1a6>
  if (sts0 == NVMS_STATUS_NORMAL)
 8027e3c:	2e01      	cmp	r6, #1
 8027e3e:	d100      	bne.n	8027e42 <try_boot+0xc2>
 8027e40:	e0b9      	b.n	8027fb6 <try_boot+0x236>
  if (sts1 == NVMS_STATUS_NORMAL)
 8027e42:	2a01      	cmp	r2, #1
 8027e44:	d100      	bne.n	8027e48 <try_boot+0xc8>
 8027e46:	e0fa      	b.n	802803e <try_boot+0x2be>
  if ((sts0 == NVMS_STATUS_PARTIAL) && (sts1 == NVMS_STATUS_BROKEN))
 8027e48:	2e02      	cmp	r6, #2
 8027e4a:	d100      	bne.n	8027e4e <try_boot+0xce>
 8027e4c:	e13d      	b.n	80280ca <try_boot+0x34a>
  if ((sts0 == NVMS_STATUS_BROKEN) && (sts1 == NVMS_STATUS_PARTIAL))
 8027e4e:	2e03      	cmp	r6, #3
 8027e50:	d102      	bne.n	8027e58 <try_boot+0xd8>
 8027e52:	2a02      	cmp	r2, #2
 8027e54:	d100      	bne.n	8027e58 <try_boot+0xd8>
 8027e56:	e15c      	b.n	8028112 <try_boot+0x392>
  CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027e58:	2000      	movs	r0, #0
 8027e5a:	f7ff ff89 	bl	8027d70 <block_erase>
 8027e5e:	2800      	cmp	r0, #0
 8027e60:	d1c0      	bne.n	8027de4 <try_boot+0x64>
  CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027e62:	3001      	adds	r0, #1
 8027e64:	f7ff ff84 	bl	8027d70 <block_erase>
 8027e68:	2800      	cmp	r0, #0
 8027e6a:	d1bb      	bne.n	8027de4 <try_boot+0x64>
  CHECK_ERROR(validate(NVMS_BLOCK0, 1));
 8027e6c:	2101      	movs	r1, #1
 8027e6e:	f7ff feff 	bl	8027c70 <validate>
 8027e72:	2800      	cmp	r0, #0
 8027e74:	d1b6      	bne.n	8027de4 <try_boot+0x64>
  CHECK_ERROR(use(NVMS_BLOCK0));
 8027e76:	f7ff fe33 	bl	8027ae0 <use>
 8027e7a:	2800      	cmp	r0, #0
 8027e7c:	d1b2      	bne.n	8027de4 <try_boot+0x64>
  return NVMS_WARNING;
 8027e7e:	3002      	adds	r0, #2
 8027e80:	e7b0      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK0));
 8027e82:	2000      	movs	r0, #0
 8027e84:	f7ff fe2c 	bl	8027ae0 <use>
 8027e88:	e7ac      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(copy_slots(NVMS_BLOCK0, NVMS_BLOCK1));
 8027e8a:	2101      	movs	r1, #1
 8027e8c:	2000      	movs	r0, #0
 8027e8e:	f7ff fec7 	bl	8027c20 <copy_slots>
 8027e92:	2800      	cmp	r0, #0
 8027e94:	d1a6      	bne.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(validate(NVMS_BLOCK1, seq0 + 1UL));
 8027e96:	9b01      	ldr	r3, [sp, #4]
 8027e98:	1c59      	adds	r1, r3, #1
 8027e9a:	3001      	adds	r0, #1
 8027e9c:	f7ff fee8 	bl	8027c70 <validate>
 8027ea0:	2800      	cmp	r0, #0
 8027ea2:	d19f      	bne.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027ea4:	f7ff ff64 	bl	8027d70 <block_erase>
 8027ea8:	2800      	cmp	r0, #0
 8027eaa:	d19b      	bne.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK1));
 8027eac:	3001      	adds	r0, #1
 8027eae:	f7ff fe17 	bl	8027ae0 <use>
 8027eb2:	2800      	cmp	r0, #0
 8027eb4:	d196      	bne.n	8027de4 <try_boot+0x64>
      return NVMS_WARNING;
 8027eb6:	0028      	movs	r0, r5
 8027eb8:	e794      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027eba:	2000      	movs	r0, #0
 8027ebc:	f7ff ff58 	bl	8027d70 <block_erase>
 8027ec0:	2800      	cmp	r0, #0
 8027ec2:	d000      	beq.n	8027ec6 <try_boot+0x146>
 8027ec4:	e78e      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(validate(NVMS_BLOCK1, 1));
 8027ec6:	2101      	movs	r1, #1
 8027ec8:	3001      	adds	r0, #1
 8027eca:	f7ff fed1 	bl	8027c70 <validate>
 8027ece:	2800      	cmp	r0, #0
 8027ed0:	d000      	beq.n	8027ed4 <try_boot+0x154>
 8027ed2:	e787      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK1));
 8027ed4:	3001      	adds	r0, #1
 8027ed6:	f7ff fe03 	bl	8027ae0 <use>
 8027eda:	2800      	cmp	r0, #0
 8027edc:	d000      	beq.n	8027ee0 <try_boot+0x160>
 8027ede:	e781      	b.n	8027de4 <try_boot+0x64>
      return NVMS_WARNING;
 8027ee0:	2002      	movs	r0, #2
 8027ee2:	e77f      	b.n	8027de4 <try_boot+0x64>
  if ((sts0 == NVMS_STATUS_NORMAL) && (sts1 == NVMS_STATUS_NORMAL))
 8027ee4:	2a01      	cmp	r2, #1
 8027ee6:	d1a7      	bne.n	8027e38 <try_boot+0xb8>
    if (seq0 > seq1)
 8027ee8:	9b01      	ldr	r3, [sp, #4]
 8027eea:	9a00      	ldr	r2, [sp, #0]
 8027eec:	4293      	cmp	r3, r2
 8027eee:	d90c      	bls.n	8027f0a <try_boot+0x18a>
      CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027ef0:	2001      	movs	r0, #1
 8027ef2:	f7ff ff3d 	bl	8027d70 <block_erase>
 8027ef6:	2800      	cmp	r0, #0
 8027ef8:	d000      	beq.n	8027efc <try_boot+0x17c>
 8027efa:	e773      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK0));
 8027efc:	f7ff fdf0 	bl	8027ae0 <use>
 8027f00:	2800      	cmp	r0, #0
 8027f02:	d000      	beq.n	8027f06 <try_boot+0x186>
 8027f04:	e76e      	b.n	8027de4 <try_boot+0x64>
      return NVMS_WARNING;
 8027f06:	2002      	movs	r0, #2
 8027f08:	e76c      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027f0a:	2000      	movs	r0, #0
 8027f0c:	f7ff ff30 	bl	8027d70 <block_erase>
 8027f10:	2800      	cmp	r0, #0
 8027f12:	d000      	beq.n	8027f16 <try_boot+0x196>
 8027f14:	e766      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK1));
 8027f16:	3001      	adds	r0, #1
 8027f18:	f7ff fde2 	bl	8027ae0 <use>
 8027f1c:	2800      	cmp	r0, #0
 8027f1e:	d000      	beq.n	8027f22 <try_boot+0x1a2>
 8027f20:	e760      	b.n	8027de4 <try_boot+0x64>
      return NVMS_WARNING;
 8027f22:	2002      	movs	r0, #2
 8027f24:	e75e      	b.n	8027de4 <try_boot+0x64>
  if ((sts0 == NVMS_STATUS_PARTIAL) && (sts1 == NVMS_STATUS_PARTIAL))
 8027f26:	2a02      	cmp	r2, #2
 8027f28:	d188      	bne.n	8027e3c <try_boot+0xbc>
    if (seq0 > seq1)
 8027f2a:	9b01      	ldr	r3, [sp, #4]
 8027f2c:	9a00      	ldr	r2, [sp, #0]
 8027f2e:	4293      	cmp	r3, r2
 8027f30:	d920      	bls.n	8027f74 <try_boot+0x1f4>
      CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027f32:	2001      	movs	r0, #1
 8027f34:	f7ff ff1c 	bl	8027d70 <block_erase>
 8027f38:	2800      	cmp	r0, #0
 8027f3a:	d000      	beq.n	8027f3e <try_boot+0x1be>
 8027f3c:	e752      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(copy_slots(NVMS_BLOCK0, NVMS_BLOCK1));
 8027f3e:	2101      	movs	r1, #1
 8027f40:	f7ff fe6e 	bl	8027c20 <copy_slots>
 8027f44:	2800      	cmp	r0, #0
 8027f46:	d000      	beq.n	8027f4a <try_boot+0x1ca>
 8027f48:	e74c      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(validate(NVMS_BLOCK1, seq0 + 1UL));
 8027f4a:	9b01      	ldr	r3, [sp, #4]
 8027f4c:	1c59      	adds	r1, r3, #1
 8027f4e:	3001      	adds	r0, #1
 8027f50:	f7ff fe8e 	bl	8027c70 <validate>
 8027f54:	2800      	cmp	r0, #0
 8027f56:	d000      	beq.n	8027f5a <try_boot+0x1da>
 8027f58:	e744      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027f5a:	f7ff ff09 	bl	8027d70 <block_erase>
 8027f5e:	2800      	cmp	r0, #0
 8027f60:	d000      	beq.n	8027f64 <try_boot+0x1e4>
 8027f62:	e73f      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK1));
 8027f64:	3001      	adds	r0, #1
 8027f66:	f7ff fdbb 	bl	8027ae0 <use>
 8027f6a:	2800      	cmp	r0, #0
 8027f6c:	d000      	beq.n	8027f70 <try_boot+0x1f0>
 8027f6e:	e739      	b.n	8027de4 <try_boot+0x64>
      return NVMS_WARNING;
 8027f70:	0020      	movs	r0, r4
 8027f72:	e737      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027f74:	2000      	movs	r0, #0
 8027f76:	f7ff fefb 	bl	8027d70 <block_erase>
 8027f7a:	2800      	cmp	r0, #0
 8027f7c:	d000      	beq.n	8027f80 <try_boot+0x200>
 8027f7e:	e731      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(copy_slots(NVMS_BLOCK1, NVMS_BLOCK0));
 8027f80:	2100      	movs	r1, #0
 8027f82:	3001      	adds	r0, #1
 8027f84:	f7ff fe4c 	bl	8027c20 <copy_slots>
 8027f88:	2800      	cmp	r0, #0
 8027f8a:	d000      	beq.n	8027f8e <try_boot+0x20e>
 8027f8c:	e72a      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(validate(NVMS_BLOCK0, seq1 + 1UL));
 8027f8e:	9b00      	ldr	r3, [sp, #0]
 8027f90:	1c59      	adds	r1, r3, #1
 8027f92:	f7ff fe6d 	bl	8027c70 <validate>
 8027f96:	2800      	cmp	r0, #0
 8027f98:	d000      	beq.n	8027f9c <try_boot+0x21c>
 8027f9a:	e723      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027f9c:	3001      	adds	r0, #1
 8027f9e:	f7ff fee7 	bl	8027d70 <block_erase>
 8027fa2:	2800      	cmp	r0, #0
 8027fa4:	d000      	beq.n	8027fa8 <try_boot+0x228>
 8027fa6:	e71d      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK0));
 8027fa8:	f7ff fd9a 	bl	8027ae0 <use>
 8027fac:	2800      	cmp	r0, #0
 8027fae:	d000      	beq.n	8027fb2 <try_boot+0x232>
 8027fb0:	e718      	b.n	8027de4 <try_boot+0x64>
      return NVMS_WARNING;
 8027fb2:	0020      	movs	r0, r4
 8027fb4:	e716      	b.n	8027de4 <try_boot+0x64>
    if (sts1 == NVMS_STATUS_PARTIAL)
 8027fb6:	2a02      	cmp	r2, #2
 8027fb8:	d00f      	beq.n	8027fda <try_boot+0x25a>
    if (sts1 == NVMS_STATUS_BROKEN)
 8027fba:	2a03      	cmp	r2, #3
 8027fbc:	d000      	beq.n	8027fc0 <try_boot+0x240>
 8027fbe:	e740      	b.n	8027e42 <try_boot+0xc2>
      CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027fc0:	2001      	movs	r0, #1
 8027fc2:	f7ff fed5 	bl	8027d70 <block_erase>
 8027fc6:	2800      	cmp	r0, #0
 8027fc8:	d000      	beq.n	8027fcc <try_boot+0x24c>
 8027fca:	e70b      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK0));
 8027fcc:	f7ff fd88 	bl	8027ae0 <use>
 8027fd0:	2800      	cmp	r0, #0
 8027fd2:	d000      	beq.n	8027fd6 <try_boot+0x256>
 8027fd4:	e706      	b.n	8027de4 <try_boot+0x64>
      return NVMS_WARNING;
 8027fd6:	2002      	movs	r0, #2
 8027fd8:	e704      	b.n	8027de4 <try_boot+0x64>
      if (seq0 > seq1)
 8027fda:	9b01      	ldr	r3, [sp, #4]
 8027fdc:	9a00      	ldr	r2, [sp, #0]
 8027fde:	4293      	cmp	r3, r2
 8027fe0:	d90c      	bls.n	8027ffc <try_boot+0x27c>
        CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8027fe2:	2001      	movs	r0, #1
 8027fe4:	f7ff fec4 	bl	8027d70 <block_erase>
 8027fe8:	2800      	cmp	r0, #0
 8027fea:	d000      	beq.n	8027fee <try_boot+0x26e>
 8027fec:	e6fa      	b.n	8027de4 <try_boot+0x64>
        CHECK_ERROR(use(NVMS_BLOCK0));
 8027fee:	f7ff fd77 	bl	8027ae0 <use>
 8027ff2:	2800      	cmp	r0, #0
 8027ff4:	d000      	beq.n	8027ff8 <try_boot+0x278>
 8027ff6:	e6f5      	b.n	8027de4 <try_boot+0x64>
        return NVMS_WARNING;
 8027ff8:	0020      	movs	r0, r4
 8027ffa:	e6f3      	b.n	8027de4 <try_boot+0x64>
        CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8027ffc:	2000      	movs	r0, #0
 8027ffe:	f7ff feb7 	bl	8027d70 <block_erase>
 8028002:	2800      	cmp	r0, #0
 8028004:	d000      	beq.n	8028008 <try_boot+0x288>
 8028006:	e6ed      	b.n	8027de4 <try_boot+0x64>
        CHECK_ERROR(copy_slots(NVMS_BLOCK1, NVMS_BLOCK0));
 8028008:	2100      	movs	r1, #0
 802800a:	3001      	adds	r0, #1
 802800c:	f7ff fe08 	bl	8027c20 <copy_slots>
 8028010:	2800      	cmp	r0, #0
 8028012:	d000      	beq.n	8028016 <try_boot+0x296>
 8028014:	e6e6      	b.n	8027de4 <try_boot+0x64>
        CHECK_ERROR(validate(NVMS_BLOCK0, seq1 + 1UL));
 8028016:	9b00      	ldr	r3, [sp, #0]
 8028018:	1c59      	adds	r1, r3, #1
 802801a:	f7ff fe29 	bl	8027c70 <validate>
 802801e:	2800      	cmp	r0, #0
 8028020:	d000      	beq.n	8028024 <try_boot+0x2a4>
 8028022:	e6df      	b.n	8027de4 <try_boot+0x64>
        CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8028024:	3001      	adds	r0, #1
 8028026:	f7ff fea3 	bl	8027d70 <block_erase>
 802802a:	2800      	cmp	r0, #0
 802802c:	d000      	beq.n	8028030 <try_boot+0x2b0>
 802802e:	e6d9      	b.n	8027de4 <try_boot+0x64>
        CHECK_ERROR(use(NVMS_BLOCK0));
 8028030:	f7ff fd56 	bl	8027ae0 <use>
 8028034:	2800      	cmp	r0, #0
 8028036:	d000      	beq.n	802803a <try_boot+0x2ba>
 8028038:	e6d4      	b.n	8027de4 <try_boot+0x64>
        return NVMS_WARNING;
 802803a:	0020      	movs	r0, r4
 802803c:	e6d2      	b.n	8027de4 <try_boot+0x64>
    if (sts0 == NVMS_STATUS_PARTIAL)
 802803e:	2e02      	cmp	r6, #2
 8028040:	d010      	beq.n	8028064 <try_boot+0x2e4>
    if (sts0 == NVMS_STATUS_BROKEN)
 8028042:	2e03      	cmp	r6, #3
 8028044:	d000      	beq.n	8028048 <try_boot+0x2c8>
 8028046:	e6ff      	b.n	8027e48 <try_boot+0xc8>
      CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8028048:	2000      	movs	r0, #0
 802804a:	f7ff fe91 	bl	8027d70 <block_erase>
 802804e:	2800      	cmp	r0, #0
 8028050:	d000      	beq.n	8028054 <try_boot+0x2d4>
 8028052:	e6c7      	b.n	8027de4 <try_boot+0x64>
      CHECK_ERROR(use(NVMS_BLOCK1));
 8028054:	3001      	adds	r0, #1
 8028056:	f7ff fd43 	bl	8027ae0 <use>
 802805a:	2800      	cmp	r0, #0
 802805c:	d000      	beq.n	8028060 <try_boot+0x2e0>
 802805e:	e6c1      	b.n	8027de4 <try_boot+0x64>
      return NVMS_WARNING;
 8028060:	2002      	movs	r0, #2
 8028062:	e6bf      	b.n	8027de4 <try_boot+0x64>
      if (seq1 > seq0)
 8028064:	9b00      	ldr	r3, [sp, #0]
 8028066:	9a01      	ldr	r2, [sp, #4]
 8028068:	4293      	cmp	r3, r2
 802806a:	d90d      	bls.n	8028088 <try_boot+0x308>
        CHECK_ERROR(block_erase(NVMS_BLOCK0));
 802806c:	2000      	movs	r0, #0
 802806e:	f7ff fe7f 	bl	8027d70 <block_erase>
 8028072:	2800      	cmp	r0, #0
 8028074:	d000      	beq.n	8028078 <try_boot+0x2f8>
 8028076:	e6b5      	b.n	8027de4 <try_boot+0x64>
        CHECK_ERROR(use(NVMS_BLOCK1));
 8028078:	3001      	adds	r0, #1
 802807a:	f7ff fd31 	bl	8027ae0 <use>
 802807e:	2800      	cmp	r0, #0
 8028080:	d000      	beq.n	8028084 <try_boot+0x304>
 8028082:	e6af      	b.n	8027de4 <try_boot+0x64>
        return NVMS_WARNING;
 8028084:	0028      	movs	r0, r5
 8028086:	e6ad      	b.n	8027de4 <try_boot+0x64>
        CHECK_ERROR(block_erase(NVMS_BLOCK1));
 8028088:	2001      	movs	r0, #1
 802808a:	f7ff fe71 	bl	8027d70 <block_erase>
 802808e:	2800      	cmp	r0, #0
 8028090:	d000      	beq.n	8028094 <try_boot+0x314>
 8028092:	e6a7      	b.n	8027de4 <try_boot+0x64>
        CHECK_ERROR(copy_slots(NVMS_BLOCK0, NVMS_BLOCK1));
 8028094:	2101      	movs	r1, #1
 8028096:	f7ff fdc3 	bl	8027c20 <copy_slots>
 802809a:	2800      	cmp	r0, #0
 802809c:	d000      	beq.n	80280a0 <try_boot+0x320>
 802809e:	e6a1      	b.n	8027de4 <try_boot+0x64>
        CHECK_ERROR(validate(NVMS_BLOCK1, seq0 + 1UL));
 80280a0:	9b01      	ldr	r3, [sp, #4]
 80280a2:	1c59      	adds	r1, r3, #1
 80280a4:	3001      	adds	r0, #1
 80280a6:	f7ff fde3 	bl	8027c70 <validate>
 80280aa:	2800      	cmp	r0, #0
 80280ac:	d000      	beq.n	80280b0 <try_boot+0x330>
 80280ae:	e699      	b.n	8027de4 <try_boot+0x64>
        CHECK_ERROR(block_erase(NVMS_BLOCK0));
 80280b0:	f7ff fe5e 	bl	8027d70 <block_erase>
 80280b4:	2800      	cmp	r0, #0
 80280b6:	d000      	beq.n	80280ba <try_boot+0x33a>
 80280b8:	e694      	b.n	8027de4 <try_boot+0x64>
        CHECK_ERROR(use(NVMS_BLOCK1));
 80280ba:	3001      	adds	r0, #1
 80280bc:	f7ff fd10 	bl	8027ae0 <use>
 80280c0:	2800      	cmp	r0, #0
 80280c2:	d000      	beq.n	80280c6 <try_boot+0x346>
 80280c4:	e68e      	b.n	8027de4 <try_boot+0x64>
        return NVMS_WARNING;
 80280c6:	0028      	movs	r0, r5
 80280c8:	e68c      	b.n	8027de4 <try_boot+0x64>
  if ((sts0 == NVMS_STATUS_PARTIAL) && (sts1 == NVMS_STATUS_BROKEN))
 80280ca:	2a03      	cmp	r2, #3
 80280cc:	d000      	beq.n	80280d0 <try_boot+0x350>
 80280ce:	e6be      	b.n	8027e4e <try_boot+0xce>
    CHECK_ERROR(block_erase(NVMS_BLOCK1));
 80280d0:	2001      	movs	r0, #1
 80280d2:	f7ff fe4d 	bl	8027d70 <block_erase>
 80280d6:	2800      	cmp	r0, #0
 80280d8:	d000      	beq.n	80280dc <try_boot+0x35c>
 80280da:	e683      	b.n	8027de4 <try_boot+0x64>
    CHECK_ERROR(copy_slots(NVMS_BLOCK0, NVMS_BLOCK1));
 80280dc:	2101      	movs	r1, #1
 80280de:	f7ff fd9f 	bl	8027c20 <copy_slots>
 80280e2:	2800      	cmp	r0, #0
 80280e4:	d000      	beq.n	80280e8 <try_boot+0x368>
 80280e6:	e67d      	b.n	8027de4 <try_boot+0x64>
    CHECK_ERROR(validate(NVMS_BLOCK1, seq0 + 1UL));
 80280e8:	9b01      	ldr	r3, [sp, #4]
 80280ea:	1c59      	adds	r1, r3, #1
 80280ec:	3001      	adds	r0, #1
 80280ee:	f7ff fdbf 	bl	8027c70 <validate>
 80280f2:	2800      	cmp	r0, #0
 80280f4:	d000      	beq.n	80280f8 <try_boot+0x378>
 80280f6:	e675      	b.n	8027de4 <try_boot+0x64>
    CHECK_ERROR(block_erase(NVMS_BLOCK0));
 80280f8:	f7ff fe3a 	bl	8027d70 <block_erase>
 80280fc:	2800      	cmp	r0, #0
 80280fe:	d000      	beq.n	8028102 <try_boot+0x382>
 8028100:	e670      	b.n	8027de4 <try_boot+0x64>
    CHECK_ERROR(use(NVMS_BLOCK1));
 8028102:	3001      	adds	r0, #1
 8028104:	f7ff fcec 	bl	8027ae0 <use>
 8028108:	2800      	cmp	r0, #0
 802810a:	d000      	beq.n	802810e <try_boot+0x38e>
 802810c:	e66a      	b.n	8027de4 <try_boot+0x64>
    return NVMS_WARNING;
 802810e:	0028      	movs	r0, r5
 8028110:	e668      	b.n	8027de4 <try_boot+0x64>
    CHECK_ERROR(block_erase(NVMS_BLOCK0));
 8028112:	2000      	movs	r0, #0
 8028114:	f7ff fe2c 	bl	8027d70 <block_erase>
 8028118:	2800      	cmp	r0, #0
 802811a:	d000      	beq.n	802811e <try_boot+0x39e>
 802811c:	e662      	b.n	8027de4 <try_boot+0x64>
    CHECK_ERROR(copy_slots(NVMS_BLOCK1, NVMS_BLOCK0));
 802811e:	2100      	movs	r1, #0
 8028120:	3001      	adds	r0, #1
 8028122:	f7ff fd7d 	bl	8027c20 <copy_slots>
 8028126:	2800      	cmp	r0, #0
 8028128:	d000      	beq.n	802812c <try_boot+0x3ac>
 802812a:	e65b      	b.n	8027de4 <try_boot+0x64>
    CHECK_ERROR(validate(NVMS_BLOCK0, seq0 + 1UL));
 802812c:	9b01      	ldr	r3, [sp, #4]
 802812e:	1c59      	adds	r1, r3, #1
 8028130:	f7ff fd9e 	bl	8027c70 <validate>
 8028134:	2800      	cmp	r0, #0
 8028136:	d000      	beq.n	802813a <try_boot+0x3ba>
 8028138:	e654      	b.n	8027de4 <try_boot+0x64>
    CHECK_ERROR(block_erase(NVMS_BLOCK1));
 802813a:	3001      	adds	r0, #1
 802813c:	f7ff fe18 	bl	8027d70 <block_erase>
 8028140:	2800      	cmp	r0, #0
 8028142:	d000      	beq.n	8028146 <try_boot+0x3c6>
 8028144:	e64e      	b.n	8027de4 <try_boot+0x64>
    CHECK_ERROR(use(NVMS_BLOCK0));
 8028146:	f7ff fccb 	bl	8027ae0 <use>
 802814a:	2800      	cmp	r0, #0
 802814c:	d000      	beq.n	8028150 <try_boot+0x3d0>
 802814e:	e649      	b.n	8027de4 <try_boot+0x64>
    return NVMS_WARNING;
 8028150:	0020      	movs	r0, r4
 8028152:	e647      	b.n	8027de4 <try_boot+0x64>

08028154 <garbage_collect>:
{
 8028154:	b510      	push	{r4, lr}
  if (nvm.block == NVMS_BLOCK0)
 8028156:	4b19      	ldr	r3, [pc, #100]	; (80281bc <garbage_collect+0x68>)
 8028158:	791b      	ldrb	r3, [r3, #4]
 802815a:	2b00      	cmp	r3, #0
 802815c:	d117      	bne.n	802818e <garbage_collect+0x3a>
    CHECK_ERROR(copy_slots(NVMS_BLOCK0, NVMS_BLOCK1));
 802815e:	2101      	movs	r1, #1
 8028160:	2000      	movs	r0, #0
 8028162:	f7ff fd5d 	bl	8027c20 <copy_slots>
 8028166:	2800      	cmp	r0, #0
 8028168:	d000      	beq.n	802816c <garbage_collect+0x18>
}
 802816a:	bd10      	pop	{r4, pc}
    CHECK_ERROR(validate(NVMS_BLOCK1, nvm.header->fields.instance + 1UL));
 802816c:	4b13      	ldr	r3, [pc, #76]	; (80281bc <garbage_collect+0x68>)
 802816e:	681b      	ldr	r3, [r3, #0]
 8028170:	68d9      	ldr	r1, [r3, #12]
 8028172:	3101      	adds	r1, #1
 8028174:	3001      	adds	r0, #1
 8028176:	f7ff fd7b 	bl	8027c70 <validate>
 802817a:	2800      	cmp	r0, #0
 802817c:	d1f5      	bne.n	802816a <garbage_collect+0x16>
    CHECK_ERROR(block_erase(NVMS_BLOCK0));
 802817e:	f7ff fdf7 	bl	8027d70 <block_erase>
 8028182:	2800      	cmp	r0, #0
 8028184:	d1f1      	bne.n	802816a <garbage_collect+0x16>
    CHECK_ERROR(use(NVMS_BLOCK1));
 8028186:	3001      	adds	r0, #1
 8028188:	f7ff fcaa 	bl	8027ae0 <use>
 802818c:	e7ed      	b.n	802816a <garbage_collect+0x16>
    CHECK_ERROR(copy_slots(NVMS_BLOCK1, NVMS_BLOCK0));
 802818e:	2100      	movs	r1, #0
 8028190:	2001      	movs	r0, #1
 8028192:	f7ff fd45 	bl	8027c20 <copy_slots>
 8028196:	2800      	cmp	r0, #0
 8028198:	d1e7      	bne.n	802816a <garbage_collect+0x16>
    CHECK_ERROR(validate(NVMS_BLOCK0, nvm.header->fields.instance + 1UL));
 802819a:	4b08      	ldr	r3, [pc, #32]	; (80281bc <garbage_collect+0x68>)
 802819c:	681b      	ldr	r3, [r3, #0]
 802819e:	68d9      	ldr	r1, [r3, #12]
 80281a0:	3101      	adds	r1, #1
 80281a2:	f7ff fd65 	bl	8027c70 <validate>
 80281a6:	2800      	cmp	r0, #0
 80281a8:	d1df      	bne.n	802816a <garbage_collect+0x16>
    CHECK_ERROR(block_erase(NVMS_BLOCK1));
 80281aa:	3001      	adds	r0, #1
 80281ac:	f7ff fde0 	bl	8027d70 <block_erase>
 80281b0:	2800      	cmp	r0, #0
 80281b2:	d1da      	bne.n	802816a <garbage_collect+0x16>
    CHECK_ERROR(use(NVMS_BLOCK0));
 80281b4:	f7ff fc94 	bl	8027ae0 <use>
 80281b8:	e7d7      	b.n	802816a <garbage_collect+0x16>
 80281ba:	46c0      	nop			; (mov r8, r8)
 80281bc:	2000b7c8 	.word	0x2000b7c8

080281c0 <NVMS_Init>:
  * @retval NVMS_FLASH_FAILURE if the flash memory is unusable because HW
  *                            failures.
  * @retval NVMS_INTERNAL      if an internal error occurred.
  */
nvms_error_t NVMS_Init(void)
{
 80281c0:	b510      	push	{r4, lr}
  NVMS_LL_Init();
 80281c2:	f7f9 fab5 	bl	8021730 <NVMS_LL_Init>
  reset();
 80281c6:	f7ff fb33 	bl	8027830 <reset>

  for (uint32_t i = NVMS_CFG_MAX_REPAIR_ATTEMPTS; i > 0UL; i--)
 80281ca:	2403      	movs	r4, #3
 80281cc:	2c00      	cmp	r4, #0
 80281ce:	d007      	beq.n	80281e0 <NVMS_Init+0x20>
  {
    nvms_error_t err = try_boot();
 80281d0:	f7ff fdd6 	bl	8027d80 <try_boot>
    if ((err == NVMS_NOERROR) || (err == NVMS_WARNING))
 80281d4:	2800      	cmp	r0, #0
 80281d6:	d004      	beq.n	80281e2 <NVMS_Init+0x22>
 80281d8:	2802      	cmp	r0, #2
 80281da:	d002      	beq.n	80281e2 <NVMS_Init+0x22>
  for (uint32_t i = NVMS_CFG_MAX_REPAIR_ATTEMPTS; i > 0UL; i--)
 80281dc:	3c01      	subs	r4, #1
 80281de:	e7f5      	b.n	80281cc <NVMS_Init+0xc>
    {
      return err;
    }
  }
  return NVMS_FLASH_FAILURE;
 80281e0:	2003      	movs	r0, #3
}
 80281e2:	bd10      	pop	{r4, pc}

080281e4 <NVMS_Deinit>:
  * @brief   Subsystem de-initialization.
  * @details The function cannot fail and does nothing if the system has not
  *          been yet initialized.
  */
void NVMS_Deinit(void)
{
 80281e4:	b510      	push	{r4, lr}
  /* Clearing data structures */
  reset();
 80281e6:	f7ff fb23 	bl	8027830 <reset>
}
 80281ea:	bd10      	pop	{r4, pc}

080281ec <NVMS_WriteDataWithType>:
  * @retval NVMS_OUT_OF_MEM    if the slot space is exhausted.
  * @retval NVMS_INTERNAL      if an internal error occurred.
  */
nvms_error_t NVMS_WriteDataWithType(nvms_slot_t slot, size_t size, nvms_data_type_t type,
                                    const uint8_t *slotp)
{
 80281ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 80281ee:	46ce      	mov	lr, r9
 80281f0:	b500      	push	{lr}
 80281f2:	b084      	sub	sp, #16
 80281f4:	0004      	movs	r4, r0
 80281f6:	000e      	movs	r6, r1
 80281f8:	9202      	str	r2, [sp, #8]
 80281fa:	9303      	str	r3, [sp, #12]
  return nvm.header != NULL;
 80281fc:	4b2a      	ldr	r3, [pc, #168]	; (80282a8 <NVMS_WriteDataWithType+0xbc>)
 80281fe:	681b      	ldr	r3, [r3, #0]
  size_t oldused;
  nvms_error_t err;
  nvms_data_header_t *hdrp;

  /* Check on initialization */
  if (!is_initialized())
 8028200:	2b00      	cmp	r3, #0
 8028202:	d04a      	beq.n	802829a <NVMS_WriteDataWithType+0xae>
  {
    return NVMS_NOTINIT;
  }

  /* Check on the slot identifier */
  if (slot >= NVMS_CFG_NUM_SLOTS)
 8028204:	2831      	cmp	r0, #49	; 0x31
 8028206:	d84a      	bhi.n	802829e <NVMS_WriteDataWithType+0xb2>
  {
    return NVMS_SLOT_INVALID;
  }

  /* Checking for immediately available space */
  free = NVMS_LL_GetBlockSize() - (nvm.free_next->hdr8 -
 8028208:	4927      	ldr	r1, [pc, #156]	; (80282a8 <NVMS_WriteDataWithType+0xbc>)
 802820a:	22d0      	movs	r2, #208	; 0xd0
 802820c:	588a      	ldr	r2, [r1, r2]
 802820e:	1ad3      	subs	r3, r2, r3
 8028210:	2280      	movs	r2, #128	; 0x80
 8028212:	0112      	lsls	r2, r2, #4
 8028214:	1ad3      	subs	r3, r2, r3

  /* If the requested space is out of the compacted block size then an error is returned.
   * NOTE: The space for one header is reserved in order to allow for a
   * data erase operation after the space has been fully allocated.
   */
  if ((sizeof(nvms_data_header_t) + size) > (NVMS_LL_GetBlockSize() -
 8028216:	0030      	movs	r0, r6
 8028218:	3020      	adds	r0, #32
                                             nvm.used_size -
 802821a:	22d4      	movs	r2, #212	; 0xd4
 802821c:	5889      	ldr	r1, [r1, r2]
 802821e:	22fc      	movs	r2, #252	; 0xfc
 8028220:	00d2      	lsls	r2, r2, #3
 8028222:	1a52      	subs	r2, r2, r1
  if ((sizeof(nvms_data_header_t) + size) > (NVMS_LL_GetBlockSize() -
 8028224:	4290      	cmp	r0, r2
 8028226:	d83c      	bhi.n	80282a2 <NVMS_WriteDataWithType+0xb6>
    return NVMS_OUT_OF_MEM;
  }

  /* This is the condition where we need to compact the current block in
     order to obtain enough space for the new data instance */
  if ((sizeof(nvms_data_header_t) + size) > free)
 8028228:	4298      	cmp	r0, r3
 802822a:	d82a      	bhi.n	8028282 <NVMS_WriteDataWithType+0x96>
  bool warning = false;
 802822c:	2300      	movs	r3, #0
 802822e:	4699      	mov	r9, r3
      return err;
    }
  }

  /* Index for the new data */
  if (nvm.slots[slot] == NULL)
 8028230:	1ca3      	adds	r3, r4, #2
 8028232:	009b      	lsls	r3, r3, #2
 8028234:	4a1c      	ldr	r2, [pc, #112]	; (80282a8 <NVMS_WriteDataWithType+0xbc>)
 8028236:	589f      	ldr	r7, [r3, r2]
 8028238:	2f00      	cmp	r7, #0
 802823a:	d029      	beq.n	8028290 <NVMS_WriteDataWithType+0xa4>
    instance = 1;
    oldused = 0;
  }
  else
  {
    instance = nvm.slots[slot]->fields.instance + 1UL;
 802823c:	68fb      	ldr	r3, [r7, #12]
 802823e:	3301      	adds	r3, #1
    oldused = (uint32_t)(nvm.slots[slot]->fields.next->hdr8) - (uint32_t)(nvm.slots[slot]->hdr8);
 8028240:	693a      	ldr	r2, [r7, #16]
 8028242:	1bd7      	subs	r7, r2, r7
  }

  /* Position of the new data instance */
  hdrp = nvm.free_next;
 8028244:	4918      	ldr	r1, [pc, #96]	; (80282a8 <NVMS_WriteDataWithType+0xbc>)
 8028246:	22d0      	movs	r2, #208	; 0xd0
 8028248:	588d      	ldr	r5, [r1, r2]

  /* Writing the new instance */
  err = append_slot(slot, size, type, slotp, instance);
 802824a:	9300      	str	r3, [sp, #0]
 802824c:	9b03      	ldr	r3, [sp, #12]
 802824e:	9a02      	ldr	r2, [sp, #8]
 8028250:	0031      	movs	r1, r6
 8028252:	0020      	movs	r0, r4
 8028254:	f7ff fd40 	bl	8027cd8 <append_slot>
  if (err != NVMS_NOERROR)
 8028258:	2800      	cmp	r0, #0
 802825a:	d10e      	bne.n	802827a <NVMS_WriteDataWithType+0x8e>
  {
    return err;
  }

  /* Adjusting the counter of the effective used size */
  nvm.slots[slot]  = hdrp;
 802825c:	4b12      	ldr	r3, [pc, #72]	; (80282a8 <NVMS_WriteDataWithType+0xbc>)
 802825e:	3402      	adds	r4, #2
 8028260:	00a4      	lsls	r4, r4, #2
 8028262:	50e5      	str	r5, [r4, r3]
  nvm.used_size -= oldused;
 8028264:	22d4      	movs	r2, #212	; 0xd4
 8028266:	5899      	ldr	r1, [r3, r2]
 8028268:	1bcf      	subs	r7, r1, r7
 802826a:	509f      	str	r7, [r3, r2]
  nvm.used_size += nvm.slots[slot]->fields.next->hdr8 - nvm.slots[slot]->hdr8;
 802826c:	6929      	ldr	r1, [r5, #16]
 802826e:	1b49      	subs	r1, r1, r5
 8028270:	187f      	adds	r7, r7, r1
 8028272:	509f      	str	r7, [r3, r2]

  return warning ? NVMS_WARNING : NVMS_NOERROR;
 8028274:	464b      	mov	r3, r9
 8028276:	2b00      	cmp	r3, #0
 8028278:	d10d      	bne.n	8028296 <NVMS_WriteDataWithType+0xaa>
}
 802827a:	b004      	add	sp, #16
 802827c:	bc80      	pop	{r7}
 802827e:	46b9      	mov	r9, r7
 8028280:	bdf0      	pop	{r4, r5, r6, r7, pc}
    err = garbage_collect();
 8028282:	f7ff ff67 	bl	8028154 <garbage_collect>
    if (err != NVMS_NOERROR)
 8028286:	2800      	cmp	r0, #0
 8028288:	d1f7      	bne.n	802827a <NVMS_WriteDataWithType+0x8e>
    warning = true;
 802828a:	2301      	movs	r3, #1
 802828c:	4699      	mov	r9, r3
 802828e:	e7cf      	b.n	8028230 <NVMS_WriteDataWithType+0x44>
    oldused = 0;
 8028290:	2700      	movs	r7, #0
    instance = 1;
 8028292:	2301      	movs	r3, #1
 8028294:	e7d6      	b.n	8028244 <NVMS_WriteDataWithType+0x58>
  return warning ? NVMS_WARNING : NVMS_NOERROR;
 8028296:	3002      	adds	r0, #2
 8028298:	e7ef      	b.n	802827a <NVMS_WriteDataWithType+0x8e>
    return NVMS_NOTINIT;
 802829a:	2001      	movs	r0, #1
 802829c:	e7ed      	b.n	802827a <NVMS_WriteDataWithType+0x8e>
    return NVMS_SLOT_INVALID;
 802829e:	2004      	movs	r0, #4
 80282a0:	e7eb      	b.n	802827a <NVMS_WriteDataWithType+0x8e>
    return NVMS_OUT_OF_MEM;
 80282a2:	2007      	movs	r0, #7
 80282a4:	e7e9      	b.n	802827a <NVMS_WriteDataWithType+0x8e>
 80282a6:	46c0      	nop			; (mov r8, r8)
 80282a8:	2000b7c8 	.word	0x2000b7c8

080282ac <NVMS_EraseData>:
  *                             failures.
  * @retval NVMS_DATA_NOT_FOUND if the data does not exists.
  * @retval NVMS_INTERNAL       if an internal error occurred.
  */
nvms_error_t NVMS_EraseData(nvms_slot_t slot)
{
 80282ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 80282ae:	b083      	sub	sp, #12
 80282b0:	0004      	movs	r4, r0
  return nvm.header != NULL;
 80282b2:	4b24      	ldr	r3, [pc, #144]	; (8028344 <NVMS_EraseData+0x98>)
 80282b4:	681a      	ldr	r2, [r3, #0]
  size_t free;
  size_t oldused;
  nvms_error_t err;

  /* Check on initialization */
  if (!is_initialized())
 80282b6:	2a00      	cmp	r2, #0
 80282b8:	d03b      	beq.n	8028332 <NVMS_EraseData+0x86>
  {
    return NVMS_NOTINIT;
  }

  /* Check on the slot identifier */
  if (slot >= NVMS_CFG_NUM_SLOTS)
 80282ba:	2831      	cmp	r0, #49	; 0x31
 80282bc:	d83c      	bhi.n	8028338 <NVMS_EraseData+0x8c>
  {
    return NVMS_SLOT_INVALID;
  }

  /* Check slot presence */
  if (nvm.slots[slot] == NULL)
 80282be:	1c83      	adds	r3, r0, #2
 80282c0:	009b      	lsls	r3, r3, #2
 80282c2:	4920      	ldr	r1, [pc, #128]	; (8028344 <NVMS_EraseData+0x98>)
 80282c4:	585b      	ldr	r3, [r3, r1]
 80282c6:	2b00      	cmp	r3, #0
 80282c8:	d038      	beq.n	802833c <NVMS_EraseData+0x90>
  {
    return NVMS_DATA_NOT_FOUND;
  }

  /* Checking for immediately available space */
  free = NVMS_LL_GetBlockSize() - (nvm.free_next->hdr8 -
 80282ca:	23d0      	movs	r3, #208	; 0xd0
 80282cc:	58cb      	ldr	r3, [r1, r3]
 80282ce:	1a9b      	subs	r3, r3, r2
 80282d0:	2280      	movs	r2, #128	; 0x80
 80282d2:	0112      	lsls	r2, r2, #4
 80282d4:	1ad3      	subs	r3, r2, r3

  /* If the requested space is out of the compacted block size then an
     error is returned.
     NOTE: This condition SHOULD NEVER HAPPEN because the slot write operation
     makes sure to leave to leave enough space for an erase operation */
  if (sizeof(nvms_data_header_t) > (NVMS_LL_GetBlockSize() - nvm.used_size))
 80282d6:	20d4      	movs	r0, #212	; 0xd4
 80282d8:	5809      	ldr	r1, [r1, r0]
 80282da:	1a52      	subs	r2, r2, r1
 80282dc:	2a1f      	cmp	r2, #31
 80282de:	d92f      	bls.n	8028340 <NVMS_EraseData+0x94>
    return NVMS_INTERNAL;
  }

  /* This is the condition where we need to compact the current block in
     order to obtain enough space for the new slot instance */
  if (sizeof(nvms_data_header_t) > free)
 80282e0:	2b1f      	cmp	r3, #31
 80282e2:	d805      	bhi.n	80282f0 <NVMS_EraseData+0x44>
  {
    warning = true;
    err = garbage_collect();
 80282e4:	f7ff ff36 	bl	8028154 <garbage_collect>
    if (err != NVMS_NOERROR)
 80282e8:	2800      	cmp	r0, #0
 80282ea:	d123      	bne.n	8028334 <NVMS_EraseData+0x88>
    warning = true;
 80282ec:	2601      	movs	r6, #1
 80282ee:	e000      	b.n	80282f2 <NVMS_EraseData+0x46>
  bool warning = false;
 80282f0:	2600      	movs	r6, #0
      return err;
    }
  }

  /* Index for the new slot */
  instance = nvm.slots[slot]->fields.instance + 1UL;
 80282f2:	1ca3      	adds	r3, r4, #2
 80282f4:	009b      	lsls	r3, r3, #2
 80282f6:	4a13      	ldr	r2, [pc, #76]	; (8028344 <NVMS_EraseData+0x98>)
 80282f8:	589d      	ldr	r5, [r3, r2]
 80282fa:	68eb      	ldr	r3, [r5, #12]
 80282fc:	3301      	adds	r3, #1
  oldused = (uint32_t)(nvm.slots[slot]->fields.next->hdr8) - (uint32_t)(nvm.slots[slot]->hdr8);
 80282fe:	692f      	ldr	r7, [r5, #16]

  /* Writing the new instance */
  err = append_slot(slot, 0, NVMS_DATA_TYPE_DEFAULT, NULL, instance);
 8028300:	2201      	movs	r2, #1
 8028302:	9300      	str	r3, [sp, #0]
 8028304:	2300      	movs	r3, #0
 8028306:	4252      	negs	r2, r2
 8028308:	2100      	movs	r1, #0
 802830a:	0020      	movs	r0, r4
 802830c:	f7ff fce4 	bl	8027cd8 <append_slot>
  if (err != NVMS_NOERROR)
 8028310:	2800      	cmp	r0, #0
 8028312:	d10f      	bne.n	8028334 <NVMS_EraseData+0x88>
  {
    return err;
  }

  /* Adjusting the counter of the effective used size */
  nvm.slots[slot]  = NULL;
 8028314:	4b0b      	ldr	r3, [pc, #44]	; (8028344 <NVMS_EraseData+0x98>)
 8028316:	3402      	adds	r4, #2
 8028318:	00a4      	lsls	r4, r4, #2
 802831a:	2200      	movs	r2, #0
 802831c:	50e2      	str	r2, [r4, r3]
  nvm.used_size -= oldused;
 802831e:	32d4      	adds	r2, #212	; 0xd4
 8028320:	1bed      	subs	r5, r5, r7
 8028322:	5899      	ldr	r1, [r3, r2]
 8028324:	468c      	mov	ip, r1
 8028326:	4465      	add	r5, ip
 8028328:	509d      	str	r5, [r3, r2]

  return warning ? NVMS_WARNING : NVMS_NOERROR;
 802832a:	2e00      	cmp	r6, #0
 802832c:	d002      	beq.n	8028334 <NVMS_EraseData+0x88>
 802832e:	3002      	adds	r0, #2
 8028330:	e000      	b.n	8028334 <NVMS_EraseData+0x88>
    return NVMS_NOTINIT;
 8028332:	2001      	movs	r0, #1
}
 8028334:	b003      	add	sp, #12
 8028336:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return NVMS_SLOT_INVALID;
 8028338:	2004      	movs	r0, #4
 802833a:	e7fb      	b.n	8028334 <NVMS_EraseData+0x88>
    return NVMS_DATA_NOT_FOUND;
 802833c:	2005      	movs	r0, #5
 802833e:	e7f9      	b.n	8028334 <NVMS_EraseData+0x88>
    return NVMS_INTERNAL;
 8028340:	2008      	movs	r0, #8
 8028342:	e7f7      	b.n	8028334 <NVMS_EraseData+0x88>
 8028344:	2000b7c8 	.word	0x2000b7c8

08028348 <NVMS_GetDataWithType>:
  * @retval NVMS_SLOT_INVALID   if the slot number is out of range.
  * @retval NVMS_DATA_NOT_FOUND if the data does not exists.
  */
nvms_error_t NVMS_GetDataWithType(nvms_slot_t slot, size_t *size_p, nvms_data_type_t *type_p,
                                  uint8_t **data_pp)
{
 8028348:	b530      	push	{r4, r5, lr}
  return nvm.header != NULL;
 802834a:	4c15      	ldr	r4, [pc, #84]	; (80283a0 <NVMS_GetDataWithType+0x58>)
 802834c:	6824      	ldr	r4, [r4, #0]
  /* Check on initialization */
  if (!is_initialized())
 802834e:	2c00      	cmp	r4, #0
 8028350:	d01d      	beq.n	802838e <NVMS_GetDataWithType+0x46>
  {
    return NVMS_NOTINIT;
  }

  /* Check on the slot identifier */
  if (slot >= NVMS_CFG_NUM_SLOTS)
 8028352:	2831      	cmp	r0, #49	; 0x31
 8028354:	d81d      	bhi.n	8028392 <NVMS_GetDataWithType+0x4a>
  {
    return NVMS_SLOT_INVALID;
  }

  /* Check slot presence */
  if (nvm.slots[slot] == NULL)
 8028356:	1c84      	adds	r4, r0, #2
 8028358:	00a4      	lsls	r4, r4, #2
 802835a:	4d11      	ldr	r5, [pc, #68]	; (80283a0 <NVMS_GetDataWithType+0x58>)
 802835c:	5964      	ldr	r4, [r4, r5]
 802835e:	2c00      	cmp	r4, #0
 8028360:	d019      	beq.n	8028396 <NVMS_GetDataWithType+0x4e>
  {
    return NVMS_DATA_NOT_FOUND;
  }

  if (size_p != NULL)
 8028362:	2900      	cmp	r1, #0
 8028364:	d001      	beq.n	802836a <NVMS_GetDataWithType+0x22>
  {
    *size_p = nvm.slots[slot]->fields.data_size;
 8028366:	69a4      	ldr	r4, [r4, #24]
 8028368:	600c      	str	r4, [r1, #0]
  }

  if (type_p != NULL)
 802836a:	2a00      	cmp	r2, #0
 802836c:	d005      	beq.n	802837a <NVMS_GetDataWithType+0x32>
  {
    *type_p = nvm.slots[slot]->fields.data_type;
 802836e:	1c81      	adds	r1, r0, #2
 8028370:	0089      	lsls	r1, r1, #2
 8028372:	4c0b      	ldr	r4, [pc, #44]	; (80283a0 <NVMS_GetDataWithType+0x58>)
 8028374:	5909      	ldr	r1, [r1, r4]
 8028376:	6949      	ldr	r1, [r1, #20]
 8028378:	6011      	str	r1, [r2, #0]
  }

  if (data_pp != NULL)
 802837a:	2b00      	cmp	r3, #0
 802837c:	d00d      	beq.n	802839a <NVMS_GetDataWithType+0x52>
  {
    *data_pp = nvm.slots[slot]->hdr8 + sizeof(nvms_data_header_t);
 802837e:	3002      	adds	r0, #2
 8028380:	0080      	lsls	r0, r0, #2
 8028382:	4a07      	ldr	r2, [pc, #28]	; (80283a0 <NVMS_GetDataWithType+0x58>)
 8028384:	5882      	ldr	r2, [r0, r2]
 8028386:	3220      	adds	r2, #32
 8028388:	601a      	str	r2, [r3, #0]
  }

  return NVMS_NOERROR;
 802838a:	2000      	movs	r0, #0
}
 802838c:	bd30      	pop	{r4, r5, pc}
    return NVMS_NOTINIT;
 802838e:	2001      	movs	r0, #1
 8028390:	e7fc      	b.n	802838c <NVMS_GetDataWithType+0x44>
    return NVMS_SLOT_INVALID;
 8028392:	2004      	movs	r0, #4
 8028394:	e7fa      	b.n	802838c <NVMS_GetDataWithType+0x44>
    return NVMS_DATA_NOT_FOUND;
 8028396:	2005      	movs	r0, #5
 8028398:	e7f8      	b.n	802838c <NVMS_GetDataWithType+0x44>
  return NVMS_NOERROR;
 802839a:	2000      	movs	r0, #0
 802839c:	e7f6      	b.n	802838c <NVMS_GetDataWithType+0x44>
 802839e:	46c0      	nop			; (mov r8, r8)
 80283a0:	2000b7c8 	.word	0x2000b7c8

080283a4 <KMS_Objects_GetRange>:
  * @brief  This function returns object range identification from key handle
  * @param  hKey key handle
  * @retval Value within @ref kms_obj_range_t
  */
kms_obj_range_t  KMS_Objects_GetRange(CK_OBJECT_HANDLE hKey)
{
 80283a4:	b510      	push	{r4, lr}
 80283a6:	b082      	sub	sp, #8
 80283a8:	0004      	movs	r4, r0
  uint32_t MinSlot;
  uint32_t MaxSlot;

  /* Read the available static slots from the platform */
  KMS_PlatfObjects_EmbeddedRange(&MinSlot, &MaxSlot);
 80283aa:	4669      	mov	r1, sp
 80283ac:	a801      	add	r0, sp, #4
 80283ae:	f000 fb31 	bl	8028a14 <KMS_PlatfObjects_EmbeddedRange>
  /* If hKey is in the range of the embedded keys */
  if ((hKey <= MaxSlot) && (hKey >= MinSlot))
 80283b2:	9b00      	ldr	r3, [sp, #0]
 80283b4:	42a3      	cmp	r3, r4
 80283b6:	d302      	bcc.n	80283be <KMS_Objects_GetRange+0x1a>
 80283b8:	9b01      	ldr	r3, [sp, #4]
 80283ba:	42a3      	cmp	r3, r4
 80283bc:	d916      	bls.n	80283ec <KMS_Objects_GetRange+0x48>
    return (KMS_OBJECT_RANGE_EMBEDDED);
  }

#ifdef KMS_NVM_ENABLED
  /* Read the available nvm slots from the platform */
  KMS_PlatfObjects_NvmStaticRange(&MinSlot, &MaxSlot);
 80283be:	4669      	mov	r1, sp
 80283c0:	a801      	add	r0, sp, #4
 80283c2:	f000 fb35 	bl	8028a30 <KMS_PlatfObjects_NvmStaticRange>
  /* If hKey is in the range of nvm keys */
  if ((hKey <= MaxSlot) && (hKey >= MinSlot))
 80283c6:	9b00      	ldr	r3, [sp, #0]
 80283c8:	42a3      	cmp	r3, r4
 80283ca:	d302      	bcc.n	80283d2 <KMS_Objects_GetRange+0x2e>
 80283cc:	9b01      	ldr	r3, [sp, #4]
 80283ce:	42a3      	cmp	r3, r4
 80283d0:	d90e      	bls.n	80283f0 <KMS_Objects_GetRange+0x4c>
    return (KMS_OBJECT_RANGE_NVM_STATIC_ID);
  }

#ifdef KMS_NVM_DYNAMIC_ENABLED
  /* Read the available nvm slots from the platform */
  KMS_PlatfObjects_NvmDynamicRange(&MinSlot, &MaxSlot);
 80283d2:	4669      	mov	r1, sp
 80283d4:	a801      	add	r0, sp, #4
 80283d6:	f000 fb39 	bl	8028a4c <KMS_PlatfObjects_NvmDynamicRange>
  /* If hKey is in the range of nvm keys */
  if ((hKey <= MaxSlot) && (hKey >= MinSlot))
 80283da:	9b00      	ldr	r3, [sp, #0]
 80283dc:	42a3      	cmp	r3, r4
 80283de:	d309      	bcc.n	80283f4 <KMS_Objects_GetRange+0x50>
 80283e0:	9b01      	ldr	r3, [sp, #4]
 80283e2:	42a3      	cmp	r3, r4
 80283e4:	d908      	bls.n	80283f8 <KMS_Objects_GetRange+0x54>
    return (KMS_OBJECT_RANGE_EXT_TOKEN_DYNAMIC_ID);
  }
#endif  /* KMS_EXT_TOKEN_ENABLED */

  /* hKey not in known ranges */
  return KMS_OBJECT_RANGE_UNKNOWN;
 80283e6:	2006      	movs	r0, #6
}
 80283e8:	b002      	add	sp, #8
 80283ea:	bd10      	pop	{r4, pc}
    return (KMS_OBJECT_RANGE_EMBEDDED);
 80283ec:	2000      	movs	r0, #0
 80283ee:	e7fb      	b.n	80283e8 <KMS_Objects_GetRange+0x44>
    return (KMS_OBJECT_RANGE_NVM_STATIC_ID);
 80283f0:	2001      	movs	r0, #1
 80283f2:	e7f9      	b.n	80283e8 <KMS_Objects_GetRange+0x44>
  return KMS_OBJECT_RANGE_UNKNOWN;
 80283f4:	2006      	movs	r0, #6
 80283f6:	e7f7      	b.n	80283e8 <KMS_Objects_GetRange+0x44>
    return (KMS_OBJECT_RANGE_NVM_DYNAMIC_ID);
 80283f8:	2002      	movs	r0, #2
 80283fa:	e7f5      	b.n	80283e8 <KMS_Objects_GetRange+0x44>

080283fc <KMS_CheckKeyIsNotLocked>:
  }
  return e_ret_status;
#else /* KMS_SE_LOCK_KEYS */
  return CKR_OK;
#endif /* KMS_SE_LOCK_KEYS */
}
 80283fc:	2000      	movs	r0, #0
 80283fe:	4770      	bx	lr

08028400 <KMS_Objects_GetPointer>:
{
 8028400:	b570      	push	{r4, r5, r6, lr}
 8028402:	b082      	sub	sp, #8
 8028404:	0004      	movs	r4, r0
  if (KMS_CheckKeyIsNotLocked(hKey) == CKR_OK)
 8028406:	f7ff fff9 	bl	80283fc <KMS_CheckKeyIsNotLocked>
 802840a:	1e05      	subs	r5, r0, #0
 802840c:	d005      	beq.n	802841a <KMS_Objects_GetPointer+0x1a>
  kms_obj_keyhead_t *p_object = NULL;
 802840e:	2600      	movs	r6, #0
  if (KMS_CheckKeyIsNotLocked(hKey) == CKR_OK)
 8028410:	2d00      	cmp	r5, #0
 8028412:	d132      	bne.n	802847a <KMS_Objects_GetPointer+0x7a>
}
 8028414:	0030      	movs	r0, r6
 8028416:	b002      	add	sp, #8
 8028418:	bd70      	pop	{r4, r5, r6, pc}
    KMS_PlatfObjects_EmbeddedRange(&min_slot, &max_slot);
 802841a:	4669      	mov	r1, sp
 802841c:	a801      	add	r0, sp, #4
 802841e:	f000 faf9 	bl	8028a14 <KMS_PlatfObjects_EmbeddedRange>
    if ((hKey <= max_slot) && (hKey >= min_slot))
 8028422:	9b00      	ldr	r3, [sp, #0]
 8028424:	42a3      	cmp	r3, r4
 8028426:	d309      	bcc.n	802843c <KMS_Objects_GetPointer+0x3c>
 8028428:	9b01      	ldr	r3, [sp, #4]
 802842a:	42a3      	cmp	r3, r4
 802842c:	d901      	bls.n	8028432 <KMS_Objects_GetPointer+0x32>
  kms_obj_keyhead_t *p_object = NULL;
 802842e:	2600      	movs	r6, #0
 8028430:	e005      	b.n	802843e <KMS_Objects_GetPointer+0x3e>
      p_object = KMS_PlatfObjects_EmbeddedObject(hKey);
 8028432:	0020      	movs	r0, r4
 8028434:	f000 faf4 	bl	8028a20 <KMS_PlatfObjects_EmbeddedObject>
 8028438:	0006      	movs	r6, r0
 802843a:	e000      	b.n	802843e <KMS_Objects_GetPointer+0x3e>
  kms_obj_keyhead_t *p_object = NULL;
 802843c:	2600      	movs	r6, #0
    KMS_PlatfObjects_NvmStaticRange(&min_slot, &max_slot);
 802843e:	4669      	mov	r1, sp
 8028440:	a801      	add	r0, sp, #4
 8028442:	f000 faf5 	bl	8028a30 <KMS_PlatfObjects_NvmStaticRange>
    if ((hKey <= max_slot) && (hKey >= min_slot))
 8028446:	9b00      	ldr	r3, [sp, #0]
 8028448:	42a3      	cmp	r3, r4
 802844a:	d302      	bcc.n	8028452 <KMS_Objects_GetPointer+0x52>
 802844c:	9b01      	ldr	r3, [sp, #4]
 802844e:	42a3      	cmp	r3, r4
 8028450:	d90e      	bls.n	8028470 <KMS_Objects_GetPointer+0x70>
    KMS_PlatfObjects_NvmDynamicRange(&min_slot, &max_slot);
 8028452:	4669      	mov	r1, sp
 8028454:	a801      	add	r0, sp, #4
 8028456:	f000 faf9 	bl	8028a4c <KMS_PlatfObjects_NvmDynamicRange>
    if ((hKey <= max_slot) && (hKey >= min_slot))
 802845a:	9b00      	ldr	r3, [sp, #0]
 802845c:	42a3      	cmp	r3, r4
 802845e:	d3d7      	bcc.n	8028410 <KMS_Objects_GetPointer+0x10>
 8028460:	9b01      	ldr	r3, [sp, #4]
 8028462:	42a3      	cmp	r3, r4
 8028464:	d8d4      	bhi.n	8028410 <KMS_Objects_GetPointer+0x10>
      p_object = KMS_PlatfObjects_NvmDynamicObject(hKey);
 8028466:	0020      	movs	r0, r4
 8028468:	f000 faf6 	bl	8028a58 <KMS_PlatfObjects_NvmDynamicObject>
 802846c:	0006      	movs	r6, r0
 802846e:	e7cf      	b.n	8028410 <KMS_Objects_GetPointer+0x10>
      p_object = KMS_PlatfObjects_NvmStaticObject(hKey);
 8028470:	0020      	movs	r0, r4
 8028472:	f000 fae3 	bl	8028a3c <KMS_PlatfObjects_NvmStaticObject>
 8028476:	0006      	movs	r6, r0
 8028478:	e7eb      	b.n	8028452 <KMS_Objects_GetPointer+0x52>
    return NULL;
 802847a:	2600      	movs	r6, #0
 802847c:	e7ca      	b.n	8028414 <KMS_Objects_GetPointer+0x14>

0802847e <KMS_FindAttributeInTemplate>:
  *         CKR_ARGUMENTS_BAD
  *         CKR_GENERAL_ERROR
  */
CK_RV KMS_FindAttributeInTemplate(CK_ATTRIBUTE_PTR pTemplate, CK_ULONG ulCount, CK_ATTRIBUTE_TYPE type,
                                  CK_ATTRIBUTE_PTR *ppAttr)
{
 802847e:	b570      	push	{r4, r5, r6, lr}
  CK_RV e_ret_status = CKR_GENERAL_ERROR;
  if ((pTemplate == NULL_PTR) || (ulCount == 0UL) || (ppAttr == NULL_PTR))
 8028480:	2800      	cmp	r0, #0
 8028482:	d014      	beq.n	80284ae <KMS_FindAttributeInTemplate+0x30>
 8028484:	2900      	cmp	r1, #0
 8028486:	d014      	beq.n	80284b2 <KMS_FindAttributeInTemplate+0x34>
 8028488:	2b00      	cmp	r3, #0
 802848a:	d014      	beq.n	80284b6 <KMS_FindAttributeInTemplate+0x38>
    e_ret_status = CKR_ARGUMENTS_BAD;
  }
  else
  {
    /* Search within template attributes the given attribute type */
    for (uint32_t i = 0; i < ulCount; i++)
 802848c:	2500      	movs	r5, #0
 802848e:	e000      	b.n	8028492 <KMS_FindAttributeInTemplate+0x14>
 8028490:	3501      	adds	r5, #1
 8028492:	428d      	cmp	r5, r1
 8028494:	d209      	bcs.n	80284aa <KMS_FindAttributeInTemplate+0x2c>
    {
      if (pTemplate[i].type == type)
 8028496:	006c      	lsls	r4, r5, #1
 8028498:	1964      	adds	r4, r4, r5
 802849a:	00a4      	lsls	r4, r4, #2
 802849c:	1904      	adds	r4, r0, r4
 802849e:	6826      	ldr	r6, [r4, #0]
 80284a0:	4296      	cmp	r6, r2
 80284a2:	d1f5      	bne.n	8028490 <KMS_FindAttributeInTemplate+0x12>
      {
        *ppAttr = &(pTemplate[i]);
 80284a4:	601c      	str	r4, [r3, #0]
        e_ret_status = CKR_OK;
 80284a6:	2000      	movs	r0, #0
        break;
 80284a8:	e004      	b.n	80284b4 <KMS_FindAttributeInTemplate+0x36>
  CK_RV e_ret_status = CKR_GENERAL_ERROR;
 80284aa:	2005      	movs	r0, #5
 80284ac:	e002      	b.n	80284b4 <KMS_FindAttributeInTemplate+0x36>
    e_ret_status = CKR_ARGUMENTS_BAD;
 80284ae:	2007      	movs	r0, #7
 80284b0:	e000      	b.n	80284b4 <KMS_FindAttributeInTemplate+0x36>
 80284b2:	2007      	movs	r0, #7
      }
    }
  }
  return e_ret_status;
}
 80284b4:	bd70      	pop	{r4, r5, r6, pc}
    e_ret_status = CKR_ARGUMENTS_BAD;
 80284b6:	2007      	movs	r0, #7
  return e_ret_status;
 80284b8:	e7fc      	b.n	80284b4 <KMS_FindAttributeInTemplate+0x36>

080284ba <KMS_Objects_SearchAttributes>:
  * @param  pAttribute found attribute
  * @retval CKR_OK if attribute is found
  *         CKR_ATTRIBUTE_TYPE_INVALID otherwise
  */
CK_RV KMS_Objects_SearchAttributes(uint32_t SearchedId, kms_obj_keyhead_t *pKmsKeyHead, kms_attr_t **pAttribute)
{
 80284ba:	b570      	push	{r4, r5, r6, lr}
  CK_RV e_ret_status = CKR_ATTRIBUTE_TYPE_INVALID;
  kms_attr_t *pkms_blob_current = (kms_attr_t *)(uint32_t)(pKmsKeyHead->blobs);
 80284bc:	000c      	movs	r4, r1
 80284be:	3414      	adds	r4, #20
  uint8_t  *pkms_blob;
  uint32_t blob_index;
  uint32_t current_attribute_size;

  /* The blob containing the attributes is described by the kms_obj_keyhead_t */
  for (blob_index = 0; blob_index < pKmsKeyHead->blobs_count; blob_index++)
 80284c0:	2500      	movs	r5, #0
 80284c2:	e005      	b.n	80284d0 <KMS_Objects_SearchAttributes+0x16>
  {
    /* Parse the attributes from the blob to find the id */
    if (pkms_blob_current->id == SearchedId)
    {
      *pAttribute = pkms_blob_current;
 80284c4:	6014      	str	r4, [r2, #0]

      /* ID is found */
      e_ret_status = CKR_OK;
 80284c6:	2000      	movs	r0, #0
      break;
 80284c8:	e010      	b.n	80284ec <KMS_Objects_SearchAttributes+0x32>
    {
      current_attribute_size += 4UL - (current_attribute_size % 4UL);
    }

    /* Point to next attribute */
    pkms_blob = &((uint8_t *)pkms_blob_current)[4UL + 4UL + current_attribute_size];
 80284ca:	3308      	adds	r3, #8
 80284cc:	18e4      	adds	r4, r4, r3
  for (blob_index = 0; blob_index < pKmsKeyHead->blobs_count; blob_index++)
 80284ce:	3501      	adds	r5, #1
 80284d0:	68cb      	ldr	r3, [r1, #12]
 80284d2:	42ab      	cmp	r3, r5
 80284d4:	d909      	bls.n	80284ea <KMS_Objects_SearchAttributes+0x30>
    if (pkms_blob_current->id == SearchedId)
 80284d6:	6823      	ldr	r3, [r4, #0]
 80284d8:	4283      	cmp	r3, r0
 80284da:	d0f3      	beq.n	80284c4 <KMS_Objects_SearchAttributes+0xa>
    current_attribute_size = pkms_blob_current->size ;
 80284dc:	6863      	ldr	r3, [r4, #4]
    if ((current_attribute_size % 4UL) != 0UL)
 80284de:	079e      	lsls	r6, r3, #30
 80284e0:	d0f3      	beq.n	80284ca <KMS_Objects_SearchAttributes+0x10>
      current_attribute_size += 4UL - (current_attribute_size % 4UL);
 80284e2:	2603      	movs	r6, #3
 80284e4:	43b3      	bics	r3, r6
 80284e6:	3304      	adds	r3, #4
 80284e8:	e7ef      	b.n	80284ca <KMS_Objects_SearchAttributes+0x10>
  CK_RV e_ret_status = CKR_ATTRIBUTE_TYPE_INVALID;
 80284ea:	2012      	movs	r0, #18

    /* Point to the next Attribute */
    pkms_blob_current = (kms_attr_t *)(uint32_t)pkms_blob;
  }
  return e_ret_status;
}
 80284ec:	bd70      	pop	{r4, r5, r6, pc}

080284ee <KMS_FindObjectsFromTemplate>:
{
 80284ee:	b5f0      	push	{r4, r5, r6, r7, lr}
 80284f0:	46de      	mov	lr, fp
 80284f2:	4657      	mov	r7, sl
 80284f4:	464e      	mov	r6, r9
 80284f6:	4645      	mov	r5, r8
 80284f8:	b5e0      	push	{r5, r6, r7, lr}
 80284fa:	b08d      	sub	sp, #52	; 0x34
 80284fc:	9102      	str	r1, [sp, #8]
 80284fe:	4693      	mov	fp, r2
 8028500:	001f      	movs	r7, r3
 8028502:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 8028504:	469a      	mov	sl, r3
  *p_working_obj_count = 0;
 8028506:	2300      	movs	r3, #0
 8028508:	603b      	str	r3, [r7, #0]
  KMS_PlatfObjects_EmbeddedRange(&h_emb_obj_min, &h_emb_obj_max);
 802850a:	a909      	add	r1, sp, #36	; 0x24
 802850c:	a80a      	add	r0, sp, #40	; 0x28
 802850e:	f000 fa81 	bl	8028a14 <KMS_PlatfObjects_EmbeddedRange>
  KMS_PlatfObjects_NvmStaticRange(&h_nvms_obj_min, &h_nvms_obj_max);
 8028512:	a907      	add	r1, sp, #28
 8028514:	a808      	add	r0, sp, #32
 8028516:	f000 fa8b 	bl	8028a30 <KMS_PlatfObjects_NvmStaticRange>
  KMS_PlatfObjects_NvmDynamicRange(&h_nvmd_obj_min, &h_nvmd_obj_max);
 802851a:	a905      	add	r1, sp, #20
 802851c:	a806      	add	r0, sp, #24
 802851e:	f000 fa95 	bl	8028a4c <KMS_PlatfObjects_NvmDynamicRange>
  h_object = h_emb_obj_min;
 8028522:	9e0a      	ldr	r6, [sp, #40]	; 0x28
  state = KMS_OBJECT_RANGE_EMBEDDED;
 8028524:	2300      	movs	r3, #0
 8028526:	4698      	mov	r8, r3
  CK_RV e_ret_status = CKR_OK;
 8028528:	9301      	str	r3, [sp, #4]
  while ((*p_working_obj_count < ulMaxCount)
 802852a:	e038      	b.n	802859e <KMS_FindObjectsFromTemplate+0xb0>
        for (template_index = 0; template_index < ulCount; template_index++)
 802852c:	3501      	adds	r5, #1
 802852e:	42b5      	cmp	r5, r6
 8028530:	d225      	bcs.n	802857e <KMS_FindObjectsFromTemplate+0x90>
          if (KMS_Objects_SearchAttributes(pTemplate[template_index].type, p_pkms_object, &p_attribute) == CKR_OK)
 8028532:	006c      	lsls	r4, r5, #1
 8028534:	1964      	adds	r4, r4, r5
 8028536:	00a4      	lsls	r4, r4, #2
 8028538:	9b16      	ldr	r3, [sp, #88]	; 0x58
 802853a:	469c      	mov	ip, r3
 802853c:	4464      	add	r4, ip
 802853e:	aa0b      	add	r2, sp, #44	; 0x2c
 8028540:	0039      	movs	r1, r7
 8028542:	6820      	ldr	r0, [r4, #0]
 8028544:	f7ff ffb9 	bl	80284ba <KMS_Objects_SearchAttributes>
 8028548:	2800      	cmp	r0, #0
 802854a:	d1ef      	bne.n	802852c <KMS_FindObjectsFromTemplate+0x3e>
            if ((p_attribute->size == pTemplate[template_index].ulValueLen)
 802854c:	980b      	ldr	r0, [sp, #44]	; 0x2c
 802854e:	6842      	ldr	r2, [r0, #4]
 8028550:	68a3      	ldr	r3, [r4, #8]
 8028552:	429a      	cmp	r2, r3
 8028554:	d1ea      	bne.n	802852c <KMS_FindObjectsFromTemplate+0x3e>
                && (memcmp(p_attribute->data, pTemplate[template_index].pValue, p_attribute->size) == 0))
 8028556:	3008      	adds	r0, #8
 8028558:	6861      	ldr	r1, [r4, #4]
 802855a:	f00c fad5 	bl	8034b08 <memcmp>
 802855e:	2800      	cmp	r0, #0
 8028560:	d1e4      	bne.n	802852c <KMS_FindObjectsFromTemplate+0x3e>
              ul_attributes_found_count++;
 8028562:	9b03      	ldr	r3, [sp, #12]
 8028564:	3301      	adds	r3, #1
 8028566:	9303      	str	r3, [sp, #12]
 8028568:	e7e0      	b.n	802852c <KMS_FindObjectsFromTemplate+0x3e>
        for (template_index = 0; template_index < ulCount; template_index++)
 802856a:	9b01      	ldr	r3, [sp, #4]
 802856c:	001d      	movs	r5, r3
        ul_attributes_found_count = 0;
 802856e:	9303      	str	r3, [sp, #12]
 8028570:	4653      	mov	r3, sl
 8028572:	9317      	str	r3, [sp, #92]	; 0x5c
 8028574:	46ba      	mov	sl, r7
 8028576:	0007      	movs	r7, r0
 8028578:	46b1      	mov	r9, r6
 802857a:	001e      	movs	r6, r3
 802857c:	e7d7      	b.n	802852e <KMS_FindObjectsFromTemplate+0x40>
        if (ul_attributes_found_count == ulCount)
 802857e:	4657      	mov	r7, sl
 8028580:	46b2      	mov	sl, r6
 8028582:	464e      	mov	r6, r9
 8028584:	9b03      	ldr	r3, [sp, #12]
 8028586:	4553      	cmp	r3, sl
 8028588:	d021      	beq.n	80285ce <KMS_FindObjectsFromTemplate+0xe0>
    h_object++;
 802858a:	3601      	adds	r6, #1
    switch (state)
 802858c:	4643      	mov	r3, r8
 802858e:	2b01      	cmp	r3, #1
 8028590:	d02c      	beq.n	80285ec <KMS_FindObjectsFromTemplate+0xfe>
 8028592:	2b02      	cmp	r3, #2
 8028594:	d031      	beq.n	80285fa <KMS_FindObjectsFromTemplate+0x10c>
 8028596:	2b00      	cmp	r3, #0
 8028598:	d021      	beq.n	80285de <KMS_FindObjectsFromTemplate+0xf0>
 802859a:	2305      	movs	r3, #5
 802859c:	9301      	str	r3, [sp, #4]
  while ((*p_working_obj_count < ulMaxCount)
 802859e:	683b      	ldr	r3, [r7, #0]
 80285a0:	455b      	cmp	r3, fp
 80285a2:	d22f      	bcs.n	8028604 <KMS_FindObjectsFromTemplate+0x116>
         && (h_object != KMS_HANDLE_KEY_NOT_KNOWN)
 80285a4:	2e00      	cmp	r6, #0
 80285a6:	d02d      	beq.n	8028604 <KMS_FindObjectsFromTemplate+0x116>
         && (e_ret_status == CKR_OK))
 80285a8:	9b01      	ldr	r3, [sp, #4]
 80285aa:	2b00      	cmp	r3, #0
 80285ac:	d12a      	bne.n	8028604 <KMS_FindObjectsFromTemplate+0x116>
    p_pkms_object = KMS_Objects_GetPointer(h_object);
 80285ae:	0030      	movs	r0, r6
 80285b0:	f7ff ff26 	bl	8028400 <KMS_Objects_GetPointer>
    if ((p_pkms_object != NULL) && (e_ret_status == CKR_OK))
 80285b4:	2800      	cmp	r0, #0
 80285b6:	d0e8      	beq.n	802858a <KMS_FindObjectsFromTemplate+0x9c>
      if (ulCount > 0UL)
 80285b8:	4653      	mov	r3, sl
 80285ba:	2b00      	cmp	r3, #0
 80285bc:	d1d5      	bne.n	802856a <KMS_FindObjectsFromTemplate+0x7c>
        phObject[*p_working_obj_count] = h_object;
 80285be:	683b      	ldr	r3, [r7, #0]
 80285c0:	009b      	lsls	r3, r3, #2
 80285c2:	9a02      	ldr	r2, [sp, #8]
 80285c4:	50d6      	str	r6, [r2, r3]
        *p_working_obj_count = *p_working_obj_count + 1;
 80285c6:	683b      	ldr	r3, [r7, #0]
 80285c8:	3301      	adds	r3, #1
 80285ca:	603b      	str	r3, [r7, #0]
 80285cc:	e7dd      	b.n	802858a <KMS_FindObjectsFromTemplate+0x9c>
          phObject[*p_working_obj_count] = h_object;
 80285ce:	683b      	ldr	r3, [r7, #0]
 80285d0:	009b      	lsls	r3, r3, #2
 80285d2:	9a02      	ldr	r2, [sp, #8]
 80285d4:	50d6      	str	r6, [r2, r3]
          *p_working_obj_count = *p_working_obj_count + 1;
 80285d6:	683b      	ldr	r3, [r7, #0]
 80285d8:	3301      	adds	r3, #1
 80285da:	603b      	str	r3, [r7, #0]
 80285dc:	e7d5      	b.n	802858a <KMS_FindObjectsFromTemplate+0x9c>
        if (h_object > h_emb_obj_max)
 80285de:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80285e0:	42b3      	cmp	r3, r6
 80285e2:	d2dc      	bcs.n	802859e <KMS_FindObjectsFromTemplate+0xb0>
          h_object = h_nvms_obj_min;
 80285e4:	9e08      	ldr	r6, [sp, #32]
          state = KMS_OBJECT_RANGE_NVM_STATIC_ID;
 80285e6:	2301      	movs	r3, #1
 80285e8:	4698      	mov	r8, r3
 80285ea:	e7d8      	b.n	802859e <KMS_FindObjectsFromTemplate+0xb0>
        if (h_object > h_nvms_obj_max)
 80285ec:	9b07      	ldr	r3, [sp, #28]
 80285ee:	42b3      	cmp	r3, r6
 80285f0:	d2d5      	bcs.n	802859e <KMS_FindObjectsFromTemplate+0xb0>
          h_object = h_nvmd_obj_min;
 80285f2:	9e06      	ldr	r6, [sp, #24]
          state = KMS_OBJECT_RANGE_NVM_DYNAMIC_ID;
 80285f4:	2302      	movs	r3, #2
 80285f6:	4698      	mov	r8, r3
 80285f8:	e7d1      	b.n	802859e <KMS_FindObjectsFromTemplate+0xb0>
        if (h_object > h_nvmd_obj_max)
 80285fa:	9b05      	ldr	r3, [sp, #20]
 80285fc:	42b3      	cmp	r3, r6
 80285fe:	d2ce      	bcs.n	802859e <KMS_FindObjectsFromTemplate+0xb0>
          h_object = KMS_HANDLE_KEY_NOT_KNOWN;
 8028600:	9e01      	ldr	r6, [sp, #4]
 8028602:	e7cc      	b.n	802859e <KMS_FindObjectsFromTemplate+0xb0>
}
 8028604:	2000      	movs	r0, #0
 8028606:	b00d      	add	sp, #52	; 0x34
 8028608:	bcf0      	pop	{r4, r5, r6, r7}
 802860a:	46bb      	mov	fp, r7
 802860c:	46b2      	mov	sl, r6
 802860e:	46a9      	mov	r9, r5
 8028610:	46a0      	mov	r8, r4
 8028612:	bdf0      	pop	{r4, r5, r6, r7, pc}

08028614 <KMS_Objects_u8ptr_2_BlobU32>:
  * @param  u8Size u8 buffer size (in bytes)
  * @param  pU32 translated buffer
  * @retval None
  */
void KMS_Objects_u8ptr_2_BlobU32(uint8_t *pU8, uint32_t u8Size, uint32_t *pU32)
{
 8028614:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t index;
  uint32_t reste = u8Size & 0x3UL;
 8028616:	2303      	movs	r3, #3
 8028618:	400b      	ands	r3, r1
 802861a:	469c      	mov	ip, r3
  for (index = 0; index < ((u8Size) / 4UL); index++)
 802861c:	2400      	movs	r4, #0
 802861e:	e00d      	b.n	802863c <KMS_Objects_u8ptr_2_BlobU32+0x28>
  {
    pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 24) + \
 8028620:	00a5      	lsls	r5, r4, #2
 8028622:	5d43      	ldrb	r3, [r0, r5]
 8028624:	061b      	lsls	r3, r3, #24
                  ((uint32_t)pU8[(index * 4UL) + 1UL] << 16) + \
 8028626:	1946      	adds	r6, r0, r5
 8028628:	7877      	ldrb	r7, [r6, #1]
 802862a:	043f      	lsls	r7, r7, #16
    pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 24) + \
 802862c:	19db      	adds	r3, r3, r7
                  ((uint32_t)pU8[(index * 4UL) + 2UL] << 8) + \
 802862e:	78b7      	ldrb	r7, [r6, #2]
 8028630:	023f      	lsls	r7, r7, #8
                  ((uint32_t)pU8[(index * 4UL) + 1UL] << 16) + \
 8028632:	19db      	adds	r3, r3, r7
                  ((uint32_t)pU8[(index * 4UL) + 3UL]);
 8028634:	78f6      	ldrb	r6, [r6, #3]
                  ((uint32_t)pU8[(index * 4UL) + 2UL] << 8) + \
 8028636:	199b      	adds	r3, r3, r6
    pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 24) + \
 8028638:	5153      	str	r3, [r2, r5]
  for (index = 0; index < ((u8Size) / 4UL); index++)
 802863a:	3401      	adds	r4, #1
 802863c:	088b      	lsrs	r3, r1, #2
 802863e:	42a3      	cmp	r3, r4
 8028640:	d8ee      	bhi.n	8028620 <KMS_Objects_u8ptr_2_BlobU32+0xc>
  }
  if (reste != 0UL)     /* check that we have a multiple of 4 bytes */
 8028642:	4663      	mov	r3, ip
 8028644:	2b00      	cmp	r3, #0
 8028646:	d007      	beq.n	8028658 <KMS_Objects_u8ptr_2_BlobU32+0x44>
  {
    if (reste == 1UL)
 8028648:	2b01      	cmp	r3, #1
 802864a:	d006      	beq.n	802865a <KMS_Objects_u8ptr_2_BlobU32+0x46>
      /* One byte remains, convention is as follow:
       *         u8[]  = {0x01}
       *         u32[] = {0x00000001} */
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL]);
    }
    if (reste == 2UL)
 802864c:	4663      	mov	r3, ip
 802864e:	2b02      	cmp	r3, #2
 8028650:	d007      	beq.n	8028662 <KMS_Objects_u8ptr_2_BlobU32+0x4e>
       *         u8[]  = {0x01, 0x02}
       *         u32[] = {0x00000102} */
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 8) + \
                    ((uint32_t)pU8[(index * 4UL) + 1UL]);
    }
    if (reste == 3UL)
 8028652:	4663      	mov	r3, ip
 8028654:	2b03      	cmp	r3, #3
 8028656:	d00c      	beq.n	8028672 <KMS_Objects_u8ptr_2_BlobU32+0x5e>
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 16) + \
                    ((uint32_t)pU8[(index * 4UL) + 1UL] << 8) + \
                    ((uint32_t)pU8[(index * 4UL) + 2UL]);
    }
  }
}
 8028658:	bdf0      	pop	{r4, r5, r6, r7, pc}
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL]);
 802865a:	00a3      	lsls	r3, r4, #2
 802865c:	5cc1      	ldrb	r1, [r0, r3]
 802865e:	50d1      	str	r1, [r2, r3]
 8028660:	e7f4      	b.n	802864c <KMS_Objects_u8ptr_2_BlobU32+0x38>
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 8) + \
 8028662:	00a1      	lsls	r1, r4, #2
 8028664:	5c43      	ldrb	r3, [r0, r1]
 8028666:	021b      	lsls	r3, r3, #8
                    ((uint32_t)pU8[(index * 4UL) + 1UL]);
 8028668:	1845      	adds	r5, r0, r1
 802866a:	786d      	ldrb	r5, [r5, #1]
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 8) + \
 802866c:	195b      	adds	r3, r3, r5
 802866e:	5053      	str	r3, [r2, r1]
 8028670:	e7ef      	b.n	8028652 <KMS_Objects_u8ptr_2_BlobU32+0x3e>
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 16) + \
 8028672:	00a4      	lsls	r4, r4, #2
 8028674:	5d03      	ldrb	r3, [r0, r4]
 8028676:	041b      	lsls	r3, r3, #16
                    ((uint32_t)pU8[(index * 4UL) + 1UL] << 8) + \
 8028678:	1900      	adds	r0, r0, r4
 802867a:	7841      	ldrb	r1, [r0, #1]
 802867c:	0209      	lsls	r1, r1, #8
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 16) + \
 802867e:	185b      	adds	r3, r3, r1
                    ((uint32_t)pU8[(index * 4UL) + 2UL]);
 8028680:	7881      	ldrb	r1, [r0, #2]
                    ((uint32_t)pU8[(index * 4UL) + 1UL] << 8) + \
 8028682:	185b      	adds	r3, r3, r1
      pU32[index] = ((uint32_t)pU8[(index * 4UL) + 0UL] << 16) + \
 8028684:	5113      	str	r3, [r2, r4]
}
 8028686:	e7e7      	b.n	8028658 <KMS_Objects_u8ptr_2_BlobU32+0x44>

08028688 <KMS_Objects_BlobU32_2_u8ptr>:
  * @param  u32Size u32 buffer size
  * @param  pU8 translated buffer
  * @retval None
  */
void  KMS_Objects_BlobU32_2_u8ptr(uint32_t *pU32, uint32_t u32Size, uint8_t *pU8)
{
 8028688:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t index_key;
  uint32_t reste = u32Size & 0x3UL;
 802868a:	2303      	movs	r3, #3
 802868c:	400b      	ands	r3, r1
 802868e:	469c      	mov	ip, r3

  for (index_key = 0; index_key < (u32Size / sizeof(uint32_t)); index_key++)
 8028690:	2500      	movs	r5, #0
 8028692:	e00e      	b.n	80286b2 <KMS_Objects_BlobU32_2_u8ptr+0x2a>
  {
    pU8[(index_key * sizeof(uint32_t))]       = (uint8_t)(pU32[index_key] >> 24);
 8028694:	00ab      	lsls	r3, r5, #2
 8028696:	18c4      	adds	r4, r0, r3
 8028698:	78e6      	ldrb	r6, [r4, #3]
 802869a:	54d6      	strb	r6, [r2, r3]
    pU8[(index_key * sizeof(uint32_t)) + 1UL] = (uint8_t)(pU32[index_key] >> 16);
 802869c:	1c5e      	adds	r6, r3, #1
 802869e:	78a7      	ldrb	r7, [r4, #2]
 80286a0:	5597      	strb	r7, [r2, r6]
    pU8[(index_key * sizeof(uint32_t)) + 2UL] = (uint8_t)(pU32[index_key] >> 8);
 80286a2:	6826      	ldr	r6, [r4, #0]
 80286a4:	0a36      	lsrs	r6, r6, #8
 80286a6:	1c9f      	adds	r7, r3, #2
 80286a8:	55d6      	strb	r6, [r2, r7]
    pU8[(index_key * sizeof(uint32_t)) + 3UL] = (uint8_t)(pU32[index_key]);
 80286aa:	3303      	adds	r3, #3
 80286ac:	7824      	ldrb	r4, [r4, #0]
 80286ae:	54d4      	strb	r4, [r2, r3]
  for (index_key = 0; index_key < (u32Size / sizeof(uint32_t)); index_key++)
 80286b0:	3501      	adds	r5, #1
 80286b2:	088b      	lsrs	r3, r1, #2
 80286b4:	42ab      	cmp	r3, r5
 80286b6:	d8ed      	bhi.n	8028694 <KMS_Objects_BlobU32_2_u8ptr+0xc>
  }

  if (reste != 0UL)     /* check that we have a multiple of 4 bytes */
 80286b8:	4663      	mov	r3, ip
 80286ba:	2b00      	cmp	r3, #0
 80286bc:	d007      	beq.n	80286ce <KMS_Objects_BlobU32_2_u8ptr+0x46>
  {
    if (reste == 1UL)
 80286be:	2b01      	cmp	r3, #1
 80286c0:	d006      	beq.n	80286d0 <KMS_Objects_BlobU32_2_u8ptr+0x48>
       *         u8[]  = {0x01}
       *         u32[] = {0x00000001} */
      pU8[(index_key * sizeof(uint32_t))]   = (uint8_t)(pU32[index_key]);
    }

    if (reste == 2UL)
 80286c2:	4663      	mov	r3, ip
 80286c4:	2b02      	cmp	r3, #2
 80286c6:	d007      	beq.n	80286d8 <KMS_Objects_BlobU32_2_u8ptr+0x50>
       *         u32[] = {0x00000102} */
      pU8[(index_key * sizeof(uint32_t))]   = (uint8_t)(pU32[index_key] >> 8);
      pU8[(index_key * sizeof(uint32_t)) + 1UL] = (uint8_t)(pU32[index_key]);
    }

    if (reste == 3UL)
 80286c8:	4663      	mov	r3, ip
 80286ca:	2b03      	cmp	r3, #3
 80286cc:	d00d      	beq.n	80286ea <KMS_Objects_BlobU32_2_u8ptr+0x62>
      pU8[(index_key * sizeof(uint32_t))]       = (uint8_t)(pU32[index_key] >> 16);
      pU8[(index_key * sizeof(uint32_t)) + 1UL] = (uint8_t)(pU32[index_key] >> 8);
      pU8[(index_key * sizeof(uint32_t)) + 2UL] = (uint8_t)(pU32[index_key]);
    }
  }
}
 80286ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
      pU8[(index_key * sizeof(uint32_t))]   = (uint8_t)(pU32[index_key]);
 80286d0:	00ab      	lsls	r3, r5, #2
 80286d2:	5cc1      	ldrb	r1, [r0, r3]
 80286d4:	54d1      	strb	r1, [r2, r3]
 80286d6:	e7f4      	b.n	80286c2 <KMS_Objects_BlobU32_2_u8ptr+0x3a>
      pU8[(index_key * sizeof(uint32_t))]   = (uint8_t)(pU32[index_key] >> 8);
 80286d8:	00ab      	lsls	r3, r5, #2
 80286da:	18c4      	adds	r4, r0, r3
 80286dc:	6821      	ldr	r1, [r4, #0]
 80286de:	0a09      	lsrs	r1, r1, #8
 80286e0:	54d1      	strb	r1, [r2, r3]
      pU8[(index_key * sizeof(uint32_t)) + 1UL] = (uint8_t)(pU32[index_key]);
 80286e2:	3301      	adds	r3, #1
 80286e4:	7821      	ldrb	r1, [r4, #0]
 80286e6:	54d1      	strb	r1, [r2, r3]
 80286e8:	e7ee      	b.n	80286c8 <KMS_Objects_BlobU32_2_u8ptr+0x40>
      pU8[(index_key * sizeof(uint32_t))]       = (uint8_t)(pU32[index_key] >> 16);
 80286ea:	00ad      	lsls	r5, r5, #2
 80286ec:	1940      	adds	r0, r0, r5
 80286ee:	7883      	ldrb	r3, [r0, #2]
 80286f0:	5553      	strb	r3, [r2, r5]
      pU8[(index_key * sizeof(uint32_t)) + 1UL] = (uint8_t)(pU32[index_key] >> 8);
 80286f2:	6803      	ldr	r3, [r0, #0]
 80286f4:	0a1b      	lsrs	r3, r3, #8
 80286f6:	1c69      	adds	r1, r5, #1
 80286f8:	5453      	strb	r3, [r2, r1]
      pU8[(index_key * sizeof(uint32_t)) + 2UL] = (uint8_t)(pU32[index_key]);
 80286fa:	3502      	adds	r5, #2
 80286fc:	7803      	ldrb	r3, [r0, #0]
 80286fe:	5553      	strb	r3, [r2, r5]
}
 8028700:	e7e5      	b.n	80286ce <KMS_Objects_BlobU32_2_u8ptr+0x46>
	...

08028704 <KMS_Objects_CreateNStoreBlobFromTemplates>:
                                                CK_ATTRIBUTE_PTR pTemplate1,
                                                CK_ULONG ulCount1,
                                                CK_ATTRIBUTE_PTR pTemplate2,
                                                CK_ULONG ulCount2,
                                                CK_OBJECT_HANDLE_PTR phObject)
{
 8028704:	b5f0      	push	{r4, r5, r6, r7, lr}
 8028706:	46de      	mov	lr, fp
 8028708:	4657      	mov	r7, sl
 802870a:	464e      	mov	r6, r9
 802870c:	4645      	mov	r5, r8
 802870e:	b5e0      	push	{r5, r6, r7, lr}
 8028710:	b083      	sub	sp, #12
 8028712:	9001      	str	r0, [sp, #4]
 8028714:	4689      	mov	r9, r1
 8028716:	0016      	movs	r6, r2
 8028718:	469a      	mov	sl, r3
  uint32_t offset;
  uint32_t *ptr;
  uint32_t tmp;
  kms_obj_keyhead_no_blob_t *p_blob;

  if ((pTemplate1 == NULL_PTR) || (ulCount1 == 0UL) || (phObject == NULL_PTR)
 802871a:	2900      	cmp	r1, #0
 802871c:	d100      	bne.n	8028720 <KMS_Objects_CreateNStoreBlobFromTemplates+0x1c>
 802871e:	e0ca      	b.n	80288b6 <KMS_Objects_CreateNStoreBlobFromTemplates+0x1b2>
 8028720:	2a00      	cmp	r2, #0
 8028722:	d100      	bne.n	8028726 <KMS_Objects_CreateNStoreBlobFromTemplates+0x22>
 8028724:	e0c9      	b.n	80288ba <KMS_Objects_CreateNStoreBlobFromTemplates+0x1b6>
 8028726:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8028728:	2b00      	cmp	r3, #0
 802872a:	d100      	bne.n	802872e <KMS_Objects_CreateNStoreBlobFromTemplates+0x2a>
 802872c:	e0c7      	b.n	80288be <KMS_Objects_CreateNStoreBlobFromTemplates+0x1ba>
      || ((pTemplate2 == NULL_PTR) && (ulCount2 != 0UL)) || ((pTemplate2 != NULL_PTR) && (ulCount2 == 0UL)))
 802872e:	4653      	mov	r3, sl
 8028730:	2b00      	cmp	r3, #0
 8028732:	d00a      	beq.n	802874a <KMS_Objects_CreateNStoreBlobFromTemplates+0x46>
 8028734:	4653      	mov	r3, sl
 8028736:	2b00      	cmp	r3, #0
 8028738:	d01f      	beq.n	802877a <KMS_Objects_CreateNStoreBlobFromTemplates+0x76>
 802873a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802873c:	2b00      	cmp	r3, #0
 802873e:	d100      	bne.n	8028742 <KMS_Objects_CreateNStoreBlobFromTemplates+0x3e>
 8028740:	e0bf      	b.n	80288c2 <KMS_Objects_CreateNStoreBlobFromTemplates+0x1be>
 8028742:	2200      	movs	r2, #0
 8028744:	2100      	movs	r1, #0
 8028746:	464d      	mov	r5, r9
 8028748:	e007      	b.n	802875a <KMS_Objects_CreateNStoreBlobFromTemplates+0x56>
 802874a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802874c:	2b00      	cmp	r3, #0
 802874e:	d0f1      	beq.n	8028734 <KMS_Objects_CreateNStoreBlobFromTemplates+0x30>
  {
    return CKR_ARGUMENTS_BAD;
 8028750:	2407      	movs	r4, #7
 8028752:	e0a8      	b.n	80288a6 <KMS_Objects_CreateNStoreBlobFromTemplates+0x1a2>
  blob_size = 0;
  for (uint32_t i = 0; i < ulCount1; i++)
  {
    /* pValue size align on 4 bytes */
    blob_size += (pTemplate1[i].ulValueLen & 0xFFFFFFFCUL)
                 + (((pTemplate1[i].ulValueLen & 0x3UL) != 0UL) ? 4UL : 0UL);
 8028754:	19db      	adds	r3, r3, r7
    blob_size += (pTemplate1[i].ulValueLen & 0xFFFFFFFCUL)
 8028756:	18c9      	adds	r1, r1, r3
  for (uint32_t i = 0; i < ulCount1; i++)
 8028758:	3201      	adds	r2, #1
 802875a:	42b2      	cmp	r2, r6
 802875c:	d211      	bcs.n	8028782 <KMS_Objects_CreateNStoreBlobFromTemplates+0x7e>
    blob_size += (pTemplate1[i].ulValueLen & 0xFFFFFFFCUL)
 802875e:	0053      	lsls	r3, r2, #1
 8028760:	189b      	adds	r3, r3, r2
 8028762:	009b      	lsls	r3, r3, #2
 8028764:	18eb      	adds	r3, r5, r3
 8028766:	6898      	ldr	r0, [r3, #8]
 8028768:	2403      	movs	r4, #3
 802876a:	0003      	movs	r3, r0
 802876c:	43a3      	bics	r3, r4
                 + (((pTemplate1[i].ulValueLen & 0x3UL) != 0UL) ? 4UL : 0UL);
 802876e:	0027      	movs	r7, r4
 8028770:	4007      	ands	r7, r0
 8028772:	4204      	tst	r4, r0
 8028774:	d0ee      	beq.n	8028754 <KMS_Objects_CreateNStoreBlobFromTemplates+0x50>
 8028776:	2704      	movs	r7, #4
 8028778:	e7ec      	b.n	8028754 <KMS_Objects_CreateNStoreBlobFromTemplates+0x50>
 802877a:	2200      	movs	r2, #0
 802877c:	2100      	movs	r1, #0
 802877e:	464d      	mov	r5, r9
 8028780:	e7eb      	b.n	802875a <KMS_Objects_CreateNStoreBlobFromTemplates+0x56>
  }

  /* Add for each attribute type & length fields */
  blob_size += ulCount1 * 2UL * sizeof(uint32_t);
 8028782:	46a9      	mov	r9, r5
 8028784:	00f4      	lsls	r4, r6, #3
 8028786:	1864      	adds	r4, r4, r1
  if ((ulCount2 != 0UL) && (pTemplate2 != NULL_PTR))
 8028788:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 802878a:	2b00      	cmp	r3, #0
 802878c:	d01f      	beq.n	80287ce <KMS_Objects_CreateNStoreBlobFromTemplates+0xca>
 802878e:	4653      	mov	r3, sl
 8028790:	2b00      	cmp	r3, #0
 8028792:	d01c      	beq.n	80287ce <KMS_Objects_CreateNStoreBlobFromTemplates+0xca>
  {
    for (uint32_t i = 0; i < ulCount2; i++)
 8028794:	2200      	movs	r2, #0
 8028796:	46b4      	mov	ip, r6
 8028798:	4655      	mov	r5, sl
 802879a:	990c      	ldr	r1, [sp, #48]	; 0x30
 802879c:	e002      	b.n	80287a4 <KMS_Objects_CreateNStoreBlobFromTemplates+0xa0>
    {
      /* pValue size align on 4 bytes */
      blob_size += (pTemplate2[i].ulValueLen & 0xFFFFFFFCUL)
                   + (((pTemplate2[i].ulValueLen & 0x3UL) != 0UL) ? 4UL : 0UL);
 802879e:	199b      	adds	r3, r3, r6
      blob_size += (pTemplate2[i].ulValueLen & 0xFFFFFFFCUL)
 80287a0:	18e4      	adds	r4, r4, r3
    for (uint32_t i = 0; i < ulCount2; i++)
 80287a2:	3201      	adds	r2, #1
 80287a4:	428a      	cmp	r2, r1
 80287a6:	d20d      	bcs.n	80287c4 <KMS_Objects_CreateNStoreBlobFromTemplates+0xc0>
      blob_size += (pTemplate2[i].ulValueLen & 0xFFFFFFFCUL)
 80287a8:	0053      	lsls	r3, r2, #1
 80287aa:	189b      	adds	r3, r3, r2
 80287ac:	009b      	lsls	r3, r3, #2
 80287ae:	18eb      	adds	r3, r5, r3
 80287b0:	6898      	ldr	r0, [r3, #8]
 80287b2:	2703      	movs	r7, #3
 80287b4:	0003      	movs	r3, r0
 80287b6:	43bb      	bics	r3, r7
                   + (((pTemplate2[i].ulValueLen & 0x3UL) != 0UL) ? 4UL : 0UL);
 80287b8:	003e      	movs	r6, r7
 80287ba:	4006      	ands	r6, r0
 80287bc:	4207      	tst	r7, r0
 80287be:	d0ee      	beq.n	802879e <KMS_Objects_CreateNStoreBlobFromTemplates+0x9a>
 80287c0:	2604      	movs	r6, #4
 80287c2:	e7ec      	b.n	802879e <KMS_Objects_CreateNStoreBlobFromTemplates+0x9a>
    }
    /* Add for each attribute type & length fields */
    blob_size += ulCount2 * 2UL * sizeof(uint32_t);
 80287c4:	4666      	mov	r6, ip
 80287c6:	46aa      	mov	sl, r5
 80287c8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80287ca:	00db      	lsls	r3, r3, #3
 80287cc:	18e4      	adds	r4, r4, r3
  }

  /* Allocate blob object */
  p_blob = (kms_obj_keyhead_no_blob_t *)KMS_Alloc(hSession, sizeof(kms_obj_keyhead_no_blob_t) + blob_size);
 80287ce:	0021      	movs	r1, r4
 80287d0:	3114      	adds	r1, #20
 80287d2:	9801      	ldr	r0, [sp, #4]
 80287d4:	f7fe ffc0 	bl	8027758 <KMS_Alloc>
 80287d8:	4683      	mov	fp, r0
  if (p_blob == NULL_PTR)
 80287da:	2800      	cmp	r0, #0
 80287dc:	d100      	bne.n	80287e0 <KMS_Objects_CreateNStoreBlobFromTemplates+0xdc>
 80287de:	e072      	b.n	80288c6 <KMS_Objects_CreateNStoreBlobFromTemplates+0x1c2>
  {
    e_ret_status = CKR_DEVICE_MEMORY;
  }
  else
  {
    p_blob->version = KMS_ABI_VERSION_CK_2_40;
 80287e0:	4b3a      	ldr	r3, [pc, #232]	; (80288cc <KMS_Objects_CreateNStoreBlobFromTemplates+0x1c8>)
 80287e2:	6003      	str	r3, [r0, #0]
    p_blob->configuration = KMS_ABI_CONFIG_KEYHEAD;
 80287e4:	4b3a      	ldr	r3, [pc, #232]	; (80288d0 <KMS_Objects_CreateNStoreBlobFromTemplates+0x1cc>)
 80287e6:	6043      	str	r3, [r0, #4]
    p_blob->blobs_size = blob_size;
 80287e8:	6084      	str	r4, [r0, #8]
    p_blob->blobs_count = ulCount1 + ulCount2;
 80287ea:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80287ec:	18f3      	adds	r3, r6, r3
 80287ee:	60c3      	str	r3, [r0, #12]
    p_blob->object_id = KMS_HANDLE_KEY_NOT_KNOWN;    /* Updated when inserting object in NVM / VM */
 80287f0:	2300      	movs	r3, #0
 80287f2:	6103      	str	r3, [r0, #16]

    offset = 0;
    tmp = (uint32_t)(p_blob);
    ptr = (uint32_t *)(tmp + sizeof(kms_obj_keyhead_no_blob_t));
 80287f4:	3314      	adds	r3, #20
 80287f6:	445b      	add	r3, fp
 80287f8:	4698      	mov	r8, r3

    /* Copy Template in blob, size and pValue are reversed, memcpy is impossible */
    for (uint32_t i = 0; i < ulCount1; i++)
 80287fa:	2500      	movs	r5, #0
    offset = 0;
 80287fc:	2700      	movs	r7, #0
 80287fe:	0033      	movs	r3, r6
 8028800:	4646      	mov	r6, r8
 8028802:	4698      	mov	r8, r3
    for (uint32_t i = 0; i < ulCount1; i++)
 8028804:	e018      	b.n	8028838 <KMS_Objects_CreateNStoreBlobFromTemplates+0x134>
    {
      ptr[(3UL * i) + offset] = pTemplate1[i].type;
 8028806:	0068      	lsls	r0, r5, #1
 8028808:	1944      	adds	r4, r0, r5
 802880a:	00a4      	lsls	r4, r4, #2
 802880c:	444c      	add	r4, r9
 802880e:	1940      	adds	r0, r0, r5
 8028810:	19c0      	adds	r0, r0, r7
 8028812:	0083      	lsls	r3, r0, #2
 8028814:	6822      	ldr	r2, [r4, #0]
 8028816:	50f2      	str	r2, [r6, r3]
      ptr[(3UL * i) + 1UL + offset] = pTemplate1[i].ulValueLen;
 8028818:	1c43      	adds	r3, r0, #1
 802881a:	009b      	lsls	r3, r3, #2
 802881c:	68a2      	ldr	r2, [r4, #8]
 802881e:	50f2      	str	r2, [r6, r3]
      (void)memcpy((uint8_t *) & (ptr[(3UL * i) + 2UL + offset]), (uint8_t *)(pTemplate1[i].pValue),
 8028820:	3002      	adds	r0, #2
 8028822:	0080      	lsls	r0, r0, #2
 8028824:	1830      	adds	r0, r6, r0
 8028826:	68a2      	ldr	r2, [r4, #8]
 8028828:	6861      	ldr	r1, [r4, #4]
 802882a:	f00c f97b 	bl	8034b24 <memcpy>
                   pTemplate1[i].ulValueLen);
      offset += (pTemplate1[i].ulValueLen - 1UL) / 4UL;
 802882e:	68a3      	ldr	r3, [r4, #8]
 8028830:	3b01      	subs	r3, #1
 8028832:	089b      	lsrs	r3, r3, #2
 8028834:	18ff      	adds	r7, r7, r3
    for (uint32_t i = 0; i < ulCount1; i++)
 8028836:	3501      	adds	r5, #1
 8028838:	4545      	cmp	r5, r8
 802883a:	d3e4      	bcc.n	8028806 <KMS_Objects_CreateNStoreBlobFromTemplates+0x102>
    }

    /* Object template #2 management when required by the caller */
    if ((ulCount2 != 0UL) && (pTemplate2 != NULL_PTR))
 802883c:	4643      	mov	r3, r8
 802883e:	46b0      	mov	r8, r6
 8028840:	001e      	movs	r6, r3
 8028842:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8028844:	2b00      	cmp	r3, #0
 8028846:	d025      	beq.n	8028894 <KMS_Objects_CreateNStoreBlobFromTemplates+0x190>
 8028848:	4653      	mov	r3, sl
 802884a:	2b00      	cmp	r3, #0
 802884c:	d022      	beq.n	8028894 <KMS_Objects_CreateNStoreBlobFromTemplates+0x190>
    {
      for (uint32_t i = 0; i < ulCount2; i++)
 802884e:	2500      	movs	r5, #0
 8028850:	46b1      	mov	r9, r6
 8028852:	4646      	mov	r6, r8
 8028854:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8028856:	429d      	cmp	r5, r3
 8028858:	d21c      	bcs.n	8028894 <KMS_Objects_CreateNStoreBlobFromTemplates+0x190>
      {
        ptr[(3UL * (i + ulCount1)) + offset] = pTemplate2[i].type;
 802885a:	006c      	lsls	r4, r5, #1
 802885c:	1964      	adds	r4, r4, r5
 802885e:	00a4      	lsls	r4, r4, #2
 8028860:	4454      	add	r4, sl
 8028862:	464b      	mov	r3, r9
 8028864:	18eb      	adds	r3, r5, r3
 8028866:	0058      	lsls	r0, r3, #1
 8028868:	18c0      	adds	r0, r0, r3
 802886a:	19c0      	adds	r0, r0, r7
 802886c:	0083      	lsls	r3, r0, #2
 802886e:	6822      	ldr	r2, [r4, #0]
 8028870:	50f2      	str	r2, [r6, r3]
        ptr[(3UL * (i + ulCount1)) + 1UL + offset] = pTemplate2[i].ulValueLen;
 8028872:	1c43      	adds	r3, r0, #1
 8028874:	009b      	lsls	r3, r3, #2
 8028876:	68a2      	ldr	r2, [r4, #8]
 8028878:	50f2      	str	r2, [r6, r3]
        (void)memcpy((uint8_t *) & (ptr[(3UL * (i + ulCount1)) + 2UL + offset]), (uint8_t *)(pTemplate2[i].pValue),
 802887a:	3002      	adds	r0, #2
 802887c:	0080      	lsls	r0, r0, #2
 802887e:	1830      	adds	r0, r6, r0
 8028880:	68a2      	ldr	r2, [r4, #8]
 8028882:	6861      	ldr	r1, [r4, #4]
 8028884:	f00c f94e 	bl	8034b24 <memcpy>
                     pTemplate2[i].ulValueLen);
        offset += (pTemplate2[i].ulValueLen - 1UL) / 4UL;
 8028888:	68a3      	ldr	r3, [r4, #8]
 802888a:	3b01      	subs	r3, #1
 802888c:	089b      	lsrs	r3, r3, #2
 802888e:	18ff      	adds	r7, r7, r3
      for (uint32_t i = 0; i < ulCount2; i++)
 8028890:	3501      	adds	r5, #1
 8028892:	e7df      	b.n	8028854 <KMS_Objects_CreateNStoreBlobFromTemplates+0x150>
      }
    }

    e_ret_status = KMS_PlatfObjects_AllocateAndStore(p_blob, phObject);
 8028894:	990d      	ldr	r1, [sp, #52]	; 0x34
 8028896:	4658      	mov	r0, fp
 8028898:	f000 f926 	bl	8028ae8 <KMS_PlatfObjects_AllocateAndStore>
 802889c:	0004      	movs	r4, r0
    KMS_Free(hSession, p_blob);
 802889e:	4659      	mov	r1, fp
 80288a0:	9801      	ldr	r0, [sp, #4]
 80288a2:	f7fe ff7f 	bl	80277a4 <KMS_Free>
  }

  return e_ret_status;
}
 80288a6:	0020      	movs	r0, r4
 80288a8:	b003      	add	sp, #12
 80288aa:	bcf0      	pop	{r4, r5, r6, r7}
 80288ac:	46bb      	mov	fp, r7
 80288ae:	46b2      	mov	sl, r6
 80288b0:	46a9      	mov	r9, r5
 80288b2:	46a0      	mov	r8, r4
 80288b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_ARGUMENTS_BAD;
 80288b6:	2407      	movs	r4, #7
 80288b8:	e7f5      	b.n	80288a6 <KMS_Objects_CreateNStoreBlobFromTemplates+0x1a2>
 80288ba:	2407      	movs	r4, #7
 80288bc:	e7f3      	b.n	80288a6 <KMS_Objects_CreateNStoreBlobFromTemplates+0x1a2>
 80288be:	2407      	movs	r4, #7
 80288c0:	e7f1      	b.n	80288a6 <KMS_Objects_CreateNStoreBlobFromTemplates+0x1a2>
 80288c2:	2407      	movs	r4, #7
 80288c4:	e7ef      	b.n	80288a6 <KMS_Objects_CreateNStoreBlobFromTemplates+0x1a2>
    e_ret_status = CKR_DEVICE_MEMORY;
 80288c6:	2431      	movs	r4, #49	; 0x31
 80288c8:	e7ed      	b.n	80288a6 <KMS_Objects_CreateNStoreBlobFromTemplates+0x1a2>
 80288ca:	46c0      	nop			; (mov r8, r8)
 80288cc:	b10b0240 	.word	0xb10b0240
 80288d0:	b10b0003 	.word	0xb10b0003

080288d4 <KMS_Objects_CreateNStoreBlobForAES>:
                                         uint8_t *pKey,
                                         uint32_t keySize,
                                         CK_ATTRIBUTE_PTR pTemplate,
                                         CK_ULONG ulCount,
                                         CK_OBJECT_HANDLE_PTR phObject)
{
 80288d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80288d6:	46c6      	mov	lr, r8
 80288d8:	b500      	push	{lr}
 80288da:	b08c      	sub	sp, #48	; 0x30
 80288dc:	0006      	movs	r6, r0
 80288de:	000d      	movs	r5, r1
 80288e0:	0014      	movs	r4, r2
 80288e2:	001f      	movs	r7, r3
   */
  CK_RV e_ret_status;
  CK_ATTRIBUTE template[3];
  uint32_t *trans_key;

  if ((pKey == NULL_PTR) || (keySize == 0UL) || (phObject == NULL_PTR)
 80288e4:	2900      	cmp	r1, #0
 80288e6:	d03d      	beq.n	8028964 <KMS_Objects_CreateNStoreBlobForAES+0x90>
 80288e8:	2a00      	cmp	r2, #0
 80288ea:	d03d      	beq.n	8028968 <KMS_Objects_CreateNStoreBlobForAES+0x94>
 80288ec:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80288ee:	2b00      	cmp	r3, #0
 80288f0:	d040      	beq.n	8028974 <KMS_Objects_CreateNStoreBlobForAES+0xa0>
      || ((pTemplate == NULL_PTR) && (ulCount != 0UL))
 80288f2:	2f00      	cmp	r7, #0
 80288f4:	d031      	beq.n	802895a <KMS_Objects_CreateNStoreBlobForAES+0x86>
      || ((pTemplate != NULL_PTR) && (ulCount == 0UL)))
 80288f6:	2f00      	cmp	r7, #0
 80288f8:	d002      	beq.n	8028900 <KMS_Objects_CreateNStoreBlobForAES+0x2c>
 80288fa:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80288fc:	2b00      	cmp	r3, #0
 80288fe:	d03b      	beq.n	8028978 <KMS_Objects_CreateNStoreBlobForAES+0xa4>
  {
    e_ret_status = CKR_ARGUMENTS_BAD;
  }
  else
  {
    trans_key = KMS_Alloc(hSession, keySize); /* AES keys shall be multiple of 4 length */
 8028900:	0021      	movs	r1, r4
 8028902:	0030      	movs	r0, r6
 8028904:	f7fe ff28 	bl	8027758 <KMS_Alloc>
 8028908:	4680      	mov	r8, r0
    if (trans_key == NULL_PTR)
 802890a:	2800      	cmp	r0, #0
 802890c:	d036      	beq.n	802897c <KMS_Objects_CreateNStoreBlobForAES+0xa8>
      e_ret_status = CKR_DEVICE_MEMORY;
    }
    else
    {
      /* Convert key from u8 to u32 */
      KMS_Objects_u8ptr_2_BlobU32(pKey, keySize, trans_key);
 802890e:	0002      	movs	r2, r0
 8028910:	0021      	movs	r1, r4
 8028912:	0028      	movs	r0, r5
 8028914:	f7ff fe7e 	bl	8028614 <KMS_Objects_u8ptr_2_BlobU32>
  pTemp->type = Type;
 8028918:	2300      	movs	r3, #0
 802891a:	9303      	str	r3, [sp, #12]
  pTemp->pValue = pValue;
 802891c:	4b18      	ldr	r3, [pc, #96]	; (8028980 <KMS_Objects_CreateNStoreBlobForAES+0xac>)
 802891e:	9304      	str	r3, [sp, #16]
  pTemp->ulValueLen = ulValueLen;
 8028920:	2304      	movs	r3, #4
 8028922:	9305      	str	r3, [sp, #20]
  pTemp->type = Type;
 8028924:	2280      	movs	r2, #128	; 0x80
 8028926:	0052      	lsls	r2, r2, #1
 8028928:	9206      	str	r2, [sp, #24]
  pTemp->pValue = pValue;
 802892a:	4a16      	ldr	r2, [pc, #88]	; (8028984 <KMS_Objects_CreateNStoreBlobForAES+0xb0>)
 802892c:	9207      	str	r2, [sp, #28]
  pTemp->ulValueLen = ulValueLen;
 802892e:	9308      	str	r3, [sp, #32]
  pTemp->type = Type;
 8028930:	330d      	adds	r3, #13
 8028932:	9309      	str	r3, [sp, #36]	; 0x24
  pTemp->pValue = pValue;
 8028934:	4643      	mov	r3, r8
 8028936:	930a      	str	r3, [sp, #40]	; 0x28
  pTemp->ulValueLen = ulValueLen;
 8028938:	940b      	str	r4, [sp, #44]	; 0x2c
      fill_TLV(&(template[0]), CKA_CLASS, (void *)&vCKO_SECRET_KEY, sizeof(CK_OBJECT_CLASS));
      fill_TLV(&(template[1]), CKA_KEY_TYPE, (void *)&vCKK_AES, sizeof(CK_KEY_TYPE));
      fill_TLV(&(template[2]), CKA_VALUE, trans_key, keySize);

      /* Create and store blob object including additional user template */
      e_ret_status = KMS_Objects_CreateNStoreBlobFromTemplates(hSession,
 802893a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 802893c:	9301      	str	r3, [sp, #4]
 802893e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8028940:	9300      	str	r3, [sp, #0]
 8028942:	003b      	movs	r3, r7
 8028944:	2203      	movs	r2, #3
 8028946:	a903      	add	r1, sp, #12
 8028948:	0030      	movs	r0, r6
 802894a:	f7ff fedb 	bl	8028704 <KMS_Objects_CreateNStoreBlobFromTemplates>
 802894e:	0004      	movs	r4, r0
                                                               3,
                                                               pTemplate,
                                                               ulCount,
                                                               phObject);

      KMS_Free(hSession, trans_key);
 8028950:	4641      	mov	r1, r8
 8028952:	0030      	movs	r0, r6
 8028954:	f7fe ff26 	bl	80277a4 <KMS_Free>
 8028958:	e007      	b.n	802896a <KMS_Objects_CreateNStoreBlobForAES+0x96>
      || ((pTemplate == NULL_PTR) && (ulCount != 0UL))
 802895a:	9b12      	ldr	r3, [sp, #72]	; 0x48
 802895c:	2b00      	cmp	r3, #0
 802895e:	d0ca      	beq.n	80288f6 <KMS_Objects_CreateNStoreBlobForAES+0x22>
    e_ret_status = CKR_ARGUMENTS_BAD;
 8028960:	2407      	movs	r4, #7
 8028962:	e002      	b.n	802896a <KMS_Objects_CreateNStoreBlobForAES+0x96>
 8028964:	2407      	movs	r4, #7
 8028966:	e000      	b.n	802896a <KMS_Objects_CreateNStoreBlobForAES+0x96>
 8028968:	2407      	movs	r4, #7
    }
  }
  return e_ret_status;
}
 802896a:	0020      	movs	r0, r4
 802896c:	b00c      	add	sp, #48	; 0x30
 802896e:	bc80      	pop	{r7}
 8028970:	46b8      	mov	r8, r7
 8028972:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e_ret_status = CKR_ARGUMENTS_BAD;
 8028974:	2407      	movs	r4, #7
 8028976:	e7f8      	b.n	802896a <KMS_Objects_CreateNStoreBlobForAES+0x96>
 8028978:	2407      	movs	r4, #7
 802897a:	e7f6      	b.n	802896a <KMS_Objects_CreateNStoreBlobForAES+0x96>
      e_ret_status = CKR_DEVICE_MEMORY;
 802897c:	2431      	movs	r4, #49	; 0x31
  return e_ret_status;
 802897e:	e7f4      	b.n	802896a <KMS_Objects_CreateNStoreBlobForAES+0x96>
 8028980:	2000b054 	.word	0x2000b054
 8028984:	2000b050 	.word	0x2000b050

08028988 <KMS_PlatfObjects_NvmStaticObjectList>:
/**
  * @brief  Update @ref KMS_PlatfObjects_NvmStaticList with NVM contents
  * @retval None
  */
static void KMS_PlatfObjects_NvmStaticObjectList(void)
{
 8028988:	b530      	push	{r4, r5, lr}
 802898a:	b083      	sub	sp, #12
  size_t nvms_data_size;
  kms_obj_keyhead_t *p_nvms_data;

  /* Load the KMS_PlatfObjects_NvmStaticList[], used to store buffer to NVM  */
  /* This should save processing time  */
  for (uint32_t i = KMS_INDEX_MIN_NVM_STATIC_OBJECTS; i <= KMS_INDEX_MAX_NVM_STATIC_OBJECTS; i++)
 802898c:	251e      	movs	r5, #30
 802898e:	e004      	b.n	802899a <KMS_PlatfObjects_NvmStaticObjectList+0x12>
    {
      KMS_PlatfObjects_NvmStaticList[i - KMS_INDEX_MIN_NVM_STATIC_OBJECTS] = p_nvms_data;
    }
    else
    {
      KMS_PlatfObjects_NvmStaticList[i - KMS_INDEX_MIN_NVM_STATIC_OBJECTS] = NULL;
 8028990:	00a4      	lsls	r4, r4, #2
 8028992:	4b0d      	ldr	r3, [pc, #52]	; (80289c8 <KMS_PlatfObjects_NvmStaticObjectList+0x40>)
 8028994:	2200      	movs	r2, #0
 8028996:	50e2      	str	r2, [r4, r3]
  for (uint32_t i = KMS_INDEX_MIN_NVM_STATIC_OBJECTS; i <= KMS_INDEX_MAX_NVM_STATIC_OBJECTS; i++)
 8028998:	3501      	adds	r5, #1
 802899a:	2d31      	cmp	r5, #49	; 0x31
 802899c:	d811      	bhi.n	80289c2 <KMS_PlatfObjects_NvmStaticObjectList+0x3a>
    nvms_rv = NVMS_GET_DATA(i - KMS_INDEX_MIN_NVM_STATIC_OBJECTS, &nvms_data_size, (uint8_t **)(uint32_t)&p_nvms_data);
 802899e:	002c      	movs	r4, r5
 80289a0:	3c1e      	subs	r4, #30
 80289a2:	466b      	mov	r3, sp
 80289a4:	2200      	movs	r2, #0
 80289a6:	a901      	add	r1, sp, #4
 80289a8:	0020      	movs	r0, r4
 80289aa:	f7ff fccd 	bl	8028348 <NVMS_GetDataWithType>
    if ((nvms_data_size != 0UL) && (nvms_rv == NVMS_NOERROR))
 80289ae:	9b01      	ldr	r3, [sp, #4]
 80289b0:	2b00      	cmp	r3, #0
 80289b2:	d0ed      	beq.n	8028990 <KMS_PlatfObjects_NvmStaticObjectList+0x8>
 80289b4:	2800      	cmp	r0, #0
 80289b6:	d1eb      	bne.n	8028990 <KMS_PlatfObjects_NvmStaticObjectList+0x8>
      KMS_PlatfObjects_NvmStaticList[i - KMS_INDEX_MIN_NVM_STATIC_OBJECTS] = p_nvms_data;
 80289b8:	00a4      	lsls	r4, r4, #2
 80289ba:	4b03      	ldr	r3, [pc, #12]	; (80289c8 <KMS_PlatfObjects_NvmStaticObjectList+0x40>)
 80289bc:	9a00      	ldr	r2, [sp, #0]
 80289be:	50e2      	str	r2, [r4, r3]
 80289c0:	e7ea      	b.n	8028998 <KMS_PlatfObjects_NvmStaticObjectList+0x10>
    }
  }
}
 80289c2:	b003      	add	sp, #12
 80289c4:	bd30      	pop	{r4, r5, pc}
 80289c6:	46c0      	nop			; (mov r8, r8)
 80289c8:	2000b8f0 	.word	0x2000b8f0

080289cc <KMS_PlatfObjects_NvmDynamicObjectList>:
/**
  * @brief  Update @ref KMS_PlatfObjects_NvmDynamicList with NVM contents
  * @retval None
  */
static void KMS_PlatfObjects_NvmDynamicObjectList(void)
{
 80289cc:	b510      	push	{r4, lr}
 80289ce:	b082      	sub	sp, #8
  size_t nvms_data_size;
  kms_obj_keyhead_t *p_nvms_data;

  /* Load the KMS_PlatfObjects_NvmDynamicList[], used to store buffer to NVM  */
  /* This should save processing time  */
  for (uint32_t i = KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS; i <= KMS_INDEX_MAX_NVM_DYNAMIC_OBJECTS; i++)
 80289d0:	2432      	movs	r4, #50	; 0x32
 80289d2:	e006      	b.n	80289e2 <KMS_PlatfObjects_NvmDynamicObjectList+0x16>
    {
      KMS_PlatfObjects_NvmDynamicList[i - KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS] = p_nvms_data;
    }
    else
    {
      KMS_PlatfObjects_NvmDynamicList[i - KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS] = NULL;
 80289d4:	0023      	movs	r3, r4
 80289d6:	3b32      	subs	r3, #50	; 0x32
 80289d8:	009b      	lsls	r3, r3, #2
 80289da:	4a0d      	ldr	r2, [pc, #52]	; (8028a10 <KMS_PlatfObjects_NvmDynamicObjectList+0x44>)
 80289dc:	2100      	movs	r1, #0
 80289de:	5099      	str	r1, [r3, r2]
  for (uint32_t i = KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS; i <= KMS_INDEX_MAX_NVM_DYNAMIC_OBJECTS; i++)
 80289e0:	3401      	adds	r4, #1
 80289e2:	2c45      	cmp	r4, #69	; 0x45
 80289e4:	d812      	bhi.n	8028a0c <KMS_PlatfObjects_NvmDynamicObjectList+0x40>
    nvms_rv = NVMS_GET_DATA(i - KMS_INDEX_MIN_NVM_STATIC_OBJECTS, &nvms_data_size, (uint8_t **)(uint32_t)&p_nvms_data);
 80289e6:	466b      	mov	r3, sp
 80289e8:	2200      	movs	r2, #0
 80289ea:	a901      	add	r1, sp, #4
 80289ec:	0020      	movs	r0, r4
 80289ee:	381e      	subs	r0, #30
 80289f0:	f7ff fcaa 	bl	8028348 <NVMS_GetDataWithType>
    if ((nvms_data_size != 0UL) && (nvms_rv == NVMS_NOERROR))
 80289f4:	9b01      	ldr	r3, [sp, #4]
 80289f6:	2b00      	cmp	r3, #0
 80289f8:	d0ec      	beq.n	80289d4 <KMS_PlatfObjects_NvmDynamicObjectList+0x8>
 80289fa:	2800      	cmp	r0, #0
 80289fc:	d1ea      	bne.n	80289d4 <KMS_PlatfObjects_NvmDynamicObjectList+0x8>
      KMS_PlatfObjects_NvmDynamicList[i - KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS] = p_nvms_data;
 80289fe:	0023      	movs	r3, r4
 8028a00:	3b32      	subs	r3, #50	; 0x32
 8028a02:	009b      	lsls	r3, r3, #2
 8028a04:	4a02      	ldr	r2, [pc, #8]	; (8028a10 <KMS_PlatfObjects_NvmDynamicObjectList+0x44>)
 8028a06:	9900      	ldr	r1, [sp, #0]
 8028a08:	5099      	str	r1, [r3, r2]
 8028a0a:	e7e9      	b.n	80289e0 <KMS_PlatfObjects_NvmDynamicObjectList+0x14>
    }

  }
}
 8028a0c:	b002      	add	sp, #8
 8028a0e:	bd10      	pop	{r4, pc}
 8028a10:	2000b8a0 	.word	0x2000b8a0

08028a14 <KMS_PlatfObjects_EmbeddedRange>:
  * @param  pMax Embedded objects max ID
  * @retval None
  */
void KMS_PlatfObjects_EmbeddedRange(uint32_t *pMin, uint32_t *pMax)
{
  *pMin = KMS_INDEX_MIN_EMBEDDED_OBJECTS;
 8028a14:	2301      	movs	r3, #1
 8028a16:	6003      	str	r3, [r0, #0]
  *pMax = KMS_INDEX_MAX_EMBEDDED_OBJECTS;
 8028a18:	331c      	adds	r3, #28
 8028a1a:	600b      	str	r3, [r1, #0]
}
 8028a1c:	4770      	bx	lr
	...

08028a20 <KMS_PlatfObjects_EmbeddedObject>:
  * @param  hKey key handle
  * @retval Corresponding object
  */
kms_obj_keyhead_t *KMS_PlatfObjects_EmbeddedObject(uint32_t hKey)
{
  return (kms_obj_keyhead_t *)(uint32_t)KMS_PlatfObjects_EmbeddedList[hKey - KMS_INDEX_MIN_EMBEDDED_OBJECTS];
 8028a20:	3801      	subs	r0, #1
 8028a22:	0080      	lsls	r0, r0, #2
 8028a24:	4b01      	ldr	r3, [pc, #4]	; (8028a2c <KMS_PlatfObjects_EmbeddedObject+0xc>)
 8028a26:	58c0      	ldr	r0, [r0, r3]
}
 8028a28:	4770      	bx	lr
 8028a2a:	46c0      	nop			; (mov r8, r8)
 8028a2c:	08035098 	.word	0x08035098

08028a30 <KMS_PlatfObjects_NvmStaticRange>:
  * @param  pMax NVM static objects max ID
  * @retval None
  */
void KMS_PlatfObjects_NvmStaticRange(uint32_t *pMin, uint32_t *pMax)
{
  *pMin = KMS_INDEX_MIN_NVM_STATIC_OBJECTS;
 8028a30:	231e      	movs	r3, #30
 8028a32:	6003      	str	r3, [r0, #0]
  *pMax = KMS_INDEX_MAX_NVM_STATIC_OBJECTS;
 8028a34:	3313      	adds	r3, #19
 8028a36:	600b      	str	r3, [r1, #0]
}
 8028a38:	4770      	bx	lr
	...

08028a3c <KMS_PlatfObjects_NvmStaticObject>:
      }
    }
  }
  return p_decrypted_object;
#else /* KMS_ENCRYPT_DECRYPT_BLOB */
  return KMS_PlatfObjects_NvmStaticList[hKey - KMS_INDEX_MIN_NVM_STATIC_OBJECTS];
 8028a3c:	381e      	subs	r0, #30
 8028a3e:	0080      	lsls	r0, r0, #2
 8028a40:	4b01      	ldr	r3, [pc, #4]	; (8028a48 <KMS_PlatfObjects_NvmStaticObject+0xc>)
 8028a42:	58c0      	ldr	r0, [r0, r3]
#endif /* KMS_ENCRYPT_DECRYPT_BLOB */
}
 8028a44:	4770      	bx	lr
 8028a46:	46c0      	nop			; (mov r8, r8)
 8028a48:	2000b8f0 	.word	0x2000b8f0

08028a4c <KMS_PlatfObjects_NvmDynamicRange>:
  * @param  pMax NVM dynamic objects max ID
  * @retval None
  */
void KMS_PlatfObjects_NvmDynamicRange(uint32_t *pMin, uint32_t *pMax)
{
  *pMin = KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS;
 8028a4c:	2332      	movs	r3, #50	; 0x32
 8028a4e:	6003      	str	r3, [r0, #0]
  *pMax = KMS_INDEX_MAX_NVM_DYNAMIC_OBJECTS;
 8028a50:	3313      	adds	r3, #19
 8028a52:	600b      	str	r3, [r1, #0]
}
 8028a54:	4770      	bx	lr
	...

08028a58 <KMS_PlatfObjects_NvmDynamicObject>:
      }
    }
  }
  return p_decrypted_object;
#else /* KMS_ENCRYPT_DECRYPT_BLOB */
  return KMS_PlatfObjects_NvmDynamicList[hKey - KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS];
 8028a58:	3832      	subs	r0, #50	; 0x32
 8028a5a:	0080      	lsls	r0, r0, #2
 8028a5c:	4b01      	ldr	r3, [pc, #4]	; (8028a64 <KMS_PlatfObjects_NvmDynamicObject+0xc>)
 8028a5e:	58c0      	ldr	r0, [r0, r3]
#endif /* KMS_ENCRYPT_DECRYPT_BLOB */
}
 8028a60:	4770      	bx	lr
 8028a62:	46c0      	nop			; (mov r8, r8)
 8028a64:	2000b8a0 	.word	0x2000b8a0

08028a68 <KMS_PlatfObjects_Init>:
  * @brief  Initialize platform objects
  * @note   Initialize NVM / VM storage and fill "cache" buffers
  * @retval None
  */
void KMS_PlatfObjects_Init(void)
{
 8028a68:	b510      	push	{r4, lr}
#ifdef KMS_NVM_ENABLED
  /* The NVMS_Init should be done only once */
  if (kms_platf_nvm_initialisation_done == 0UL)
 8028a6a:	4b07      	ldr	r3, [pc, #28]	; (8028a88 <KMS_PlatfObjects_Init+0x20>)
 8028a6c:	681b      	ldr	r3, [r3, #0]
 8028a6e:	2b00      	cmp	r3, #0
 8028a70:	d004      	beq.n	8028a7c <KMS_PlatfObjects_Init+0x14>
    /* Initialize the NVMS */
    (void)NVMS_Init();
    kms_platf_nvm_initialisation_done = 1UL;
  }

  KMS_PlatfObjects_NvmStaticObjectList();
 8028a72:	f7ff ff89 	bl	8028988 <KMS_PlatfObjects_NvmStaticObjectList>
#ifdef KMS_NVM_DYNAMIC_ENABLED
  KMS_PlatfObjects_NvmDynamicObjectList();
 8028a76:	f7ff ffa9 	bl	80289cc <KMS_PlatfObjects_NvmDynamicObjectList>
    kms_platf_vm_initialisation_done = 1UL;
  }

  KMS_PlatfObjects_VmDynamicObjectList();
#endif /* KMS_VM_DYNAMIC_ENABLED */
}
 8028a7a:	bd10      	pop	{r4, pc}
    (void)NVMS_Init();
 8028a7c:	f7ff fba0 	bl	80281c0 <NVMS_Init>
    kms_platf_nvm_initialisation_done = 1UL;
 8028a80:	4b01      	ldr	r3, [pc, #4]	; (8028a88 <KMS_PlatfObjects_Init+0x20>)
 8028a82:	2201      	movs	r2, #1
 8028a84:	601a      	str	r2, [r3, #0]
 8028a86:	e7f4      	b.n	8028a72 <KMS_PlatfObjects_Init+0xa>
 8028a88:	2000b940 	.word	0x2000b940

08028a8c <KMS_PlatfObjects_Finalize>:
/**
  * @brief  De-Initialize platform objects
  * @retval None
  */
void KMS_PlatfObjects_Finalize(void)
{
 8028a8c:	b510      	push	{r4, lr}
#ifdef KMS_NVM_ENABLED
  /* Finalize the NVMS */
  NVMS_Deinit();
 8028a8e:	f7ff fba9 	bl	80281e4 <NVMS_Deinit>

  /* We must re-allow the call to NVMS_Init() */
  kms_platf_nvm_initialisation_done = 0UL;
 8028a92:	4b02      	ldr	r3, [pc, #8]	; (8028a9c <KMS_PlatfObjects_Finalize+0x10>)
 8028a94:	2200      	movs	r2, #0
 8028a96:	601a      	str	r2, [r3, #0]
  VMS_Deinit();

  /* We must re-allow the call to VMS_Init() */
  kms_platf_vm_initialisation_done = 0UL;
#endif /* KMS_VM_DYNAMIC_ENABLED */
}
 8028a98:	bd10      	pop	{r4, pc}
 8028a9a:	46c0      	nop			; (mov r8, r8)
 8028a9c:	2000b940 	.word	0x2000b940

08028aa0 <KMS_PlatfObjects_NvmStoreObject>:
  * @param  ObjectSize Object size
  * @retval CKR_OK if storage is successful
  *         CKR_DEVICE_MEMORY otherwise
  */
CK_RV KMS_PlatfObjects_NvmStoreObject(uint32_t ObjectId, uint8_t *pObjectToAdd,  uint32_t ObjectSize)
{
 8028aa0:	b510      	push	{r4, lr}
 8028aa2:	0004      	movs	r4, r0
 8028aa4:	000b      	movs	r3, r1
 8028aa6:	0011      	movs	r1, r2
    return e_ret_status;
  }
#endif /* KMS_ENCRYPT_DECRYPT_BLOB */

  /* It's a NVM STATIC object */
  if ((ObjectId >= KMS_INDEX_MIN_NVM_STATIC_OBJECTS) && (ObjectId <= KMS_INDEX_MAX_NVM_STATIC_OBJECTS))
 8028aa8:	381e      	subs	r0, #30
 8028aaa:	2813      	cmp	r0, #19
 8028aac:	d90c      	bls.n	8028ac8 <KMS_PlatfObjects_NvmStoreObject+0x28>
  }
  else
  {
#ifdef KMS_NVM_DYNAMIC_ENABLED
    /* It's a NVM DYNAMIC object */
    if ((ObjectId >= KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS) && (ObjectId <= KMS_INDEX_MAX_NVM_DYNAMIC_OBJECTS))
 8028aae:	3c32      	subs	r4, #50	; 0x32
 8028ab0:	2c13      	cmp	r4, #19
 8028ab2:	d911      	bls.n	8028ad8 <KMS_PlatfObjects_NvmStoreObject+0x38>
    {
      rv = NVMS_WRITE_DATA(ObjectId - KMS_INDEX_MIN_NVM_STATIC_OBJECTS, ObjectSize, (const uint8_t *)pObjectToAdd);
    }
    else
    {
      rv = NVMS_SLOT_INVALID;
 8028ab4:	2004      	movs	r0, #4
  /* Free the allocated object when needed */
  KMS_PlatfObjects_FreeObject(KMS_SESSION_ID_INTERNAL | ObjectId,
                                 &p_encrypted_object);
#endif /* KMS_ENCRYPT_DECRYPT_BLOB */
  /* A Garbage collection generate a WARNING ==> Not an error */
  if ((rv == NVMS_NOERROR) || (rv == NVMS_WARNING))
 8028ab6:	2802      	cmp	r0, #2
 8028ab8:	d013      	beq.n	8028ae2 <KMS_PlatfObjects_NvmStoreObject+0x42>
  {
    e_ret_status = CKR_OK;
  }
  else
  {
    e_ret_status = CKR_DEVICE_MEMORY;
 8028aba:	2431      	movs	r4, #49	; 0x31
  }

  /* Refresh NVM lists */
  KMS_PlatfObjects_NvmStaticObjectList();
 8028abc:	f7ff ff64 	bl	8028988 <KMS_PlatfObjects_NvmStaticObjectList>
#ifdef KMS_NVM_DYNAMIC_ENABLED
  KMS_PlatfObjects_NvmDynamicObjectList();
 8028ac0:	f7ff ff84 	bl	80289cc <KMS_PlatfObjects_NvmDynamicObjectList>
#endif /* KMS_NVM_DYNAMIC_ENABLED */

  return e_ret_status;
}
 8028ac4:	0020      	movs	r0, r4
 8028ac6:	bd10      	pop	{r4, pc}
    rv = NVMS_WRITE_DATA(ObjectId - KMS_INDEX_MIN_NVM_STATIC_OBJECTS, ObjectSize, (const uint8_t *)pObjectToAdd);
 8028ac8:	2201      	movs	r2, #1
 8028aca:	4252      	negs	r2, r2
 8028acc:	f7ff fb8e 	bl	80281ec <NVMS_WriteDataWithType>
  if ((rv == NVMS_NOERROR) || (rv == NVMS_WARNING))
 8028ad0:	2800      	cmp	r0, #0
 8028ad2:	d1f0      	bne.n	8028ab6 <KMS_PlatfObjects_NvmStoreObject+0x16>
    e_ret_status = CKR_OK;
 8028ad4:	2400      	movs	r4, #0
 8028ad6:	e7f1      	b.n	8028abc <KMS_PlatfObjects_NvmStoreObject+0x1c>
      rv = NVMS_WRITE_DATA(ObjectId - KMS_INDEX_MIN_NVM_STATIC_OBJECTS, ObjectSize, (const uint8_t *)pObjectToAdd);
 8028ad8:	2201      	movs	r2, #1
 8028ada:	4252      	negs	r2, r2
 8028adc:	f7ff fb86 	bl	80281ec <NVMS_WriteDataWithType>
 8028ae0:	e7f6      	b.n	8028ad0 <KMS_PlatfObjects_NvmStoreObject+0x30>
    e_ret_status = CKR_OK;
 8028ae2:	2400      	movs	r4, #0
 8028ae4:	e7ea      	b.n	8028abc <KMS_PlatfObjects_NvmStoreObject+0x1c>
	...

08028ae8 <KMS_PlatfObjects_AllocateAndStore>:
{
 8028ae8:	b570      	push	{r4, r5, r6, lr}
 8028aea:	0006      	movs	r6, r0
 8028aec:	1e0d      	subs	r5, r1, #0
  if ((pObjId == NULL_PTR) || (pBlob == NULL_PTR))
 8028aee:	d01e      	beq.n	8028b2e <KMS_PlatfObjects_AllocateAndStore+0x46>
 8028af0:	2800      	cmp	r0, #0
 8028af2:	d01e      	beq.n	8028b32 <KMS_PlatfObjects_AllocateAndStore+0x4a>
    *pObjId = KMS_HANDLE_KEY_NOT_KNOWN;
 8028af4:	2300      	movs	r3, #0
 8028af6:	600b      	str	r3, [r1, #0]
    for (Index = 0; Index <= (KMS_INDEX_MAX_NVM_DYNAMIC_OBJECTS - KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS); Index++)
 8028af8:	e000      	b.n	8028afc <KMS_PlatfObjects_AllocateAndStore+0x14>
 8028afa:	3301      	adds	r3, #1
 8028afc:	2b13      	cmp	r3, #19
 8028afe:	d806      	bhi.n	8028b0e <KMS_PlatfObjects_AllocateAndStore+0x26>
      if (KMS_PlatfObjects_NvmDynamicList[Index] == NULL)
 8028b00:	009a      	lsls	r2, r3, #2
 8028b02:	4c0d      	ldr	r4, [pc, #52]	; (8028b38 <KMS_PlatfObjects_AllocateAndStore+0x50>)
 8028b04:	5912      	ldr	r2, [r2, r4]
 8028b06:	2a00      	cmp	r2, #0
 8028b08:	d1f7      	bne.n	8028afa <KMS_PlatfObjects_AllocateAndStore+0x12>
        *pObjId = Index + KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS;
 8028b0a:	3332      	adds	r3, #50	; 0x32
 8028b0c:	602b      	str	r3, [r5, #0]
    if (*pObjId == KMS_HANDLE_KEY_NOT_KNOWN)
 8028b0e:	6828      	ldr	r0, [r5, #0]
 8028b10:	2800      	cmp	r0, #0
 8028b12:	d101      	bne.n	8028b18 <KMS_PlatfObjects_AllocateAndStore+0x30>
      e_ret_status = CKR_DEVICE_MEMORY;
 8028b14:	2031      	movs	r0, #49	; 0x31
}
 8028b16:	bd70      	pop	{r4, r5, r6, pc}
      pBlob->object_id = *pObjId;
 8028b18:	6130      	str	r0, [r6, #16]
      e_ret_status = KMS_PlatfObjects_NvmStoreObject(*pObjId,
 8028b1a:	68b2      	ldr	r2, [r6, #8]
 8028b1c:	3214      	adds	r2, #20
 8028b1e:	0031      	movs	r1, r6
 8028b20:	f7ff ffbe 	bl	8028aa0 <KMS_PlatfObjects_NvmStoreObject>
      if (e_ret_status != CKR_OK)
 8028b24:	2800      	cmp	r0, #0
 8028b26:	d0f6      	beq.n	8028b16 <KMS_PlatfObjects_AllocateAndStore+0x2e>
        *pObjId = KMS_HANDLE_KEY_NOT_KNOWN;
 8028b28:	2300      	movs	r3, #0
 8028b2a:	602b      	str	r3, [r5, #0]
 8028b2c:	e7f3      	b.n	8028b16 <KMS_PlatfObjects_AllocateAndStore+0x2e>
    e_ret_status = CKR_ARGUMENTS_BAD;
 8028b2e:	2007      	movs	r0, #7
 8028b30:	e7f1      	b.n	8028b16 <KMS_PlatfObjects_AllocateAndStore+0x2e>
 8028b32:	2007      	movs	r0, #7
 8028b34:	e7ef      	b.n	8028b16 <KMS_PlatfObjects_AllocateAndStore+0x2e>
 8028b36:	46c0      	nop			; (mov r8, r8)
 8028b38:	2000b8a0 	.word	0x2000b8a0

08028b3c <KMS_PlatfObjects_NvmRemoveObject>:
  * @param  ObjectId Object ID
  * @retval CKR_OK if removal is successful
  *         CKR_DEVICE_MEMORY otherwise
  */
CK_RV KMS_PlatfObjects_NvmRemoveObject(uint32_t ObjectId)
{
 8028b3c:	b510      	push	{r4, lr}
  nvms_error_t rv = NVMS_DATA_NOT_FOUND;
  CK_RV e_ret_status;

  /* Check that the ObjectID is in dynamic range */
  if ((ObjectId >= KMS_INDEX_MIN_NVM_DYNAMIC_OBJECTS) && (ObjectId <= KMS_INDEX_MAX_NVM_DYNAMIC_OBJECTS))
 8028b3e:	0003      	movs	r3, r0
 8028b40:	3b32      	subs	r3, #50	; 0x32
 8028b42:	2b13      	cmp	r3, #19
 8028b44:	d909      	bls.n	8028b5a <KMS_PlatfObjects_NvmRemoveObject+0x1e>
  nvms_error_t rv = NVMS_DATA_NOT_FOUND;
 8028b46:	2005      	movs	r0, #5
  {
    rv = NVMS_EraseData(ObjectId - KMS_INDEX_MIN_NVM_STATIC_OBJECTS);
  }
  /* A Garbage collection generate a WARNING ==> Not an error */
  if ((rv == NVMS_NOERROR) || (rv == NVMS_WARNING))
 8028b48:	2802      	cmp	r0, #2
 8028b4a:	d00d      	beq.n	8028b68 <KMS_PlatfObjects_NvmRemoveObject+0x2c>
  {
    e_ret_status = CKR_OK;
  }
  else
  {
    e_ret_status = CKR_DEVICE_MEMORY;
 8028b4c:	2431      	movs	r4, #49	; 0x31
  }

  /* Refresh NVM lists */
  KMS_PlatfObjects_NvmStaticObjectList();
 8028b4e:	f7ff ff1b 	bl	8028988 <KMS_PlatfObjects_NvmStaticObjectList>
#ifdef KMS_NVM_DYNAMIC_ENABLED
  KMS_PlatfObjects_NvmDynamicObjectList();
 8028b52:	f7ff ff3b 	bl	80289cc <KMS_PlatfObjects_NvmDynamicObjectList>
#endif /* KMS_NVM_DYNAMIC_ENABLED */

  return e_ret_status;
}
 8028b56:	0020      	movs	r0, r4
 8028b58:	bd10      	pop	{r4, pc}
    rv = NVMS_EraseData(ObjectId - KMS_INDEX_MIN_NVM_STATIC_OBJECTS);
 8028b5a:	381e      	subs	r0, #30
 8028b5c:	f7ff fba6 	bl	80282ac <NVMS_EraseData>
  if ((rv == NVMS_NOERROR) || (rv == NVMS_WARNING))
 8028b60:	2800      	cmp	r0, #0
 8028b62:	d1f1      	bne.n	8028b48 <KMS_PlatfObjects_NvmRemoveObject+0xc>
    e_ret_status = CKR_OK;
 8028b64:	2400      	movs	r4, #0
 8028b66:	e7f2      	b.n	8028b4e <KMS_PlatfObjects_NvmRemoveObject+0x12>
 8028b68:	2400      	movs	r4, #0
 8028b6a:	e7f0      	b.n	8028b4e <KMS_PlatfObjects_NvmRemoveObject+0x12>

08028b6c <sign_verify_init>:
  */
CK_RV     sign_verify_init(CK_SESSION_HANDLE hSession,
                           CK_MECHANISM_PTR  pMechanism,
                           CK_OBJECT_HANDLE  hKey,
                           uint32_t sigver_flag)
{
 8028b6c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8028b6e:	46d6      	mov	lr, sl
 8028b70:	b500      	push	{lr}
 8028b72:	b084      	sub	sp, #16
 8028b74:	0004      	movs	r4, r0
 8028b76:	000d      	movs	r5, r1
 8028b78:	9200      	str	r2, [sp, #0]
 8028b7a:	9301      	str	r3, [sp, #4]
  CK_RV e_ret_status = CKR_MECHANISM_INVALID;

  if (!KMS_IS_INITIALIZED())
 8028b7c:	4b62      	ldr	r3, [pc, #392]	; (8028d08 <sign_verify_init+0x19c>)
 8028b7e:	781b      	ldrb	r3, [r3, #0]
 8028b80:	2b00      	cmp	r3, #0
 8028b82:	d100      	bne.n	8028b86 <sign_verify_init+0x1a>
 8028b84:	e0b3      	b.n	8028cee <sign_verify_init+0x182>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 8028b86:	f7fe fc91 	bl	80274ac <KMS_CheckSessionHdle>
 8028b8a:	2800      	cmp	r0, #0
 8028b8c:	d000      	beq.n	8028b90 <sign_verify_init+0x24>
 8028b8e:	e0b5      	b.n	8028cfc <sign_verify_init+0x190>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_IDLE)
 8028b90:	1e66      	subs	r6, r4, #1
 8028b92:	00f3      	lsls	r3, r6, #3
 8028b94:	199b      	adds	r3, r3, r6
 8028b96:	009b      	lsls	r3, r3, #2
 8028b98:	4a5b      	ldr	r2, [pc, #364]	; (8028d08 <sign_verify_init+0x19c>)
 8028b9a:	18d3      	adds	r3, r2, r3
 8028b9c:	68db      	ldr	r3, [r3, #12]
 8028b9e:	2b00      	cmp	r3, #0
 8028ba0:	d000      	beq.n	8028ba4 <sign_verify_init+0x38>
 8028ba2:	e0ad      	b.n	8028d00 <sign_verify_init+0x194>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }

  /* Check that we support the expected mechanism  */
  if (pMechanism == NULL_PTR)
 8028ba4:	2d00      	cmp	r5, #0
 8028ba6:	d100      	bne.n	8028baa <sign_verify_init+0x3e>
 8028ba8:	e0ac      	b.n	8028d04 <sign_verify_init+0x198>
  {
    return CKR_ARGUMENTS_BAD;
  }
  switch (pMechanism->mechanism)
 8028baa:	682b      	ldr	r3, [r5, #0]
 8028bac:	4a57      	ldr	r2, [pc, #348]	; (8028d0c <sign_verify_init+0x1a0>)
 8028bae:	4694      	mov	ip, r2
 8028bb0:	4463      	add	r3, ip
 8028bb2:	2b01      	cmp	r3, #1
 8028bb4:	d901      	bls.n	8028bba <sign_verify_init+0x4e>
  CK_RV e_ret_status = CKR_MECHANISM_INVALID;
 8028bb6:	2770      	movs	r7, #112	; 0x70
 8028bb8:	e09b      	b.n	8028cf2 <sign_verify_init+0x186>
      kms_attr_t *P_pKeyAttribute;
      kms_aes_cmac_sv_ctx_t *p_ctx;

      /* Read the key value from the Key Handle                 */
      /* Key Handle is the index to one of static or nvm        */
      pkms_object = KMS_Objects_GetPointer(hKey);
 8028bba:	9800      	ldr	r0, [sp, #0]
 8028bbc:	f7ff fc20 	bl	8028400 <KMS_Objects_GetPointer>

      /* Check that hKey is valid:
       * - NULL_PTR value means not found key handle
       * - KMS_ABI_VERSION_CK_2_40 & KMS_ABI_CONFIG_KEYHEAD are magic in header of the key
       */
      if ((pkms_object != NULL) &&
 8028bc0:	2800      	cmp	r0, #0
 8028bc2:	d100      	bne.n	8028bc6 <sign_verify_init+0x5a>
 8028bc4:	e08f      	b.n	8028ce6 <sign_verify_init+0x17a>
 8028bc6:	4b52      	ldr	r3, [pc, #328]	; (8028d10 <sign_verify_init+0x1a4>)
 8028bc8:	6802      	ldr	r2, [r0, #0]
 8028bca:	429a      	cmp	r2, r3
 8028bcc:	d001      	beq.n	8028bd2 <sign_verify_init+0x66>
        }
      }
      else
      {
        /* Can not retrieve proper key handle */
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8028bce:	2782      	movs	r7, #130	; 0x82
 8028bd0:	e08f      	b.n	8028cf2 <sign_verify_init+0x186>
          (pkms_object->version == KMS_ABI_VERSION_CK_2_40) &&
 8028bd2:	4b50      	ldr	r3, [pc, #320]	; (8028d14 <sign_verify_init+0x1a8>)
 8028bd4:	6842      	ldr	r2, [r0, #4]
 8028bd6:	429a      	cmp	r2, r3
 8028bd8:	d001      	beq.n	8028bde <sign_verify_init+0x72>
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8028bda:	2782      	movs	r7, #130	; 0x82
 8028bdc:	e089      	b.n	8028cf2 <sign_verify_init+0x186>
        e_ret_status = KMS_Objects_SearchAttributes(CKA_VALUE, pkms_object, &P_pKeyAttribute);
 8028bde:	aa03      	add	r2, sp, #12
 8028be0:	0001      	movs	r1, r0
 8028be2:	2011      	movs	r0, #17
 8028be4:	f7ff fc69 	bl	80284ba <KMS_Objects_SearchAttributes>
 8028be8:	1e07      	subs	r7, r0, #0
        if (e_ret_status == CKR_OK)
 8028bea:	d000      	beq.n	8028bee <sign_verify_init+0x82>
 8028bec:	e081      	b.n	8028cf2 <sign_verify_init+0x186>
          if ((P_pKeyAttribute->size == CA_CRL_AES128_KEY) ||     /* 128 bits */
 8028bee:	9b03      	ldr	r3, [sp, #12]
 8028bf0:	685b      	ldr	r3, [r3, #4]
 8028bf2:	2b10      	cmp	r3, #16
 8028bf4:	d005      	beq.n	8028c02 <sign_verify_init+0x96>
 8028bf6:	2b18      	cmp	r3, #24
 8028bf8:	d003      	beq.n	8028c02 <sign_verify_init+0x96>
              (P_pKeyAttribute->size == CA_CRL_AES192_KEY) ||     /* 192 bits */
 8028bfa:	2b20      	cmp	r3, #32
 8028bfc:	d001      	beq.n	8028c02 <sign_verify_init+0x96>
            e_ret_status = CKR_ARGUMENTS_BAD;
 8028bfe:	2707      	movs	r7, #7
 8028c00:	e077      	b.n	8028cf2 <sign_verify_init+0x186>
            p_ctx = KMS_Alloc(hSession, sizeof(kms_aes_cmac_sv_ctx_t));
 8028c02:	2178      	movs	r1, #120	; 0x78
 8028c04:	0020      	movs	r0, r4
 8028c06:	f7fe fda7 	bl	8027758 <KMS_Alloc>
 8028c0a:	4682      	mov	sl, r0
            if (p_ctx == NULL_PTR)
 8028c0c:	2800      	cmp	r0, #0
 8028c0e:	d06c      	beq.n	8028cea <sign_verify_init+0x17e>
            KMS_GETSESSION(hSession).hKey = hKey;
 8028c10:	00f3      	lsls	r3, r6, #3
 8028c12:	199b      	adds	r3, r3, r6
 8028c14:	009a      	lsls	r2, r3, #2
 8028c16:	4b3c      	ldr	r3, [pc, #240]	; (8028d08 <sign_verify_init+0x19c>)
 8028c18:	189b      	adds	r3, r3, r2
 8028c1a:	9a00      	ldr	r2, [sp, #0]
 8028c1c:	625a      	str	r2, [r3, #36]	; 0x24
            KMS_GETSESSION(hSession).Mechanism = pMechanism->mechanism;
 8028c1e:	682a      	ldr	r2, [r5, #0]
 8028c20:	621a      	str	r2, [r3, #32]
            KMS_GETSESSION(hSession).pCtx = p_ctx;
 8028c22:	6298      	str	r0, [r3, #40]	; 0x28
            if ((pMechanism->mechanism == CKM_AES_CMAC_GENERAL)
 8028c24:	682b      	ldr	r3, [r5, #0]
 8028c26:	4a3c      	ldr	r2, [pc, #240]	; (8028d18 <sign_verify_init+0x1ac>)
 8028c28:	4293      	cmp	r3, r2
 8028c2a:	d021      	beq.n	8028c70 <sign_verify_init+0x104>
            else if ((pMechanism->mechanism == CKM_AES_CMAC_GENERAL)
 8028c2c:	4a3a      	ldr	r2, [pc, #232]	; (8028d18 <sign_verify_init+0x1ac>)
 8028c2e:	4293      	cmp	r3, r2
 8028c30:	d024      	beq.n	8028c7c <sign_verify_init+0x110>
              p_ctx->tagLength = CA_CRL_AES_BLOCK;
 8028c32:	2310      	movs	r3, #16
 8028c34:	4652      	mov	r2, sl
 8028c36:	6313      	str	r3, [r2, #48]	; 0x30
            p_ctx->ca_ctx.mFlags = CA_E_SK_DEFAULT;
 8028c38:	2338      	movs	r3, #56	; 0x38
 8028c3a:	2200      	movs	r2, #0
 8028c3c:	4651      	mov	r1, sl
 8028c3e:	54ca      	strb	r2, [r1, r3]
            p_ctx->ca_ctx.mKeySize = (int32_t)P_pKeyAttribute->size ;
 8028c40:	9803      	ldr	r0, [sp, #12]
 8028c42:	6842      	ldr	r2, [r0, #4]
 8028c44:	658a      	str	r2, [r1, #88]	; 0x58
            KMS_Objects_BlobU32_2_u8ptr(&(P_pKeyAttribute->data[0]), P_pKeyAttribute->size, p_ctx->key);
 8028c46:	6841      	ldr	r1, [r0, #4]
 8028c48:	3008      	adds	r0, #8
 8028c4a:	4652      	mov	r2, sl
 8028c4c:	f7ff fd1c 	bl	8028688 <KMS_Objects_BlobU32_2_u8ptr>
            p_ctx->ca_ctx.pmKey = p_ctx->key;
 8028c50:	4653      	mov	r3, sl
 8028c52:	63db      	str	r3, [r3, #60]	; 0x3c
            p_ctx->ca_ctx.mTagSize = (int32_t)p_ctx->tagLength;
 8028c54:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8028c56:	665a      	str	r2, [r3, #100]	; 0x64
            p_ctx->ca_ctx.pmTag = p_ctx->tag;
 8028c58:	3320      	adds	r3, #32
 8028c5a:	4652      	mov	r2, sl
 8028c5c:	6613      	str	r3, [r2, #96]	; 0x60
            if (sigver_flag == KMS_FLAG_SIGN)
 8028c5e:	9b01      	ldr	r3, [sp, #4]
 8028c60:	2b00      	cmp	r3, #0
 8028c62:	d01a      	beq.n	8028c9a <sign_verify_init+0x12e>
        e_ret_status = KMS_Objects_SearchAttributes(CKA_VALUE, pkms_object, &P_pKeyAttribute);
 8028c64:	003b      	movs	r3, r7
            if (sigver_flag == KMS_FLAG_VERIFY)
 8028c66:	9a01      	ldr	r2, [sp, #4]
 8028c68:	2a01      	cmp	r2, #1
 8028c6a:	d02a      	beq.n	8028cc2 <sign_verify_init+0x156>
 8028c6c:	001f      	movs	r7, r3
 8028c6e:	e040      	b.n	8028cf2 <sign_verify_init+0x186>
                && (pMechanism->pParameter != NULL_PTR))
 8028c70:	686a      	ldr	r2, [r5, #4]
 8028c72:	2a00      	cmp	r2, #0
 8028c74:	d0da      	beq.n	8028c2c <sign_verify_init+0xc0>
              p_ctx->tagLength = *(CK_ULONG_PTR)pMechanism->pParameter;
 8028c76:	6812      	ldr	r2, [r2, #0]
 8028c78:	6302      	str	r2, [r0, #48]	; 0x30
 8028c7a:	e7dd      	b.n	8028c38 <sign_verify_init+0xcc>
                     && (pMechanism->pParameter == NULL_PTR))
 8028c7c:	686b      	ldr	r3, [r5, #4]
 8028c7e:	2b00      	cmp	r3, #0
 8028c80:	d1d7      	bne.n	8028c32 <sign_verify_init+0xc6>
              KMS_Free(hSession, p_ctx);
 8028c82:	4651      	mov	r1, sl
 8028c84:	0020      	movs	r0, r4
 8028c86:	f7fe fd8d 	bl	80277a4 <KMS_Free>
              KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8028c8a:	2324      	movs	r3, #36	; 0x24
 8028c8c:	435e      	muls	r6, r3
 8028c8e:	4b1e      	ldr	r3, [pc, #120]	; (8028d08 <sign_verify_init+0x19c>)
 8028c90:	199b      	adds	r3, r3, r6
 8028c92:	2200      	movs	r2, #0
 8028c94:	629a      	str	r2, [r3, #40]	; 0x28
              e_ret_status = CKR_ARGUMENTS_BAD;
 8028c96:	2707      	movs	r7, #7
              break;
 8028c98:	e02b      	b.n	8028cf2 <sign_verify_init+0x186>
              if (CA_AES_CMAC_Encrypt_Init(&p_ctx->ca_ctx) == CA_AES_SUCCESS)
 8028c9a:	4650      	mov	r0, sl
 8028c9c:	3034      	adds	r0, #52	; 0x34
 8028c9e:	f7fd f9f1 	bl	8026084 <CA_AES_CMAC_Encrypt_Init>
 8028ca2:	2800      	cmp	r0, #0
 8028ca4:	d101      	bne.n	8028caa <sign_verify_init+0x13e>
                e_ret_status = CKR_OK;
 8028ca6:	9b01      	ldr	r3, [sp, #4]
 8028ca8:	e7dd      	b.n	8028c66 <sign_verify_init+0xfa>
                KMS_Free(hSession, p_ctx);
 8028caa:	4651      	mov	r1, sl
 8028cac:	0020      	movs	r0, r4
 8028cae:	f7fe fd79 	bl	80277a4 <KMS_Free>
                KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8028cb2:	2224      	movs	r2, #36	; 0x24
 8028cb4:	4372      	muls	r2, r6
 8028cb6:	4b14      	ldr	r3, [pc, #80]	; (8028d08 <sign_verify_init+0x19c>)
 8028cb8:	189b      	adds	r3, r3, r2
 8028cba:	2200      	movs	r2, #0
 8028cbc:	629a      	str	r2, [r3, #40]	; 0x28
                e_ret_status = CKR_FUNCTION_FAILED;
 8028cbe:	2306      	movs	r3, #6
 8028cc0:	e7d1      	b.n	8028c66 <sign_verify_init+0xfa>
              if (CA_AES_CMAC_Decrypt_Init(&p_ctx->ca_ctx) == CA_AES_SUCCESS)
 8028cc2:	4650      	mov	r0, sl
 8028cc4:	3034      	adds	r0, #52	; 0x34
 8028cc6:	f7fd fa3b 	bl	8026140 <CA_AES_CMAC_Decrypt_Init>
 8028cca:	2800      	cmp	r0, #0
 8028ccc:	d011      	beq.n	8028cf2 <sign_verify_init+0x186>
                KMS_Free(hSession, p_ctx);
 8028cce:	4651      	mov	r1, sl
 8028cd0:	0020      	movs	r0, r4
 8028cd2:	f7fe fd67 	bl	80277a4 <KMS_Free>
                KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8028cd6:	2224      	movs	r2, #36	; 0x24
 8028cd8:	4372      	muls	r2, r6
 8028cda:	4b0b      	ldr	r3, [pc, #44]	; (8028d08 <sign_verify_init+0x19c>)
 8028cdc:	189b      	adds	r3, r3, r2
 8028cde:	2200      	movs	r2, #0
 8028ce0:	629a      	str	r2, [r3, #40]	; 0x28
                e_ret_status = CKR_FUNCTION_FAILED;
 8028ce2:	2706      	movs	r7, #6
 8028ce4:	e005      	b.n	8028cf2 <sign_verify_init+0x186>
        e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8028ce6:	2782      	movs	r7, #130	; 0x82
 8028ce8:	e003      	b.n	8028cf2 <sign_verify_init+0x186>
              e_ret_status = CKR_DEVICE_MEMORY;
 8028cea:	2731      	movs	r7, #49	; 0x31
 8028cec:	e001      	b.n	8028cf2 <sign_verify_init+0x186>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8028cee:	27c8      	movs	r7, #200	; 0xc8
 8028cf0:	007f      	lsls	r7, r7, #1
    default:
      break;
  }

  return e_ret_status;
}
 8028cf2:	0038      	movs	r0, r7
 8028cf4:	b004      	add	sp, #16
 8028cf6:	bc80      	pop	{r7}
 8028cf8:	46ba      	mov	sl, r7
 8028cfa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8028cfc:	27b3      	movs	r7, #179	; 0xb3
 8028cfe:	e7f8      	b.n	8028cf2 <sign_verify_init+0x186>
    return CKR_SESSION_HANDLE_INVALID;
 8028d00:	27b3      	movs	r7, #179	; 0xb3
 8028d02:	e7f6      	b.n	8028cf2 <sign_verify_init+0x186>
    return CKR_ARGUMENTS_BAD;
 8028d04:	2707      	movs	r7, #7
 8028d06:	e7f4      	b.n	8028cf2 <sign_verify_init+0x186>
 8028d08:	2000b300 	.word	0x2000b300
 8028d0c:	ffffef76 	.word	0xffffef76
 8028d10:	b10b0240 	.word	0xb10b0240
 8028d14:	b10b0003 	.word	0xb10b0003
 8028d18:	0000108b 	.word	0x0000108b

08028d1c <KMS_SignInit>:
  *         @ref sign_verify_init returned values
  */
CK_RV     KMS_SignInit(CK_SESSION_HANDLE hSession,
                       CK_MECHANISM_PTR  pMechanism,
                       CK_OBJECT_HANDLE  hKey)
{
 8028d1c:	b510      	push	{r4, lr}
 8028d1e:	0004      	movs	r4, r0
#if defined(KMS_SIGN)
  CK_RV e_ret_status = sign_verify_init(hSession, pMechanism, hKey, KMS_FLAG_SIGN);
 8028d20:	2300      	movs	r3, #0
 8028d22:	f7ff ff23 	bl	8028b6c <sign_verify_init>

  if (e_ret_status == CKR_OK)
 8028d26:	2800      	cmp	r0, #0
 8028d28:	d107      	bne.n	8028d3a <KMS_SignInit+0x1e>
  {
    /* If successful, set processing state of the session */
    KMS_GETSESSION(hSession).state = KMS_SESSION_SIGN;
 8028d2a:	3c01      	subs	r4, #1
 8028d2c:	00e3      	lsls	r3, r4, #3
 8028d2e:	191c      	adds	r4, r3, r4
 8028d30:	00a4      	lsls	r4, r4, #2
 8028d32:	4b02      	ldr	r3, [pc, #8]	; (8028d3c <KMS_SignInit+0x20>)
 8028d34:	191c      	adds	r4, r3, r4
 8028d36:	2304      	movs	r3, #4
 8028d38:	60e3      	str	r3, [r4, #12]

  return e_ret_status;
#else /* KMS_SIGN */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_SIGN */
}
 8028d3a:	bd10      	pop	{r4, pc}
 8028d3c:	2000b300 	.word	0x2000b300

08028d40 <KMS_Sign>:
CK_RV     KMS_Sign(CK_SESSION_HANDLE hSession,         /* the session's handle */
                   CK_BYTE_PTR       pData,           /* the data to sign */
                   CK_ULONG          ulDataLen,       /* count of bytes to sign */
                   CK_BYTE_PTR       pSignature,      /* gets the signature */
                   CK_ULONG_PTR      pulSignatureLen)  /* gets signature length */
{
 8028d40:	b5f0      	push	{r4, r5, r6, r7, lr}
 8028d42:	46c6      	mov	lr, r8
 8028d44:	b500      	push	{lr}
 8028d46:	b082      	sub	sp, #8
 8028d48:	0004      	movs	r4, r0
 8028d4a:	9100      	str	r1, [sp, #0]
 8028d4c:	0017      	movs	r7, r2
 8028d4e:	9301      	str	r3, [sp, #4]
#if defined(KMS_SIGN)
  CK_RV e_ret_status = CKR_OK;
  kms_obj_keyhead_t *pkms_object;

  if (!KMS_IS_INITIALIZED())
 8028d50:	4b42      	ldr	r3, [pc, #264]	; (8028e5c <KMS_Sign+0x11c>)
 8028d52:	781b      	ldrb	r3, [r3, #0]
 8028d54:	2b00      	cmp	r3, #0
 8028d56:	d076      	beq.n	8028e46 <KMS_Sign+0x106>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 8028d58:	f7fe fba8 	bl	80274ac <KMS_CheckSessionHdle>
 8028d5c:	1e05      	subs	r5, r0, #0
 8028d5e:	d000      	beq.n	8028d62 <KMS_Sign+0x22>
 8028d60:	e078      	b.n	8028e54 <KMS_Sign+0x114>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_SIGN)
 8028d62:	1e66      	subs	r6, r4, #1
 8028d64:	00f3      	lsls	r3, r6, #3
 8028d66:	199b      	adds	r3, r3, r6
 8028d68:	009b      	lsls	r3, r3, #2
 8028d6a:	4a3c      	ldr	r2, [pc, #240]	; (8028e5c <KMS_Sign+0x11c>)
 8028d6c:	18d3      	adds	r3, r2, r3
 8028d6e:	68db      	ldr	r3, [r3, #12]
 8028d70:	2b04      	cmp	r3, #4
 8028d72:	d000      	beq.n	8028d76 <KMS_Sign+0x36>
 8028d74:	e070      	b.n	8028e58 <KMS_Sign+0x118>
  {
    return CKR_OPERATION_NOT_INITIALIZED;
  }

  /* If a digest has to be computed */
  switch (KMS_GETSESSION(hSession).Mechanism)
 8028d76:	00f3      	lsls	r3, r6, #3
 8028d78:	199b      	adds	r3, r3, r6
 8028d7a:	009b      	lsls	r3, r3, #2
 8028d7c:	18d3      	adds	r3, r2, r3
 8028d7e:	6a1b      	ldr	r3, [r3, #32]
 8028d80:	4a37      	ldr	r2, [pc, #220]	; (8028e60 <KMS_Sign+0x120>)
 8028d82:	4694      	mov	ip, r2
 8028d84:	4463      	add	r3, ip
 8028d86:	2b01      	cmp	r3, #1
 8028d88:	d918      	bls.n	8028dbc <KMS_Sign+0x7c>
    }
#endif /* KMS_AES_CMAC & KMS_FCT_SIGN */

    default:
    {
      e_ret_status = CKR_MECHANISM_INVALID;
 8028d8a:	2570      	movs	r5, #112	; 0x70

  /* Upon completion error or not:
   * - free the allocated context
   * - release the session
   */
  KMS_GETSESSION(hSession).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 8028d8c:	00f3      	lsls	r3, r6, #3
 8028d8e:	199b      	adds	r3, r3, r6
 8028d90:	009b      	lsls	r3, r3, #2
 8028d92:	4a32      	ldr	r2, [pc, #200]	; (8028e5c <KMS_Sign+0x11c>)
 8028d94:	18d3      	adds	r3, r2, r3
 8028d96:	2200      	movs	r2, #0
 8028d98:	625a      	str	r2, [r3, #36]	; 0x24
  if (KMS_GETSESSION(hSession).pCtx != NULL_PTR)
 8028d9a:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8028d9c:	2900      	cmp	r1, #0
 8028d9e:	d009      	beq.n	8028db4 <KMS_Sign+0x74>
  {
    KMS_Free(hSession, KMS_GETSESSION(hSession).pCtx);
 8028da0:	0020      	movs	r0, r4
 8028da2:	f7fe fcff 	bl	80277a4 <KMS_Free>
    KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8028da6:	00f3      	lsls	r3, r6, #3
 8028da8:	199b      	adds	r3, r3, r6
 8028daa:	009b      	lsls	r3, r3, #2
 8028dac:	4a2b      	ldr	r2, [pc, #172]	; (8028e5c <KMS_Sign+0x11c>)
 8028dae:	18d3      	adds	r3, r2, r3
 8028db0:	2200      	movs	r2, #0
 8028db2:	629a      	str	r2, [r3, #40]	; 0x28
  }

  KMS_SetStateIdle(hSession);
 8028db4:	0020      	movs	r0, r4
 8028db6:	f7fe fbc1 	bl	802753c <KMS_SetStateIdle>

  return e_ret_status;
 8028dba:	e046      	b.n	8028e4a <KMS_Sign+0x10a>
    pkms_object = KMS_Objects_GetPointer(KMS_GETSESSION(hSession).hKey);
 8028dbc:	00f3      	lsls	r3, r6, #3
 8028dbe:	199b      	adds	r3, r3, r6
 8028dc0:	009b      	lsls	r3, r3, #2
 8028dc2:	4a26      	ldr	r2, [pc, #152]	; (8028e5c <KMS_Sign+0x11c>)
 8028dc4:	18d3      	adds	r3, r2, r3
 8028dc6:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8028dc8:	f7ff fb1a 	bl	8028400 <KMS_Objects_GetPointer>
    if ((pkms_object != NULL) &&
 8028dcc:	2800      	cmp	r0, #0
 8028dce:	d038      	beq.n	8028e42 <KMS_Sign+0x102>
 8028dd0:	4b24      	ldr	r3, [pc, #144]	; (8028e64 <KMS_Sign+0x124>)
 8028dd2:	6802      	ldr	r2, [r0, #0]
 8028dd4:	429a      	cmp	r2, r3
 8028dd6:	d001      	beq.n	8028ddc <KMS_Sign+0x9c>
      e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8028dd8:	2582      	movs	r5, #130	; 0x82
 8028dda:	e7d7      	b.n	8028d8c <KMS_Sign+0x4c>
        (pkms_object->configuration == KMS_ABI_CONFIG_KEYHEAD))
 8028ddc:	6842      	ldr	r2, [r0, #4]
        (pkms_object->version == KMS_ABI_VERSION_CK_2_40) &&
 8028dde:	4b22      	ldr	r3, [pc, #136]	; (8028e68 <KMS_Sign+0x128>)
 8028de0:	429a      	cmp	r2, r3
 8028de2:	d001      	beq.n	8028de8 <KMS_Sign+0xa8>
      e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8028de4:	2582      	movs	r5, #130	; 0x82
 8028de6:	e7d1      	b.n	8028d8c <KMS_Sign+0x4c>
      switch (KMS_GETSESSION(hSession).Mechanism)
 8028de8:	00f3      	lsls	r3, r6, #3
 8028dea:	199b      	adds	r3, r3, r6
 8028dec:	009b      	lsls	r3, r3, #2
 8028dee:	4a1b      	ldr	r2, [pc, #108]	; (8028e5c <KMS_Sign+0x11c>)
 8028df0:	18d3      	adds	r3, r2, r3
 8028df2:	6a1b      	ldr	r3, [r3, #32]
 8028df4:	4a1a      	ldr	r2, [pc, #104]	; (8028e60 <KMS_Sign+0x120>)
 8028df6:	4694      	mov	ip, r2
 8028df8:	4463      	add	r3, ip
 8028dfa:	2b01      	cmp	r3, #1
 8028dfc:	d901      	bls.n	8028e02 <KMS_Sign+0xc2>
          e_ret_status = CKR_MECHANISM_INVALID;
 8028dfe:	2570      	movs	r5, #112	; 0x70
 8028e00:	e7c4      	b.n	8028d8c <KMS_Sign+0x4c>
          kms_aes_cmac_sv_ctx_t *p_ctx = KMS_GETSESSION(hSession).pCtx;
 8028e02:	00f3      	lsls	r3, r6, #3
 8028e04:	199b      	adds	r3, r3, r6
 8028e06:	009b      	lsls	r3, r3, #2
 8028e08:	4a14      	ldr	r2, [pc, #80]	; (8028e5c <KMS_Sign+0x11c>)
 8028e0a:	18d3      	adds	r3, r2, r3
 8028e0c:	6a98      	ldr	r0, [r3, #40]	; 0x28
          p_ctx->ca_ctx.mFlags |= CA_E_SK_FINAL_APPEND;
 8028e0e:	2238      	movs	r2, #56	; 0x38
 8028e10:	5c83      	ldrb	r3, [r0, r2]
 8028e12:	2120      	movs	r1, #32
 8028e14:	430b      	orrs	r3, r1
 8028e16:	5483      	strb	r3, [r0, r2]
          if (CA_AES_CMAC_Encrypt_Append(&(p_ctx->ca_ctx),
 8028e18:	2334      	movs	r3, #52	; 0x34
 8028e1a:	4698      	mov	r8, r3
 8028e1c:	4480      	add	r8, r0
 8028e1e:	003a      	movs	r2, r7
 8028e20:	9900      	ldr	r1, [sp, #0]
 8028e22:	4640      	mov	r0, r8
 8028e24:	f7fd f94a 	bl	80260bc <CA_AES_CMAC_Encrypt_Append>
 8028e28:	2800      	cmp	r0, #0
 8028e2a:	d001      	beq.n	8028e30 <KMS_Sign+0xf0>
            e_ret_status = CKR_FUNCTION_FAILED;
 8028e2c:	2506      	movs	r5, #6
 8028e2e:	e7ad      	b.n	8028d8c <KMS_Sign+0x4c>
            if (CA_AES_CMAC_Encrypt_Finish(&(p_ctx->ca_ctx),
 8028e30:	aa08      	add	r2, sp, #32
 8028e32:	9901      	ldr	r1, [sp, #4]
 8028e34:	4640      	mov	r0, r8
 8028e36:	f7fd f967 	bl	8026108 <CA_AES_CMAC_Encrypt_Finish>
 8028e3a:	2800      	cmp	r0, #0
 8028e3c:	d0a6      	beq.n	8028d8c <KMS_Sign+0x4c>
              e_ret_status = CKR_FUNCTION_FAILED;
 8028e3e:	2506      	movs	r5, #6
 8028e40:	e7a4      	b.n	8028d8c <KMS_Sign+0x4c>
      e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8028e42:	2582      	movs	r5, #130	; 0x82
 8028e44:	e7a2      	b.n	8028d8c <KMS_Sign+0x4c>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8028e46:	25c8      	movs	r5, #200	; 0xc8
 8028e48:	006d      	lsls	r5, r5, #1
#else /* KMS_SIGN */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_SIGN */
}
 8028e4a:	0028      	movs	r0, r5
 8028e4c:	b002      	add	sp, #8
 8028e4e:	bc80      	pop	{r7}
 8028e50:	46b8      	mov	r8, r7
 8028e52:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8028e54:	25b3      	movs	r5, #179	; 0xb3
 8028e56:	e7f8      	b.n	8028e4a <KMS_Sign+0x10a>
    return CKR_OPERATION_NOT_INITIALIZED;
 8028e58:	2591      	movs	r5, #145	; 0x91
 8028e5a:	e7f6      	b.n	8028e4a <KMS_Sign+0x10a>
 8028e5c:	2000b300 	.word	0x2000b300
 8028e60:	ffffef76 	.word	0xffffef76
 8028e64:	b10b0240 	.word	0xb10b0240
 8028e68:	b10b0003 	.word	0xb10b0003

08028e6c <KMS_VerifyInit>:
  *         @ref sign_verify_init returned values
  */
CK_RV        KMS_VerifyInit(CK_SESSION_HANDLE hSession,
                            CK_MECHANISM_PTR  pMechanism,
                            CK_OBJECT_HANDLE  hKey)
{
 8028e6c:	b510      	push	{r4, lr}
 8028e6e:	0004      	movs	r4, r0
#if defined(KMS_VERIFY)
  CK_RV e_ret_status = sign_verify_init(hSession, pMechanism, hKey, KMS_FLAG_VERIFY);
 8028e70:	2301      	movs	r3, #1
 8028e72:	f7ff fe7b 	bl	8028b6c <sign_verify_init>

  if (e_ret_status == CKR_OK)
 8028e76:	2800      	cmp	r0, #0
 8028e78:	d107      	bne.n	8028e8a <KMS_VerifyInit+0x1e>
  {
    /* If successful, set processing state of the session */
    KMS_GETSESSION(hSession).state = KMS_SESSION_VERIFY;
 8028e7a:	3c01      	subs	r4, #1
 8028e7c:	00e3      	lsls	r3, r4, #3
 8028e7e:	191c      	adds	r4, r3, r4
 8028e80:	00a4      	lsls	r4, r4, #2
 8028e82:	4b02      	ldr	r3, [pc, #8]	; (8028e8c <KMS_VerifyInit+0x20>)
 8028e84:	191c      	adds	r4, r3, r4
 8028e86:	2305      	movs	r3, #5
 8028e88:	60e3      	str	r3, [r4, #12]

  return e_ret_status;
#else /* KMS_VERIFY */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_VERIFY */
}
 8028e8a:	bd10      	pop	{r4, pc}
 8028e8c:	2000b300 	.word	0x2000b300

08028e90 <KMS_Verify>:
                  CK_BYTE_PTR       pData,           /* signed data */
                  CK_ULONG          ulDataLen,       /* length of signed data */
                  CK_BYTE_PTR       pSignature,      /* signature */
                  CK_ULONG          ulSignatureLen)  /* signature length */

{
 8028e90:	b5f0      	push	{r4, r5, r6, r7, lr}
 8028e92:	46d6      	mov	lr, sl
 8028e94:	4647      	mov	r7, r8
 8028e96:	b580      	push	{r7, lr}
 8028e98:	b083      	sub	sp, #12
 8028e9a:	0004      	movs	r4, r0
 8028e9c:	9100      	str	r1, [sp, #0]
 8028e9e:	9201      	str	r2, [sp, #4]
 8028ea0:	001d      	movs	r5, r3
#if defined(KMS_VERIFY)
  CK_RV    e_ret_status ;
  kms_obj_keyhead_t *pkms_object;

  if (!KMS_IS_INITIALIZED())
 8028ea2:	4b47      	ldr	r3, [pc, #284]	; (8028fc0 <KMS_Verify+0x130>)
 8028ea4:	781b      	ldrb	r3, [r3, #0]
 8028ea6:	2b00      	cmp	r3, #0
 8028ea8:	d07d      	beq.n	8028fa6 <KMS_Verify+0x116>
  {
    return CKR_CRYPTOKI_NOT_INITIALIZED;
  }
  if (KMS_CheckSessionHdle(hSession) != CKR_OK)
 8028eaa:	f7fe faff 	bl	80274ac <KMS_CheckSessionHdle>
 8028eae:	1e06      	subs	r6, r0, #0
 8028eb0:	d000      	beq.n	8028eb4 <KMS_Verify+0x24>
 8028eb2:	e080      	b.n	8028fb6 <KMS_Verify+0x126>
  {
    return CKR_SESSION_HANDLE_INVALID;
  }
  /* No processing already on going  */
  if (KMS_GETSESSION(hSession).state != KMS_SESSION_VERIFY)
 8028eb4:	1e67      	subs	r7, r4, #1
 8028eb6:	00fb      	lsls	r3, r7, #3
 8028eb8:	19db      	adds	r3, r3, r7
 8028eba:	009b      	lsls	r3, r3, #2
 8028ebc:	4a40      	ldr	r2, [pc, #256]	; (8028fc0 <KMS_Verify+0x130>)
 8028ebe:	18d3      	adds	r3, r2, r3
 8028ec0:	68db      	ldr	r3, [r3, #12]
 8028ec2:	2b05      	cmp	r3, #5
 8028ec4:	d000      	beq.n	8028ec8 <KMS_Verify+0x38>
 8028ec6:	e078      	b.n	8028fba <KMS_Verify+0x12a>
  {
    return CKR_OPERATION_NOT_INITIALIZED;
  }

  /* If a digest has to be computed */
  switch (KMS_GETSESSION(hSession).Mechanism)
 8028ec8:	00fb      	lsls	r3, r7, #3
 8028eca:	19db      	adds	r3, r3, r7
 8028ecc:	009b      	lsls	r3, r3, #2
 8028ece:	18d3      	adds	r3, r2, r3
 8028ed0:	6a1b      	ldr	r3, [r3, #32]
 8028ed2:	4a3c      	ldr	r2, [pc, #240]	; (8028fc4 <KMS_Verify+0x134>)
 8028ed4:	4694      	mov	ip, r2
 8028ed6:	4463      	add	r3, ip
 8028ed8:	2b01      	cmp	r3, #1
 8028eda:	d918      	bls.n	8028f0e <KMS_Verify+0x7e>
    }
#endif /* KMS_AES_CMAC & KMS_FCT_VERIFY */

    default:
    {
      e_ret_status = CKR_FUNCTION_FAILED;
 8028edc:	2606      	movs	r6, #6

  /* Upon completion error or not:
   * - free the allocated context
   * - release the session
   */
  KMS_GETSESSION(hSession).hKey = KMS_HANDLE_KEY_NOT_KNOWN;
 8028ede:	00fb      	lsls	r3, r7, #3
 8028ee0:	19db      	adds	r3, r3, r7
 8028ee2:	009b      	lsls	r3, r3, #2
 8028ee4:	4a36      	ldr	r2, [pc, #216]	; (8028fc0 <KMS_Verify+0x130>)
 8028ee6:	18d3      	adds	r3, r2, r3
 8028ee8:	2200      	movs	r2, #0
 8028eea:	625a      	str	r2, [r3, #36]	; 0x24
  if (KMS_GETSESSION(hSession).pCtx != NULL_PTR)
 8028eec:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8028eee:	2900      	cmp	r1, #0
 8028ef0:	d009      	beq.n	8028f06 <KMS_Verify+0x76>
  {
    KMS_Free(hSession, KMS_GETSESSION(hSession).pCtx);
 8028ef2:	0020      	movs	r0, r4
 8028ef4:	f7fe fc56 	bl	80277a4 <KMS_Free>
    KMS_GETSESSION(hSession).pCtx = NULL_PTR;
 8028ef8:	00fb      	lsls	r3, r7, #3
 8028efa:	19db      	adds	r3, r3, r7
 8028efc:	009b      	lsls	r3, r3, #2
 8028efe:	4a30      	ldr	r2, [pc, #192]	; (8028fc0 <KMS_Verify+0x130>)
 8028f00:	18d3      	adds	r3, r2, r3
 8028f02:	2200      	movs	r2, #0
 8028f04:	629a      	str	r2, [r3, #40]	; 0x28
  }

  KMS_SetStateIdle(hSession);
 8028f06:	0020      	movs	r0, r4
 8028f08:	f7fe fb18 	bl	802753c <KMS_SetStateIdle>

  return e_ret_status;
 8028f0c:	e04d      	b.n	8028faa <KMS_Verify+0x11a>
    pkms_object = KMS_Objects_GetPointer(KMS_GETSESSION(hSession).hKey);
 8028f0e:	00fb      	lsls	r3, r7, #3
 8028f10:	19db      	adds	r3, r3, r7
 8028f12:	009b      	lsls	r3, r3, #2
 8028f14:	4a2a      	ldr	r2, [pc, #168]	; (8028fc0 <KMS_Verify+0x130>)
 8028f16:	18d3      	adds	r3, r2, r3
 8028f18:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8028f1a:	f7ff fa71 	bl	8028400 <KMS_Objects_GetPointer>
    if ((pkms_object != NULL) &&
 8028f1e:	2800      	cmp	r0, #0
 8028f20:	d03f      	beq.n	8028fa2 <KMS_Verify+0x112>
 8028f22:	4b29      	ldr	r3, [pc, #164]	; (8028fc8 <KMS_Verify+0x138>)
 8028f24:	6802      	ldr	r2, [r0, #0]
 8028f26:	429a      	cmp	r2, r3
 8028f28:	d001      	beq.n	8028f2e <KMS_Verify+0x9e>
      e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8028f2a:	2682      	movs	r6, #130	; 0x82
 8028f2c:	e7d7      	b.n	8028ede <KMS_Verify+0x4e>
        (pkms_object->configuration == KMS_ABI_CONFIG_KEYHEAD))
 8028f2e:	6842      	ldr	r2, [r0, #4]
        (pkms_object->version == KMS_ABI_VERSION_CK_2_40) &&
 8028f30:	4b26      	ldr	r3, [pc, #152]	; (8028fcc <KMS_Verify+0x13c>)
 8028f32:	429a      	cmp	r2, r3
 8028f34:	d001      	beq.n	8028f3a <KMS_Verify+0xaa>
      e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8028f36:	2682      	movs	r6, #130	; 0x82
 8028f38:	e7d1      	b.n	8028ede <KMS_Verify+0x4e>
      switch (KMS_GETSESSION(hSession).Mechanism)
 8028f3a:	00fb      	lsls	r3, r7, #3
 8028f3c:	19db      	adds	r3, r3, r7
 8028f3e:	009b      	lsls	r3, r3, #2
 8028f40:	4a1f      	ldr	r2, [pc, #124]	; (8028fc0 <KMS_Verify+0x130>)
 8028f42:	18d3      	adds	r3, r2, r3
 8028f44:	6a1b      	ldr	r3, [r3, #32]
 8028f46:	4a1f      	ldr	r2, [pc, #124]	; (8028fc4 <KMS_Verify+0x134>)
 8028f48:	4694      	mov	ip, r2
 8028f4a:	4463      	add	r3, ip
 8028f4c:	2b01      	cmp	r3, #1
 8028f4e:	d901      	bls.n	8028f54 <KMS_Verify+0xc4>
          e_ret_status = CKR_FUNCTION_FAILED;
 8028f50:	2606      	movs	r6, #6
 8028f52:	e7c4      	b.n	8028ede <KMS_Verify+0x4e>
          kms_aes_cmac_sv_ctx_t *p_ctx = KMS_GETSESSION(hSession).pCtx;
 8028f54:	00fb      	lsls	r3, r7, #3
 8028f56:	19db      	adds	r3, r3, r7
 8028f58:	009b      	lsls	r3, r3, #2
 8028f5a:	4a19      	ldr	r2, [pc, #100]	; (8028fc0 <KMS_Verify+0x130>)
 8028f5c:	18d3      	adds	r3, r2, r3
 8028f5e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8028f60:	469a      	mov	sl, r3
          p_ctx->ca_ctx.mFlags |= CA_E_SK_FINAL_APPEND;
 8028f62:	2238      	movs	r2, #56	; 0x38
 8028f64:	5c9b      	ldrb	r3, [r3, r2]
 8028f66:	2120      	movs	r1, #32
 8028f68:	430b      	orrs	r3, r1
 8028f6a:	4651      	mov	r1, sl
 8028f6c:	548b      	strb	r3, [r1, r2]
          if (CA_AES_CMAC_Decrypt_Append(&(p_ctx->ca_ctx),
 8028f6e:	2334      	movs	r3, #52	; 0x34
 8028f70:	4453      	add	r3, sl
 8028f72:	4698      	mov	r8, r3
 8028f74:	9a01      	ldr	r2, [sp, #4]
 8028f76:	9900      	ldr	r1, [sp, #0]
 8028f78:	0018      	movs	r0, r3
 8028f7a:	f7fd f901 	bl	8026180 <CA_AES_CMAC_Decrypt_Append>
 8028f7e:	2800      	cmp	r0, #0
 8028f80:	d001      	beq.n	8028f86 <KMS_Verify+0xf6>
            e_ret_status = CKR_FUNCTION_FAILED;
 8028f82:	2606      	movs	r6, #6
 8028f84:	e7ab      	b.n	8028ede <KMS_Verify+0x4e>
          p_ctx->ca_ctx.mTagSize = (int32_t)ulSignatureLen;
 8028f86:	4653      	mov	r3, sl
 8028f88:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8028f8a:	665a      	str	r2, [r3, #100]	; 0x64
          p_ctx->ca_ctx.pmTag = pSignature;
 8028f8c:	661d      	str	r5, [r3, #96]	; 0x60
          if (CA_AES_CMAC_Decrypt_Finish(&(p_ctx->ca_ctx),
 8028f8e:	aa0a      	add	r2, sp, #40	; 0x28
 8028f90:	0029      	movs	r1, r5
 8028f92:	4640      	mov	r0, r8
 8028f94:	f7fd f91a 	bl	80261cc <CA_AES_CMAC_Decrypt_Finish>
 8028f98:	4b0d      	ldr	r3, [pc, #52]	; (8028fd0 <KMS_Verify+0x140>)
 8028f9a:	4298      	cmp	r0, r3
 8028f9c:	d09f      	beq.n	8028ede <KMS_Verify+0x4e>
            e_ret_status = CKR_SIGNATURE_INVALID;
 8028f9e:	26c0      	movs	r6, #192	; 0xc0
 8028fa0:	e79d      	b.n	8028ede <KMS_Verify+0x4e>
      e_ret_status = CKR_OBJECT_HANDLE_INVALID;
 8028fa2:	2682      	movs	r6, #130	; 0x82
 8028fa4:	e79b      	b.n	8028ede <KMS_Verify+0x4e>
    return CKR_CRYPTOKI_NOT_INITIALIZED;
 8028fa6:	26c8      	movs	r6, #200	; 0xc8
 8028fa8:	0076      	lsls	r6, r6, #1

#else /* KMS_VERIFY */
  return CKR_FUNCTION_NOT_SUPPORTED;
#endif /* KMS_VERIFY */
}
 8028faa:	0030      	movs	r0, r6
 8028fac:	b003      	add	sp, #12
 8028fae:	bcc0      	pop	{r6, r7}
 8028fb0:	46ba      	mov	sl, r7
 8028fb2:	46b0      	mov	r8, r6
 8028fb4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return CKR_SESSION_HANDLE_INVALID;
 8028fb6:	26b3      	movs	r6, #179	; 0xb3
 8028fb8:	e7f7      	b.n	8028faa <KMS_Verify+0x11a>
    return CKR_OPERATION_NOT_INITIALIZED;
 8028fba:	2691      	movs	r6, #145	; 0x91
 8028fbc:	e7f5      	b.n	8028faa <KMS_Verify+0x11a>
 8028fbe:	46c0      	nop			; (mov r8, r8)
 8028fc0:	2000b300 	.word	0x2000b300
 8028fc4:	ffffef76 	.word	0xffffef76
 8028fc8:	b10b0240 	.word	0xb10b0240
 8028fcc:	b10b0003 	.word	0xb10b0003
 8028fd0:	000003eb 	.word	0x000003eb

08028fd4 <LmHandlerPackageIsInitialized>:
        return LORAMAC_HANDLER_ERROR;
    }
}

static bool LmHandlerPackageIsInitialized( uint8_t id )
{
 8028fd4:	b510      	push	{r4, lr}
    if( ( id < PKG_MAX_NUMBER ) && ( LmHandlerPackages[id]->IsInitialized != NULL ) )
 8028fd6:	2804      	cmp	r0, #4
 8028fd8:	d807      	bhi.n	8028fea <LmHandlerPackageIsInitialized+0x16>
 8028fda:	0080      	lsls	r0, r0, #2
 8028fdc:	4b05      	ldr	r3, [pc, #20]	; (8028ff4 <LmHandlerPackageIsInitialized+0x20>)
 8028fde:	58c3      	ldr	r3, [r0, r3]
 8028fe0:	689b      	ldr	r3, [r3, #8]
 8028fe2:	2b00      	cmp	r3, #0
 8028fe4:	d003      	beq.n	8028fee <LmHandlerPackageIsInitialized+0x1a>
    {
        return LmHandlerPackages[id]->IsInitialized( );
 8028fe6:	4798      	blx	r3
    }
    else
    {
        return false;
    }
}
 8028fe8:	bd10      	pop	{r4, pc}
        return false;
 8028fea:	2000      	movs	r0, #0
 8028fec:	e7fc      	b.n	8028fe8 <LmHandlerPackageIsInitialized+0x14>
 8028fee:	2000      	movs	r0, #0
 8028ff0:	e7fa      	b.n	8028fe8 <LmHandlerPackageIsInitialized+0x14>
 8028ff2:	46c0      	nop			; (mov r8, r8)
 8028ff4:	2000ba60 	.word	0x2000ba60

08028ff8 <LmHandlerPackagesNotify>:

static void LmHandlerPackagesNotify( PackageNotifyTypes_t notifyType, void *params )
{
 8028ff8:	b570      	push	{r4, r5, r6, lr}
 8028ffa:	0005      	movs	r5, r0
 8028ffc:	000e      	movs	r6, r1
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8028ffe:	2400      	movs	r4, #0
 8029000:	e00e      	b.n	8029020 <LmHandlerPackagesNotify+0x28>
    {
        if( LmHandlerPackages[i] != NULL )
        {
            switch( notifyType )
 8029002:	2d03      	cmp	r5, #3
 8029004:	d10a      	bne.n	802901c <LmHandlerPackagesNotify+0x24>
                        }
                        break;
                    }
                case PACKAGE_MLME_INDICATION:
                    {
                        if( LmHandlerPackages[i]->OnMlmeIndicationProcess != NULL )
 8029006:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8029008:	2b00      	cmp	r3, #0
 802900a:	d007      	beq.n	802901c <LmHandlerPackagesNotify+0x24>
                        {
                            LmHandlerPackages[i]->OnMlmeIndicationProcess( params );
 802900c:	0030      	movs	r0, r6
 802900e:	4798      	blx	r3
 8029010:	e004      	b.n	802901c <LmHandlerPackagesNotify+0x24>
                        if( LmHandlerPackages[i]->OnMcpsConfirmProcess != NULL )
 8029012:	699b      	ldr	r3, [r3, #24]
 8029014:	2b00      	cmp	r3, #0
 8029016:	d001      	beq.n	802901c <LmHandlerPackagesNotify+0x24>
                            LmHandlerPackages[i]->OnMcpsConfirmProcess( ( McpsConfirm_t * ) params );
 8029018:	0030      	movs	r0, r6
 802901a:	4798      	blx	r3
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 802901c:	3401      	adds	r4, #1
 802901e:	b264      	sxtb	r4, r4
 8029020:	2c04      	cmp	r4, #4
 8029022:	dc17      	bgt.n	8029054 <LmHandlerPackagesNotify+0x5c>
        if( LmHandlerPackages[i] != NULL )
 8029024:	00a3      	lsls	r3, r4, #2
 8029026:	4a0c      	ldr	r2, [pc, #48]	; (8029058 <LmHandlerPackagesNotify+0x60>)
 8029028:	589b      	ldr	r3, [r3, r2]
 802902a:	2b00      	cmp	r3, #0
 802902c:	d0f6      	beq.n	802901c <LmHandlerPackagesNotify+0x24>
            switch( notifyType )
 802902e:	2d02      	cmp	r5, #2
 8029030:	d00a      	beq.n	8029048 <LmHandlerPackagesNotify+0x50>
 8029032:	d8e6      	bhi.n	8029002 <LmHandlerPackagesNotify+0xa>
 8029034:	2d00      	cmp	r5, #0
 8029036:	d0ec      	beq.n	8029012 <LmHandlerPackagesNotify+0x1a>
 8029038:	2d01      	cmp	r5, #1
 802903a:	d1ef      	bne.n	802901c <LmHandlerPackagesNotify+0x24>
                        if( LmHandlerPackages[i]->OnMcpsIndicationProcess != NULL )
 802903c:	69db      	ldr	r3, [r3, #28]
 802903e:	2b00      	cmp	r3, #0
 8029040:	d0ec      	beq.n	802901c <LmHandlerPackagesNotify+0x24>
                            LmHandlerPackages[i]->OnMcpsIndicationProcess( ( McpsIndication_t * )params );
 8029042:	0030      	movs	r0, r6
 8029044:	4798      	blx	r3
 8029046:	e7e9      	b.n	802901c <LmHandlerPackagesNotify+0x24>
                        if( LmHandlerPackages[i]->OnMlmeConfirmProcess != NULL )
 8029048:	6a1b      	ldr	r3, [r3, #32]
 802904a:	2b00      	cmp	r3, #0
 802904c:	d0e6      	beq.n	802901c <LmHandlerPackagesNotify+0x24>
                            LmHandlerPackages[i]->OnMlmeConfirmProcess( ( MlmeConfirm_t * )params );
 802904e:	0030      	movs	r0, r6
 8029050:	4798      	blx	r3
 8029052:	e7e3      	b.n	802901c <LmHandlerPackagesNotify+0x24>
                        break;
                    }
            }
        }
    }
}
 8029054:	bd70      	pop	{r4, r5, r6, pc}
 8029056:	46c0      	nop			; (mov r8, r8)
 8029058:	2000ba60 	.word	0x2000ba60

0802905c <MlmeIndication>:
{
 802905c:	b510      	push	{r4, lr}
 802905e:	0004      	movs	r4, r0
    RxParams.IsMcpsIndication = 0;
 8029060:	4b11      	ldr	r3, [pc, #68]	; (80290a8 <MlmeIndication+0x4c>)
 8029062:	2200      	movs	r2, #0
 8029064:	701a      	strb	r2, [r3, #0]
    RxParams.Status = mlmeIndication->Status;
 8029066:	7842      	ldrb	r2, [r0, #1]
 8029068:	705a      	strb	r2, [r3, #1]
    RxParams.Datarate = mlmeIndication->RxDatarate;
 802906a:	2202      	movs	r2, #2
 802906c:	5682      	ldrsb	r2, [r0, r2]
 802906e:	721a      	strb	r2, [r3, #8]
    RxParams.Rssi = rxStatus->Rssi;
 8029070:	2000      	movs	r0, #0
 8029072:	5e0a      	ldrsh	r2, [r1, r0]
 8029074:	725a      	strb	r2, [r3, #9]
    RxParams.Snr = rxStatus->Snr;
 8029076:	2202      	movs	r2, #2
 8029078:	568a      	ldrsb	r2, [r1, r2]
 802907a:	729a      	strb	r2, [r3, #10]
    RxParams.RxSlot = rxStatus->RxSlot;
 802907c:	78ca      	ldrb	r2, [r1, #3]
 802907e:	741a      	strb	r2, [r3, #16]
    RxParams.DownlinkCounter = mlmeIndication->DownLinkCounter;
 8029080:	6862      	ldr	r2, [r4, #4]
 8029082:	60da      	str	r2, [r3, #12]
    if( ( LmHandlerCallbacks->OnRxData != NULL ) && ( mlmeIndication->MlmeIndication != MLME_BEACON ) && ( mlmeIndication->MlmeIndication != MLME_BEACON_LOST ) )
 8029084:	4b09      	ldr	r3, [pc, #36]	; (80290ac <MlmeIndication+0x50>)
 8029086:	681b      	ldr	r3, [r3, #0]
 8029088:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802908a:	2b00      	cmp	r3, #0
 802908c:	d007      	beq.n	802909e <MlmeIndication+0x42>
 802908e:	7822      	ldrb	r2, [r4, #0]
 8029090:	2a0a      	cmp	r2, #10
 8029092:	d004      	beq.n	802909e <MlmeIndication+0x42>
 8029094:	2a0e      	cmp	r2, #14
 8029096:	d002      	beq.n	802909e <MlmeIndication+0x42>
        LmHandlerCallbacks->OnRxData( NULL, &RxParams );
 8029098:	4903      	ldr	r1, [pc, #12]	; (80290a8 <MlmeIndication+0x4c>)
 802909a:	2000      	movs	r0, #0
 802909c:	4798      	blx	r3
    LmHandlerPackagesNotify( PACKAGE_MLME_INDICATION, mlmeIndication );
 802909e:	0021      	movs	r1, r4
 80290a0:	2003      	movs	r0, #3
 80290a2:	f7ff ffa9 	bl	8028ff8 <LmHandlerPackagesNotify>
}
 80290a6:	bd10      	pop	{r4, pc}
 80290a8:	2000b064 	.word	0x2000b064
 80290ac:	2000ba5c 	.word	0x2000ba5c

080290b0 <McpsConfirm>:
{
 80290b0:	b510      	push	{r4, lr}
 80290b2:	0004      	movs	r4, r0
    TxParams.IsMcpsConfirm = 1;
 80290b4:	4b0e      	ldr	r3, [pc, #56]	; (80290f0 <McpsConfirm+0x40>)
 80290b6:	2201      	movs	r2, #1
 80290b8:	701a      	strb	r2, [r3, #0]
    TxParams.Status = mcpsConfirm->Status;
 80290ba:	7842      	ldrb	r2, [r0, #1]
 80290bc:	705a      	strb	r2, [r3, #1]
    TxParams.Datarate = mcpsConfirm->Datarate;
 80290be:	2202      	movs	r2, #2
 80290c0:	5682      	ldrsb	r2, [r0, r2]
 80290c2:	729a      	strb	r2, [r3, #10]
    TxParams.UplinkCounter = mcpsConfirm->UpLinkCounter;
 80290c4:	68c2      	ldr	r2, [r0, #12]
 80290c6:	60da      	str	r2, [r3, #12]
    TxParams.TxPower = mcpsConfirm->TxPower;
 80290c8:	2203      	movs	r2, #3
 80290ca:	5682      	ldrsb	r2, [r0, r2]
 80290cc:	761a      	strb	r2, [r3, #24]
    TxParams.Channel = mcpsConfirm->Channel;
 80290ce:	6902      	ldr	r2, [r0, #16]
 80290d0:	765a      	strb	r2, [r3, #25]
    TxParams.AckReceived = mcpsConfirm->AckReceived;
 80290d2:	7902      	ldrb	r2, [r0, #4]
 80290d4:	725a      	strb	r2, [r3, #9]
    if( LmHandlerCallbacks->OnTxData != NULL )
 80290d6:	4b07      	ldr	r3, [pc, #28]	; (80290f4 <McpsConfirm+0x44>)
 80290d8:	681b      	ldr	r3, [r3, #0]
 80290da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80290dc:	2b00      	cmp	r3, #0
 80290de:	d001      	beq.n	80290e4 <McpsConfirm+0x34>
        LmHandlerCallbacks->OnTxData( &TxParams );
 80290e0:	4803      	ldr	r0, [pc, #12]	; (80290f0 <McpsConfirm+0x40>)
 80290e2:	4798      	blx	r3
    LmHandlerPackagesNotify( PACKAGE_MCPS_CONFIRM, mcpsConfirm );
 80290e4:	0021      	movs	r1, r4
 80290e6:	2000      	movs	r0, #0
 80290e8:	f7ff ff86 	bl	8028ff8 <LmHandlerPackagesNotify>
}
 80290ec:	bd10      	pop	{r4, pc}
 80290ee:	46c0      	nop			; (mov r8, r8)
 80290f0:	2000b078 	.word	0x2000b078
 80290f4:	2000ba5c 	.word	0x2000ba5c

080290f8 <LmHandlerPackageIsTxPending>:

static bool LmHandlerPackageIsTxPending( void )
{
 80290f8:	b510      	push	{r4, lr}
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 80290fa:	2400      	movs	r4, #0
 80290fc:	e001      	b.n	8029102 <LmHandlerPackageIsTxPending+0xa>
 80290fe:	3401      	adds	r4, #1
 8029100:	b264      	sxtb	r4, r4
 8029102:	2c04      	cmp	r4, #4
 8029104:	dc09      	bgt.n	802911a <LmHandlerPackageIsTxPending+0x22>
    {
#if (defined( LORAMAC_VERSION ) && ( LORAMAC_VERSION == 0x01000300 ))
        if( ( LmHandlerPackages[i] != NULL ) && ( i != PACKAGE_ID_COMPLIANCE ) )
#else
        if( LmHandlerPackages[i] != NULL )
 8029106:	00a3      	lsls	r3, r4, #2
 8029108:	4a05      	ldr	r2, [pc, #20]	; (8029120 <LmHandlerPackageIsTxPending+0x28>)
 802910a:	589b      	ldr	r3, [r3, r2]
 802910c:	2b00      	cmp	r3, #0
 802910e:	d0f6      	beq.n	80290fe <LmHandlerPackageIsTxPending+0x6>
#endif /* LORAMAC_VERSION */
        {
            if( LmHandlerPackages[i]->IsTxPending( ) == true )
 8029110:	68db      	ldr	r3, [r3, #12]
 8029112:	4798      	blx	r3
 8029114:	2800      	cmp	r0, #0
 8029116:	d0f2      	beq.n	80290fe <LmHandlerPackageIsTxPending+0x6>
 8029118:	e000      	b.n	802911c <LmHandlerPackageIsTxPending+0x24>
            {
                return true;
            }
        }
    }
    return false;
 802911a:	2000      	movs	r0, #0
}
 802911c:	bd10      	pop	{r4, pc}
 802911e:	46c0      	nop			; (mov r8, r8)
 8029120:	2000ba60 	.word	0x2000ba60

08029124 <LmHandlerPackagesProcess>:

static void LmHandlerPackagesProcess( void )
{
 8029124:	b570      	push	{r4, r5, r6, lr}
    for( int8_t i = 0; i < PKG_MAX_NUMBER; i++ )
 8029126:	2400      	movs	r4, #0
 8029128:	e001      	b.n	802912e <LmHandlerPackagesProcess+0xa>
 802912a:	3401      	adds	r4, #1
 802912c:	b264      	sxtb	r4, r4
 802912e:	2c04      	cmp	r4, #4
 8029130:	dc12      	bgt.n	8029158 <LmHandlerPackagesProcess+0x34>
    {
        if( ( LmHandlerPackages[i] != NULL ) &&
 8029132:	00a3      	lsls	r3, r4, #2
 8029134:	4a09      	ldr	r2, [pc, #36]	; (802915c <LmHandlerPackagesProcess+0x38>)
 8029136:	589b      	ldr	r3, [r3, r2]
 8029138:	2b00      	cmp	r3, #0
 802913a:	d0f6      	beq.n	802912a <LmHandlerPackagesProcess+0x6>
            ( LmHandlerPackages[i]->Process != NULL ) &&
 802913c:	691b      	ldr	r3, [r3, #16]
        if( ( LmHandlerPackages[i] != NULL ) &&
 802913e:	2b00      	cmp	r3, #0
 8029140:	d0f3      	beq.n	802912a <LmHandlerPackagesProcess+0x6>
            ( LmHandlerPackageIsInitialized( i ) != false ) )
 8029142:	b2e0      	uxtb	r0, r4
 8029144:	f7ff ff46 	bl	8028fd4 <LmHandlerPackageIsInitialized>
            ( LmHandlerPackages[i]->Process != NULL ) &&
 8029148:	2800      	cmp	r0, #0
 802914a:	d0ee      	beq.n	802912a <LmHandlerPackagesProcess+0x6>
        {
            LmHandlerPackages[i]->Process( );
 802914c:	00a5      	lsls	r5, r4, #2
 802914e:	4b03      	ldr	r3, [pc, #12]	; (802915c <LmHandlerPackagesProcess+0x38>)
 8029150:	58eb      	ldr	r3, [r5, r3]
 8029152:	691b      	ldr	r3, [r3, #16]
 8029154:	4798      	blx	r3
 8029156:	e7e8      	b.n	802912a <LmHandlerPackagesProcess+0x6>
        }
    }
}
 8029158:	bd70      	pop	{r4, r5, r6, pc}
 802915a:	46c0      	nop			; (mov r8, r8)
 802915c:	2000ba60 	.word	0x2000ba60

08029160 <LmHandlerOnTxFrameCtrlChanged>:

#if (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
static void LmHandlerOnTxFrameCtrlChanged( LmHandlerMsgTypes_t isTxConfirmed )
{
 8029160:	b510      	push	{r4, lr}
    LmHandlerParams.IsTxConfirmed = isTxConfirmed;
 8029162:	4b04      	ldr	r3, [pc, #16]	; (8029174 <LmHandlerOnTxFrameCtrlChanged+0x14>)
 8029164:	70d8      	strb	r0, [r3, #3]

    if (LmHandlerCallbacks->OnTxFrameCtrlChanged != NULL)
 8029166:	4b04      	ldr	r3, [pc, #16]	; (8029178 <LmHandlerOnTxFrameCtrlChanged+0x18>)
 8029168:	681b      	ldr	r3, [r3, #0]
 802916a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802916c:	2b00      	cmp	r3, #0
 802916e:	d000      	beq.n	8029172 <LmHandlerOnTxFrameCtrlChanged+0x12>
    {
        LmHandlerCallbacks->OnTxFrameCtrlChanged( isTxConfirmed );
 8029170:	4798      	blx	r3
    }
}
 8029172:	bd10      	pop	{r4, pc}
 8029174:	2000ba74 	.word	0x2000ba74
 8029178:	2000ba5c 	.word	0x2000ba5c

0802917c <LmHandlerOnPingSlotPeriodicityChanged>:

static void LmHandlerOnPingSlotPeriodicityChanged( uint8_t pingSlotPeriodicity )
{
 802917c:	b510      	push	{r4, lr}
    LmHandlerParams.PingSlotPeriodicity = pingSlotPeriodicity;
 802917e:	4b04      	ldr	r3, [pc, #16]	; (8029190 <LmHandlerOnPingSlotPeriodicityChanged+0x14>)
 8029180:	7418      	strb	r0, [r3, #16]

    if (LmHandlerCallbacks->OnPingSlotPeriodicityChanged != NULL)
 8029182:	4b04      	ldr	r3, [pc, #16]	; (8029194 <LmHandlerOnPingSlotPeriodicityChanged+0x18>)
 8029184:	681b      	ldr	r3, [r3, #0]
 8029186:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8029188:	2b00      	cmp	r3, #0
 802918a:	d000      	beq.n	802918e <LmHandlerOnPingSlotPeriodicityChanged+0x12>
    {
        LmHandlerCallbacks->OnPingSlotPeriodicityChanged( pingSlotPeriodicity );
 802918c:	4798      	blx	r3
    }
}
 802918e:	bd10      	pop	{r4, pc}
 8029190:	2000ba74 	.word	0x2000ba74
 8029194:	2000ba5c 	.word	0x2000ba5c

08029198 <LmHandlerJoin>:
{
 8029198:	b570      	push	{r4, r5, r6, lr}
 802919a:	b090      	sub	sp, #64	; 0x40
 802919c:	000c      	movs	r4, r1
    mlmeReq.Type = MLME_JOIN;
 802919e:	ab0b      	add	r3, sp, #44	; 0x2c
 80291a0:	2201      	movs	r2, #1
 80291a2:	701a      	strb	r2, [r3, #0]
    mlmeReq.Req.Join.Datarate = LmHandlerParams.TxDatarate;
 80291a4:	4a2f      	ldr	r2, [pc, #188]	; (8029264 <LmHandlerJoin+0xcc>)
 80291a6:	2604      	movs	r6, #4
 80291a8:	5796      	ldrsb	r6, [r2, r6]
 80291aa:	7911      	ldrb	r1, [r2, #4]
 80291ac:	7159      	strb	r1, [r3, #5]
    mlmeReq.Req.Join.TxPower = LmHandlerParams.TxPower;
 80291ae:	7952      	ldrb	r2, [r2, #5]
 80291b0:	b252      	sxtb	r2, r2
 80291b2:	719a      	strb	r2, [r3, #6]
    if( mode == ACTIVATION_TYPE_OTAA )
 80291b4:	2802      	cmp	r0, #2
 80291b6:	d024      	beq.n	8029202 <LmHandlerJoin+0x6a>
        mlmeReq.Req.Join.NetworkActivation = ACTIVATION_TYPE_ABP;
 80291b8:	2101      	movs	r1, #1
 80291ba:	ab0b      	add	r3, sp, #44	; 0x2c
 80291bc:	7119      	strb	r1, [r3, #4]
        JoinParams.Mode = ACTIVATION_TYPE_ABP;
 80291be:	4b2a      	ldr	r3, [pc, #168]	; (8029268 <LmHandlerJoin+0xd0>)
 80291c0:	71d9      	strb	r1, [r3, #7]
        JoinParams.Datarate = LmHandlerParams.TxDatarate;
 80291c2:	711e      	strb	r6, [r3, #4]
        JoinParams.TxPower = LmHandlerParams.TxPower;
 80291c4:	715a      	strb	r2, [r3, #5]
        JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 80291c6:	2200      	movs	r2, #0
 80291c8:	719a      	strb	r2, [r3, #6]
        JoinParams.forceRejoin = forceRejoin;
 80291ca:	721c      	strb	r4, [r3, #8]
        if( CtxRestoreDone == false )
 80291cc:	4b27      	ldr	r3, [pc, #156]	; (802926c <LmHandlerJoin+0xd4>)
 80291ce:	781b      	ldrb	r3, [r3, #0]
 80291d0:	2b00      	cmp	r3, #0
 80291d2:	d01e      	beq.n	8029212 <LmHandlerJoin+0x7a>
        LoRaMacStart();
 80291d4:	f003 ff70 	bl	802d0b8 <LoRaMacStart>
        mibReq.Type = MIB_NETWORK_ACTIVATION;
 80291d8:	2301      	movs	r3, #1
 80291da:	466a      	mov	r2, sp
 80291dc:	7113      	strb	r3, [r2, #4]
        mibReq.Param.NetworkActivation = ACTIVATION_TYPE_ABP;
 80291de:	7213      	strb	r3, [r2, #8]
        LoRaMacMibSetRequestConfirm( &mibReq );
 80291e0:	a801      	add	r0, sp, #4
 80291e2:	f004 f967 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
    if( ( CtxRestoreDone == false ) || ( forceRejoin == true ) )
 80291e6:	4b21      	ldr	r3, [pc, #132]	; (802926c <LmHandlerJoin+0xd4>)
 80291e8:	781b      	ldrb	r3, [r3, #0]
 80291ea:	2b00      	cmp	r3, #0
 80291ec:	d001      	beq.n	80291f2 <LmHandlerJoin+0x5a>
 80291ee:	2c00      	cmp	r4, #0
 80291f0:	d002      	beq.n	80291f8 <LmHandlerJoin+0x60>
        LoRaMacMlmeRequest( &mlmeReq );
 80291f2:	a80b      	add	r0, sp, #44	; 0x2c
 80291f4:	f004 fbd4 	bl	802d9a0 <LoRaMacMlmeRequest>
    DutyCycleWaitTime = mlmeReq.ReqReturn.DutyCycleWaitTime;
 80291f8:	4b1d      	ldr	r3, [pc, #116]	; (8029270 <LmHandlerJoin+0xd8>)
 80291fa:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80291fc:	601a      	str	r2, [r3, #0]
}
 80291fe:	b010      	add	sp, #64	; 0x40
 8029200:	bd70      	pop	{r4, r5, r6, pc}
        mlmeReq.Req.Join.NetworkActivation = ACTIVATION_TYPE_OTAA;
 8029202:	2202      	movs	r2, #2
 8029204:	711a      	strb	r2, [r3, #4]
        JoinParams.Mode = ACTIVATION_TYPE_OTAA;
 8029206:	4b18      	ldr	r3, [pc, #96]	; (8029268 <LmHandlerJoin+0xd0>)
 8029208:	71da      	strb	r2, [r3, #7]
        JoinParams.forceRejoin = forceRejoin;
 802920a:	721c      	strb	r4, [r3, #8]
        LoRaMacStart();
 802920c:	f003 ff54 	bl	802d0b8 <LoRaMacStart>
 8029210:	e7e9      	b.n	80291e6 <LmHandlerJoin+0x4e>
            mibReq.Type = MIB_CHANNELS_DEFAULT_DATARATE;
 8029212:	ad01      	add	r5, sp, #4
 8029214:	331f      	adds	r3, #31
 8029216:	702b      	strb	r3, [r5, #0]
            mibReq.Param.ChannelsDefaultDatarate = LmHandlerParams.TxDatarate;
 8029218:	712e      	strb	r6, [r5, #4]
            LoRaMacMibSetRequestConfirm( &mibReq );
 802921a:	0028      	movs	r0, r5
 802921c:	f004 f94a 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
            mibReq.Type = MIB_CHANNELS_DATARATE;
 8029220:	2320      	movs	r3, #32
 8029222:	702b      	strb	r3, [r5, #0]
            mibReq.Param.ChannelsDatarate = LmHandlerParams.TxDatarate;
 8029224:	4e0f      	ldr	r6, [pc, #60]	; (8029264 <LmHandlerJoin+0xcc>)
 8029226:	2304      	movs	r3, #4
 8029228:	56f3      	ldrsb	r3, [r6, r3]
 802922a:	712b      	strb	r3, [r5, #4]
            LoRaMacMibSetRequestConfirm( &mibReq );
 802922c:	0028      	movs	r0, r5
 802922e:	f004 f941 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
            mibReq.Type = MIB_CHANNELS_DEFAULT_TX_POWER;
 8029232:	2322      	movs	r3, #34	; 0x22
 8029234:	702b      	strb	r3, [r5, #0]
            mibReq.Param.ChannelsDefaultTxPower = LmHandlerParams.TxPower;
 8029236:	2305      	movs	r3, #5
 8029238:	56f3      	ldrsb	r3, [r6, r3]
 802923a:	712b      	strb	r3, [r5, #4]
            LoRaMacMibSetRequestConfirm( &mibReq );
 802923c:	0028      	movs	r0, r5
 802923e:	f004 f939 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
            mibReq.Type = MIB_CHANNELS_TX_POWER;
 8029242:	2321      	movs	r3, #33	; 0x21
 8029244:	702b      	strb	r3, [r5, #0]
            mibReq.Param.ChannelsTxPower = LmHandlerParams.TxPower;
 8029246:	2305      	movs	r3, #5
 8029248:	56f3      	ldrsb	r3, [r6, r3]
 802924a:	712b      	strb	r3, [r5, #4]
            LoRaMacMibSetRequestConfirm( &mibReq );
 802924c:	0028      	movs	r0, r5
 802924e:	f004 f931 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
            mibReq.Type = MIB_ABP_LORAWAN_VERSION;
 8029252:	2329      	movs	r3, #41	; 0x29
 8029254:	702b      	strb	r3, [r5, #0]
            mibReq.Param.AbpLrWanVersion.Value = ABP_ACTIVATION_LRWAN_VERSION;
 8029256:	4b07      	ldr	r3, [pc, #28]	; (8029274 <LmHandlerJoin+0xdc>)
 8029258:	9302      	str	r3, [sp, #8]
            LoRaMacMibSetRequestConfirm( &mibReq );
 802925a:	0028      	movs	r0, r5
 802925c:	f004 f92a 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 8029260:	e7b8      	b.n	80291d4 <LmHandlerJoin+0x3c>
 8029262:	46c0      	nop			; (mov r8, r8)
 8029264:	2000ba74 	.word	0x2000ba74
 8029268:	2000b058 	.word	0x2000b058
 802926c:	2000ba50 	.word	0x2000ba50
 8029270:	2000ba54 	.word	0x2000ba54
 8029274:	01000400 	.word	0x01000400

08029278 <LmHandlerDeviceTimeReq>:
{
 8029278:	b510      	push	{r4, lr}
 802927a:	b086      	sub	sp, #24
    mlmeReq.Type = MLME_DEVICE_TIME;
 802927c:	ac01      	add	r4, sp, #4
 802927e:	2309      	movs	r3, #9
 8029280:	7023      	strb	r3, [r4, #0]
    status = LoRaMacMlmeRequest( &mlmeReq );
 8029282:	0020      	movs	r0, r4
 8029284:	f004 fb8c 	bl	802d9a0 <LoRaMacMlmeRequest>
    DutyCycleWaitTime = mlmeReq.ReqReturn.DutyCycleWaitTime;
 8029288:	9a05      	ldr	r2, [sp, #20]
 802928a:	4b04      	ldr	r3, [pc, #16]	; (802929c <LmHandlerDeviceTimeReq+0x24>)
 802928c:	601a      	str	r2, [r3, #0]
    if( status == LORAMAC_STATUS_OK )
 802928e:	2800      	cmp	r0, #0
 8029290:	d101      	bne.n	8029296 <LmHandlerDeviceTimeReq+0x1e>
}
 8029292:	b006      	add	sp, #24
 8029294:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029296:	2001      	movs	r0, #1
 8029298:	4240      	negs	r0, r0
 802929a:	e7fa      	b.n	8029292 <LmHandlerDeviceTimeReq+0x1a>
 802929c:	2000ba54 	.word	0x2000ba54

080292a0 <LmHandlerDeInit>:
{
 80292a0:	b510      	push	{r4, lr}
    if( LoRaMacDeInitialization() == LORAMAC_STATUS_OK )
 80292a2:	f004 fdb9 	bl	802de18 <LoRaMacDeInitialization>
 80292a6:	2800      	cmp	r0, #0
 80292a8:	d10e      	bne.n	80292c8 <LmHandlerDeInit+0x28>
        LmHandlerCallbacks = NULL;
 80292aa:	4b09      	ldr	r3, [pc, #36]	; (80292d0 <LmHandlerDeInit+0x30>)
 80292ac:	2200      	movs	r2, #0
 80292ae:	601a      	str	r2, [r3, #0]
        memset1( ( uint8_t * )&LoRaMacPrimitives, 0, sizeof( LoRaMacPrimitives_t ) );
 80292b0:	3210      	adds	r2, #16
 80292b2:	2100      	movs	r1, #0
 80292b4:	4807      	ldr	r0, [pc, #28]	; (80292d4 <LmHandlerDeInit+0x34>)
 80292b6:	f008 ff3c 	bl	8032132 <memset1>
        memset1( ( uint8_t * )&LoRaMacCallbacks, 0, sizeof( LoRaMacCallback_t ) );
 80292ba:	2218      	movs	r2, #24
 80292bc:	2100      	movs	r1, #0
 80292be:	4806      	ldr	r0, [pc, #24]	; (80292d8 <LmHandlerDeInit+0x38>)
 80292c0:	f008 ff37 	bl	8032132 <memset1>
        return LORAMAC_HANDLER_SUCCESS;
 80292c4:	2000      	movs	r0, #0
}
 80292c6:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_BUSY_ERROR;
 80292c8:	2002      	movs	r0, #2
 80292ca:	4240      	negs	r0, r0
 80292cc:	e7fb      	b.n	80292c6 <LmHandlerDeInit+0x26>
 80292ce:	46c0      	nop			; (mov r8, r8)
 80292d0:	2000ba5c 	.word	0x2000ba5c
 80292d4:	2000bab4 	.word	0x2000bab4
 80292d8:	2000ba9c 	.word	0x2000ba9c

080292dc <LmHandlerGetDutyCycleWaitTime>:
    return DutyCycleWaitTime;
 80292dc:	4b01      	ldr	r3, [pc, #4]	; (80292e4 <LmHandlerGetDutyCycleWaitTime+0x8>)
 80292de:	6818      	ldr	r0, [r3, #0]
}
 80292e0:	4770      	bx	lr
 80292e2:	46c0      	nop			; (mov r8, r8)
 80292e4:	2000ba54 	.word	0x2000ba54

080292e8 <LmHandlerJoinStatus>:
{
 80292e8:	b500      	push	{lr}
 80292ea:	b08b      	sub	sp, #44	; 0x2c
    mibReq.Type = MIB_NETWORK_ACTIVATION;
 80292ec:	2301      	movs	r3, #1
 80292ee:	466a      	mov	r2, sp
 80292f0:	7013      	strb	r3, [r2, #0]
    status = LoRaMacMibGetRequestConfirm( &mibReq );
 80292f2:	4668      	mov	r0, sp
 80292f4:	f003 ffb2 	bl	802d25c <LoRaMacMibGetRequestConfirm>
    if( status == LORAMAC_STATUS_OK )
 80292f8:	2800      	cmp	r0, #0
 80292fa:	d105      	bne.n	8029308 <LmHandlerJoinStatus+0x20>
        if( mibReq.Param.NetworkActivation == ACTIVATION_TYPE_NONE )
 80292fc:	466b      	mov	r3, sp
 80292fe:	7918      	ldrb	r0, [r3, #4]
 8029300:	2800      	cmp	r0, #0
 8029302:	d002      	beq.n	802930a <LmHandlerJoinStatus+0x22>
            return LORAMAC_HANDLER_SET;
 8029304:	2001      	movs	r0, #1
 8029306:	e000      	b.n	802930a <LmHandlerJoinStatus+0x22>
        return LORAMAC_HANDLER_RESET;
 8029308:	2000      	movs	r0, #0
}
 802930a:	b00b      	add	sp, #44	; 0x2c
 802930c:	bd00      	pop	{pc}
	...

08029310 <LmHandlerIsBusy>:
{
 8029310:	b510      	push	{r4, lr}
    if( LoRaMacIsBusy( ) == true )
 8029312:	f003 fc77 	bl	802cc04 <LoRaMacIsBusy>
 8029316:	2800      	cmp	r0, #0
 8029318:	d000      	beq.n	802931c <LmHandlerIsBusy+0xc>
}
 802931a:	bd10      	pop	{r4, pc}
    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
 802931c:	f7ff ffe4 	bl	80292e8 <LmHandlerJoinStatus>
 8029320:	2801      	cmp	r0, #1
 8029322:	d006      	beq.n	8029332 <LmHandlerIsBusy+0x22>
        LmHandlerJoin( JoinParams.Mode, JoinParams.forceRejoin );
 8029324:	4b04      	ldr	r3, [pc, #16]	; (8029338 <LmHandlerIsBusy+0x28>)
 8029326:	7a19      	ldrb	r1, [r3, #8]
 8029328:	79d8      	ldrb	r0, [r3, #7]
 802932a:	f7ff ff35 	bl	8029198 <LmHandlerJoin>
        return true;
 802932e:	2001      	movs	r0, #1
 8029330:	e7f3      	b.n	802931a <LmHandlerIsBusy+0xa>
    if( LmHandlerPackageIsTxPending( ) == true )
 8029332:	f7ff fee1 	bl	80290f8 <LmHandlerPackageIsTxPending>
 8029336:	e7f0      	b.n	802931a <LmHandlerIsBusy+0xa>
 8029338:	2000b058 	.word	0x2000b058

0802933c <LmHandlerSend>:
{
 802933c:	b570      	push	{r4, r5, r6, lr}
 802933e:	b086      	sub	sp, #24
 8029340:	0004      	movs	r4, r0
 8029342:	000d      	movs	r5, r1
 8029344:	0016      	movs	r6, r2
    if( LoRaMacIsBusy() == true )
 8029346:	f003 fc5d 	bl	802cc04 <LoRaMacIsBusy>
 802934a:	2800      	cmp	r0, #0
 802934c:	d15b      	bne.n	8029406 <LmHandlerSend+0xca>
    if( LoRaMacIsStopped() == true )
 802934e:	f003 fc7b 	bl	802cc48 <LoRaMacIsStopped>
 8029352:	2800      	cmp	r0, #0
 8029354:	d15a      	bne.n	802940c <LmHandlerSend+0xd0>
    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
 8029356:	f7ff ffc7 	bl	80292e8 <LmHandlerJoinStatus>
 802935a:	2801      	cmp	r0, #1
 802935c:	d12c      	bne.n	80293b8 <LmHandlerSend+0x7c>
    TxParams.MsgType = isTxConfirmed;
 802935e:	4b2e      	ldr	r3, [pc, #184]	; (8029418 <LmHandlerSend+0xdc>)
 8029360:	721d      	strb	r5, [r3, #8]
    mcpsReq.Type = ( isTxConfirmed == LORAMAC_HANDLER_UNCONFIRMED_MSG ) ? MCPS_UNCONFIRMED : MCPS_CONFIRMED;
 8029362:	1e6b      	subs	r3, r5, #1
 8029364:	419d      	sbcs	r5, r3
 8029366:	ab01      	add	r3, sp, #4
 8029368:	701d      	strb	r5, [r3, #0]
    mcpsReq.Req.Unconfirmed.Datarate = LmHandlerParams.TxDatarate;
 802936a:	4a2c      	ldr	r2, [pc, #176]	; (802941c <LmHandlerSend+0xe0>)
 802936c:	7912      	ldrb	r2, [r2, #4]
 802936e:	b252      	sxtb	r2, r2
 8029370:	739a      	strb	r2, [r3, #14]
    if( LoRaMacQueryTxPossible( appData->BufferSize, &txInfo ) != LORAMAC_STATUS_OK )
 8029372:	7860      	ldrb	r0, [r4, #1]
 8029374:	4669      	mov	r1, sp
 8029376:	f003 ff07 	bl	802d188 <LoRaMacQueryTxPossible>
 802937a:	2800      	cmp	r0, #0
 802937c:	d024      	beq.n	80293c8 <LmHandlerSend+0x8c>
        mcpsReq.Type = MCPS_UNCONFIRMED;
 802937e:	ab01      	add	r3, sp, #4
 8029380:	2200      	movs	r2, #0
 8029382:	701a      	strb	r2, [r3, #0]
        mcpsReq.Req.Unconfirmed.fBuffer = NULL;
 8029384:	9203      	str	r2, [sp, #12]
        mcpsReq.Req.Unconfirmed.fBufferSize = 0;
 8029386:	819a      	strh	r2, [r3, #12]
        lmhStatus = LORAMAC_HANDLER_PAYLOAD_LENGTH_RESTRICTED;
 8029388:	2507      	movs	r5, #7
 802938a:	426d      	negs	r5, r5
    TxParams.AppData = *appData;
 802938c:	4a22      	ldr	r2, [pc, #136]	; (8029418 <LmHandlerSend+0xdc>)
 802938e:	0013      	movs	r3, r2
 8029390:	3310      	adds	r3, #16
 8029392:	cc03      	ldmia	r4!, {r0, r1}
 8029394:	c303      	stmia	r3!, {r0, r1}
    TxParams.Datarate = LmHandlerParams.TxDatarate;
 8029396:	4b21      	ldr	r3, [pc, #132]	; (802941c <LmHandlerSend+0xe0>)
 8029398:	791b      	ldrb	r3, [r3, #4]
 802939a:	b25b      	sxtb	r3, r3
 802939c:	7293      	strb	r3, [r2, #10]
    status = LoRaMacMcpsRequest( &mcpsReq, allowDelayedTx );
 802939e:	0031      	movs	r1, r6
 80293a0:	a801      	add	r0, sp, #4
 80293a2:	f004 fc05 	bl	802dbb0 <LoRaMacMcpsRequest>
    DutyCycleWaitTime = mcpsReq.ReqReturn.DutyCycleWaitTime;
 80293a6:	9a05      	ldr	r2, [sp, #20]
 80293a8:	4b1d      	ldr	r3, [pc, #116]	; (8029420 <LmHandlerSend+0xe4>)
 80293aa:	601a      	str	r2, [r3, #0]
    switch( status )
 80293ac:	2811      	cmp	r0, #17
 80293ae:	d827      	bhi.n	8029400 <LmHandlerSend+0xc4>
 80293b0:	0080      	lsls	r0, r0, #2
 80293b2:	4b1c      	ldr	r3, [pc, #112]	; (8029424 <LmHandlerSend+0xe8>)
 80293b4:	581b      	ldr	r3, [r3, r0]
 80293b6:	469f      	mov	pc, r3
        LmHandlerJoin( JoinParams.Mode, JoinParams.forceRejoin );
 80293b8:	4b1b      	ldr	r3, [pc, #108]	; (8029428 <LmHandlerSend+0xec>)
 80293ba:	7a19      	ldrb	r1, [r3, #8]
 80293bc:	79d8      	ldrb	r0, [r3, #7]
 80293be:	f7ff feeb 	bl	8029198 <LmHandlerJoin>
        return LORAMAC_HANDLER_NO_NETWORK_JOINED;
 80293c2:	2503      	movs	r5, #3
 80293c4:	426d      	negs	r5, r5
 80293c6:	e00b      	b.n	80293e0 <LmHandlerSend+0xa4>
        mcpsReq.Req.Unconfirmed.fPort = appData->Port;
 80293c8:	7822      	ldrb	r2, [r4, #0]
 80293ca:	ab01      	add	r3, sp, #4
 80293cc:	711a      	strb	r2, [r3, #4]
        mcpsReq.Req.Unconfirmed.fBufferSize = appData->BufferSize;
 80293ce:	7862      	ldrb	r2, [r4, #1]
 80293d0:	819a      	strh	r2, [r3, #12]
        mcpsReq.Req.Unconfirmed.fBuffer = appData->Buffer;
 80293d2:	6862      	ldr	r2, [r4, #4]
 80293d4:	9203      	str	r2, [sp, #12]
    LmHandlerErrorStatus_t lmhStatus = LORAMAC_HANDLER_ERROR;
 80293d6:	2501      	movs	r5, #1
 80293d8:	426d      	negs	r5, r5
 80293da:	e7d7      	b.n	802938c <LmHandlerSend+0x50>
    switch( status )
 80293dc:	2502      	movs	r5, #2
 80293de:	426d      	negs	r5, r5
}
 80293e0:	0028      	movs	r0, r5
 80293e2:	b006      	add	sp, #24
 80293e4:	bd70      	pop	{r4, r5, r6, pc}
            IsUplinkTxPending = false;
 80293e6:	4b11      	ldr	r3, [pc, #68]	; (802942c <LmHandlerSend+0xf0>)
 80293e8:	2200      	movs	r2, #0
 80293ea:	701a      	strb	r2, [r3, #0]
            if( lmhStatus != LORAMAC_HANDLER_PAYLOAD_LENGTH_RESTRICTED )
 80293ec:	1deb      	adds	r3, r5, #7
 80293ee:	d0f7      	beq.n	80293e0 <LmHandlerSend+0xa4>
                lmhStatus = LORAMAC_HANDLER_SUCCESS;
 80293f0:	2500      	movs	r5, #0
 80293f2:	e7f5      	b.n	80293e0 <LmHandlerSend+0xa4>
            lmhStatus = LORAMAC_HANDLER_CRYPTO_ERROR;
 80293f4:	2505      	movs	r5, #5
 80293f6:	426d      	negs	r5, r5
            break;
 80293f8:	e7f2      	b.n	80293e0 <LmHandlerSend+0xa4>
            lmhStatus = LORAMAC_HANDLER_DUTYCYCLE_RESTRICTED;
 80293fa:	2506      	movs	r5, #6
 80293fc:	426d      	negs	r5, r5
            break;
 80293fe:	e7ef      	b.n	80293e0 <LmHandlerSend+0xa4>
            lmhStatus = LORAMAC_HANDLER_ERROR;
 8029400:	2501      	movs	r5, #1
 8029402:	426d      	negs	r5, r5
            break;
 8029404:	e7ec      	b.n	80293e0 <LmHandlerSend+0xa4>
        return LORAMAC_HANDLER_BUSY_ERROR;
 8029406:	2502      	movs	r5, #2
 8029408:	426d      	negs	r5, r5
 802940a:	e7e9      	b.n	80293e0 <LmHandlerSend+0xa4>
        return LORAMAC_HANDLER_NO_NETWORK_JOINED;
 802940c:	2503      	movs	r5, #3
 802940e:	426d      	negs	r5, r5
 8029410:	e7e6      	b.n	80293e0 <LmHandlerSend+0xa4>
            lmhStatus = LORAMAC_HANDLER_NO_NETWORK_JOINED;
 8029412:	2503      	movs	r5, #3
 8029414:	426d      	negs	r5, r5
 8029416:	e7e3      	b.n	80293e0 <LmHandlerSend+0xa4>
 8029418:	2000b078 	.word	0x2000b078
 802941c:	2000ba74 	.word	0x2000ba74
 8029420:	2000ba54 	.word	0x2000ba54
 8029424:	0803510c 	.word	0x0803510c
 8029428:	2000b058 	.word	0x2000b058
 802942c:	2000ba58 	.word	0x2000ba58

08029430 <LmHandlerProcess>:
{
 8029430:	b500      	push	{lr}
 8029432:	b083      	sub	sp, #12
    LoRaMacProcess( );
 8029434:	f003 fc14 	bl	802cc60 <LoRaMacProcess>
    LmHandlerPackagesProcess( );
 8029438:	f7ff fe74 	bl	8029124 <LmHandlerPackagesProcess>
    if( LmHandlerPackageIsTxPending( ) == true )
 802943c:	f7ff fe5c 	bl	80290f8 <LmHandlerPackageIsTxPending>
 8029440:	2800      	cmp	r0, #0
 8029442:	d103      	bne.n	802944c <LmHandlerProcess+0x1c>
    if( IsUplinkTxPending == true )
 8029444:	4b0b      	ldr	r3, [pc, #44]	; (8029474 <LmHandlerProcess+0x44>)
 8029446:	781b      	ldrb	r3, [r3, #0]
 8029448:	2b00      	cmp	r3, #0
 802944a:	d101      	bne.n	8029450 <LmHandlerProcess+0x20>
}
 802944c:	b003      	add	sp, #12
 802944e:	bd00      	pop	{pc}
        LmHandlerAppData_t appData =
 8029450:	2300      	movs	r3, #0
 8029452:	466a      	mov	r2, sp
 8029454:	7013      	strb	r3, [r2, #0]
 8029456:	7053      	strb	r3, [r2, #1]
 8029458:	9301      	str	r3, [sp, #4]
        if( LmHandlerSend( &appData, LmHandlerParams.IsTxConfirmed, false ) == LORAMAC_HANDLER_SUCCESS )
 802945a:	4b07      	ldr	r3, [pc, #28]	; (8029478 <LmHandlerProcess+0x48>)
 802945c:	78d9      	ldrb	r1, [r3, #3]
 802945e:	2200      	movs	r2, #0
 8029460:	4668      	mov	r0, sp
 8029462:	f7ff ff6b 	bl	802933c <LmHandlerSend>
 8029466:	2800      	cmp	r0, #0
 8029468:	d1f0      	bne.n	802944c <LmHandlerProcess+0x1c>
            IsUplinkTxPending = false;
 802946a:	4b02      	ldr	r3, [pc, #8]	; (8029474 <LmHandlerProcess+0x44>)
 802946c:	2200      	movs	r2, #0
 802946e:	701a      	strb	r2, [r3, #0]
 8029470:	e7ec      	b.n	802944c <LmHandlerProcess+0x1c>
 8029472:	46c0      	nop			; (mov r8, r8)
 8029474:	2000ba58 	.word	0x2000ba58
 8029478:	2000ba74 	.word	0x2000ba74

0802947c <LmHandlerRequestClass>:
{
 802947c:	b510      	push	{r4, lr}
 802947e:	b08a      	sub	sp, #40	; 0x28
 8029480:	0004      	movs	r4, r0
    if( LoRaMacIsBusy() == true )
 8029482:	f003 fbbf 	bl	802cc04 <LoRaMacIsBusy>
 8029486:	2800      	cmp	r0, #0
 8029488:	d13e      	bne.n	8029508 <LmHandlerRequestClass+0x8c>
    if( LmHandlerJoinStatus() != LORAMAC_HANDLER_SET )
 802948a:	f7ff ff2d 	bl	80292e8 <LmHandlerJoinStatus>
 802948e:	2801      	cmp	r0, #1
 8029490:	d13d      	bne.n	802950e <LmHandlerRequestClass+0x92>
    mibReq.Type = MIB_DEVICE_CLASS;
 8029492:	2300      	movs	r3, #0
 8029494:	466a      	mov	r2, sp
 8029496:	7013      	strb	r3, [r2, #0]
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029498:	4668      	mov	r0, sp
 802949a:	f003 fedf 	bl	802d25c <LoRaMacMibGetRequestConfirm>
 802949e:	2800      	cmp	r0, #0
 80294a0:	d138      	bne.n	8029514 <LmHandlerRequestClass+0x98>
    currentClass = mibReq.Param.Class;
 80294a2:	466b      	mov	r3, sp
 80294a4:	791b      	ldrb	r3, [r3, #4]
    if( currentClass != newClass )
 80294a6:	42a3      	cmp	r3, r4
 80294a8:	d037      	beq.n	802951a <LmHandlerRequestClass+0x9e>
        switch( newClass )
 80294aa:	2c01      	cmp	r4, #1
 80294ac:	d037      	beq.n	802951e <LmHandlerRequestClass+0xa2>
 80294ae:	2c02      	cmp	r4, #2
 80294b0:	d018      	beq.n	80294e4 <LmHandlerRequestClass+0x68>
 80294b2:	2c00      	cmp	r4, #0
 80294b4:	d002      	beq.n	80294bc <LmHandlerRequestClass+0x40>
 80294b6:	2000      	movs	r0, #0
}
 80294b8:	b00a      	add	sp, #40	; 0x28
 80294ba:	bd10      	pop	{r4, pc}
                    if( currentClass != CLASS_A )
 80294bc:	2b00      	cmp	r3, #0
 80294be:	d101      	bne.n	80294c4 <LmHandlerRequestClass+0x48>
    LmHandlerErrorStatus_t errorStatus = LORAMAC_HANDLER_SUCCESS;
 80294c0:	2000      	movs	r0, #0
 80294c2:	e7f9      	b.n	80294b8 <LmHandlerRequestClass+0x3c>
                        mibReq.Param.Class = newClass;
 80294c4:	466b      	mov	r3, sp
 80294c6:	711c      	strb	r4, [r3, #4]
                        if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 80294c8:	4668      	mov	r0, sp
 80294ca:	f003 fff3 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 80294ce:	2800      	cmp	r0, #0
 80294d0:	d128      	bne.n	8029524 <LmHandlerRequestClass+0xa8>
                            if( LmHandlerCallbacks->OnClassChange != NULL )
 80294d2:	4b1b      	ldr	r3, [pc, #108]	; (8029540 <LmHandlerRequestClass+0xc4>)
 80294d4:	681b      	ldr	r3, [r3, #0]
 80294d6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80294d8:	2b00      	cmp	r3, #0
 80294da:	d026      	beq.n	802952a <LmHandlerRequestClass+0xae>
                                LmHandlerCallbacks->OnClassChange( newClass );
 80294dc:	0020      	movs	r0, r4
 80294de:	4798      	blx	r3
    LmHandlerErrorStatus_t errorStatus = LORAMAC_HANDLER_SUCCESS;
 80294e0:	2000      	movs	r0, #0
 80294e2:	e7e9      	b.n	80294b8 <LmHandlerRequestClass+0x3c>
                    if( currentClass != CLASS_A )
 80294e4:	2b00      	cmp	r3, #0
 80294e6:	d122      	bne.n	802952e <LmHandlerRequestClass+0xb2>
                        mibReq.Param.Class = newClass;
 80294e8:	466b      	mov	r3, sp
 80294ea:	711c      	strb	r4, [r3, #4]
                        if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 80294ec:	4668      	mov	r0, sp
 80294ee:	f003 ffe1 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 80294f2:	2800      	cmp	r0, #0
 80294f4:	d11e      	bne.n	8029534 <LmHandlerRequestClass+0xb8>
                            if( LmHandlerCallbacks->OnClassChange != NULL )
 80294f6:	4b12      	ldr	r3, [pc, #72]	; (8029540 <LmHandlerRequestClass+0xc4>)
 80294f8:	681b      	ldr	r3, [r3, #0]
 80294fa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80294fc:	2b00      	cmp	r3, #0
 80294fe:	d01c      	beq.n	802953a <LmHandlerRequestClass+0xbe>
                                LmHandlerCallbacks->OnClassChange( newClass );
 8029500:	0020      	movs	r0, r4
 8029502:	4798      	blx	r3
    LmHandlerErrorStatus_t errorStatus = LORAMAC_HANDLER_SUCCESS;
 8029504:	2000      	movs	r0, #0
 8029506:	e7d7      	b.n	80294b8 <LmHandlerRequestClass+0x3c>
        return LORAMAC_HANDLER_BUSY_ERROR;
 8029508:	2002      	movs	r0, #2
 802950a:	4240      	negs	r0, r0
 802950c:	e7d4      	b.n	80294b8 <LmHandlerRequestClass+0x3c>
        return LORAMAC_HANDLER_NO_NETWORK_JOINED;
 802950e:	2003      	movs	r0, #3
 8029510:	4240      	negs	r0, r0
 8029512:	e7d1      	b.n	80294b8 <LmHandlerRequestClass+0x3c>
        return LORAMAC_HANDLER_ERROR;
 8029514:	2001      	movs	r0, #1
 8029516:	4240      	negs	r0, r0
 8029518:	e7ce      	b.n	80294b8 <LmHandlerRequestClass+0x3c>
    LmHandlerErrorStatus_t errorStatus = LORAMAC_HANDLER_SUCCESS;
 802951a:	2000      	movs	r0, #0
 802951c:	e7cc      	b.n	80294b8 <LmHandlerRequestClass+0x3c>
                    errorStatus = LORAMAC_HANDLER_ERROR;
 802951e:	2001      	movs	r0, #1
 8029520:	4240      	negs	r0, r0
 8029522:	e7c9      	b.n	80294b8 <LmHandlerRequestClass+0x3c>
                            errorStatus = LORAMAC_HANDLER_ERROR;
 8029524:	2001      	movs	r0, #1
 8029526:	4240      	negs	r0, r0
 8029528:	e7c6      	b.n	80294b8 <LmHandlerRequestClass+0x3c>
    LmHandlerErrorStatus_t errorStatus = LORAMAC_HANDLER_SUCCESS;
 802952a:	2000      	movs	r0, #0
 802952c:	e7c4      	b.n	80294b8 <LmHandlerRequestClass+0x3c>
                        errorStatus = LORAMAC_HANDLER_ERROR;
 802952e:	2001      	movs	r0, #1
 8029530:	4240      	negs	r0, r0
 8029532:	e7c1      	b.n	80294b8 <LmHandlerRequestClass+0x3c>
                            errorStatus = LORAMAC_HANDLER_ERROR;
 8029534:	2001      	movs	r0, #1
 8029536:	4240      	negs	r0, r0
 8029538:	e7be      	b.n	80294b8 <LmHandlerRequestClass+0x3c>
    LmHandlerErrorStatus_t errorStatus = LORAMAC_HANDLER_SUCCESS;
 802953a:	2000      	movs	r0, #0
 802953c:	e7bc      	b.n	80294b8 <LmHandlerRequestClass+0x3c>
 802953e:	46c0      	nop			; (mov r8, r8)
 8029540:	2000ba5c 	.word	0x2000ba5c

08029544 <LmHandlerGetCurrentClass>:
{
 8029544:	b510      	push	{r4, lr}
 8029546:	b08a      	sub	sp, #40	; 0x28
 8029548:	1e04      	subs	r4, r0, #0
    if( deviceClass == NULL )
 802954a:	d00c      	beq.n	8029566 <LmHandlerGetCurrentClass+0x22>
    mibReq.Type = MIB_DEVICE_CLASS;
 802954c:	2300      	movs	r3, #0
 802954e:	466a      	mov	r2, sp
 8029550:	7013      	strb	r3, [r2, #0]
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029552:	4668      	mov	r0, sp
 8029554:	f003 fe82 	bl	802d25c <LoRaMacMibGetRequestConfirm>
 8029558:	2800      	cmp	r0, #0
 802955a:	d107      	bne.n	802956c <LmHandlerGetCurrentClass+0x28>
    *deviceClass = mibReq.Param.Class;
 802955c:	466b      	mov	r3, sp
 802955e:	791b      	ldrb	r3, [r3, #4]
 8029560:	7023      	strb	r3, [r4, #0]
}
 8029562:	b00a      	add	sp, #40	; 0x28
 8029564:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029566:	2001      	movs	r0, #1
 8029568:	4240      	negs	r0, r0
 802956a:	e7fa      	b.n	8029562 <LmHandlerGetCurrentClass+0x1e>
        return LORAMAC_HANDLER_ERROR;
 802956c:	2001      	movs	r0, #1
 802956e:	4240      	negs	r0, r0
 8029570:	e7f7      	b.n	8029562 <LmHandlerGetCurrentClass+0x1e>
	...

08029574 <McpsIndication>:
{
 8029574:	b510      	push	{r4, lr}
 8029576:	b084      	sub	sp, #16
 8029578:	0004      	movs	r4, r0
    DeviceClass_t deviceClass = CLASS_A;
 802957a:	466b      	mov	r3, sp
 802957c:	2200      	movs	r2, #0
 802957e:	71da      	strb	r2, [r3, #7]
    RxParams.IsMcpsIndication = 1;
 8029580:	4a1e      	ldr	r2, [pc, #120]	; (80295fc <McpsIndication+0x88>)
 8029582:	2301      	movs	r3, #1
 8029584:	7013      	strb	r3, [r2, #0]
    RxParams.Status = mcpsIndication->Status;
 8029586:	7843      	ldrb	r3, [r0, #1]
 8029588:	7053      	strb	r3, [r2, #1]
    if( RxParams.Status != LORAMAC_EVENT_INFO_STATUS_OK )
 802958a:	2b00      	cmp	r3, #0
 802958c:	d133      	bne.n	80295f6 <McpsIndication+0x82>
    RxParams.Datarate = mcpsIndication->RxDatarate;
 802958e:	2204      	movs	r2, #4
 8029590:	5682      	ldrsb	r2, [r0, r2]
 8029592:	4b1a      	ldr	r3, [pc, #104]	; (80295fc <McpsIndication+0x88>)
 8029594:	721a      	strb	r2, [r3, #8]
    RxParams.Rssi = rxStatus->Rssi;
 8029596:	2000      	movs	r0, #0
 8029598:	5e0a      	ldrsh	r2, [r1, r0]
 802959a:	725a      	strb	r2, [r3, #9]
    RxParams.Snr = rxStatus->Snr;
 802959c:	2202      	movs	r2, #2
 802959e:	568a      	ldrsb	r2, [r1, r2]
 80295a0:	729a      	strb	r2, [r3, #10]
    RxParams.RxSlot = rxStatus->RxSlot;
 80295a2:	78ca      	ldrb	r2, [r1, #3]
 80295a4:	741a      	strb	r2, [r3, #16]
    RxParams.DownlinkCounter = mcpsIndication->DownLinkCounter;
 80295a6:	6922      	ldr	r2, [r4, #16]
 80295a8:	60da      	str	r2, [r3, #12]
    appData.Port = mcpsIndication->Port;
 80295aa:	78e2      	ldrb	r2, [r4, #3]
 80295ac:	ab02      	add	r3, sp, #8
 80295ae:	701a      	strb	r2, [r3, #0]
    appData.BufferSize = mcpsIndication->BufferSize;
 80295b0:	7b22      	ldrb	r2, [r4, #12]
 80295b2:	705a      	strb	r2, [r3, #1]
    appData.Buffer = mcpsIndication->Buffer;
 80295b4:	68a2      	ldr	r2, [r4, #8]
 80295b6:	9203      	str	r2, [sp, #12]
    if( LmHandlerCallbacks->OnRxData != NULL )
 80295b8:	4b11      	ldr	r3, [pc, #68]	; (8029600 <McpsIndication+0x8c>)
 80295ba:	681b      	ldr	r3, [r3, #0]
 80295bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80295be:	2b00      	cmp	r3, #0
 80295c0:	d002      	beq.n	80295c8 <McpsIndication+0x54>
        LmHandlerCallbacks->OnRxData( &appData, &RxParams );
 80295c2:	490e      	ldr	r1, [pc, #56]	; (80295fc <McpsIndication+0x88>)
 80295c4:	a802      	add	r0, sp, #8
 80295c6:	4798      	blx	r3
    if( ( LmHandlerCallbacks->OnSysTimeUpdate != NULL ) && ( mcpsIndication->DeviceTimeAnsReceived == true ) )
 80295c8:	4b0d      	ldr	r3, [pc, #52]	; (8029600 <McpsIndication+0x8c>)
 80295ca:	681b      	ldr	r3, [r3, #0]
 80295cc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80295ce:	2b00      	cmp	r3, #0
 80295d0:	d003      	beq.n	80295da <McpsIndication+0x66>
 80295d2:	7e22      	ldrb	r2, [r4, #24]
 80295d4:	2a00      	cmp	r2, #0
 80295d6:	d000      	beq.n	80295da <McpsIndication+0x66>
        LmHandlerCallbacks->OnSysTimeUpdate( );
 80295d8:	4798      	blx	r3
    LmHandlerPackagesNotify( PACKAGE_MCPS_INDICATION, mcpsIndication );
 80295da:	0021      	movs	r1, r4
 80295dc:	2001      	movs	r0, #1
 80295de:	f7ff fd0b 	bl	8028ff8 <LmHandlerPackagesNotify>
    LmHandlerGetCurrentClass( &deviceClass );
 80295e2:	466b      	mov	r3, sp
 80295e4:	1dd8      	adds	r0, r3, #7
 80295e6:	f7ff ffad 	bl	8029544 <LmHandlerGetCurrentClass>
    if( mcpsIndication->IsUplinkTxPending != 0 )
 80295ea:	7963      	ldrb	r3, [r4, #5]
 80295ec:	2b00      	cmp	r3, #0
 80295ee:	d002      	beq.n	80295f6 <McpsIndication+0x82>
        IsUplinkTxPending = true;
 80295f0:	4b04      	ldr	r3, [pc, #16]	; (8029604 <McpsIndication+0x90>)
 80295f2:	2201      	movs	r2, #1
 80295f4:	701a      	strb	r2, [r3, #0]
}
 80295f6:	b004      	add	sp, #16
 80295f8:	bd10      	pop	{r4, pc}
 80295fa:	46c0      	nop			; (mov r8, r8)
 80295fc:	2000b064 	.word	0x2000b064
 8029600:	2000ba5c 	.word	0x2000ba5c
 8029604:	2000ba58 	.word	0x2000ba58

08029608 <LmHandlerGetTxDatarate>:
{
 8029608:	b510      	push	{r4, lr}
 802960a:	b08a      	sub	sp, #40	; 0x28
 802960c:	1e04      	subs	r4, r0, #0
    if( txDatarate == NULL )
 802960e:	d00f      	beq.n	8029630 <LmHandlerGetTxDatarate+0x28>
    mibGet.Type = MIB_CHANNELS_DATARATE;
 8029610:	2320      	movs	r3, #32
 8029612:	466a      	mov	r2, sp
 8029614:	7013      	strb	r3, [r2, #0]
    if( LoRaMacMibGetRequestConfirm( &mibGet ) != LORAMAC_STATUS_OK )
 8029616:	4668      	mov	r0, sp
 8029618:	f003 fe20 	bl	802d25c <LoRaMacMibGetRequestConfirm>
 802961c:	2800      	cmp	r0, #0
 802961e:	d10a      	bne.n	8029636 <LmHandlerGetTxDatarate+0x2e>
    *txDatarate = mibGet.Param.ChannelsDatarate;
 8029620:	466b      	mov	r3, sp
 8029622:	791b      	ldrb	r3, [r3, #4]
 8029624:	b25b      	sxtb	r3, r3
 8029626:	7023      	strb	r3, [r4, #0]
    LmHandlerParams.TxDatarate = *txDatarate;
 8029628:	4a04      	ldr	r2, [pc, #16]	; (802963c <LmHandlerGetTxDatarate+0x34>)
 802962a:	7113      	strb	r3, [r2, #4]
}
 802962c:	b00a      	add	sp, #40	; 0x28
 802962e:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029630:	2001      	movs	r0, #1
 8029632:	4240      	negs	r0, r0
 8029634:	e7fa      	b.n	802962c <LmHandlerGetTxDatarate+0x24>
        return LORAMAC_HANDLER_ERROR;
 8029636:	2001      	movs	r0, #1
 8029638:	4240      	negs	r0, r0
 802963a:	e7f7      	b.n	802962c <LmHandlerGetTxDatarate+0x24>
 802963c:	2000ba74 	.word	0x2000ba74

08029640 <LmHandlerGetActiveRegion>:
    if( region == NULL )
 8029640:	2800      	cmp	r0, #0
 8029642:	d004      	beq.n	802964e <LmHandlerGetActiveRegion+0xe>
    *region = LmHandlerParams.ActiveRegion;
 8029644:	4b03      	ldr	r3, [pc, #12]	; (8029654 <LmHandlerGetActiveRegion+0x14>)
 8029646:	781b      	ldrb	r3, [r3, #0]
 8029648:	7003      	strb	r3, [r0, #0]
    return LORAMAC_HANDLER_SUCCESS;
 802964a:	2000      	movs	r0, #0
}
 802964c:	4770      	bx	lr
        return LORAMAC_HANDLER_ERROR;
 802964e:	2001      	movs	r0, #1
 8029650:	4240      	negs	r0, r0
 8029652:	e7fb      	b.n	802964c <LmHandlerGetActiveRegion+0xc>
 8029654:	2000ba74 	.word	0x2000ba74

08029658 <LmHandlerSetSystemMaxRxError>:
{
 8029658:	b500      	push	{lr}
 802965a:	b08b      	sub	sp, #44	; 0x2c
    mibReq.Type = MIB_SYSTEM_MAX_RX_ERROR;
 802965c:	2323      	movs	r3, #35	; 0x23
 802965e:	466a      	mov	r2, sp
 8029660:	7013      	strb	r3, [r2, #0]
    mibReq.Param.SystemMaxRxError = maxErrorInMs;
 8029662:	9001      	str	r0, [sp, #4]
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029664:	4668      	mov	r0, sp
 8029666:	f003 ff25 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 802966a:	2800      	cmp	r0, #0
 802966c:	d101      	bne.n	8029672 <LmHandlerSetSystemMaxRxError+0x1a>
}
 802966e:	b00b      	add	sp, #44	; 0x2c
 8029670:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 8029672:	2001      	movs	r0, #1
 8029674:	4240      	negs	r0, r0
 8029676:	e7fa      	b.n	802966e <LmHandlerSetSystemMaxRxError+0x16>

08029678 <LmHandlerConfigure>:
{
 8029678:	b570      	push	{r4, r5, r6, lr}
 802967a:	b08e      	sub	sp, #56	; 0x38
 802967c:	0001      	movs	r1, r0
    memcpy1( ( void * )&LmHandlerParams, ( const void * )handlerParams, sizeof( LmHandlerParams_t ) );
 802967e:	4c6b      	ldr	r4, [pc, #428]	; (802982c <LmHandlerConfigure+0x1b4>)
 8029680:	2218      	movs	r2, #24
 8029682:	0020      	movs	r0, r4
 8029684:	f008 fd3d 	bl	8032102 <memcpy1>
    IsUplinkTxPending = false;
 8029688:	4b69      	ldr	r3, [pc, #420]	; (8029830 <LmHandlerConfigure+0x1b8>)
 802968a:	2200      	movs	r2, #0
 802968c:	701a      	strb	r2, [r3, #0]
    loraInfo = LoraInfo_GetPtr();
 802968e:	f7f8 ff73 	bl	8022578 <LoraInfo_GetPtr>
    if( 0U == ( ( 1 << ( LmHandlerParams.ActiveRegion ) ) & ( loraInfo->Region ) ) )
 8029692:	7822      	ldrb	r2, [r4, #0]
 8029694:	2301      	movs	r3, #1
 8029696:	4093      	lsls	r3, r2
 8029698:	6841      	ldr	r1, [r0, #4]
 802969a:	4219      	tst	r1, r3
 802969c:	d106      	bne.n	80296ac <LmHandlerConfigure+0x34>
        MW_LOG( TS_ON, VLEVEL_ALWAYS, "error: Region is not defined in the MW: set lorawan_conf.h accordingly\r\n" );
 802969e:	4b65      	ldr	r3, [pc, #404]	; (8029834 <LmHandlerConfigure+0x1bc>)
 80296a0:	2201      	movs	r2, #1
 80296a2:	2100      	movs	r1, #0
 80296a4:	2000      	movs	r0, #0
 80296a6:	f00a fbe3 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
        while( 1 ) {} /* error: Region is not defined in the MW */
 80296aa:	e7fe      	b.n	80296aa <LmHandlerConfigure+0x32>
    if( LoRaMacInitialization( &LoRaMacPrimitives, &LoRaMacCallbacks, LmHandlerParams.ActiveRegion ) != LORAMAC_STATUS_OK )
 80296ac:	4962      	ldr	r1, [pc, #392]	; (8029838 <LmHandlerConfigure+0x1c0>)
 80296ae:	4863      	ldr	r0, [pc, #396]	; (802983c <LmHandlerConfigure+0x1c4>)
 80296b0:	f003 fb1e 	bl	802ccf0 <LoRaMacInitialization>
 80296b4:	2800      	cmp	r0, #0
 80296b6:	d000      	beq.n	80296ba <LmHandlerConfigure+0x42>
 80296b8:	e0b1      	b.n	802981e <LmHandlerConfigure+0x1a6>
    mibReq.Type = MIB_NVM_CTXS;
 80296ba:	a804      	add	r0, sp, #16
 80296bc:	2327      	movs	r3, #39	; 0x27
 80296be:	7003      	strb	r3, [r0, #0]
    if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 80296c0:	f003 fef8 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 80296c4:	2800      	cmp	r0, #0
 80296c6:	d000      	beq.n	80296ca <LmHandlerConfigure+0x52>
 80296c8:	e079      	b.n	80297be <LmHandlerConfigure+0x146>
        CtxRestoreDone = true;
 80296ca:	4b5d      	ldr	r3, [pc, #372]	; (8029840 <LmHandlerConfigure+0x1c8>)
 80296cc:	2201      	movs	r2, #1
 80296ce:	701a      	strb	r2, [r3, #0]
    if( CtxRestoreDone == true )
 80296d0:	4b5b      	ldr	r3, [pc, #364]	; (8029840 <LmHandlerConfigure+0x1c8>)
 80296d2:	781b      	ldrb	r3, [r3, #0]
 80296d4:	2b00      	cmp	r3, #0
 80296d6:	d100      	bne.n	80296da <LmHandlerConfigure+0x62>
 80296d8:	e099      	b.n	802980e <LmHandlerConfigure+0x196>
        if( LmHandlerCallbacks->OnNvmDataChange != NULL )
 80296da:	4b5a      	ldr	r3, [pc, #360]	; (8029844 <LmHandlerConfigure+0x1cc>)
 80296dc:	681b      	ldr	r3, [r3, #0]
 80296de:	69db      	ldr	r3, [r3, #28]
 80296e0:	2b00      	cmp	r3, #0
 80296e2:	d001      	beq.n	80296e8 <LmHandlerConfigure+0x70>
            LmHandlerCallbacks->OnNvmDataChange( LORAMAC_HANDLER_NVM_RESTORE );
 80296e4:	2000      	movs	r0, #0
 80296e6:	4798      	blx	r3
        mibReq.Type = MIB_NVM_CTXS;
 80296e8:	ac04      	add	r4, sp, #16
 80296ea:	2327      	movs	r3, #39	; 0x27
 80296ec:	7023      	strb	r3, [r4, #0]
        LoRaMacMibGetRequestConfirm( &mibReq );
 80296ee:	0020      	movs	r0, r4
 80296f0:	f003 fdb4 	bl	802d25c <LoRaMacMibGetRequestConfirm>
        LoRaMacNvmData_t *current_nvm = mibReq.Param.Contexts;
 80296f4:	9a05      	ldr	r2, [sp, #20]
        LmHandlerParams.ActiveRegion = current_nvm->MacGroup2.Region;
 80296f6:	2348      	movs	r3, #72	; 0x48
 80296f8:	5cd1      	ldrb	r1, [r2, r3]
 80296fa:	4b4c      	ldr	r3, [pc, #304]	; (802982c <LmHandlerConfigure+0x1b4>)
 80296fc:	7019      	strb	r1, [r3, #0]
        LmHandlerParams.DefaultClass = current_nvm->MacGroup2.DeviceClass;
 80296fe:	218c      	movs	r1, #140	; 0x8c
 8029700:	0049      	lsls	r1, r1, #1
 8029702:	5c51      	ldrb	r1, [r2, r1]
 8029704:	7059      	strb	r1, [r3, #1]
        LmHandlerParams.AdrEnable = current_nvm->MacGroup2.AdrCtrlOn;
 8029706:	218d      	movs	r1, #141	; 0x8d
 8029708:	0049      	lsls	r1, r1, #1
 802970a:	5c52      	ldrb	r2, [r2, r1]
 802970c:	709a      	strb	r2, [r3, #2]
    if( SecureElementInitMcuID( LoRaMacCallbacks.GetUniqueId, LoRaMacCallbacks.GetDevAddress ) != SECURE_ELEMENT_SUCCESS )
 802970e:	4b4a      	ldr	r3, [pc, #296]	; (8029838 <LmHandlerConfigure+0x1c0>)
 8029710:	68d9      	ldr	r1, [r3, #12]
 8029712:	6898      	ldr	r0, [r3, #8]
 8029714:	f008 fc1d 	bl	8031f52 <SecureElementInitMcuID>
 8029718:	2800      	cmp	r0, #0
 802971a:	d000      	beq.n	802971e <LmHandlerConfigure+0xa6>
 802971c:	e082      	b.n	8029824 <LmHandlerConfigure+0x1ac>
    mibReq.Type = MIB_DEV_ADDR;
 802971e:	ac04      	add	r4, sp, #16
 8029720:	2306      	movs	r3, #6
 8029722:	7023      	strb	r3, [r4, #0]
    LoRaMacMibGetRequestConfirm( &mibReq );
 8029724:	0020      	movs	r0, r4
 8029726:	f003 fd99 	bl	802d25c <LoRaMacMibGetRequestConfirm>
    CommissioningParams.DevAddr = mibReq.Param.DevAddr;
 802972a:	4d47      	ldr	r5, [pc, #284]	; (8029848 <LmHandlerConfigure+0x1d0>)
 802972c:	6863      	ldr	r3, [r4, #4]
 802972e:	616b      	str	r3, [r5, #20]
    LoRaMacMibSetRequestConfirm( &mibReq );
 8029730:	0020      	movs	r0, r4
 8029732:	f003 febf 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_DEV_EUI;
 8029736:	2302      	movs	r3, #2
 8029738:	7023      	strb	r3, [r4, #0]
    mibReq.Param.DevEui = CommissioningParams.DevEui;
 802973a:	6065      	str	r5, [r4, #4]
    LoRaMacMibGetRequestConfirm( &mibReq );
 802973c:	0020      	movs	r0, r4
 802973e:	f003 fd8d 	bl	802d25c <LoRaMacMibGetRequestConfirm>
    mibReq.Type = MIB_JOIN_EUI;
 8029742:	2303      	movs	r3, #3
 8029744:	7023      	strb	r3, [r4, #0]
    mibReq.Param.JoinEui = CommissioningParams.JoinEui;
 8029746:	3508      	adds	r5, #8
 8029748:	6065      	str	r5, [r4, #4]
    LoRaMacMibGetRequestConfirm( &mibReq );
 802974a:	0020      	movs	r0, r4
 802974c:	f003 fd86 	bl	802d25c <LoRaMacMibGetRequestConfirm>
    SecureElementPrintKeys();
 8029750:	f008 fc88 	bl	8032064 <SecureElementPrintKeys>
    MW_LOG( TS_OFF, VLEVEL_L, "###### KMS ENABLED \r\n" );
 8029754:	4b3d      	ldr	r3, [pc, #244]	; (802984c <LmHandlerConfigure+0x1d4>)
 8029756:	2200      	movs	r2, #0
 8029758:	2100      	movs	r1, #0
 802975a:	2001      	movs	r0, #1
 802975c:	f00a fb88 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
    mibReq.Type = MIB_PUBLIC_NETWORK;
 8029760:	260f      	movs	r6, #15
 8029762:	7026      	strb	r6, [r4, #0]
    mibReq.Param.EnablePublicNetwork = LORAWAN_PUBLIC_NETWORK;
 8029764:	2301      	movs	r3, #1
 8029766:	7123      	strb	r3, [r4, #4]
    LoRaMacMibSetRequestConfirm( &mibReq );
 8029768:	0020      	movs	r0, r4
 802976a:	f003 fea3 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_REPEATER_SUPPORT;
 802976e:	2310      	movs	r3, #16
 8029770:	7023      	strb	r3, [r4, #0]
    mibReq.Param.EnableRepeaterSupport = LORAWAN_REPEATER_SUPPORT;
 8029772:	2300      	movs	r3, #0
 8029774:	7123      	strb	r3, [r4, #4]
    LoRaMacMibSetRequestConfirm( &mibReq );
 8029776:	0020      	movs	r0, r4
 8029778:	f003 fe9c 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_ADR;
 802977c:	2304      	movs	r3, #4
 802977e:	7023      	strb	r3, [r4, #0]
    mibReq.Param.AdrEnable = LmHandlerParams.AdrEnable;
 8029780:	4d2a      	ldr	r5, [pc, #168]	; (802982c <LmHandlerConfigure+0x1b4>)
 8029782:	78ab      	ldrb	r3, [r5, #2]
 8029784:	7123      	strb	r3, [r4, #4]
    LoRaMacMibSetRequestConfirm( &mibReq );
 8029786:	0020      	movs	r0, r4
 8029788:	f003 fe94 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
    mibReq.Type = MIB_RXB_C_TIMEOUT;
 802978c:	233a      	movs	r3, #58	; 0x3a
 802978e:	7023      	strb	r3, [r4, #0]
    mibReq.Param.RxBCTimeout = LmHandlerParams.RxBCTimeout;
 8029790:	696b      	ldr	r3, [r5, #20]
 8029792:	6063      	str	r3, [r4, #4]
    LoRaMacMibSetRequestConfirm( &mibReq );
 8029794:	0020      	movs	r0, r4
 8029796:	f003 fe8d 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
    getPhy.Attribute = PHY_DUTY_CYCLE;
 802979a:	a902      	add	r1, sp, #8
 802979c:	700e      	strb	r6, [r1, #0]
    phyParam = RegionGetPhyParam( LmHandlerParams.ActiveRegion, &getPhy );
 802979e:	7828      	ldrb	r0, [r5, #0]
 80297a0:	f005 fc26 	bl	802eff0 <RegionGetPhyParam>
 80297a4:	9001      	str	r0, [sp, #4]
    LmHandlerParams.DutyCycleEnabled = ( bool ) phyParam.Value;
 80297a6:	1e43      	subs	r3, r0, #1
 80297a8:	4198      	sbcs	r0, r3
 80297aa:	71e8      	strb	r0, [r5, #7]
    LmHandlerSetSystemMaxRxError( 20 );
 80297ac:	2014      	movs	r0, #20
 80297ae:	f7ff ff53 	bl	8029658 <LmHandlerSetSystemMaxRxError>
    LoRaMacTestSetDutyCycleOn( LmHandlerParams.DutyCycleEnabled );
 80297b2:	79e8      	ldrb	r0, [r5, #7]
 80297b4:	f004 fb10 	bl	802ddd8 <LoRaMacTestSetDutyCycleOn>
    return LORAMAC_HANDLER_SUCCESS;
 80297b8:	2000      	movs	r0, #0
}
 80297ba:	b00e      	add	sp, #56	; 0x38
 80297bc:	bd70      	pop	{r4, r5, r6, pc}
        mibReq.Type = MIB_NVM_BKP_CTXS;
 80297be:	ab04      	add	r3, sp, #16
 80297c0:	2228      	movs	r2, #40	; 0x28
 80297c2:	701a      	strb	r2, [r3, #0]
        if( LmHandlerCallbacks->OnRestoreContextRequest != NULL )
 80297c4:	4b1f      	ldr	r3, [pc, #124]	; (8029844 <LmHandlerConfigure+0x1cc>)
 80297c6:	681b      	ldr	r3, [r3, #0]
 80297c8:	691b      	ldr	r3, [r3, #16]
 80297ca:	2b00      	cmp	r3, #0
 80297cc:	d008      	beq.n	80297e0 <LmHandlerConfigure+0x168>
            LoRaMacMibGetRequestConfirm( &mibReq );
 80297ce:	a804      	add	r0, sp, #16
 80297d0:	f003 fd44 	bl	802d25c <LoRaMacMibGetRequestConfirm>
            LmHandlerCallbacks->OnRestoreContextRequest( mibReq.Param.BackupContexts, sizeof( LoRaMacNvmData_t ) );
 80297d4:	4b1b      	ldr	r3, [pc, #108]	; (8029844 <LmHandlerConfigure+0x1cc>)
 80297d6:	681b      	ldr	r3, [r3, #0]
 80297d8:	691b      	ldr	r3, [r3, #16]
 80297da:	9805      	ldr	r0, [sp, #20]
 80297dc:	491c      	ldr	r1, [pc, #112]	; (8029850 <LmHandlerConfigure+0x1d8>)
 80297de:	4798      	blx	r3
        mibReq.Type = MIB_NVM_CTXS;
 80297e0:	a804      	add	r0, sp, #16
 80297e2:	2327      	movs	r3, #39	; 0x27
 80297e4:	7003      	strb	r3, [r0, #0]
        if( LoRaMacMibSetRequestConfirm( &mibReq ) == LORAMAC_STATUS_OK )
 80297e6:	f003 fe65 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 80297ea:	2800      	cmp	r0, #0
 80297ec:	d000      	beq.n	80297f0 <LmHandlerConfigure+0x178>
 80297ee:	e76f      	b.n	80296d0 <LmHandlerConfigure+0x58>
            mibReq.Type = MIB_NETWORK_ACTIVATION;
 80297f0:	2301      	movs	r3, #1
 80297f2:	466a      	mov	r2, sp
 80297f4:	7413      	strb	r3, [r2, #16]
            LoRaMacMibGetRequestConfirm( &mibReq );
 80297f6:	a804      	add	r0, sp, #16
 80297f8:	f003 fd30 	bl	802d25c <LoRaMacMibGetRequestConfirm>
            if( mibReq.Param.NetworkActivation != ACTIVATION_TYPE_NONE )
 80297fc:	466b      	mov	r3, sp
 80297fe:	7d1b      	ldrb	r3, [r3, #20]
 8029800:	2b00      	cmp	r3, #0
 8029802:	d100      	bne.n	8029806 <LmHandlerConfigure+0x18e>
 8029804:	e764      	b.n	80296d0 <LmHandlerConfigure+0x58>
                CtxRestoreDone = true;
 8029806:	4b0e      	ldr	r3, [pc, #56]	; (8029840 <LmHandlerConfigure+0x1c8>)
 8029808:	2201      	movs	r2, #1
 802980a:	701a      	strb	r2, [r3, #0]
 802980c:	e760      	b.n	80296d0 <LmHandlerConfigure+0x58>
        mibReq.Type = MIB_NET_ID;
 802980e:	a804      	add	r0, sp, #16
 8029810:	2305      	movs	r3, #5
 8029812:	7003      	strb	r3, [r0, #0]
        mibReq.Param.NetID = LORAWAN_NETWORK_ID;
 8029814:	2300      	movs	r3, #0
 8029816:	6043      	str	r3, [r0, #4]
        LoRaMacMibSetRequestConfirm( &mibReq );
 8029818:	f003 fe4c 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 802981c:	e777      	b.n	802970e <LmHandlerConfigure+0x96>
        return LORAMAC_HANDLER_ERROR;
 802981e:	2001      	movs	r0, #1
 8029820:	4240      	negs	r0, r0
 8029822:	e7ca      	b.n	80297ba <LmHandlerConfigure+0x142>
        return LORAMAC_HANDLER_ERROR;
 8029824:	2001      	movs	r0, #1
 8029826:	4240      	negs	r0, r0
 8029828:	e7c7      	b.n	80297ba <LmHandlerConfigure+0x142>
 802982a:	46c0      	nop			; (mov r8, r8)
 802982c:	2000ba74 	.word	0x2000ba74
 8029830:	2000ba58 	.word	0x2000ba58
 8029834:	08035154 	.word	0x08035154
 8029838:	2000ba9c 	.word	0x2000ba9c
 802983c:	2000bab4 	.word	0x2000bab4
 8029840:	2000ba50 	.word	0x2000ba50
 8029844:	2000ba5c 	.word	0x2000ba5c
 8029848:	2000ba38 	.word	0x2000ba38
 802984c:	080351a0 	.word	0x080351a0
 8029850:	000004fc 	.word	0x000004fc

08029854 <LmHandlerPackageRegister>:
{
 8029854:	b530      	push	{r4, r5, lr}
 8029856:	b083      	sub	sp, #12
 8029858:	0004      	movs	r4, r0
 802985a:	000d      	movs	r5, r1
    LmhPackage_t *package = NULL;
 802985c:	2300      	movs	r3, #0
 802985e:	9301      	str	r3, [sp, #4]
    switch( id )
 8029860:	2800      	cmp	r0, #0
 8029862:	d11c      	bne.n	802989e <LmHandlerPackageRegister+0x4a>
                package = LmhpCompliancePackageFactory( );
 8029864:	f000 fde6 	bl	802a434 <LmhpCompliancePackageFactory>
 8029868:	9001      	str	r0, [sp, #4]
    if( package != NULL )
 802986a:	9b01      	ldr	r3, [sp, #4]
 802986c:	2b00      	cmp	r3, #0
 802986e:	d01e      	beq.n	80298ae <LmHandlerPackageRegister+0x5a>
        LmHandlerPackages[id] = package;
 8029870:	00a4      	lsls	r4, r4, #2
 8029872:	4a10      	ldr	r2, [pc, #64]	; (80298b4 <LmHandlerPackageRegister+0x60>)
 8029874:	50a3      	str	r3, [r4, r2]
        LmHandlerPackages[id]->OnJoinRequest = LmHandlerJoin;
 8029876:	4a10      	ldr	r2, [pc, #64]	; (80298b8 <LmHandlerPackageRegister+0x64>)
 8029878:	629a      	str	r2, [r3, #40]	; 0x28
        LmHandlerPackages[id]->OnSysTimeUpdate = LmHandlerCallbacks->OnSysTimeUpdate;
 802987a:	4a10      	ldr	r2, [pc, #64]	; (80298bc <LmHandlerPackageRegister+0x68>)
 802987c:	6812      	ldr	r2, [r2, #0]
 802987e:	6b91      	ldr	r1, [r2, #56]	; 0x38
 8029880:	6319      	str	r1, [r3, #48]	; 0x30
        LmHandlerPackages[id]->OnSystemReset = LmHandlerCallbacks->OnSystemReset;
 8029882:	6c91      	ldr	r1, [r2, #72]	; 0x48
 8029884:	6359      	str	r1, [r3, #52]	; 0x34
        LmHandlerPackages[id]->OnDeviceTimeRequest = LmHandlerDeviceTimeReq;
 8029886:	490e      	ldr	r1, [pc, #56]	; (80298c0 <LmHandlerPackageRegister+0x6c>)
 8029888:	62d9      	str	r1, [r3, #44]	; 0x2c
        LmHandlerPackages[id]->OnPackageProcessEvent = LmHandlerCallbacks->OnMacProcess;
 802988a:	6992      	ldr	r2, [r2, #24]
 802988c:	615a      	str	r2, [r3, #20]
        LmHandlerPackages[id]->Init( params, AppData.Buffer, AppData.BufferSize );
 802988e:	685b      	ldr	r3, [r3, #4]
 8029890:	22f2      	movs	r2, #242	; 0xf2
 8029892:	490c      	ldr	r1, [pc, #48]	; (80298c4 <LmHandlerPackageRegister+0x70>)
 8029894:	0028      	movs	r0, r5
 8029896:	4798      	blx	r3
        return LORAMAC_HANDLER_SUCCESS;
 8029898:	2000      	movs	r0, #0
}
 802989a:	b003      	add	sp, #12
 802989c:	bd30      	pop	{r4, r5, pc}
                if( LORAMAC_HANDLER_SUCCESS != LmhpPackagesRegister( id, &package ) )
 802989e:	a901      	add	r1, sp, #4
 80298a0:	f000 fdce 	bl	802a440 <LmhpPackagesRegister>
 80298a4:	2800      	cmp	r0, #0
 80298a6:	d0e0      	beq.n	802986a <LmHandlerPackageRegister+0x16>
                    return LORAMAC_HANDLER_ERROR;
 80298a8:	2001      	movs	r0, #1
 80298aa:	4240      	negs	r0, r0
 80298ac:	e7f5      	b.n	802989a <LmHandlerPackageRegister+0x46>
        return LORAMAC_HANDLER_ERROR;
 80298ae:	2001      	movs	r0, #1
 80298b0:	4240      	negs	r0, r0
 80298b2:	e7f2      	b.n	802989a <LmHandlerPackageRegister+0x46>
 80298b4:	2000ba60 	.word	0x2000ba60
 80298b8:	08029199 	.word	0x08029199
 80298bc:	2000ba5c 	.word	0x2000ba5c
 80298c0:	08029279 	.word	0x08029279
 80298c4:	2000b944 	.word	0x2000b944

080298c8 <LmHandlerInit>:
{
 80298c8:	b500      	push	{lr}
 80298ca:	b083      	sub	sp, #12
 80298cc:	9101      	str	r1, [sp, #4]
    LmHandlerCallbacks = handlerCallbacks;
 80298ce:	4b19      	ldr	r3, [pc, #100]	; (8029934 <LmHandlerInit+0x6c>)
 80298d0:	6018      	str	r0, [r3, #0]
    LoRaMacPrimitives.MacMcpsConfirm = McpsConfirm;
 80298d2:	4b19      	ldr	r3, [pc, #100]	; (8029938 <LmHandlerInit+0x70>)
 80298d4:	4a19      	ldr	r2, [pc, #100]	; (802993c <LmHandlerInit+0x74>)
 80298d6:	601a      	str	r2, [r3, #0]
    LoRaMacPrimitives.MacMcpsIndication = McpsIndication;
 80298d8:	4a19      	ldr	r2, [pc, #100]	; (8029940 <LmHandlerInit+0x78>)
 80298da:	605a      	str	r2, [r3, #4]
    LoRaMacPrimitives.MacMlmeConfirm = MlmeConfirm;
 80298dc:	4a19      	ldr	r2, [pc, #100]	; (8029944 <LmHandlerInit+0x7c>)
 80298de:	609a      	str	r2, [r3, #8]
    LoRaMacPrimitives.MacMlmeIndication = MlmeIndication;
 80298e0:	4a19      	ldr	r2, [pc, #100]	; (8029948 <LmHandlerInit+0x80>)
 80298e2:	60da      	str	r2, [r3, #12]
    LoRaMacCallbacks.GetBatteryLevel = LmHandlerCallbacks->GetBatteryLevel;
 80298e4:	4b19      	ldr	r3, [pc, #100]	; (802994c <LmHandlerInit+0x84>)
 80298e6:	6802      	ldr	r2, [r0, #0]
 80298e8:	601a      	str	r2, [r3, #0]
    LoRaMacCallbacks.GetTemperatureLevel = LmHandlerCallbacks->GetTemperature;
 80298ea:	6842      	ldr	r2, [r0, #4]
 80298ec:	605a      	str	r2, [r3, #4]
    LoRaMacCallbacks.GetUniqueId = LmHandlerCallbacks->GetUniqueId;
 80298ee:	6882      	ldr	r2, [r0, #8]
 80298f0:	609a      	str	r2, [r3, #8]
    LoRaMacCallbacks.GetDevAddress = LmHandlerCallbacks->GetDevAddr;
 80298f2:	68c2      	ldr	r2, [r0, #12]
 80298f4:	60da      	str	r2, [r3, #12]
    LoRaMacCallbacks.NvmDataChange  = NvmDataMgmtEvent;
 80298f6:	4a16      	ldr	r2, [pc, #88]	; (8029950 <LmHandlerInit+0x88>)
 80298f8:	611a      	str	r2, [r3, #16]
    LoRaMacCallbacks.MacProcessNotify = LmHandlerCallbacks->OnMacProcess;
 80298fa:	6982      	ldr	r2, [r0, #24]
 80298fc:	615a      	str	r2, [r3, #20]
    LmhpComplianceParams.FwVersion.Value = fwVersion;
 80298fe:	4915      	ldr	r1, [pc, #84]	; (8029954 <LmHandlerInit+0x8c>)
 8029900:	9b01      	ldr	r3, [sp, #4]
 8029902:	600b      	str	r3, [r1, #0]
    LmhpComplianceParams.OnTxPeriodicityChanged = LmHandlerCallbacks->OnTxPeriodicityChanged;
 8029904:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8029906:	604b      	str	r3, [r1, #4]
    LmhpComplianceParams.OnTxFrameCtrlChanged = LmHandlerOnTxFrameCtrlChanged;
 8029908:	4b13      	ldr	r3, [pc, #76]	; (8029958 <LmHandlerInit+0x90>)
 802990a:	608b      	str	r3, [r1, #8]
    LmhpComplianceParams.OnPingSlotPeriodicityChanged = LmHandlerOnPingSlotPeriodicityChanged;
 802990c:	4b13      	ldr	r3, [pc, #76]	; (802995c <LmHandlerInit+0x94>)
 802990e:	60cb      	str	r3, [r1, #12]
    if( LmHandlerPackageRegister( PACKAGE_ID_COMPLIANCE, &LmhpComplianceParams ) != LORAMAC_HANDLER_SUCCESS )
 8029910:	2000      	movs	r0, #0
 8029912:	f7ff ff9f 	bl	8029854 <LmHandlerPackageRegister>
 8029916:	2800      	cmp	r0, #0
 8029918:	d106      	bne.n	8029928 <LmHandlerInit+0x60>
    if( LmhpPackagesRegistrationInit( ( Version_t * )&fwVersion ) != LORAMAC_HANDLER_SUCCESS )
 802991a:	a801      	add	r0, sp, #4
 802991c:	f000 fd8e 	bl	802a43c <LmhpPackagesRegistrationInit>
 8029920:	2800      	cmp	r0, #0
 8029922:	d104      	bne.n	802992e <LmHandlerInit+0x66>
}
 8029924:	b003      	add	sp, #12
 8029926:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 8029928:	2001      	movs	r0, #1
 802992a:	4240      	negs	r0, r0
 802992c:	e7fa      	b.n	8029924 <LmHandlerInit+0x5c>
        return LORAMAC_HANDLER_ERROR;
 802992e:	2001      	movs	r0, #1
 8029930:	4240      	negs	r0, r0
 8029932:	e7f7      	b.n	8029924 <LmHandlerInit+0x5c>
 8029934:	2000ba5c 	.word	0x2000ba5c
 8029938:	2000bab4 	.word	0x2000bab4
 802993c:	080290b1 	.word	0x080290b1
 8029940:	08029575 	.word	0x08029575
 8029944:	08029c79 	.word	0x08029c79
 8029948:	0802905d 	.word	0x0802905d
 802994c:	2000ba9c 	.word	0x2000ba9c
 8029950:	0802ef95 	.word	0x0802ef95
 8029954:	2000ba8c 	.word	0x2000ba8c
 8029958:	08029161 	.word	0x08029161
 802995c:	0802917d 	.word	0x0802917d

08029960 <LmHandlerGetVersion>:
 *=============================================================================
 */

LmHandlerErrorStatus_t LmHandlerGetVersion( LmHandlerVersionType_t lmhType, uint32_t *featureVersion )
{
    if( featureVersion == NULL )
 8029960:	2900      	cmp	r1, #0
 8029962:	d00d      	beq.n	8029980 <LmHandlerGetVersion+0x20>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    switch( lmhType )
 8029964:	2800      	cmp	r0, #0
 8029966:	d003      	beq.n	8029970 <LmHandlerGetVersion+0x10>
 8029968:	2801      	cmp	r0, #1
 802996a:	d005      	beq.n	8029978 <LmHandlerGetVersion+0x18>
 802996c:	2000      	movs	r0, #0
        default:
            break;
    }

    return LORAMAC_HANDLER_SUCCESS;
}
 802996e:	4770      	bx	lr
            *featureVersion = LORAMAC_VERSION;
 8029970:	4b05      	ldr	r3, [pc, #20]	; (8029988 <LmHandlerGetVersion+0x28>)
 8029972:	600b      	str	r3, [r1, #0]
    return LORAMAC_HANDLER_SUCCESS;
 8029974:	2000      	movs	r0, #0
            break;
 8029976:	e7fa      	b.n	802996e <LmHandlerGetVersion+0xe>
            *featureVersion = REGION_VERSION;
 8029978:	4b04      	ldr	r3, [pc, #16]	; (802998c <LmHandlerGetVersion+0x2c>)
 802997a:	600b      	str	r3, [r1, #0]
    return LORAMAC_HANDLER_SUCCESS;
 802997c:	2000      	movs	r0, #0
            break;
 802997e:	e7f6      	b.n	802996e <LmHandlerGetVersion+0xe>
        return LORAMAC_HANDLER_ERROR;
 8029980:	2001      	movs	r0, #1
 8029982:	4240      	negs	r0, r0
 8029984:	e7f3      	b.n	802996e <LmHandlerGetVersion+0xe>
 8029986:	46c0      	nop			; (mov r8, r8)
 8029988:	01000400 	.word	0x01000400
 802998c:	02010001 	.word	0x02010001

08029990 <LmHandlerStop>:

LmHandlerErrorStatus_t LmHandlerStop( void )
{
 8029990:	b510      	push	{r4, lr}
    if( LoRaMacDeInitialization() == LORAMAC_STATUS_OK )
 8029992:	f004 fa41 	bl	802de18 <LoRaMacDeInitialization>
 8029996:	2800      	cmp	r0, #0
 8029998:	d100      	bne.n	802999c <LmHandlerStop+0xc>
    }
    else
    {
        return LORAMAC_HANDLER_BUSY_ERROR;
    }
}
 802999a:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_BUSY_ERROR;
 802999c:	2002      	movs	r0, #2
 802999e:	4240      	negs	r0, r0
 80299a0:	e7fb      	b.n	802999a <LmHandlerStop+0xa>

080299a2 <LmHandlerHalt>:

LmHandlerErrorStatus_t LmHandlerHalt( void )
{
 80299a2:	b510      	push	{r4, lr}
    if( LoRaMacHalt() == LORAMAC_STATUS_OK )
 80299a4:	f003 fbba 	bl	802d11c <LoRaMacHalt>
 80299a8:	2800      	cmp	r0, #0
 80299aa:	d100      	bne.n	80299ae <LmHandlerHalt+0xc>
    }
    else
    {
        return LORAMAC_HANDLER_BUSY_ERROR;
    }
}
 80299ac:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_BUSY_ERROR;
 80299ae:	2002      	movs	r0, #2
 80299b0:	4240      	negs	r0, r0
 80299b2:	e7fb      	b.n	80299ac <LmHandlerHalt+0xa>

080299b4 <LmHandlerLinkCheckReq>:

LmHandlerErrorStatus_t LmHandlerLinkCheckReq( void )
{
 80299b4:	b500      	push	{lr}
 80299b6:	b087      	sub	sp, #28
    LoRaMacStatus_t status;
    MlmeReq_t mlmeReq;

    mlmeReq.Type = MLME_LINK_CHECK;
 80299b8:	a801      	add	r0, sp, #4
 80299ba:	2305      	movs	r3, #5
 80299bc:	7003      	strb	r3, [r0, #0]

    status = LoRaMacMlmeRequest( &mlmeReq );
 80299be:	f003 ffef 	bl	802d9a0 <LoRaMacMlmeRequest>

    if( status == LORAMAC_STATUS_OK )
 80299c2:	2800      	cmp	r0, #0
 80299c4:	d101      	bne.n	80299ca <LmHandlerLinkCheckReq+0x16>
    }
    else
    {
        return LORAMAC_HANDLER_ERROR;
    }
}
 80299c6:	b007      	add	sp, #28
 80299c8:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 80299ca:	2001      	movs	r0, #1
 80299cc:	4240      	negs	r0, r0
 80299ce:	e7fa      	b.n	80299c6 <LmHandlerLinkCheckReq+0x12>

080299d0 <LmHandlerGetDevEUI>:

LmHandlerErrorStatus_t LmHandlerGetDevEUI( uint8_t *devEUI )
{
 80299d0:	b500      	push	{lr}
 80299d2:	b08b      	sub	sp, #44	; 0x2c
    MibRequestConfirm_t mibReq;
    if( devEUI == NULL )
 80299d4:	2800      	cmp	r0, #0
 80299d6:	d00a      	beq.n	80299ee <LmHandlerGetDevEUI+0x1e>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    mibReq.Type = MIB_DEV_EUI;
 80299d8:	2302      	movs	r3, #2
 80299da:	466a      	mov	r2, sp
 80299dc:	7013      	strb	r3, [r2, #0]
    mibReq.Param.DevEui = devEUI;
 80299de:	9001      	str	r0, [sp, #4]
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 80299e0:	4668      	mov	r0, sp
 80299e2:	f003 fc3b 	bl	802d25c <LoRaMacMibGetRequestConfirm>
 80299e6:	2800      	cmp	r0, #0
 80299e8:	d104      	bne.n	80299f4 <LmHandlerGetDevEUI+0x24>
    {
        return LORAMAC_HANDLER_ERROR;
    }
    return LORAMAC_HANDLER_SUCCESS;
}
 80299ea:	b00b      	add	sp, #44	; 0x2c
 80299ec:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 80299ee:	2001      	movs	r0, #1
 80299f0:	4240      	negs	r0, r0
 80299f2:	e7fa      	b.n	80299ea <LmHandlerGetDevEUI+0x1a>
        return LORAMAC_HANDLER_ERROR;
 80299f4:	2001      	movs	r0, #1
 80299f6:	4240      	negs	r0, r0
 80299f8:	e7f7      	b.n	80299ea <LmHandlerGetDevEUI+0x1a>

080299fa <LmHandlerSetDevEUI>:

LmHandlerErrorStatus_t LmHandlerSetDevEUI( uint8_t *devEUI )
{
 80299fa:	b510      	push	{r4, lr}
 80299fc:	b08a      	sub	sp, #40	; 0x28
 80299fe:	0004      	movs	r4, r0
    MibRequestConfirm_t mibReq;

    /* Not yet joined */
    if( LmHandlerJoinStatus() != LORAMAC_HANDLER_SET )
 8029a00:	f7ff fc72 	bl	80292e8 <LmHandlerJoinStatus>
 8029a04:	2801      	cmp	r0, #1
 8029a06:	d00e      	beq.n	8029a26 <LmHandlerSetDevEUI+0x2c>
    {
        mibReq.Type = MIB_DEV_EUI;
 8029a08:	2302      	movs	r3, #2
 8029a0a:	466a      	mov	r2, sp
 8029a0c:	7013      	strb	r3, [r2, #0]
        mibReq.Param.DevEui = devEUI;
 8029a0e:	9401      	str	r4, [sp, #4]
        if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029a10:	4668      	mov	r0, sp
 8029a12:	f003 fd4f 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 8029a16:	2800      	cmp	r0, #0
 8029a18:	d102      	bne.n	8029a20 <LmHandlerSetDevEUI+0x26>
        {
            return LORAMAC_HANDLER_ERROR;
        }
        return LORAMAC_HANDLER_SUCCESS;
 8029a1a:	2000      	movs	r0, #0
    else
    {
        /* Cannot change Keys in running state */
        return LORAMAC_HANDLER_ERROR;
    }
}
 8029a1c:	b00a      	add	sp, #40	; 0x28
 8029a1e:	bd10      	pop	{r4, pc}
            return LORAMAC_HANDLER_ERROR;
 8029a20:	2001      	movs	r0, #1
 8029a22:	4240      	negs	r0, r0
 8029a24:	e7fa      	b.n	8029a1c <LmHandlerSetDevEUI+0x22>
        return LORAMAC_HANDLER_ERROR;
 8029a26:	2001      	movs	r0, #1
 8029a28:	4240      	negs	r0, r0
 8029a2a:	e7f7      	b.n	8029a1c <LmHandlerSetDevEUI+0x22>

08029a2c <LmHandlerGetAppEUI>:

LmHandlerErrorStatus_t LmHandlerGetAppEUI( uint8_t *appEUI )
{
 8029a2c:	b500      	push	{lr}
 8029a2e:	b08b      	sub	sp, #44	; 0x2c
    MibRequestConfirm_t mibReq;

    if( appEUI == NULL )
 8029a30:	2800      	cmp	r0, #0
 8029a32:	d00a      	beq.n	8029a4a <LmHandlerGetAppEUI+0x1e>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    mibReq.Type = MIB_JOIN_EUI;
 8029a34:	2303      	movs	r3, #3
 8029a36:	466a      	mov	r2, sp
 8029a38:	7013      	strb	r3, [r2, #0]
    mibReq.Param.JoinEui = appEUI;
 8029a3a:	9001      	str	r0, [sp, #4]
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029a3c:	4668      	mov	r0, sp
 8029a3e:	f003 fc0d 	bl	802d25c <LoRaMacMibGetRequestConfirm>
 8029a42:	2800      	cmp	r0, #0
 8029a44:	d104      	bne.n	8029a50 <LmHandlerGetAppEUI+0x24>
    {
        return LORAMAC_HANDLER_ERROR;
    }
    return LORAMAC_HANDLER_SUCCESS;
}
 8029a46:	b00b      	add	sp, #44	; 0x2c
 8029a48:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 8029a4a:	2001      	movs	r0, #1
 8029a4c:	4240      	negs	r0, r0
 8029a4e:	e7fa      	b.n	8029a46 <LmHandlerGetAppEUI+0x1a>
        return LORAMAC_HANDLER_ERROR;
 8029a50:	2001      	movs	r0, #1
 8029a52:	4240      	negs	r0, r0
 8029a54:	e7f7      	b.n	8029a46 <LmHandlerGetAppEUI+0x1a>

08029a56 <LmHandlerSetAppEUI>:

LmHandlerErrorStatus_t LmHandlerSetAppEUI( uint8_t *appEUI )
{
 8029a56:	b510      	push	{r4, lr}
 8029a58:	b08a      	sub	sp, #40	; 0x28
 8029a5a:	0004      	movs	r4, r0
    MibRequestConfirm_t mibReq;

    /* Not yet joined */
    if( LmHandlerJoinStatus() != LORAMAC_HANDLER_SET )
 8029a5c:	f7ff fc44 	bl	80292e8 <LmHandlerJoinStatus>
 8029a60:	2801      	cmp	r0, #1
 8029a62:	d00e      	beq.n	8029a82 <LmHandlerSetAppEUI+0x2c>
    {
        mibReq.Type = MIB_JOIN_EUI;
 8029a64:	2303      	movs	r3, #3
 8029a66:	466a      	mov	r2, sp
 8029a68:	7013      	strb	r3, [r2, #0]
        mibReq.Param.JoinEui = appEUI;
 8029a6a:	9401      	str	r4, [sp, #4]
        if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029a6c:	4668      	mov	r0, sp
 8029a6e:	f003 fd21 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 8029a72:	2800      	cmp	r0, #0
 8029a74:	d102      	bne.n	8029a7c <LmHandlerSetAppEUI+0x26>
        {
            return LORAMAC_HANDLER_ERROR;
        }
        return LORAMAC_HANDLER_SUCCESS;
 8029a76:	2000      	movs	r0, #0
    else
    {
        /* Cannot change Keys in running state */
        return LORAMAC_HANDLER_ERROR;
    }
}
 8029a78:	b00a      	add	sp, #40	; 0x28
 8029a7a:	bd10      	pop	{r4, pc}
            return LORAMAC_HANDLER_ERROR;
 8029a7c:	2001      	movs	r0, #1
 8029a7e:	4240      	negs	r0, r0
 8029a80:	e7fa      	b.n	8029a78 <LmHandlerSetAppEUI+0x22>
        return LORAMAC_HANDLER_ERROR;
 8029a82:	2001      	movs	r0, #1
 8029a84:	4240      	negs	r0, r0
 8029a86:	e7f7      	b.n	8029a78 <LmHandlerSetAppEUI+0x22>

08029a88 <LmHandlerGetNetworkID>:

LmHandlerErrorStatus_t LmHandlerGetNetworkID( uint32_t *networkId )
{
 8029a88:	b510      	push	{r4, lr}
 8029a8a:	b08a      	sub	sp, #40	; 0x28
 8029a8c:	1e04      	subs	r4, r0, #0
    MibRequestConfirm_t mibReq;

    if( networkId == NULL )
 8029a8e:	d00b      	beq.n	8029aa8 <LmHandlerGetNetworkID+0x20>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    mibReq.Type = MIB_NET_ID;
 8029a90:	2305      	movs	r3, #5
 8029a92:	466a      	mov	r2, sp
 8029a94:	7013      	strb	r3, [r2, #0]
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029a96:	4668      	mov	r0, sp
 8029a98:	f003 fbe0 	bl	802d25c <LoRaMacMibGetRequestConfirm>
 8029a9c:	2800      	cmp	r0, #0
 8029a9e:	d106      	bne.n	8029aae <LmHandlerGetNetworkID+0x26>
    {
        return LORAMAC_HANDLER_ERROR;
    }
    *networkId = mibReq.Param.NetID;
 8029aa0:	9b01      	ldr	r3, [sp, #4]
 8029aa2:	6023      	str	r3, [r4, #0]
    return LORAMAC_HANDLER_SUCCESS;
}
 8029aa4:	b00a      	add	sp, #40	; 0x28
 8029aa6:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029aa8:	2001      	movs	r0, #1
 8029aaa:	4240      	negs	r0, r0
 8029aac:	e7fa      	b.n	8029aa4 <LmHandlerGetNetworkID+0x1c>
        return LORAMAC_HANDLER_ERROR;
 8029aae:	2001      	movs	r0, #1
 8029ab0:	4240      	negs	r0, r0
 8029ab2:	e7f7      	b.n	8029aa4 <LmHandlerGetNetworkID+0x1c>

08029ab4 <LmHandlerSetNetworkID>:

LmHandlerErrorStatus_t LmHandlerSetNetworkID( uint32_t networkId )
{
 8029ab4:	b510      	push	{r4, lr}
 8029ab6:	b08a      	sub	sp, #40	; 0x28
 8029ab8:	0004      	movs	r4, r0
    MibRequestConfirm_t mibReq;

    /* Not yet joined */
    if( LmHandlerJoinStatus() != LORAMAC_HANDLER_SET )
 8029aba:	f7ff fc15 	bl	80292e8 <LmHandlerJoinStatus>
 8029abe:	2801      	cmp	r0, #1
 8029ac0:	d00e      	beq.n	8029ae0 <LmHandlerSetNetworkID+0x2c>
    {
        mibReq.Type = MIB_NET_ID;
 8029ac2:	2305      	movs	r3, #5
 8029ac4:	466a      	mov	r2, sp
 8029ac6:	7013      	strb	r3, [r2, #0]
        mibReq.Param.NetID = networkId;
 8029ac8:	9401      	str	r4, [sp, #4]
        if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029aca:	4668      	mov	r0, sp
 8029acc:	f003 fcf2 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 8029ad0:	2800      	cmp	r0, #0
 8029ad2:	d102      	bne.n	8029ada <LmHandlerSetNetworkID+0x26>
        {
            return LORAMAC_HANDLER_ERROR;
        }
        return LORAMAC_HANDLER_SUCCESS;
 8029ad4:	2000      	movs	r0, #0
    else
    {
        /* Cannot change NetworkID in running state */
        return LORAMAC_HANDLER_ERROR;
    }
}
 8029ad6:	b00a      	add	sp, #40	; 0x28
 8029ad8:	bd10      	pop	{r4, pc}
            return LORAMAC_HANDLER_ERROR;
 8029ada:	2001      	movs	r0, #1
 8029adc:	4240      	negs	r0, r0
 8029ade:	e7fa      	b.n	8029ad6 <LmHandlerSetNetworkID+0x22>
        return LORAMAC_HANDLER_ERROR;
 8029ae0:	2001      	movs	r0, #1
 8029ae2:	4240      	negs	r0, r0
 8029ae4:	e7f7      	b.n	8029ad6 <LmHandlerSetNetworkID+0x22>

08029ae6 <LmHandlerGetDevAddr>:

LmHandlerErrorStatus_t LmHandlerGetDevAddr( uint32_t *devAddr )
{
 8029ae6:	b510      	push	{r4, lr}
 8029ae8:	b08a      	sub	sp, #40	; 0x28
 8029aea:	1e04      	subs	r4, r0, #0
    MibRequestConfirm_t mibReq;

    if( devAddr == NULL )
 8029aec:	d00b      	beq.n	8029b06 <LmHandlerGetDevAddr+0x20>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    mibReq.Type = MIB_DEV_ADDR;
 8029aee:	2306      	movs	r3, #6
 8029af0:	466a      	mov	r2, sp
 8029af2:	7013      	strb	r3, [r2, #0]
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029af4:	4668      	mov	r0, sp
 8029af6:	f003 fbb1 	bl	802d25c <LoRaMacMibGetRequestConfirm>
 8029afa:	2800      	cmp	r0, #0
 8029afc:	d106      	bne.n	8029b0c <LmHandlerGetDevAddr+0x26>
    {
        return LORAMAC_HANDLER_ERROR;
    }
    *devAddr = mibReq.Param.DevAddr;
 8029afe:	9b01      	ldr	r3, [sp, #4]
 8029b00:	6023      	str	r3, [r4, #0]
    return LORAMAC_HANDLER_SUCCESS;
}
 8029b02:	b00a      	add	sp, #40	; 0x28
 8029b04:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029b06:	2001      	movs	r0, #1
 8029b08:	4240      	negs	r0, r0
 8029b0a:	e7fa      	b.n	8029b02 <LmHandlerGetDevAddr+0x1c>
        return LORAMAC_HANDLER_ERROR;
 8029b0c:	2001      	movs	r0, #1
 8029b0e:	4240      	negs	r0, r0
 8029b10:	e7f7      	b.n	8029b02 <LmHandlerGetDevAddr+0x1c>

08029b12 <LmHandlerSetDevAddr>:

LmHandlerErrorStatus_t LmHandlerSetDevAddr( uint32_t devAddr )
{
 8029b12:	b510      	push	{r4, lr}
 8029b14:	b08a      	sub	sp, #40	; 0x28
 8029b16:	0004      	movs	r4, r0
    MibRequestConfirm_t mibReq;

    /* Not yet joined */
    if( LmHandlerJoinStatus() != LORAMAC_HANDLER_SET )
 8029b18:	f7ff fbe6 	bl	80292e8 <LmHandlerJoinStatus>
 8029b1c:	2801      	cmp	r0, #1
 8029b1e:	d00e      	beq.n	8029b3e <LmHandlerSetDevAddr+0x2c>
    {
        mibReq.Type = MIB_DEV_ADDR;
 8029b20:	2306      	movs	r3, #6
 8029b22:	466a      	mov	r2, sp
 8029b24:	7013      	strb	r3, [r2, #0]
        mibReq.Param.DevAddr = devAddr;
 8029b26:	9401      	str	r4, [sp, #4]
        if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029b28:	4668      	mov	r0, sp
 8029b2a:	f003 fcc3 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 8029b2e:	2800      	cmp	r0, #0
 8029b30:	d102      	bne.n	8029b38 <LmHandlerSetDevAddr+0x26>
        {
            return LORAMAC_HANDLER_ERROR;
        }
        return LORAMAC_HANDLER_SUCCESS;
 8029b32:	2000      	movs	r0, #0
    else
    {
        /* Cannot change DevAddr in running state */
        return LORAMAC_HANDLER_ERROR;
    }
}
 8029b34:	b00a      	add	sp, #40	; 0x28
 8029b36:	bd10      	pop	{r4, pc}
            return LORAMAC_HANDLER_ERROR;
 8029b38:	2001      	movs	r0, #1
 8029b3a:	4240      	negs	r0, r0
 8029b3c:	e7fa      	b.n	8029b34 <LmHandlerSetDevAddr+0x22>
        return LORAMAC_HANDLER_ERROR;
 8029b3e:	2001      	movs	r0, #1
 8029b40:	4240      	negs	r0, r0
 8029b42:	e7f7      	b.n	8029b34 <LmHandlerSetDevAddr+0x22>

08029b44 <LmHandlerSetActiveRegion>:

LmHandlerErrorStatus_t LmHandlerSetActiveRegion( LoRaMacRegion_t region )
{
 8029b44:	b510      	push	{r4, lr}
 8029b46:	0004      	movs	r4, r0
    /* Not yet joined */
    if( LmHandlerJoinStatus() != LORAMAC_HANDLER_SET )
 8029b48:	f7ff fbce 	bl	80292e8 <LmHandlerJoinStatus>
 8029b4c:	2801      	cmp	r0, #1
 8029b4e:	d004      	beq.n	8029b5a <LmHandlerSetActiveRegion+0x16>
    {
        LmHandlerParams.ActiveRegion = region;
 8029b50:	4803      	ldr	r0, [pc, #12]	; (8029b60 <LmHandlerSetActiveRegion+0x1c>)
 8029b52:	7004      	strb	r4, [r0, #0]
        return LmHandlerConfigure( &LmHandlerParams );
 8029b54:	f7ff fd90 	bl	8029678 <LmHandlerConfigure>
    else
    {
        /* Cannot change Region in running state */
        return LORAMAC_HANDLER_ERROR;
    }
}
 8029b58:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029b5a:	2001      	movs	r0, #1
 8029b5c:	4240      	negs	r0, r0
 8029b5e:	e7fb      	b.n	8029b58 <LmHandlerSetActiveRegion+0x14>
 8029b60:	2000ba74 	.word	0x2000ba74

08029b64 <LmHandlerGetAdrEnable>:

LmHandlerErrorStatus_t LmHandlerGetAdrEnable( bool *adrEnable )
{
    if( adrEnable == NULL )
 8029b64:	2800      	cmp	r0, #0
 8029b66:	d004      	beq.n	8029b72 <LmHandlerGetAdrEnable+0xe>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    *adrEnable = LmHandlerParams.AdrEnable;
 8029b68:	4b03      	ldr	r3, [pc, #12]	; (8029b78 <LmHandlerGetAdrEnable+0x14>)
 8029b6a:	789b      	ldrb	r3, [r3, #2]
 8029b6c:	7003      	strb	r3, [r0, #0]
    return LORAMAC_HANDLER_SUCCESS;
 8029b6e:	2000      	movs	r0, #0
}
 8029b70:	4770      	bx	lr
        return LORAMAC_HANDLER_ERROR;
 8029b72:	2001      	movs	r0, #1
 8029b74:	4240      	negs	r0, r0
 8029b76:	e7fb      	b.n	8029b70 <LmHandlerGetAdrEnable+0xc>
 8029b78:	2000ba74 	.word	0x2000ba74

08029b7c <LmHandlerSetAdrEnable>:

LmHandlerErrorStatus_t LmHandlerSetAdrEnable( bool adrEnable )
{
 8029b7c:	b510      	push	{r4, lr}
 8029b7e:	b08a      	sub	sp, #40	; 0x28
 8029b80:	0004      	movs	r4, r0
    MibRequestConfirm_t mibReq;
    mibReq.Type = MIB_ADR;
 8029b82:	2304      	movs	r3, #4
 8029b84:	466a      	mov	r2, sp
 8029b86:	7013      	strb	r3, [r2, #0]
    mibReq.Param.AdrEnable = adrEnable;
 8029b88:	7110      	strb	r0, [r2, #4]
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029b8a:	4668      	mov	r0, sp
 8029b8c:	f003 fc92 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 8029b90:	2800      	cmp	r0, #0
 8029b92:	d103      	bne.n	8029b9c <LmHandlerSetAdrEnable+0x20>
    {
        return LORAMAC_HANDLER_ERROR;
    }
    LmHandlerParams.AdrEnable = adrEnable;
 8029b94:	4b03      	ldr	r3, [pc, #12]	; (8029ba4 <LmHandlerSetAdrEnable+0x28>)
 8029b96:	709c      	strb	r4, [r3, #2]

    return LORAMAC_HANDLER_SUCCESS;
}
 8029b98:	b00a      	add	sp, #40	; 0x28
 8029b9a:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029b9c:	2001      	movs	r0, #1
 8029b9e:	4240      	negs	r0, r0
 8029ba0:	e7fa      	b.n	8029b98 <LmHandlerSetAdrEnable+0x1c>
 8029ba2:	46c0      	nop			; (mov r8, r8)
 8029ba4:	2000ba74 	.word	0x2000ba74

08029ba8 <LmHandlerSetTxDatarate>:

LmHandlerErrorStatus_t LmHandlerSetTxDatarate( int8_t txDatarate )
{
 8029ba8:	b510      	push	{r4, lr}
 8029baa:	b08a      	sub	sp, #40	; 0x28
 8029bac:	0004      	movs	r4, r0
    if( LmHandlerParams.AdrEnable == true )
 8029bae:	4b0b      	ldr	r3, [pc, #44]	; (8029bdc <LmHandlerSetTxDatarate+0x34>)
 8029bb0:	789b      	ldrb	r3, [r3, #2]
 8029bb2:	2b00      	cmp	r3, #0
 8029bb4:	d10c      	bne.n	8029bd0 <LmHandlerSetTxDatarate+0x28>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    MibRequestConfirm_t mibReq;
    mibReq.Type = MIB_CHANNELS_DATARATE;
 8029bb6:	3320      	adds	r3, #32
 8029bb8:	466a      	mov	r2, sp
 8029bba:	7013      	strb	r3, [r2, #0]
    mibReq.Param.ChannelsDatarate = txDatarate;
 8029bbc:	7110      	strb	r0, [r2, #4]
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029bbe:	4668      	mov	r0, sp
 8029bc0:	f003 fc78 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 8029bc4:	2800      	cmp	r0, #0
 8029bc6:	d106      	bne.n	8029bd6 <LmHandlerSetTxDatarate+0x2e>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    LmHandlerParams.TxDatarate = txDatarate;
 8029bc8:	4b04      	ldr	r3, [pc, #16]	; (8029bdc <LmHandlerSetTxDatarate+0x34>)
 8029bca:	711c      	strb	r4, [r3, #4]

    return LORAMAC_HANDLER_SUCCESS;
}
 8029bcc:	b00a      	add	sp, #40	; 0x28
 8029bce:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029bd0:	2001      	movs	r0, #1
 8029bd2:	4240      	negs	r0, r0
 8029bd4:	e7fa      	b.n	8029bcc <LmHandlerSetTxDatarate+0x24>
        return LORAMAC_HANDLER_ERROR;
 8029bd6:	2001      	movs	r0, #1
 8029bd8:	4240      	negs	r0, r0
 8029bda:	e7f7      	b.n	8029bcc <LmHandlerSetTxDatarate+0x24>
 8029bdc:	2000ba74 	.word	0x2000ba74

08029be0 <LmHandlerGetDutyCycleEnable>:

LmHandlerErrorStatus_t LmHandlerGetDutyCycleEnable( bool *dutyCycleEnable )
{
    if( dutyCycleEnable == NULL )
 8029be0:	2800      	cmp	r0, #0
 8029be2:	d004      	beq.n	8029bee <LmHandlerGetDutyCycleEnable+0xe>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    *dutyCycleEnable = LmHandlerParams.DutyCycleEnabled;
 8029be4:	4b03      	ldr	r3, [pc, #12]	; (8029bf4 <LmHandlerGetDutyCycleEnable+0x14>)
 8029be6:	79db      	ldrb	r3, [r3, #7]
 8029be8:	7003      	strb	r3, [r0, #0]
    return LORAMAC_HANDLER_SUCCESS;
 8029bea:	2000      	movs	r0, #0
}
 8029bec:	4770      	bx	lr
        return LORAMAC_HANDLER_ERROR;
 8029bee:	2001      	movs	r0, #1
 8029bf0:	4240      	negs	r0, r0
 8029bf2:	e7fb      	b.n	8029bec <LmHandlerGetDutyCycleEnable+0xc>
 8029bf4:	2000ba74 	.word	0x2000ba74

08029bf8 <LmHandlerSetDutyCycleEnable>:

LmHandlerErrorStatus_t LmHandlerSetDutyCycleEnable( bool dutyCycleEnable )
{
 8029bf8:	b510      	push	{r4, lr}
    LmHandlerParams.DutyCycleEnabled = dutyCycleEnable;
 8029bfa:	4b03      	ldr	r3, [pc, #12]	; (8029c08 <LmHandlerSetDutyCycleEnable+0x10>)
 8029bfc:	71d8      	strb	r0, [r3, #7]
    LoRaMacTestSetDutyCycleOn( dutyCycleEnable );
 8029bfe:	f004 f8eb 	bl	802ddd8 <LoRaMacTestSetDutyCycleOn>

    return LORAMAC_HANDLER_SUCCESS;
}
 8029c02:	2000      	movs	r0, #0
 8029c04:	bd10      	pop	{r4, pc}
 8029c06:	46c0      	nop			; (mov r8, r8)
 8029c08:	2000ba74 	.word	0x2000ba74

08029c0c <LmHandlerGetRX2Params>:

LmHandlerErrorStatus_t LmHandlerGetRX2Params( RxChannelParams_t *rxParams )
{
 8029c0c:	b510      	push	{r4, lr}
 8029c0e:	b08c      	sub	sp, #48	; 0x30
 8029c10:	1e04      	subs	r4, r0, #0
    if( rxParams == NULL )
 8029c12:	d00f      	beq.n	8029c34 <LmHandlerGetRX2Params+0x28>
        return LORAMAC_HANDLER_ERROR;
    }

    MibRequestConfirm_t mibReq;

    mibReq.Type = MIB_RX2_CHANNEL;
 8029c14:	2312      	movs	r3, #18
 8029c16:	aa02      	add	r2, sp, #8
 8029c18:	7013      	strb	r3, [r2, #0]
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029c1a:	0010      	movs	r0, r2
 8029c1c:	f003 fb1e 	bl	802d25c <LoRaMacMibGetRequestConfirm>
 8029c20:	2800      	cmp	r0, #0
 8029c22:	d10a      	bne.n	8029c3a <LmHandlerGetRX2Params+0x2e>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    rxParams->Frequency = mibReq.Param.Rx2Channel.Frequency;
 8029c24:	9b03      	ldr	r3, [sp, #12]
 8029c26:	9301      	str	r3, [sp, #4]
 8029c28:	6023      	str	r3, [r4, #0]
    rxParams->Datarate = mibReq.Param.Rx2Channel.Datarate;
 8029c2a:	ab02      	add	r3, sp, #8
 8029c2c:	7a1b      	ldrb	r3, [r3, #8]
 8029c2e:	7123      	strb	r3, [r4, #4]
    return LORAMAC_HANDLER_SUCCESS;
}
 8029c30:	b00c      	add	sp, #48	; 0x30
 8029c32:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029c34:	2001      	movs	r0, #1
 8029c36:	4240      	negs	r0, r0
 8029c38:	e7fa      	b.n	8029c30 <LmHandlerGetRX2Params+0x24>
        return LORAMAC_HANDLER_ERROR;
 8029c3a:	2001      	movs	r0, #1
 8029c3c:	4240      	negs	r0, r0
 8029c3e:	e7f7      	b.n	8029c30 <LmHandlerGetRX2Params+0x24>

08029c40 <LmHandlerGetTxPower>:

LmHandlerErrorStatus_t LmHandlerGetTxPower( int8_t *txPower )
{
 8029c40:	b510      	push	{r4, lr}
 8029c42:	b08a      	sub	sp, #40	; 0x28
 8029c44:	1e04      	subs	r4, r0, #0
    MibRequestConfirm_t mibReq;
    if( txPower == NULL )
 8029c46:	d00f      	beq.n	8029c68 <LmHandlerGetTxPower+0x28>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    mibReq.Type = MIB_CHANNELS_TX_POWER;
 8029c48:	2321      	movs	r3, #33	; 0x21
 8029c4a:	466a      	mov	r2, sp
 8029c4c:	7013      	strb	r3, [r2, #0]
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029c4e:	4668      	mov	r0, sp
 8029c50:	f003 fb04 	bl	802d25c <LoRaMacMibGetRequestConfirm>
 8029c54:	2800      	cmp	r0, #0
 8029c56:	d10a      	bne.n	8029c6e <LmHandlerGetTxPower+0x2e>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    *txPower = mibReq.Param.ChannelsTxPower;
 8029c58:	466b      	mov	r3, sp
 8029c5a:	791b      	ldrb	r3, [r3, #4]
 8029c5c:	b25b      	sxtb	r3, r3
 8029c5e:	7023      	strb	r3, [r4, #0]
    LmHandlerParams.TxPower = *txPower;
 8029c60:	4a04      	ldr	r2, [pc, #16]	; (8029c74 <LmHandlerGetTxPower+0x34>)
 8029c62:	7153      	strb	r3, [r2, #5]
    return LORAMAC_HANDLER_SUCCESS;
}
 8029c64:	b00a      	add	sp, #40	; 0x28
 8029c66:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029c68:	2001      	movs	r0, #1
 8029c6a:	4240      	negs	r0, r0
 8029c6c:	e7fa      	b.n	8029c64 <LmHandlerGetTxPower+0x24>
        return LORAMAC_HANDLER_ERROR;
 8029c6e:	2001      	movs	r0, #1
 8029c70:	4240      	negs	r0, r0
 8029c72:	e7f7      	b.n	8029c64 <LmHandlerGetTxPower+0x24>
 8029c74:	2000ba74 	.word	0x2000ba74

08029c78 <MlmeConfirm>:
{
 8029c78:	b510      	push	{r4, lr}
 8029c7a:	b08a      	sub	sp, #40	; 0x28
 8029c7c:	0004      	movs	r4, r0
    TxParams.IsMcpsConfirm = 0;
 8029c7e:	4b2e      	ldr	r3, [pc, #184]	; (8029d38 <MlmeConfirm+0xc0>)
 8029c80:	2200      	movs	r2, #0
 8029c82:	701a      	strb	r2, [r3, #0]
    TxParams.Status = mlmeConfirm->Status;
 8029c84:	7842      	ldrb	r2, [r0, #1]
 8029c86:	705a      	strb	r2, [r3, #1]
    if( LmHandlerCallbacks->OnTxData != NULL )
 8029c88:	4b2c      	ldr	r3, [pc, #176]	; (8029d3c <MlmeConfirm+0xc4>)
 8029c8a:	681b      	ldr	r3, [r3, #0]
 8029c8c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8029c8e:	2b00      	cmp	r3, #0
 8029c90:	d001      	beq.n	8029c96 <MlmeConfirm+0x1e>
        LmHandlerCallbacks->OnTxData( &TxParams );
 8029c92:	4829      	ldr	r0, [pc, #164]	; (8029d38 <MlmeConfirm+0xc0>)
 8029c94:	4798      	blx	r3
    LmHandlerPackagesNotify( PACKAGE_MLME_CONFIRM, mlmeConfirm );
 8029c96:	0021      	movs	r1, r4
 8029c98:	2002      	movs	r0, #2
 8029c9a:	f7ff f9ad 	bl	8028ff8 <LmHandlerPackagesNotify>
    switch( mlmeConfirm->MlmeRequest )
 8029c9e:	7823      	ldrb	r3, [r4, #0]
 8029ca0:	2b05      	cmp	r3, #5
 8029ca2:	d03b      	beq.n	8029d1c <MlmeConfirm+0xa4>
 8029ca4:	2b0b      	cmp	r3, #11
 8029ca6:	d041      	beq.n	8029d2c <MlmeConfirm+0xb4>
 8029ca8:	2b01      	cmp	r3, #1
 8029caa:	d001      	beq.n	8029cb0 <MlmeConfirm+0x38>
}
 8029cac:	b00a      	add	sp, #40	; 0x28
 8029cae:	bd10      	pop	{r4, pc}
                mibReq.Type = MIB_DEV_ADDR;
 8029cb0:	3305      	adds	r3, #5
 8029cb2:	466a      	mov	r2, sp
 8029cb4:	7013      	strb	r3, [r2, #0]
                LoRaMacMibGetRequestConfirm( &mibReq );
 8029cb6:	4668      	mov	r0, sp
 8029cb8:	f003 fad0 	bl	802d25c <LoRaMacMibGetRequestConfirm>
                if( SecureElementSetDevAddr( JoinParams.Mode, mibReq.Param.DevAddr ) == SECURE_ELEMENT_SUCCESS )
 8029cbc:	9901      	ldr	r1, [sp, #4]
 8029cbe:	4b20      	ldr	r3, [pc, #128]	; (8029d40 <MlmeConfirm+0xc8>)
 8029cc0:	79d8      	ldrb	r0, [r3, #7]
 8029cc2:	f008 f912 	bl	8031eea <SecureElementSetDevAddr>
 8029cc6:	2800      	cmp	r0, #0
 8029cc8:	d102      	bne.n	8029cd0 <MlmeConfirm+0x58>
                    CommissioningParams.DevAddr = mibReq.Param.DevAddr;
 8029cca:	4b1e      	ldr	r3, [pc, #120]	; (8029d44 <MlmeConfirm+0xcc>)
 8029ccc:	9a01      	ldr	r2, [sp, #4]
 8029cce:	615a      	str	r2, [r3, #20]
                LmHandlerGetTxDatarate( &JoinParams.Datarate );
 8029cd0:	4c1b      	ldr	r4, [pc, #108]	; (8029d40 <MlmeConfirm+0xc8>)
 8029cd2:	1d20      	adds	r0, r4, #4
 8029cd4:	f7ff fc98 	bl	8029608 <LmHandlerGetTxDatarate>
                LmHandlerGetTxPower( &JoinParams.TxPower );
 8029cd8:	1d60      	adds	r0, r4, #5
 8029cda:	f7ff ffb1 	bl	8029c40 <LmHandlerGetTxPower>
                if( TxParams.Status == LORAMAC_EVENT_INFO_STATUS_OK )
 8029cde:	4b16      	ldr	r3, [pc, #88]	; (8029d38 <MlmeConfirm+0xc0>)
 8029ce0:	785b      	ldrb	r3, [r3, #1]
 8029ce2:	2b00      	cmp	r3, #0
 8029ce4:	d012      	beq.n	8029d0c <MlmeConfirm+0x94>
                    JoinParams.Status = LORAMAC_HANDLER_ERROR;
 8029ce6:	4b16      	ldr	r3, [pc, #88]	; (8029d40 <MlmeConfirm+0xc8>)
 8029ce8:	22ff      	movs	r2, #255	; 0xff
 8029cea:	719a      	strb	r2, [r3, #6]
                if( LmHandlerCallbacks->OnJoinRequest != NULL )
 8029cec:	4b13      	ldr	r3, [pc, #76]	; (8029d3c <MlmeConfirm+0xc4>)
 8029cee:	681b      	ldr	r3, [r3, #0]
 8029cf0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8029cf2:	2b00      	cmp	r3, #0
 8029cf4:	d001      	beq.n	8029cfa <MlmeConfirm+0x82>
                    LmHandlerCallbacks->OnJoinRequest( &JoinParams );
 8029cf6:	4812      	ldr	r0, [pc, #72]	; (8029d40 <MlmeConfirm+0xc8>)
 8029cf8:	4798      	blx	r3
                if( TxParams.Status == LORAMAC_EVENT_INFO_STATUS_OK )
 8029cfa:	4b0f      	ldr	r3, [pc, #60]	; (8029d38 <MlmeConfirm+0xc0>)
 8029cfc:	785b      	ldrb	r3, [r3, #1]
 8029cfe:	2b00      	cmp	r3, #0
 8029d00:	d1d4      	bne.n	8029cac <MlmeConfirm+0x34>
                    SecureElementPrintSessionKeys( JoinParams.Mode );
 8029d02:	4b0f      	ldr	r3, [pc, #60]	; (8029d40 <MlmeConfirm+0xc8>)
 8029d04:	79d8      	ldrb	r0, [r3, #7]
 8029d06:	f008 f9bf 	bl	8032088 <SecureElementPrintSessionKeys>
            break;
 8029d0a:	e7cf      	b.n	8029cac <MlmeConfirm+0x34>
                    JoinParams.Status = LORAMAC_HANDLER_SUCCESS;
 8029d0c:	4b0c      	ldr	r3, [pc, #48]	; (8029d40 <MlmeConfirm+0xc8>)
 8029d0e:	2200      	movs	r2, #0
 8029d10:	719a      	strb	r2, [r3, #6]
                    LmHandlerRequestClass( LmHandlerParams.DefaultClass );
 8029d12:	4b0d      	ldr	r3, [pc, #52]	; (8029d48 <MlmeConfirm+0xd0>)
 8029d14:	7858      	ldrb	r0, [r3, #1]
 8029d16:	f7ff fbb1 	bl	802947c <LmHandlerRequestClass>
 8029d1a:	e7e7      	b.n	8029cec <MlmeConfirm+0x74>
                RxParams.LinkCheck = true;
 8029d1c:	4b0b      	ldr	r3, [pc, #44]	; (8029d4c <MlmeConfirm+0xd4>)
 8029d1e:	2201      	movs	r2, #1
 8029d20:	745a      	strb	r2, [r3, #17]
                RxParams.DemodMargin = mlmeConfirm->DemodMargin;
 8029d22:	7a22      	ldrb	r2, [r4, #8]
 8029d24:	749a      	strb	r2, [r3, #18]
                RxParams.NbGateways = mlmeConfirm->NbGateways;
 8029d26:	7a62      	ldrb	r2, [r4, #9]
 8029d28:	74da      	strb	r2, [r3, #19]
            break;
 8029d2a:	e7bf      	b.n	8029cac <MlmeConfirm+0x34>
                if( mlmeConfirm->Status == LORAMAC_EVENT_INFO_STATUS_OK )
 8029d2c:	7863      	ldrb	r3, [r4, #1]
 8029d2e:	2b00      	cmp	r3, #0
 8029d30:	d0bc      	beq.n	8029cac <MlmeConfirm+0x34>
                    LmHandlerDeviceTimeReq( );
 8029d32:	f7ff faa1 	bl	8029278 <LmHandlerDeviceTimeReq>
}
 8029d36:	e7b9      	b.n	8029cac <MlmeConfirm+0x34>
 8029d38:	2000b078 	.word	0x2000b078
 8029d3c:	2000ba5c 	.word	0x2000ba5c
 8029d40:	2000b058 	.word	0x2000b058
 8029d44:	2000ba38 	.word	0x2000ba38
 8029d48:	2000ba74 	.word	0x2000ba74
 8029d4c:	2000b064 	.word	0x2000b064

08029d50 <LmHandlerGetRx1Delay>:

LmHandlerErrorStatus_t LmHandlerGetRx1Delay( uint32_t *rxDelay )
{
 8029d50:	b510      	push	{r4, lr}
 8029d52:	b08a      	sub	sp, #40	; 0x28
 8029d54:	1e04      	subs	r4, r0, #0
    MibRequestConfirm_t mibReq;
    if( rxDelay == NULL )
 8029d56:	d00b      	beq.n	8029d70 <LmHandlerGetRx1Delay+0x20>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    mibReq.Type = MIB_RECEIVE_DELAY_1;
 8029d58:	231a      	movs	r3, #26
 8029d5a:	466a      	mov	r2, sp
 8029d5c:	7013      	strb	r3, [r2, #0]
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029d5e:	4668      	mov	r0, sp
 8029d60:	f003 fa7c 	bl	802d25c <LoRaMacMibGetRequestConfirm>
 8029d64:	2800      	cmp	r0, #0
 8029d66:	d106      	bne.n	8029d76 <LmHandlerGetRx1Delay+0x26>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    *rxDelay = mibReq.Param.ReceiveDelay1;
 8029d68:	9b01      	ldr	r3, [sp, #4]
 8029d6a:	6023      	str	r3, [r4, #0]
    return LORAMAC_HANDLER_SUCCESS;
}
 8029d6c:	b00a      	add	sp, #40	; 0x28
 8029d6e:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029d70:	2001      	movs	r0, #1
 8029d72:	4240      	negs	r0, r0
 8029d74:	e7fa      	b.n	8029d6c <LmHandlerGetRx1Delay+0x1c>
        return LORAMAC_HANDLER_ERROR;
 8029d76:	2001      	movs	r0, #1
 8029d78:	4240      	negs	r0, r0
 8029d7a:	e7f7      	b.n	8029d6c <LmHandlerGetRx1Delay+0x1c>

08029d7c <LmHandlerGetRx2Delay>:

LmHandlerErrorStatus_t LmHandlerGetRx2Delay( uint32_t *rxDelay )
{
 8029d7c:	b510      	push	{r4, lr}
 8029d7e:	b08a      	sub	sp, #40	; 0x28
 8029d80:	1e04      	subs	r4, r0, #0
    MibRequestConfirm_t mibReq;
    if( rxDelay == NULL )
 8029d82:	d00b      	beq.n	8029d9c <LmHandlerGetRx2Delay+0x20>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    mibReq.Type = MIB_RECEIVE_DELAY_2;
 8029d84:	231b      	movs	r3, #27
 8029d86:	466a      	mov	r2, sp
 8029d88:	7013      	strb	r3, [r2, #0]
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029d8a:	4668      	mov	r0, sp
 8029d8c:	f003 fa66 	bl	802d25c <LoRaMacMibGetRequestConfirm>
 8029d90:	2800      	cmp	r0, #0
 8029d92:	d106      	bne.n	8029da2 <LmHandlerGetRx2Delay+0x26>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    *rxDelay = mibReq.Param.ReceiveDelay2;
 8029d94:	9b01      	ldr	r3, [sp, #4]
 8029d96:	6023      	str	r3, [r4, #0]
    return LORAMAC_HANDLER_SUCCESS;
}
 8029d98:	b00a      	add	sp, #40	; 0x28
 8029d9a:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029d9c:	2001      	movs	r0, #1
 8029d9e:	4240      	negs	r0, r0
 8029da0:	e7fa      	b.n	8029d98 <LmHandlerGetRx2Delay+0x1c>
        return LORAMAC_HANDLER_ERROR;
 8029da2:	2001      	movs	r0, #1
 8029da4:	4240      	negs	r0, r0
 8029da6:	e7f7      	b.n	8029d98 <LmHandlerGetRx2Delay+0x1c>

08029da8 <LmHandlerGetJoinRx1Delay>:

LmHandlerErrorStatus_t LmHandlerGetJoinRx1Delay( uint32_t *rxDelay )
{
 8029da8:	b510      	push	{r4, lr}
 8029daa:	b08a      	sub	sp, #40	; 0x28
 8029dac:	1e04      	subs	r4, r0, #0
    MibRequestConfirm_t mibReq;
    if( rxDelay == NULL )
 8029dae:	d00b      	beq.n	8029dc8 <LmHandlerGetJoinRx1Delay+0x20>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    mibReq.Type = MIB_JOIN_ACCEPT_DELAY_1;
 8029db0:	231c      	movs	r3, #28
 8029db2:	466a      	mov	r2, sp
 8029db4:	7013      	strb	r3, [r2, #0]
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029db6:	4668      	mov	r0, sp
 8029db8:	f003 fa50 	bl	802d25c <LoRaMacMibGetRequestConfirm>
 8029dbc:	2800      	cmp	r0, #0
 8029dbe:	d106      	bne.n	8029dce <LmHandlerGetJoinRx1Delay+0x26>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    *rxDelay = mibReq.Param.JoinAcceptDelay1;
 8029dc0:	9b01      	ldr	r3, [sp, #4]
 8029dc2:	6023      	str	r3, [r4, #0]
    return LORAMAC_HANDLER_SUCCESS;
}
 8029dc4:	b00a      	add	sp, #40	; 0x28
 8029dc6:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029dc8:	2001      	movs	r0, #1
 8029dca:	4240      	negs	r0, r0
 8029dcc:	e7fa      	b.n	8029dc4 <LmHandlerGetJoinRx1Delay+0x1c>
        return LORAMAC_HANDLER_ERROR;
 8029dce:	2001      	movs	r0, #1
 8029dd0:	4240      	negs	r0, r0
 8029dd2:	e7f7      	b.n	8029dc4 <LmHandlerGetJoinRx1Delay+0x1c>

08029dd4 <LmHandlerGetJoinRx2Delay>:

LmHandlerErrorStatus_t LmHandlerGetJoinRx2Delay( uint32_t *rxDelay )
{
 8029dd4:	b510      	push	{r4, lr}
 8029dd6:	b08a      	sub	sp, #40	; 0x28
 8029dd8:	1e04      	subs	r4, r0, #0
    MibRequestConfirm_t mibReq;
    if( rxDelay == NULL )
 8029dda:	d00b      	beq.n	8029df4 <LmHandlerGetJoinRx2Delay+0x20>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    mibReq.Type = MIB_JOIN_ACCEPT_DELAY_2;
 8029ddc:	231d      	movs	r3, #29
 8029dde:	466a      	mov	r2, sp
 8029de0:	7013      	strb	r3, [r2, #0]
    if( LoRaMacMibGetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029de2:	4668      	mov	r0, sp
 8029de4:	f003 fa3a 	bl	802d25c <LoRaMacMibGetRequestConfirm>
 8029de8:	2800      	cmp	r0, #0
 8029dea:	d106      	bne.n	8029dfa <LmHandlerGetJoinRx2Delay+0x26>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    *rxDelay = mibReq.Param.JoinAcceptDelay2;
 8029dec:	9b01      	ldr	r3, [sp, #4]
 8029dee:	6023      	str	r3, [r4, #0]
    return LORAMAC_HANDLER_SUCCESS;
}
 8029df0:	b00a      	add	sp, #40	; 0x28
 8029df2:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029df4:	2001      	movs	r0, #1
 8029df6:	4240      	negs	r0, r0
 8029df8:	e7fa      	b.n	8029df0 <LmHandlerGetJoinRx2Delay+0x1c>
        return LORAMAC_HANDLER_ERROR;
 8029dfa:	2001      	movs	r0, #1
 8029dfc:	4240      	negs	r0, r0
 8029dfe:	e7f7      	b.n	8029df0 <LmHandlerGetJoinRx2Delay+0x1c>

08029e00 <LmHandlerSetTxPower>:

LmHandlerErrorStatus_t LmHandlerSetTxPower( int8_t txPower )
{
 8029e00:	b510      	push	{r4, lr}
 8029e02:	b08a      	sub	sp, #40	; 0x28
 8029e04:	0004      	movs	r4, r0
    MibRequestConfirm_t mibReq;

    mibReq.Type = MIB_CHANNELS_TX_POWER;
 8029e06:	2321      	movs	r3, #33	; 0x21
 8029e08:	466a      	mov	r2, sp
 8029e0a:	7013      	strb	r3, [r2, #0]
    mibReq.Param.ChannelsTxPower = txPower;
 8029e0c:	7110      	strb	r0, [r2, #4]
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029e0e:	4668      	mov	r0, sp
 8029e10:	f003 fb50 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 8029e14:	2800      	cmp	r0, #0
 8029e16:	d103      	bne.n	8029e20 <LmHandlerSetTxPower+0x20>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    LmHandlerParams.TxPower = txPower;
 8029e18:	4b03      	ldr	r3, [pc, #12]	; (8029e28 <LmHandlerSetTxPower+0x28>)
 8029e1a:	715c      	strb	r4, [r3, #5]
    return LORAMAC_HANDLER_SUCCESS;
}
 8029e1c:	b00a      	add	sp, #40	; 0x28
 8029e1e:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029e20:	2001      	movs	r0, #1
 8029e22:	4240      	negs	r0, r0
 8029e24:	e7fa      	b.n	8029e1c <LmHandlerSetTxPower+0x1c>
 8029e26:	46c0      	nop			; (mov r8, r8)
 8029e28:	2000ba74 	.word	0x2000ba74

08029e2c <LmHandlerSetRX2Params>:

LmHandlerErrorStatus_t LmHandlerSetRX2Params( RxChannelParams_t *rxParams )
{
 8029e2c:	b500      	push	{lr}
 8029e2e:	b08b      	sub	sp, #44	; 0x2c
    MibRequestConfirm_t mibReq;

    mibReq.Type = MIB_RX2_CHANNEL;
 8029e30:	2312      	movs	r3, #18
 8029e32:	466a      	mov	r2, sp
 8029e34:	7013      	strb	r3, [r2, #0]
    mibReq.Param.Rx2Channel.Frequency = rxParams->Frequency;
 8029e36:	6803      	ldr	r3, [r0, #0]
 8029e38:	9301      	str	r3, [sp, #4]
    mibReq.Param.Rx2Channel.Datarate = rxParams->Datarate;
 8029e3a:	7903      	ldrb	r3, [r0, #4]
 8029e3c:	7213      	strb	r3, [r2, #8]
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029e3e:	4668      	mov	r0, sp
 8029e40:	f003 fb38 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 8029e44:	2800      	cmp	r0, #0
 8029e46:	d101      	bne.n	8029e4c <LmHandlerSetRX2Params+0x20>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    return LORAMAC_HANDLER_SUCCESS;
}
 8029e48:	b00b      	add	sp, #44	; 0x2c
 8029e4a:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 8029e4c:	2001      	movs	r0, #1
 8029e4e:	4240      	negs	r0, r0
 8029e50:	e7fa      	b.n	8029e48 <LmHandlerSetRX2Params+0x1c>

08029e52 <LmHandlerSetRx1Delay>:

LmHandlerErrorStatus_t LmHandlerSetRx1Delay( uint32_t rxDelay )
{
 8029e52:	b500      	push	{lr}
 8029e54:	b08b      	sub	sp, #44	; 0x2c
    MibRequestConfirm_t mibReq;
    mibReq.Type = MIB_RECEIVE_DELAY_1;
 8029e56:	231a      	movs	r3, #26
 8029e58:	466a      	mov	r2, sp
 8029e5a:	7013      	strb	r3, [r2, #0]
    mibReq.Param.ReceiveDelay1 = rxDelay;
 8029e5c:	9001      	str	r0, [sp, #4]
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029e5e:	4668      	mov	r0, sp
 8029e60:	f003 fb28 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 8029e64:	2800      	cmp	r0, #0
 8029e66:	d101      	bne.n	8029e6c <LmHandlerSetRx1Delay+0x1a>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    return LORAMAC_HANDLER_SUCCESS;
}
 8029e68:	b00b      	add	sp, #44	; 0x2c
 8029e6a:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 8029e6c:	2001      	movs	r0, #1
 8029e6e:	4240      	negs	r0, r0
 8029e70:	e7fa      	b.n	8029e68 <LmHandlerSetRx1Delay+0x16>

08029e72 <LmHandlerSetRx2Delay>:

LmHandlerErrorStatus_t LmHandlerSetRx2Delay( uint32_t rxDelay )
{
 8029e72:	b500      	push	{lr}
 8029e74:	b08b      	sub	sp, #44	; 0x2c
    MibRequestConfirm_t mibReq;
    mibReq.Type = MIB_RECEIVE_DELAY_2;
 8029e76:	231b      	movs	r3, #27
 8029e78:	466a      	mov	r2, sp
 8029e7a:	7013      	strb	r3, [r2, #0]
    mibReq.Param.ReceiveDelay2 = rxDelay;
 8029e7c:	9001      	str	r0, [sp, #4]
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029e7e:	4668      	mov	r0, sp
 8029e80:	f003 fb18 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 8029e84:	2800      	cmp	r0, #0
 8029e86:	d101      	bne.n	8029e8c <LmHandlerSetRx2Delay+0x1a>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    return LORAMAC_HANDLER_SUCCESS;
}
 8029e88:	b00b      	add	sp, #44	; 0x2c
 8029e8a:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 8029e8c:	2001      	movs	r0, #1
 8029e8e:	4240      	negs	r0, r0
 8029e90:	e7fa      	b.n	8029e88 <LmHandlerSetRx2Delay+0x16>

08029e92 <LmHandlerSetJoinRx1Delay>:

LmHandlerErrorStatus_t LmHandlerSetJoinRx1Delay( uint32_t rxDelay )
{
 8029e92:	b500      	push	{lr}
 8029e94:	b08b      	sub	sp, #44	; 0x2c
    MibRequestConfirm_t mibReq;
    mibReq.Type = MIB_JOIN_ACCEPT_DELAY_1;
 8029e96:	231c      	movs	r3, #28
 8029e98:	466a      	mov	r2, sp
 8029e9a:	7013      	strb	r3, [r2, #0]
    mibReq.Param.JoinAcceptDelay1 = rxDelay;
 8029e9c:	9001      	str	r0, [sp, #4]
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029e9e:	4668      	mov	r0, sp
 8029ea0:	f003 fb08 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 8029ea4:	2800      	cmp	r0, #0
 8029ea6:	d101      	bne.n	8029eac <LmHandlerSetJoinRx1Delay+0x1a>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    return LORAMAC_HANDLER_SUCCESS;
}
 8029ea8:	b00b      	add	sp, #44	; 0x2c
 8029eaa:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 8029eac:	2001      	movs	r0, #1
 8029eae:	4240      	negs	r0, r0
 8029eb0:	e7fa      	b.n	8029ea8 <LmHandlerSetJoinRx1Delay+0x16>

08029eb2 <LmHandlerSetJoinRx2Delay>:

LmHandlerErrorStatus_t LmHandlerSetJoinRx2Delay( uint32_t rxDelay )
{
 8029eb2:	b500      	push	{lr}
 8029eb4:	b08b      	sub	sp, #44	; 0x2c
    MibRequestConfirm_t mibReq;
    mibReq.Type = MIB_JOIN_ACCEPT_DELAY_2;
 8029eb6:	231d      	movs	r3, #29
 8029eb8:	466a      	mov	r2, sp
 8029eba:	7013      	strb	r3, [r2, #0]
    mibReq.Param.JoinAcceptDelay2 = rxDelay;
 8029ebc:	9001      	str	r0, [sp, #4]
    if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029ebe:	4668      	mov	r0, sp
 8029ec0:	f003 faf8 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 8029ec4:	2800      	cmp	r0, #0
 8029ec6:	d101      	bne.n	8029ecc <LmHandlerSetJoinRx2Delay+0x1a>
    {
        return LORAMAC_HANDLER_ERROR;
    }

    return LORAMAC_HANDLER_SUCCESS;
}
 8029ec8:	b00b      	add	sp, #44	; 0x2c
 8029eca:	bd00      	pop	{pc}
        return LORAMAC_HANDLER_ERROR;
 8029ecc:	2001      	movs	r0, #1
 8029ece:	4240      	negs	r0, r0
 8029ed0:	e7fa      	b.n	8029ec8 <LmHandlerSetJoinRx2Delay+0x16>

08029ed2 <LmHandlerGetPingPeriodicity>:
    }

    *pingPeriodicity = LmHandlerParams.PingSlotPeriodicity;
    return LORAMAC_HANDLER_SUCCESS;
#else /* LORAMAC_CLASSB_ENABLED == 0 */
    return LORAMAC_HANDLER_ERROR;
 8029ed2:	2001      	movs	r0, #1
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8029ed4:	4240      	negs	r0, r0
 8029ed6:	4770      	bx	lr

08029ed8 <LmHandlerSetPingPeriodicity>:
    {
        /* Cannot change Region in running state */
        return LmHandlerPingSlotReq( pingPeriodicity );
    }
#else /* LORAMAC_CLASSB_ENABLED == 0 */
    return LORAMAC_HANDLER_ERROR;
 8029ed8:	2001      	movs	r0, #1
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8029eda:	4240      	negs	r0, r0
 8029edc:	4770      	bx	lr

08029ede <LmHandlerGetBeaconState>:
        return LORAMAC_HANDLER_ERROR;
    }
    *beaconState =  mibReq.Param.BeaconState;
    return LORAMAC_HANDLER_SUCCESS;
#else /* LORAMAC_CLASSB_ENABLED == 0 */
    return LORAMAC_HANDLER_ERROR;
 8029ede:	2001      	movs	r0, #1
#endif /* LORAMAC_CLASSB_ENABLED */
}
 8029ee0:	4240      	negs	r0, r0
 8029ee2:	4770      	bx	lr

08029ee4 <LmHandlerGetKey>:

LmHandlerErrorStatus_t LmHandlerGetKey( KeyIdentifier_t keyID, uint8_t *key )
{
 8029ee4:	b510      	push	{r4, lr}
#if (!defined (LORAWAN_KMS) || (LORAWAN_KMS == 0))
    Key_t *keyItem;
#endif /* LORAWAN_KMS */

    if( key == NULL )
 8029ee6:	2900      	cmp	r1, #0
 8029ee8:	d004      	beq.n	8029ef4 <LmHandlerGetKey+0x10>
    {
        return LORAMAC_HANDLER_ERROR;
    }
    memcpy1( key, keyItem->KeyValue, 16 );
#else
    if( SECURE_ELEMENT_SUCCESS != SecureElementGetKeyByID( keyID, key ) )
 8029eea:	f007 fb95 	bl	8031618 <SecureElementGetKeyByID>
 8029eee:	2800      	cmp	r0, #0
 8029ef0:	d103      	bne.n	8029efa <LmHandlerGetKey+0x16>
    }

#endif /* LORAWAN_KMS */

    return LORAMAC_HANDLER_SUCCESS;
}
 8029ef2:	bd10      	pop	{r4, pc}
        return LORAMAC_HANDLER_ERROR;
 8029ef4:	2001      	movs	r0, #1
 8029ef6:	4240      	negs	r0, r0
 8029ef8:	e7fb      	b.n	8029ef2 <LmHandlerGetKey+0xe>
        return LORAMAC_HANDLER_ERROR;
 8029efa:	2001      	movs	r0, #1
 8029efc:	4240      	negs	r0, r0
 8029efe:	e7f8      	b.n	8029ef2 <LmHandlerGetKey+0xe>

08029f00 <LmHandlerSetKey>:

LmHandlerErrorStatus_t LmHandlerSetKey( KeyIdentifier_t keyID, uint8_t *key )
{
 8029f00:	b530      	push	{r4, r5, lr}
 8029f02:	b08b      	sub	sp, #44	; 0x2c
 8029f04:	0004      	movs	r4, r0
 8029f06:	000d      	movs	r5, r1
    /* Not yet joined */
    if( LmHandlerJoinStatus( ) != LORAMAC_HANDLER_SET )
 8029f08:	f7ff f9ee 	bl	80292e8 <LmHandlerJoinStatus>
 8029f0c:	2801      	cmp	r0, #1
 8029f0e:	d017      	beq.n	8029f40 <LmHandlerSetKey+0x40>
    {
        if( keyID == APP_KEY ) /* Specific usage because APP_KEY is used to derive other keys */
 8029f10:	2c00      	cmp	r4, #0
 8029f12:	d10d      	bne.n	8029f30 <LmHandlerSetKey+0x30>
        {
            MibRequestConfirm_t mibReq;
            mibReq.Type = MIB_APP_KEY;
 8029f14:	2307      	movs	r3, #7
 8029f16:	466a      	mov	r2, sp
 8029f18:	7013      	strb	r3, [r2, #0]
            mibReq.Param.AppKey = key;
 8029f1a:	9501      	str	r5, [sp, #4]
            if( LoRaMacMibSetRequestConfirm( &mibReq ) != LORAMAC_STATUS_OK )
 8029f1c:	4668      	mov	r0, sp
 8029f1e:	f003 fac9 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
 8029f22:	2800      	cmp	r0, #0
 8029f24:	d002      	beq.n	8029f2c <LmHandlerSetKey+0x2c>
            {
                return LORAMAC_HANDLER_ERROR;
 8029f26:	2001      	movs	r0, #1
 8029f28:	4240      	negs	r0, r0
 8029f2a:	e007      	b.n	8029f3c <LmHandlerSetKey+0x3c>
            }
            return LORAMAC_HANDLER_SUCCESS;
 8029f2c:	2000      	movs	r0, #0
 8029f2e:	e005      	b.n	8029f3c <LmHandlerSetKey+0x3c>
        }
        else if( SECURE_ELEMENT_SUCCESS != SecureElementSetKey( keyID, key ) )
 8029f30:	0029      	movs	r1, r5
 8029f32:	0020      	movs	r0, r4
 8029f34:	f007 fdfa 	bl	8031b2c <SecureElementSetKey>
 8029f38:	2800      	cmp	r0, #0
 8029f3a:	d104      	bne.n	8029f46 <LmHandlerSetKey+0x46>
        /* Cannot change Keys in running state */
        return LORAMAC_HANDLER_ERROR;
    }

    return LORAMAC_HANDLER_SUCCESS;
}
 8029f3c:	b00b      	add	sp, #44	; 0x2c
 8029f3e:	bd30      	pop	{r4, r5, pc}
        return LORAMAC_HANDLER_ERROR;
 8029f40:	2001      	movs	r0, #1
 8029f42:	4240      	negs	r0, r0
 8029f44:	e7fa      	b.n	8029f3c <LmHandlerSetKey+0x3c>
            return LORAMAC_HANDLER_ERROR;
 8029f46:	2001      	movs	r0, #1
 8029f48:	4240      	negs	r0, r0
 8029f4a:	e7f7      	b.n	8029f3c <LmHandlerSetKey+0x3c>

08029f4c <LmHandlerNvmDataStore>:

LmHandlerErrorStatus_t LmHandlerNvmDataStore( void )
{
 8029f4c:	b510      	push	{r4, lr}
 8029f4e:	b08a      	sub	sp, #40	; 0x28
    LoRaMacNvmData_t *nvm;
    uint32_t nvm_size;
    LmHandlerErrorStatus_t lmhStatus = LORAMAC_HANDLER_SUCCESS;
    int32_t status = NVM_DATA_OK;

    lmhStatus = LmHandlerHalt();
 8029f50:	f7ff fd27 	bl	80299a2 <LmHandlerHalt>
 8029f54:	1e04      	subs	r4, r0, #0

    if( lmhStatus == LORAMAC_HANDLER_SUCCESS )
 8029f56:	d00b      	beq.n	8029f70 <LmHandlerNvmDataStore+0x24>
        {
            lmhStatus = LORAMAC_HANDLER_ERROR;
        }
    }

    if( ( lmhStatus == LORAMAC_HANDLER_SUCCESS ) && ( LmHandlerCallbacks->OnNvmDataChange != NULL ) )
 8029f58:	2c00      	cmp	r4, #0
 8029f5a:	d106      	bne.n	8029f6a <LmHandlerNvmDataStore+0x1e>
 8029f5c:	4b18      	ldr	r3, [pc, #96]	; (8029fc0 <LmHandlerNvmDataStore+0x74>)
 8029f5e:	681b      	ldr	r3, [r3, #0]
 8029f60:	69db      	ldr	r3, [r3, #28]
 8029f62:	2b00      	cmp	r3, #0
 8029f64:	d001      	beq.n	8029f6a <LmHandlerNvmDataStore+0x1e>
    {
        LmHandlerCallbacks->OnNvmDataChange( LORAMAC_HANDLER_NVM_STORE );
 8029f66:	2001      	movs	r0, #1
 8029f68:	4798      	blx	r3

    return lmhStatus;
#else
    return LORAMAC_HANDLER_ERROR;
#endif /* CONTEXT_MANAGEMENT_ENABLED */
}
 8029f6a:	0020      	movs	r0, r4
 8029f6c:	b00a      	add	sp, #40	; 0x28
 8029f6e:	bd10      	pop	{r4, pc}
        status = NvmDataMgmtStoreBegin();
 8029f70:	f005 f818 	bl	802efa4 <NvmDataMgmtStoreBegin>
        if( status == NVM_DATA_NO_UPDATED_DATA )
 8029f74:	1c83      	adds	r3, r0, #2
 8029f76:	d014      	beq.n	8029fa2 <LmHandlerNvmDataStore+0x56>
        else if( ( status != NVM_DATA_OK ) || ( LmHandlerCallbacks->OnStoreContextRequest == NULL ) )
 8029f78:	2800      	cmp	r0, #0
 8029f7a:	d11b      	bne.n	8029fb4 <LmHandlerNvmDataStore+0x68>
 8029f7c:	4b10      	ldr	r3, [pc, #64]	; (8029fc0 <LmHandlerNvmDataStore+0x74>)
 8029f7e:	681b      	ldr	r3, [r3, #0]
 8029f80:	695b      	ldr	r3, [r3, #20]
 8029f82:	2b00      	cmp	r3, #0
 8029f84:	d019      	beq.n	8029fba <LmHandlerNvmDataStore+0x6e>
            mibReq.Type = MIB_NVM_CTXS;
 8029f86:	2327      	movs	r3, #39	; 0x27
 8029f88:	466a      	mov	r2, sp
 8029f8a:	7013      	strb	r3, [r2, #0]
            LoRaMacMibGetRequestConfirm( &mibReq );
 8029f8c:	4668      	mov	r0, sp
 8029f8e:	f003 f965 	bl	802d25c <LoRaMacMibGetRequestConfirm>
            nvm = ( LoRaMacNvmData_t * )mibReq.Param.Contexts;
 8029f92:	9801      	ldr	r0, [sp, #4]
            LmHandlerCallbacks->OnStoreContextRequest( nvm, nvm_size );
 8029f94:	4b0a      	ldr	r3, [pc, #40]	; (8029fc0 <LmHandlerNvmDataStore+0x74>)
 8029f96:	681b      	ldr	r3, [r3, #0]
 8029f98:	695b      	ldr	r3, [r3, #20]
 8029f9a:	21a0      	movs	r1, #160	; 0xa0
 8029f9c:	00c9      	lsls	r1, r1, #3
 8029f9e:	4798      	blx	r3
 8029fa0:	e001      	b.n	8029fa6 <LmHandlerNvmDataStore+0x5a>
            lmhStatus = LORAMAC_HANDLER_NVM_DATA_UP_TO_DATE;
 8029fa2:	2408      	movs	r4, #8
 8029fa4:	4264      	negs	r4, r4
        if( NvmDataMgmtStoreEnd() != NVM_DATA_OK )
 8029fa6:	f005 f80f 	bl	802efc8 <NvmDataMgmtStoreEnd>
 8029faa:	2800      	cmp	r0, #0
 8029fac:	d0d4      	beq.n	8029f58 <LmHandlerNvmDataStore+0xc>
            lmhStatus = LORAMAC_HANDLER_ERROR;
 8029fae:	2401      	movs	r4, #1
 8029fb0:	4264      	negs	r4, r4
 8029fb2:	e7da      	b.n	8029f6a <LmHandlerNvmDataStore+0x1e>
            lmhStatus = LORAMAC_HANDLER_ERROR;
 8029fb4:	2401      	movs	r4, #1
 8029fb6:	4264      	negs	r4, r4
 8029fb8:	e7f5      	b.n	8029fa6 <LmHandlerNvmDataStore+0x5a>
 8029fba:	2401      	movs	r4, #1
 8029fbc:	4264      	negs	r4, r4
 8029fbe:	e7f2      	b.n	8029fa6 <LmHandlerNvmDataStore+0x5a>
 8029fc0:	2000ba5c 	.word	0x2000ba5c

08029fc4 <LmhpComplianceIsInitialized>:
    ComplianceTestState.IsClassReqCmdPending = false;
}

static bool LmhpComplianceIsInitialized( void )
{
    return ComplianceTestState.Initialized;
 8029fc4:	4b01      	ldr	r3, [pc, #4]	; (8029fcc <LmhpComplianceIsInitialized+0x8>)
 8029fc6:	7818      	ldrb	r0, [r3, #0]
}
 8029fc8:	4770      	bx	lr
 8029fca:	46c0      	nop			; (mov r8, r8)
 8029fcc:	2000bac8 	.word	0x2000bac8

08029fd0 <LmhpComplianceIsTxPending>:

static bool LmhpComplianceIsTxPending( void )
{
    return ComplianceTestState.IsTxPending;
 8029fd0:	4b01      	ldr	r3, [pc, #4]	; (8029fd8 <LmhpComplianceIsTxPending+0x8>)
 8029fd2:	7858      	ldrb	r0, [r3, #1]
}
 8029fd4:	4770      	bx	lr
 8029fd6:	46c0      	nop			; (mov r8, r8)
 8029fd8:	2000bac8 	.word	0x2000bac8

08029fdc <LmhpComplianceOnMlmeConfirm>:
            }
#endif /* CLASS_B not available */
        default:
            break;
    }
}
 8029fdc:	4770      	bx	lr

08029fde <LmhpComplianceOnMlmeIndication>:
            }
#endif /* CLASS_B not available */
        default:
            break;
    }
}
 8029fde:	4770      	bx	lr

08029fe0 <OnProcessTimer>:
    }
}
#endif /* CLASS_B not available */

static void OnProcessTimer( void *context )
{
 8029fe0:	b510      	push	{r4, lr}
    if( ComplianceTestState.DataBufferSize != 0 )
 8029fe2:	4b06      	ldr	r3, [pc, #24]	; (8029ffc <OnProcessTimer+0x1c>)
 8029fe4:	7a9b      	ldrb	r3, [r3, #10]
 8029fe6:	2b00      	cmp	r3, #0
 8029fe8:	d002      	beq.n	8029ff0 <OnProcessTimer+0x10>
    {
        ComplianceTestState.IsTxPending = true;
 8029fea:	4b04      	ldr	r3, [pc, #16]	; (8029ffc <OnProcessTimer+0x1c>)
 8029fec:	2201      	movs	r2, #1
 8029fee:	705a      	strb	r2, [r3, #1]
    }
    if( CompliancePackage.OnPackageProcessEvent != NULL )
 8029ff0:	4b03      	ldr	r3, [pc, #12]	; (802a000 <OnProcessTimer+0x20>)
 8029ff2:	695b      	ldr	r3, [r3, #20]
 8029ff4:	2b00      	cmp	r3, #0
 8029ff6:	d000      	beq.n	8029ffa <OnProcessTimer+0x1a>
    {
        CompliancePackage.OnPackageProcessEvent();
 8029ff8:	4798      	blx	r3
    }
}
 8029ffa:	bd10      	pop	{r4, pc}
 8029ffc:	2000bac8 	.word	0x2000bac8
 802a000:	2000b094 	.word	0x2000b094

0802a004 <LmhpComplianceOnMcpsIndication>:
{
 802a004:	b5f0      	push	{r4, r5, r6, r7, lr}
 802a006:	b097      	sub	sp, #92	; 0x5c
    if( ComplianceTestState.Initialized == false )
 802a008:	4bbb      	ldr	r3, [pc, #748]	; (802a2f8 <LmhpComplianceOnMcpsIndication+0x2f4>)
 802a00a:	781b      	ldrb	r3, [r3, #0]
 802a00c:	2b00      	cmp	r3, #0
 802a00e:	d035      	beq.n	802a07c <LmhpComplianceOnMcpsIndication+0x78>
    if( ( mcpsIndication->Port > 0 ) || ( mcpsIndication->AckReceived == true ) )
 802a010:	78c3      	ldrb	r3, [r0, #3]
 802a012:	2b00      	cmp	r3, #0
 802a014:	d102      	bne.n	802a01c <LmhpComplianceOnMcpsIndication+0x18>
 802a016:	7b83      	ldrb	r3, [r0, #14]
 802a018:	2b00      	cmp	r3, #0
 802a01a:	d003      	beq.n	802a024 <LmhpComplianceOnMcpsIndication+0x20>
        ComplianceTestState.RxAppCnt++;
 802a01c:	4ab6      	ldr	r2, [pc, #728]	; (802a2f8 <LmhpComplianceOnMcpsIndication+0x2f4>)
 802a01e:	8a13      	ldrh	r3, [r2, #16]
 802a020:	3301      	adds	r3, #1
 802a022:	8213      	strh	r3, [r2, #16]
    if( mcpsIndication->RxData == false )
 802a024:	7b43      	ldrb	r3, [r0, #13]
 802a026:	2b00      	cmp	r3, #0
 802a028:	d028      	beq.n	802a07c <LmhpComplianceOnMcpsIndication+0x78>
    if( mcpsIndication->Port != COMPLIANCE_PORT )
 802a02a:	78c3      	ldrb	r3, [r0, #3]
 802a02c:	2be0      	cmp	r3, #224	; 0xe0
 802a02e:	d125      	bne.n	802a07c <LmhpComplianceOnMcpsIndication+0x78>
    ComplianceTestState.DataBufferSize = 0;
 802a030:	4bb1      	ldr	r3, [pc, #708]	; (802a2f8 <LmhpComplianceOnMcpsIndication+0x2f4>)
 802a032:	2200      	movs	r2, #0
 802a034:	729a      	strb	r2, [r3, #10]
    switch( mcpsIndication->Buffer[cmdIndex++] )
 802a036:	6882      	ldr	r2, [r0, #8]
 802a038:	7813      	ldrb	r3, [r2, #0]
 802a03a:	2b7f      	cmp	r3, #127	; 0x7f
 802a03c:	d814      	bhi.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
 802a03e:	009b      	lsls	r3, r3, #2
 802a040:	49ae      	ldr	r1, [pc, #696]	; (802a2fc <LmhpComplianceOnMcpsIndication+0x2f8>)
 802a042:	58cb      	ldr	r3, [r1, r3]
 802a044:	469f      	mov	pc, r3
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = COMPLIANCE_PKG_VERSION_ANS;
 802a046:	4bac      	ldr	r3, [pc, #688]	; (802a2f8 <LmhpComplianceOnMcpsIndication+0x2f4>)
 802a048:	2101      	movs	r1, #1
 802a04a:	7299      	strb	r1, [r3, #10]
 802a04c:	2200      	movs	r2, #0
 802a04e:	68d8      	ldr	r0, [r3, #12]
 802a050:	7002      	strb	r2, [r0, #0]
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = COMPLIANCE_ID;
 802a052:	7a9a      	ldrb	r2, [r3, #10]
 802a054:	1c50      	adds	r0, r2, #1
 802a056:	7298      	strb	r0, [r3, #10]
 802a058:	2006      	movs	r0, #6
 802a05a:	68dc      	ldr	r4, [r3, #12]
 802a05c:	54a0      	strb	r0, [r4, r2]
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = COMPLIANCE_VERSION;
 802a05e:	68d8      	ldr	r0, [r3, #12]
 802a060:	7a9a      	ldrb	r2, [r3, #10]
 802a062:	1c54      	adds	r4, r2, #1
 802a064:	729c      	strb	r4, [r3, #10]
 802a066:	5481      	strb	r1, [r0, r2]
    if( ComplianceTestState.DataBufferSize != 0 )
 802a068:	4ba3      	ldr	r3, [pc, #652]	; (802a2f8 <LmhpComplianceOnMcpsIndication+0x2f4>)
 802a06a:	7a9b      	ldrb	r3, [r3, #10]
 802a06c:	2b00      	cmp	r3, #0
 802a06e:	d100      	bne.n	802a072 <LmhpComplianceOnMcpsIndication+0x6e>
 802a070:	e13b      	b.n	802a2ea <LmhpComplianceOnMcpsIndication+0x2e6>
        if( ProcessTimer.IsRunning == 0U)
 802a072:	4ba3      	ldr	r3, [pc, #652]	; (802a300 <LmhpComplianceOnMcpsIndication+0x2fc>)
 802a074:	7a5b      	ldrb	r3, [r3, #9]
 802a076:	2b00      	cmp	r3, #0
 802a078:	d100      	bne.n	802a07c <LmhpComplianceOnMcpsIndication+0x78>
 802a07a:	e12c      	b.n	802a2d6 <LmhpComplianceOnMcpsIndication+0x2d2>
}
 802a07c:	b017      	add	sp, #92	; 0x5c
 802a07e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                ComplianceTestState.IsResetCmdPending = true;
 802a080:	4a9d      	ldr	r2, [pc, #628]	; (802a2f8 <LmhpComplianceOnMcpsIndication+0x2f4>)
 802a082:	2334      	movs	r3, #52	; 0x34
 802a084:	2101      	movs	r1, #1
 802a086:	54d1      	strb	r1, [r2, r3]
                break;
 802a088:	e7ee      	b.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                if( CompliancePackage.OnJoinRequest != NULL )
 802a08a:	4b9e      	ldr	r3, [pc, #632]	; (802a304 <LmhpComplianceOnMcpsIndication+0x300>)
 802a08c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802a08e:	2b00      	cmp	r3, #0
 802a090:	d0ea      	beq.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                    CompliancePackage.OnJoinRequest( ACTIVATION_TYPE_OTAA, true );
 802a092:	2101      	movs	r1, #1
 802a094:	2002      	movs	r0, #2
 802a096:	4798      	blx	r3
 802a098:	e7e6      	b.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                ComplianceTestState.NewClass = ( DeviceClass_t ) mcpsIndication->Buffer[cmdIndex++];
 802a09a:	7851      	ldrb	r1, [r2, #1]
 802a09c:	4b96      	ldr	r3, [pc, #600]	; (802a2f8 <LmhpComplianceOnMcpsIndication+0x2f4>)
 802a09e:	2236      	movs	r2, #54	; 0x36
 802a0a0:	5499      	strb	r1, [r3, r2]
                ComplianceTestState.IsClassReqCmdPending = true;
 802a0a2:	3a01      	subs	r2, #1
 802a0a4:	2101      	movs	r1, #1
 802a0a6:	5499      	strb	r1, [r3, r2]
                break;
 802a0a8:	e7de      	b.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                mibReq.Type            = MIB_ADR;
 802a0aa:	2304      	movs	r3, #4
 802a0ac:	4669      	mov	r1, sp
 802a0ae:	710b      	strb	r3, [r1, #4]
                mibReq.Param.AdrEnable = mcpsIndication->Buffer[cmdIndex++];
 802a0b0:	7853      	ldrb	r3, [r2, #1]
 802a0b2:	1e5a      	subs	r2, r3, #1
 802a0b4:	4193      	sbcs	r3, r2
 802a0b6:	720b      	strb	r3, [r1, #8]
                LoRaMacMibSetRequestConfirm( &mibReq );
 802a0b8:	a801      	add	r0, sp, #4
 802a0ba:	f003 f9fb 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
                break;
 802a0be:	e7d3      	b.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                LoRaMacTestSetDutyCycleOn( mcpsIndication->Buffer[cmdIndex++] );
 802a0c0:	7850      	ldrb	r0, [r2, #1]
 802a0c2:	1e43      	subs	r3, r0, #1
 802a0c4:	4198      	sbcs	r0, r3
 802a0c6:	b2c0      	uxtb	r0, r0
 802a0c8:	f003 fe86 	bl	802ddd8 <LoRaMacTestSetDutyCycleOn>
                break;
 802a0cc:	e7cc      	b.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                uint32_t periodicity[] = { 0, 5000, 10000, 20000, 30000, 40000, 50000, 60000, 120000, 240000, 480000 };
 802a0ce:	a801      	add	r0, sp, #4
 802a0d0:	4b8d      	ldr	r3, [pc, #564]	; (802a308 <LmhpComplianceOnMcpsIndication+0x304>)
 802a0d2:	0001      	movs	r1, r0
 802a0d4:	cb31      	ldmia	r3!, {r0, r4, r5}
 802a0d6:	c131      	stmia	r1!, {r0, r4, r5}
 802a0d8:	cb31      	ldmia	r3!, {r0, r4, r5}
 802a0da:	c131      	stmia	r1!, {r0, r4, r5}
 802a0dc:	cb31      	ldmia	r3!, {r0, r4, r5}
 802a0de:	c131      	stmia	r1!, {r0, r4, r5}
 802a0e0:	cb11      	ldmia	r3!, {r0, r4}
 802a0e2:	c111      	stmia	r1!, {r0, r4}
                uint8_t  index         = mcpsIndication->Buffer[cmdIndex++];
 802a0e4:	7853      	ldrb	r3, [r2, #1]
                if( index < ( sizeof( periodicity ) / sizeof( uint32_t ) ) )
 802a0e6:	2b0a      	cmp	r3, #10
 802a0e8:	d8be      	bhi.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                    if( ComplianceParams->OnTxPeriodicityChanged != NULL )
 802a0ea:	4a88      	ldr	r2, [pc, #544]	; (802a30c <LmhpComplianceOnMcpsIndication+0x308>)
 802a0ec:	6812      	ldr	r2, [r2, #0]
 802a0ee:	6852      	ldr	r2, [r2, #4]
 802a0f0:	2a00      	cmp	r2, #0
 802a0f2:	d0b9      	beq.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                        ComplianceParams->OnTxPeriodicityChanged( periodicity[index] );
 802a0f4:	009b      	lsls	r3, r3, #2
 802a0f6:	a901      	add	r1, sp, #4
 802a0f8:	5858      	ldr	r0, [r3, r1]
 802a0fa:	4790      	blx	r2
                break;
 802a0fc:	e7b4      	b.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                uint8_t frameType = mcpsIndication->Buffer[cmdIndex++];
 802a0fe:	7853      	ldrb	r3, [r2, #1]
                if( ( frameType == 1 ) || ( frameType == 2 ) )
 802a100:	1e5a      	subs	r2, r3, #1
 802a102:	b2d2      	uxtb	r2, r2
 802a104:	2a01      	cmp	r2, #1
 802a106:	d8af      	bhi.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                    ComplianceTestState.IsTxConfirmed = ( frameType != 1 ) ? LORAMAC_HANDLER_CONFIRMED_MSG : LORAMAC_HANDLER_UNCONFIRMED_MSG;
 802a108:	3b01      	subs	r3, #1
 802a10a:	1e5a      	subs	r2, r3, #1
 802a10c:	4193      	sbcs	r3, r2
 802a10e:	b2d8      	uxtb	r0, r3
 802a110:	4b79      	ldr	r3, [pc, #484]	; (802a2f8 <LmhpComplianceOnMcpsIndication+0x2f4>)
 802a112:	7218      	strb	r0, [r3, #8]
                    if( ComplianceParams->OnTxFrameCtrlChanged != NULL )
 802a114:	4b7d      	ldr	r3, [pc, #500]	; (802a30c <LmhpComplianceOnMcpsIndication+0x308>)
 802a116:	681b      	ldr	r3, [r3, #0]
 802a118:	689b      	ldr	r3, [r3, #8]
 802a11a:	2b00      	cmp	r3, #0
 802a11c:	d0a4      	beq.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                        ComplianceParams->OnTxFrameCtrlChanged( ComplianceTestState.IsTxConfirmed );
 802a11e:	4798      	blx	r3
 802a120:	e7a2      	b.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = COMPLIANCE_ECHO_PAYLOAD_ANS;
 802a122:	4b75      	ldr	r3, [pc, #468]	; (802a2f8 <LmhpComplianceOnMcpsIndication+0x2f4>)
 802a124:	68da      	ldr	r2, [r3, #12]
 802a126:	2101      	movs	r1, #1
 802a128:	7299      	strb	r1, [r3, #10]
 802a12a:	2308      	movs	r3, #8
 802a12c:	7013      	strb	r3, [r2, #0]
                for( uint8_t i = 1; i < MIN( mcpsIndication->BufferSize, ComplianceTestState.DataBufferMaxSize );
 802a12e:	3b07      	subs	r3, #7
    switch( mcpsIndication->Buffer[cmdIndex++] )
 802a130:	2401      	movs	r4, #1
                for( uint8_t i = 1; i < MIN( mcpsIndication->BufferSize, ComplianceTestState.DataBufferMaxSize );
 802a132:	e00f      	b.n	802a154 <LmhpComplianceOnMcpsIndication+0x150>
 802a134:	b2d2      	uxtb	r2, r2
 802a136:	429a      	cmp	r2, r3
 802a138:	d996      	bls.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                    ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = mcpsIndication->Buffer[cmdIndex++] + 1;
 802a13a:	1c65      	adds	r5, r4, #1
 802a13c:	6882      	ldr	r2, [r0, #8]
 802a13e:	5d12      	ldrb	r2, [r2, r4]
 802a140:	496d      	ldr	r1, [pc, #436]	; (802a2f8 <LmhpComplianceOnMcpsIndication+0x2f4>)
 802a142:	68ce      	ldr	r6, [r1, #12]
 802a144:	7a8c      	ldrb	r4, [r1, #10]
 802a146:	1c67      	adds	r7, r4, #1
 802a148:	728f      	strb	r7, [r1, #10]
 802a14a:	3201      	adds	r2, #1
 802a14c:	5532      	strb	r2, [r6, r4]
                     i++ )
 802a14e:	3301      	adds	r3, #1
 802a150:	b2db      	uxtb	r3, r3
                    ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = mcpsIndication->Buffer[cmdIndex++] + 1;
 802a152:	b2ec      	uxtb	r4, r5
                for( uint8_t i = 1; i < MIN( mcpsIndication->BufferSize, ComplianceTestState.DataBufferMaxSize );
 802a154:	4a68      	ldr	r2, [pc, #416]	; (802a2f8 <LmhpComplianceOnMcpsIndication+0x2f4>)
 802a156:	7a51      	ldrb	r1, [r2, #9]
 802a158:	7b05      	ldrb	r5, [r0, #12]
 802a15a:	1c0a      	adds	r2, r1, #0
 802a15c:	42a9      	cmp	r1, r5
 802a15e:	d9e9      	bls.n	802a134 <LmhpComplianceOnMcpsIndication+0x130>
 802a160:	1c2a      	adds	r2, r5, #0
 802a162:	e7e7      	b.n	802a134 <LmhpComplianceOnMcpsIndication+0x130>
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = COMPLIANCE_RX_APP_CNT_ANS;
 802a164:	4b64      	ldr	r3, [pc, #400]	; (802a2f8 <LmhpComplianceOnMcpsIndication+0x2f4>)
 802a166:	2201      	movs	r2, #1
 802a168:	729a      	strb	r2, [r3, #10]
 802a16a:	3208      	adds	r2, #8
 802a16c:	68d9      	ldr	r1, [r3, #12]
 802a16e:	700a      	strb	r2, [r1, #0]
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = ComplianceTestState.RxAppCnt;
 802a170:	8a19      	ldrh	r1, [r3, #16]
 802a172:	7a9a      	ldrb	r2, [r3, #10]
 802a174:	1c50      	adds	r0, r2, #1
 802a176:	7298      	strb	r0, [r3, #10]
 802a178:	68d8      	ldr	r0, [r3, #12]
 802a17a:	5481      	strb	r1, [r0, r2]
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = ComplianceTestState.RxAppCnt >> 8;
 802a17c:	8a1a      	ldrh	r2, [r3, #16]
 802a17e:	68d8      	ldr	r0, [r3, #12]
 802a180:	7a99      	ldrb	r1, [r3, #10]
 802a182:	1c4c      	adds	r4, r1, #1
 802a184:	729c      	strb	r4, [r3, #10]
 802a186:	0a12      	lsrs	r2, r2, #8
 802a188:	5442      	strb	r2, [r0, r1]
                break;
 802a18a:	e76d      	b.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                ComplianceTestState.RxAppCnt = 0;
 802a18c:	4b5a      	ldr	r3, [pc, #360]	; (802a2f8 <LmhpComplianceOnMcpsIndication+0x2f4>)
 802a18e:	2200      	movs	r2, #0
 802a190:	821a      	strh	r2, [r3, #16]
                break;
 802a192:	e769      	b.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                mlmeReq.Type = MLME_LINK_CHECK;
 802a194:	a801      	add	r0, sp, #4
 802a196:	2305      	movs	r3, #5
 802a198:	7003      	strb	r3, [r0, #0]
                LoRaMacMlmeRequest( &mlmeReq );
 802a19a:	f003 fc01 	bl	802d9a0 <LoRaMacMlmeRequest>
                break;
 802a19e:	e763      	b.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                CompliancePackage.OnDeviceTimeRequest( );
 802a1a0:	4b58      	ldr	r3, [pc, #352]	; (802a304 <LmhpComplianceOnMcpsIndication+0x300>)
 802a1a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802a1a4:	4798      	blx	r3
                break;
 802a1a6:	e75f      	b.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                ComplianceTestState.ClassBStatus.PingSlotPeriodicity = mcpsIndication->Buffer[cmdIndex++];
 802a1a8:	7850      	ldrb	r0, [r2, #1]
 802a1aa:	4b53      	ldr	r3, [pc, #332]	; (802a2f8 <LmhpComplianceOnMcpsIndication+0x2f4>)
 802a1ac:	7558      	strb	r0, [r3, #21]
                if( ComplianceParams->OnPingSlotPeriodicityChanged != NULL )
 802a1ae:	4b57      	ldr	r3, [pc, #348]	; (802a30c <LmhpComplianceOnMcpsIndication+0x308>)
 802a1b0:	681b      	ldr	r3, [r3, #0]
 802a1b2:	68db      	ldr	r3, [r3, #12]
 802a1b4:	2b00      	cmp	r3, #0
 802a1b6:	d100      	bne.n	802a1ba <LmhpComplianceOnMcpsIndication+0x1b6>
 802a1b8:	e756      	b.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                    ComplianceParams->OnPingSlotPeriodicityChanged( ComplianceTestState.ClassBStatus.PingSlotPeriodicity );
 802a1ba:	4798      	blx	r3
 802a1bc:	e754      	b.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                if( mcpsIndication->BufferSize == 7 )
 802a1be:	7b03      	ldrb	r3, [r0, #12]
 802a1c0:	2b07      	cmp	r3, #7
 802a1c2:	d000      	beq.n	802a1c6 <LmhpComplianceOnMcpsIndication+0x1c2>
 802a1c4:	e750      	b.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                    mlmeReq.Type = MLME_TXCW;
 802a1c6:	ab01      	add	r3, sp, #4
 802a1c8:	2106      	movs	r1, #6
 802a1ca:	7019      	strb	r1, [r3, #0]
                        ( uint16_t )( mcpsIndication->Buffer[cmdIndex] | ( mcpsIndication->Buffer[cmdIndex + 1] << 8 ) );
 802a1cc:	7851      	ldrb	r1, [r2, #1]
 802a1ce:	7894      	ldrb	r4, [r2, #2]
 802a1d0:	0224      	lsls	r4, r4, #8
 802a1d2:	4321      	orrs	r1, r4
                    mlmeReq.Req.TxCw.Timeout =
 802a1d4:	8099      	strh	r1, [r3, #4]
                        ( uint32_t )( mcpsIndication->Buffer[cmdIndex] | ( mcpsIndication->Buffer[cmdIndex + 1] << 8 ) |
 802a1d6:	78d1      	ldrb	r1, [r2, #3]
 802a1d8:	7914      	ldrb	r4, [r2, #4]
 802a1da:	0224      	lsls	r4, r4, #8
 802a1dc:	4321      	orrs	r1, r4
                                      ( mcpsIndication->Buffer[cmdIndex + 2] << 16 ) ) *
 802a1de:	7952      	ldrb	r2, [r2, #5]
 802a1e0:	0412      	lsls	r2, r2, #16
                        ( uint32_t )( mcpsIndication->Buffer[cmdIndex] | ( mcpsIndication->Buffer[cmdIndex + 1] << 8 ) |
 802a1e2:	430a      	orrs	r2, r1
                                      ( mcpsIndication->Buffer[cmdIndex + 2] << 16 ) ) *
 802a1e4:	2164      	movs	r1, #100	; 0x64
 802a1e6:	434a      	muls	r2, r1
                    mlmeReq.Req.TxCw.Frequency =
 802a1e8:	9203      	str	r2, [sp, #12]
                    mlmeReq.Req.TxCw.Power = mcpsIndication->Buffer[cmdIndex++];
 802a1ea:	6882      	ldr	r2, [r0, #8]
 802a1ec:	7992      	ldrb	r2, [r2, #6]
 802a1ee:	b252      	sxtb	r2, r2
 802a1f0:	731a      	strb	r2, [r3, #12]
                    LoRaMacMlmeRequest( &mlmeReq );
 802a1f2:	0018      	movs	r0, r3
 802a1f4:	f003 fbd4 	bl	802d9a0 <LoRaMacMlmeRequest>
                break;
 802a1f8:	e736      	b.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                mibReq.Type = MIB_IS_CERT_FPORT_ON;
 802a1fa:	233b      	movs	r3, #59	; 0x3b
 802a1fc:	466a      	mov	r2, sp
 802a1fe:	2130      	movs	r1, #48	; 0x30
 802a200:	1852      	adds	r2, r2, r1
 802a202:	7013      	strb	r3, [r2, #0]
                mibReq.Param.IsCertPortOn = false;
 802a204:	2300      	movs	r3, #0
 802a206:	466a      	mov	r2, sp
 802a208:	3104      	adds	r1, #4
 802a20a:	1852      	adds	r2, r2, r1
 802a20c:	7013      	strb	r3, [r2, #0]
                LoRaMacMibSetRequestConfirm( &mibReq );
 802a20e:	a80c      	add	r0, sp, #48	; 0x30
 802a210:	f003 f950 	bl	802d4b4 <LoRaMacMibSetRequestConfirm>
                ComplianceTestState.IsResetCmdPending = true;
 802a214:	4a38      	ldr	r2, [pc, #224]	; (802a2f8 <LmhpComplianceOnMcpsIndication+0x2f4>)
 802a216:	2334      	movs	r3, #52	; 0x34
 802a218:	2101      	movs	r1, #1
 802a21a:	54d1      	strb	r1, [r2, r3]
                break;
 802a21c:	e724      	b.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
                mibReq.Type = MIB_LORAWAN_VERSION;
 802a21e:	ac01      	add	r4, sp, #4
 802a220:	232a      	movs	r3, #42	; 0x2a
 802a222:	7023      	strb	r3, [r4, #0]
                LoRaMacMibGetRequestConfirm( &mibReq );
 802a224:	0020      	movs	r0, r4
 802a226:	f003 f819 	bl	802d25c <LoRaMacMibGetRequestConfirm>
                lrwanVersion   = mibReq.Param.LrWanVersion.LoRaWan;
 802a22a:	9902      	ldr	r1, [sp, #8]
                lrwanRpVersion = mibReq.Param.LrWanVersion.LoRaWanRegion;
 802a22c:	9a03      	ldr	r2, [sp, #12]
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = COMPLIANCE_DUT_VERSION_ANS;
 802a22e:	4b32      	ldr	r3, [pc, #200]	; (802a2f8 <LmhpComplianceOnMcpsIndication+0x2f4>)
 802a230:	7a98      	ldrb	r0, [r3, #10]
 802a232:	1c44      	adds	r4, r0, #1
 802a234:	729c      	strb	r4, [r3, #10]
 802a236:	247f      	movs	r4, #127	; 0x7f
 802a238:	68dd      	ldr	r5, [r3, #12]
 802a23a:	542c      	strb	r4, [r5, r0]
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = ComplianceParams->FwVersion.Fields.Major;
 802a23c:	4833      	ldr	r0, [pc, #204]	; (802a30c <LmhpComplianceOnMcpsIndication+0x308>)
 802a23e:	6800      	ldr	r0, [r0, #0]
 802a240:	7a9c      	ldrb	r4, [r3, #10]
 802a242:	1c65      	adds	r5, r4, #1
 802a244:	729d      	strb	r5, [r3, #10]
 802a246:	78c5      	ldrb	r5, [r0, #3]
 802a248:	68de      	ldr	r6, [r3, #12]
 802a24a:	5535      	strb	r5, [r6, r4]
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = ComplianceParams->FwVersion.Fields.Minor;
 802a24c:	7a9c      	ldrb	r4, [r3, #10]
 802a24e:	1c65      	adds	r5, r4, #1
 802a250:	729d      	strb	r5, [r3, #10]
 802a252:	7885      	ldrb	r5, [r0, #2]
 802a254:	68de      	ldr	r6, [r3, #12]
 802a256:	5535      	strb	r5, [r6, r4]
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = ComplianceParams->FwVersion.Fields.Patch;
 802a258:	7a9c      	ldrb	r4, [r3, #10]
 802a25a:	1c65      	adds	r5, r4, #1
 802a25c:	729d      	strb	r5, [r3, #10]
 802a25e:	7845      	ldrb	r5, [r0, #1]
 802a260:	68de      	ldr	r6, [r3, #12]
 802a262:	5535      	strb	r5, [r6, r4]
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = ComplianceParams->FwVersion.Fields.Revision;
 802a264:	7a9c      	ldrb	r4, [r3, #10]
 802a266:	1c65      	adds	r5, r4, #1
 802a268:	729d      	strb	r5, [r3, #10]
 802a26a:	7800      	ldrb	r0, [r0, #0]
 802a26c:	68dd      	ldr	r5, [r3, #12]
 802a26e:	5528      	strb	r0, [r5, r4]
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = lrwanVersion.Fields.Major;
 802a270:	7a98      	ldrb	r0, [r3, #10]
 802a272:	1c44      	adds	r4, r0, #1
 802a274:	729c      	strb	r4, [r3, #10]
 802a276:	0e0c      	lsrs	r4, r1, #24
 802a278:	68dd      	ldr	r5, [r3, #12]
 802a27a:	542c      	strb	r4, [r5, r0]
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = lrwanVersion.Fields.Minor;
 802a27c:	7a9c      	ldrb	r4, [r3, #10]
 802a27e:	1c60      	adds	r0, r4, #1
 802a280:	7298      	strb	r0, [r3, #10]
 802a282:	0208      	lsls	r0, r1, #8
 802a284:	0e00      	lsrs	r0, r0, #24
 802a286:	68dd      	ldr	r5, [r3, #12]
 802a288:	5528      	strb	r0, [r5, r4]
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = lrwanVersion.Fields.Patch;
 802a28a:	7a9c      	ldrb	r4, [r3, #10]
 802a28c:	1c60      	adds	r0, r4, #1
 802a28e:	7298      	strb	r0, [r3, #10]
 802a290:	0408      	lsls	r0, r1, #16
 802a292:	0e00      	lsrs	r0, r0, #24
 802a294:	68dd      	ldr	r5, [r3, #12]
 802a296:	5528      	strb	r0, [r5, r4]
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = lrwanVersion.Fields.Revision;
 802a298:	7a98      	ldrb	r0, [r3, #10]
 802a29a:	1c44      	adds	r4, r0, #1
 802a29c:	729c      	strb	r4, [r3, #10]
 802a29e:	68dc      	ldr	r4, [r3, #12]
 802a2a0:	5421      	strb	r1, [r4, r0]
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = lrwanRpVersion.Fields.Major;
 802a2a2:	7a99      	ldrb	r1, [r3, #10]
 802a2a4:	1c48      	adds	r0, r1, #1
 802a2a6:	7298      	strb	r0, [r3, #10]
 802a2a8:	0e10      	lsrs	r0, r2, #24
 802a2aa:	68dc      	ldr	r4, [r3, #12]
 802a2ac:	5460      	strb	r0, [r4, r1]
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = lrwanRpVersion.Fields.Minor;
 802a2ae:	7a98      	ldrb	r0, [r3, #10]
 802a2b0:	1c41      	adds	r1, r0, #1
 802a2b2:	7299      	strb	r1, [r3, #10]
 802a2b4:	0211      	lsls	r1, r2, #8
 802a2b6:	0e09      	lsrs	r1, r1, #24
 802a2b8:	68dc      	ldr	r4, [r3, #12]
 802a2ba:	5421      	strb	r1, [r4, r0]
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = lrwanRpVersion.Fields.Patch;
 802a2bc:	7a98      	ldrb	r0, [r3, #10]
 802a2be:	1c41      	adds	r1, r0, #1
 802a2c0:	7299      	strb	r1, [r3, #10]
 802a2c2:	0411      	lsls	r1, r2, #16
 802a2c4:	0e09      	lsrs	r1, r1, #24
 802a2c6:	68dc      	ldr	r4, [r3, #12]
 802a2c8:	5421      	strb	r1, [r4, r0]
                ComplianceTestState.DataBuffer[ComplianceTestState.DataBufferSize++] = lrwanRpVersion.Fields.Revision;
 802a2ca:	68d8      	ldr	r0, [r3, #12]
 802a2cc:	7a99      	ldrb	r1, [r3, #10]
 802a2ce:	1c4c      	adds	r4, r1, #1
 802a2d0:	729c      	strb	r4, [r3, #10]
 802a2d2:	5442      	strb	r2, [r0, r1]
                break;
 802a2d4:	e6c8      	b.n	802a068 <LmhpComplianceOnMcpsIndication+0x64>
            TimerSetValue( &ProcessTimer, 1000 );
 802a2d6:	21fa      	movs	r1, #250	; 0xfa
 802a2d8:	4c09      	ldr	r4, [pc, #36]	; (802a300 <LmhpComplianceOnMcpsIndication+0x2fc>)
 802a2da:	0089      	lsls	r1, r1, #2
 802a2dc:	0020      	movs	r0, r4
 802a2de:	f00a fa01 	bl	80346e4 <UTIL_TIMER_SetPeriod>
            TimerStart( &ProcessTimer );
 802a2e2:	0020      	movs	r0, r4
 802a2e4:	f00a f9b8 	bl	8034658 <UTIL_TIMER_Start>
 802a2e8:	e6c8      	b.n	802a07c <LmhpComplianceOnMcpsIndication+0x78>
        TimerStop( &ProcessTimer );
 802a2ea:	4805      	ldr	r0, [pc, #20]	; (802a300 <LmhpComplianceOnMcpsIndication+0x2fc>)
 802a2ec:	f00a f952 	bl	8034594 <UTIL_TIMER_Stop>
        ComplianceTestState.IsTxPending = false;
 802a2f0:	4b01      	ldr	r3, [pc, #4]	; (802a2f8 <LmhpComplianceOnMcpsIndication+0x2f4>)
 802a2f2:	2200      	movs	r2, #0
 802a2f4:	705a      	strb	r2, [r3, #1]
 802a2f6:	e6c1      	b.n	802a07c <LmhpComplianceOnMcpsIndication+0x78>
 802a2f8:	2000bac8 	.word	0x2000bac8
 802a2fc:	080351b8 	.word	0x080351b8
 802a300:	2000bb00 	.word	0x2000bb00
 802a304:	2000b094 	.word	0x2000b094
 802a308:	08034cc0 	.word	0x08034cc0
 802a30c:	2000bac4 	.word	0x2000bac4

0802a310 <LmhpComplianceProcess>:
{
 802a310:	b530      	push	{r4, r5, lr}
 802a312:	b083      	sub	sp, #12
    if( ComplianceTestState.IsTxPending == true )
 802a314:	4b27      	ldr	r3, [pc, #156]	; (802a3b4 <LmhpComplianceProcess+0xa4>)
 802a316:	785b      	ldrb	r3, [r3, #1]
 802a318:	2b00      	cmp	r3, #0
 802a31a:	d113      	bne.n	802a344 <LmhpComplianceProcess+0x34>
        if( ComplianceTestState.IsClassReqCmdPending == true )
 802a31c:	4a25      	ldr	r2, [pc, #148]	; (802a3b4 <LmhpComplianceProcess+0xa4>)
 802a31e:	2335      	movs	r3, #53	; 0x35
 802a320:	5cd3      	ldrb	r3, [r2, r3]
 802a322:	2b00      	cmp	r3, #0
 802a324:	d13c      	bne.n	802a3a0 <LmhpComplianceProcess+0x90>
    if( ComplianceTestState.IsResetCmdPending == true )
 802a326:	4a23      	ldr	r2, [pc, #140]	; (802a3b4 <LmhpComplianceProcess+0xa4>)
 802a328:	2334      	movs	r3, #52	; 0x34
 802a32a:	5cd3      	ldrb	r3, [r2, r3]
 802a32c:	2b00      	cmp	r3, #0
 802a32e:	d007      	beq.n	802a340 <LmhpComplianceProcess+0x30>
        ComplianceTestState.IsResetCmdPending = false;
 802a330:	2334      	movs	r3, #52	; 0x34
 802a332:	2100      	movs	r1, #0
 802a334:	54d1      	strb	r1, [r2, r3]
        if( CompliancePackage.OnSystemReset != NULL )
 802a336:	4b20      	ldr	r3, [pc, #128]	; (802a3b8 <LmhpComplianceProcess+0xa8>)
 802a338:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802a33a:	2b00      	cmp	r3, #0
 802a33c:	d000      	beq.n	802a340 <LmhpComplianceProcess+0x30>
            CompliancePackage.OnSystemReset( );
 802a33e:	4798      	blx	r3
}
 802a340:	b003      	add	sp, #12
 802a342:	bd30      	pop	{r4, r5, pc}
        TimerTime_t now = TimerGetCurrentTime( );
 802a344:	f00a f8e6 	bl	8034514 <UTIL_TIMER_GetCurrentTime>
 802a348:	0004      	movs	r4, r0
        if( now > ( ComplianceTestState.TxPendingTimestamp + LmHandlerGetDutyCycleWaitTime( ) ) )
 802a34a:	4b1a      	ldr	r3, [pc, #104]	; (802a3b4 <LmhpComplianceProcess+0xa4>)
 802a34c:	685d      	ldr	r5, [r3, #4]
 802a34e:	f7fe ffc5 	bl	80292dc <LmHandlerGetDutyCycleWaitTime>
 802a352:	182d      	adds	r5, r5, r0
 802a354:	42a5      	cmp	r5, r4
 802a356:	d2e6      	bcs.n	802a326 <LmhpComplianceProcess+0x16>
            if( ComplianceTestState.DataBufferSize != 0 )
 802a358:	4b16      	ldr	r3, [pc, #88]	; (802a3b4 <LmhpComplianceProcess+0xa4>)
 802a35a:	7a9b      	ldrb	r3, [r3, #10]
 802a35c:	2b00      	cmp	r3, #0
 802a35e:	d0e2      	beq.n	802a326 <LmhpComplianceProcess+0x16>
                LmHandlerAppData_t appData =
 802a360:	22e0      	movs	r2, #224	; 0xe0
 802a362:	4669      	mov	r1, sp
 802a364:	700a      	strb	r2, [r1, #0]
 802a366:	704b      	strb	r3, [r1, #1]
                    .Buffer     = ComplianceTestState.DataBuffer,
 802a368:	4b12      	ldr	r3, [pc, #72]	; (802a3b4 <LmhpComplianceProcess+0xa4>)
                LmHandlerAppData_t appData =
 802a36a:	68da      	ldr	r2, [r3, #12]
 802a36c:	9201      	str	r2, [sp, #4]
                lmhStatus = LmHandlerSend( &appData, ComplianceTestState.IsTxConfirmed, true );
 802a36e:	7a19      	ldrb	r1, [r3, #8]
 802a370:	2201      	movs	r2, #1
 802a372:	4668      	mov	r0, sp
 802a374:	f7fe ffe2 	bl	802933c <LmHandlerSend>
                if( ( lmhStatus == LORAMAC_HANDLER_SUCCESS ) || ( lmhStatus == LORAMAC_HANDLER_PAYLOAD_LENGTH_RESTRICTED ) )
 802a378:	2800      	cmp	r0, #0
 802a37a:	d001      	beq.n	802a380 <LmhpComplianceProcess+0x70>
 802a37c:	1dc3      	adds	r3, r0, #7
 802a37e:	d106      	bne.n	802a38e <LmhpComplianceProcess+0x7e>
                    ComplianceTestState.IsTxPending = false;
 802a380:	4b0c      	ldr	r3, [pc, #48]	; (802a3b4 <LmhpComplianceProcess+0xa4>)
 802a382:	2200      	movs	r2, #0
 802a384:	705a      	strb	r2, [r3, #1]
                    ComplianceTestState.DataBufferSize = 0;
 802a386:	729a      	strb	r2, [r3, #10]
                ComplianceTestState.TxPendingTimestamp = now;
 802a388:	4b0a      	ldr	r3, [pc, #40]	; (802a3b4 <LmhpComplianceProcess+0xa4>)
 802a38a:	605c      	str	r4, [r3, #4]
 802a38c:	e7cb      	b.n	802a326 <LmhpComplianceProcess+0x16>
                    TimerSetValue( &ProcessTimer, 1500 );
 802a38e:	4d0b      	ldr	r5, [pc, #44]	; (802a3bc <LmhpComplianceProcess+0xac>)
 802a390:	490b      	ldr	r1, [pc, #44]	; (802a3c0 <LmhpComplianceProcess+0xb0>)
 802a392:	0028      	movs	r0, r5
 802a394:	f00a f9a6 	bl	80346e4 <UTIL_TIMER_SetPeriod>
                    TimerStart( &ProcessTimer );
 802a398:	0028      	movs	r0, r5
 802a39a:	f00a f95d 	bl	8034658 <UTIL_TIMER_Start>
 802a39e:	e7f3      	b.n	802a388 <LmhpComplianceProcess+0x78>
            ComplianceTestState.IsClassReqCmdPending = false;
 802a3a0:	0013      	movs	r3, r2
 802a3a2:	2235      	movs	r2, #53	; 0x35
 802a3a4:	2100      	movs	r1, #0
 802a3a6:	5499      	strb	r1, [r3, r2]
            LmHandlerRequestClass( ComplianceTestState.NewClass );
 802a3a8:	3201      	adds	r2, #1
 802a3aa:	5c98      	ldrb	r0, [r3, r2]
 802a3ac:	f7ff f866 	bl	802947c <LmHandlerRequestClass>
 802a3b0:	e7b9      	b.n	802a326 <LmhpComplianceProcess+0x16>
 802a3b2:	46c0      	nop			; (mov r8, r8)
 802a3b4:	2000bac8 	.word	0x2000bac8
 802a3b8:	2000b094 	.word	0x2000b094
 802a3bc:	2000bb00 	.word	0x2000bb00
 802a3c0:	000005dc 	.word	0x000005dc

0802a3c4 <LmhpComplianceInit>:
{
 802a3c4:	b510      	push	{r4, lr}
 802a3c6:	b082      	sub	sp, #8
    if( ( params != NULL ) && ( dataBuffer != NULL ) )
 802a3c8:	2800      	cmp	r0, #0
 802a3ca:	d012      	beq.n	802a3f2 <LmhpComplianceInit+0x2e>
 802a3cc:	2900      	cmp	r1, #0
 802a3ce:	d010      	beq.n	802a3f2 <LmhpComplianceInit+0x2e>
        ComplianceParams                      = ( LmhpComplianceParams_t * ) params;
 802a3d0:	4b14      	ldr	r3, [pc, #80]	; (802a424 <LmhpComplianceInit+0x60>)
 802a3d2:	6018      	str	r0, [r3, #0]
        ComplianceTestState.DataBuffer        = dataBuffer;
 802a3d4:	4b14      	ldr	r3, [pc, #80]	; (802a428 <LmhpComplianceInit+0x64>)
 802a3d6:	60d9      	str	r1, [r3, #12]
        ComplianceTestState.DataBufferMaxSize = dataBufferMaxSize;
 802a3d8:	725a      	strb	r2, [r3, #9]
        ComplianceTestState.Initialized       = true;
 802a3da:	2201      	movs	r2, #1
 802a3dc:	701a      	strb	r2, [r3, #0]
        TimerInit( &ProcessTimer, OnProcessTimer );
 802a3de:	2101      	movs	r1, #1
 802a3e0:	2300      	movs	r3, #0
 802a3e2:	9300      	str	r3, [sp, #0]
 802a3e4:	4b11      	ldr	r3, [pc, #68]	; (802a42c <LmhpComplianceInit+0x68>)
 802a3e6:	2200      	movs	r2, #0
 802a3e8:	4249      	negs	r1, r1
 802a3ea:	4811      	ldr	r0, [pc, #68]	; (802a430 <LmhpComplianceInit+0x6c>)
 802a3ec:	f00a f872 	bl	80344d4 <UTIL_TIMER_Create>
 802a3f0:	e004      	b.n	802a3fc <LmhpComplianceInit+0x38>
        ComplianceParams                = NULL;
 802a3f2:	2300      	movs	r3, #0
 802a3f4:	4a0b      	ldr	r2, [pc, #44]	; (802a424 <LmhpComplianceInit+0x60>)
 802a3f6:	6013      	str	r3, [r2, #0]
        ComplianceTestState.Initialized = false;
 802a3f8:	4a0b      	ldr	r2, [pc, #44]	; (802a428 <LmhpComplianceInit+0x64>)
 802a3fa:	7013      	strb	r3, [r2, #0]
    ComplianceTestState.RxAppCnt = 0;
 802a3fc:	4c0a      	ldr	r4, [pc, #40]	; (802a428 <LmhpComplianceInit+0x64>)
 802a3fe:	2300      	movs	r3, #0
 802a400:	8223      	strh	r3, [r4, #16]
    memset1( ( uint8_t * ) &ComplianceTestState.ClassBStatus, 0, sizeof( ClassBStatus_t ) / sizeof( uint8_t ) );
 802a402:	0020      	movs	r0, r4
 802a404:	3014      	adds	r0, #20
 802a406:	2220      	movs	r2, #32
 802a408:	2100      	movs	r1, #0
 802a40a:	f007 fe92 	bl	8032132 <memset1>
    ComplianceTestState.IsTxPending = false;
 802a40e:	2300      	movs	r3, #0
 802a410:	2200      	movs	r2, #0
 802a412:	7062      	strb	r2, [r4, #1]
    ComplianceTestState.IsBeaconRxStatusIndOn = false;
 802a414:	74a3      	strb	r3, [r4, #18]
    ComplianceTestState.IsResetCmdPending = false;
 802a416:	2234      	movs	r2, #52	; 0x34
 802a418:	54a3      	strb	r3, [r4, r2]
    ComplianceTestState.IsClassReqCmdPending = false;
 802a41a:	3201      	adds	r2, #1
 802a41c:	54a3      	strb	r3, [r4, r2]
}
 802a41e:	b002      	add	sp, #8
 802a420:	bd10      	pop	{r4, pc}
 802a422:	46c0      	nop			; (mov r8, r8)
 802a424:	2000bac4 	.word	0x2000bac4
 802a428:	2000bac8 	.word	0x2000bac8
 802a42c:	08029fe1 	.word	0x08029fe1
 802a430:	2000bb00 	.word	0x2000bb00

0802a434 <LmhpCompliancePackageFactory>:
}
 802a434:	4800      	ldr	r0, [pc, #0]	; (802a438 <LmhpCompliancePackageFactory+0x4>)
 802a436:	4770      	bx	lr
 802a438:	2000b094 	.word	0x2000b094

0802a43c <LmhpPackagesRegistrationInit>:
    }
#endif /* LORAWAN_PACKAGES_VERSION */
#endif /* LORAWAN_DATA_DISTRIB_MGT */

    return LORAMAC_HANDLER_SUCCESS;
}
 802a43c:	2000      	movs	r0, #0
 802a43e:	4770      	bx	lr

0802a440 <LmhpPackagesRegister>:
                break;
            }
    }
    return LORAMAC_HANDLER_SUCCESS;
#else
    return LORAMAC_HANDLER_ERROR;
 802a440:	2001      	movs	r0, #1
#endif /* LORAWAN_DATA_DISTRIB_MGT */
}
 802a442:	4240      	negs	r0, r0
 802a444:	4770      	bx	lr
	...

0802a448 <UpdateRxSlotIdleState>:
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxTimeOut\r\n" );
}

static void UpdateRxSlotIdleState( void )
{
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 802a448:	4a08      	ldr	r2, [pc, #32]	; (802a46c <UpdateRxSlotIdleState+0x24>)
 802a44a:	238c      	movs	r3, #140	; 0x8c
 802a44c:	005b      	lsls	r3, r3, #1
 802a44e:	5cd3      	ldrb	r3, [r2, r3]
 802a450:	2b02      	cmp	r3, #2
 802a452:	d005      	beq.n	802a460 <UpdateRxSlotIdleState+0x18>
    {
        MacCtx.RxSlot = RX_SLOT_NONE;
 802a454:	4a06      	ldr	r2, [pc, #24]	; (802a470 <UpdateRxSlotIdleState+0x28>)
 802a456:	2392      	movs	r3, #146	; 0x92
 802a458:	00db      	lsls	r3, r3, #3
 802a45a:	2106      	movs	r1, #6
 802a45c:	54d1      	strb	r1, [r2, r3]
    }
    else
    {
        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;
    }
}
 802a45e:	4770      	bx	lr
        MacCtx.RxSlot = RX_SLOT_WIN_CLASS_C;
 802a460:	4a03      	ldr	r2, [pc, #12]	; (802a470 <UpdateRxSlotIdleState+0x28>)
 802a462:	2392      	movs	r3, #146	; 0x92
 802a464:	00db      	lsls	r3, r3, #3
 802a466:	2102      	movs	r1, #2
 802a468:	54d1      	strb	r1, [r2, r3]
}
 802a46a:	e7f8      	b.n	802a45e <UpdateRxSlotIdleState+0x16>
 802a46c:	2000a000 	.word	0x2000a000
 802a470:	2000bb1c 	.word	0x2000bb1c

0802a474 <LoRaMacEnableRequests>:
    return false;
}

static void LoRaMacEnableRequests( LoRaMacRequestHandling_t requestState )
{
    MacCtx.AllowRequests = requestState;
 802a474:	4a01      	ldr	r2, [pc, #4]	; (802a47c <LoRaMacEnableRequests+0x8>)
 802a476:	4b02      	ldr	r3, [pc, #8]	; (802a480 <LoRaMacEnableRequests+0xc>)
 802a478:	54d0      	strb	r0, [r2, r3]
}
 802a47a:	4770      	bx	lr
 802a47c:	2000bb1c 	.word	0x2000bb1c
 802a480:	00000492 	.word	0x00000492

0802a484 <LoRaMacHandleIndicationEvents>:
        MacCtx.MacFlags.Bits.MacDone = 0;
    }
}

static void LoRaMacHandleIndicationEvents( void )
{
 802a484:	b510      	push	{r4, lr}
    // Handle MLME indication
    if( MacCtx.MacFlags.Bits.MlmeInd == 1 )
 802a486:	4a15      	ldr	r2, [pc, #84]	; (802a4dc <LoRaMacHandleIndicationEvents+0x58>)
 802a488:	4b15      	ldr	r3, [pc, #84]	; (802a4e0 <LoRaMacHandleIndicationEvents+0x5c>)
 802a48a:	5cd3      	ldrb	r3, [r2, r3]
 802a48c:	071b      	lsls	r3, r3, #28
 802a48e:	d50f      	bpl.n	802a4b0 <LoRaMacHandleIndicationEvents+0x2c>
    {
        MacCtx.MacFlags.Bits.MlmeInd = 0;
 802a490:	0010      	movs	r0, r2
 802a492:	4a13      	ldr	r2, [pc, #76]	; (802a4e0 <LoRaMacHandleIndicationEvents+0x5c>)
 802a494:	5c83      	ldrb	r3, [r0, r2]
 802a496:	2108      	movs	r1, #8
 802a498:	438b      	bics	r3, r1
 802a49a:	5483      	strb	r3, [r0, r2]
        MacCtx.MacPrimitives->MacMlmeIndication( &MacCtx.MlmeIndication, &MacCtx.RxStatus );
 802a49c:	23d1      	movs	r3, #209	; 0xd1
 802a49e:	009b      	lsls	r3, r3, #2
 802a4a0:	58c3      	ldr	r3, [r0, r3]
 802a4a2:	68db      	ldr	r3, [r3, #12]
 802a4a4:	4a0f      	ldr	r2, [pc, #60]	; (802a4e4 <LoRaMacHandleIndicationEvents+0x60>)
 802a4a6:	1881      	adds	r1, r0, r2
 802a4a8:	3a24      	subs	r2, #36	; 0x24
 802a4aa:	4694      	mov	ip, r2
 802a4ac:	4460      	add	r0, ip
 802a4ae:	4798      	blx	r3
    }

    // Handle MCPS indication
    if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 802a4b0:	4a0a      	ldr	r2, [pc, #40]	; (802a4dc <LoRaMacHandleIndicationEvents+0x58>)
 802a4b2:	4b0b      	ldr	r3, [pc, #44]	; (802a4e0 <LoRaMacHandleIndicationEvents+0x5c>)
 802a4b4:	5cd3      	ldrb	r3, [r2, r3]
 802a4b6:	079b      	lsls	r3, r3, #30
 802a4b8:	d50f      	bpl.n	802a4da <LoRaMacHandleIndicationEvents+0x56>
    {
        MacCtx.MacFlags.Bits.McpsInd = 0;
 802a4ba:	0010      	movs	r0, r2
 802a4bc:	4a08      	ldr	r2, [pc, #32]	; (802a4e0 <LoRaMacHandleIndicationEvents+0x5c>)
 802a4be:	5c83      	ldrb	r3, [r0, r2]
 802a4c0:	2102      	movs	r1, #2
 802a4c2:	438b      	bics	r3, r1
 802a4c4:	5483      	strb	r3, [r0, r2]
        MacCtx.MacPrimitives->MacMcpsIndication( &MacCtx.McpsIndication, &MacCtx.RxStatus );
 802a4c6:	23d1      	movs	r3, #209	; 0xd1
 802a4c8:	009b      	lsls	r3, r3, #2
 802a4ca:	58c3      	ldr	r3, [r0, r3]
 802a4cc:	685b      	ldr	r3, [r3, #4]
 802a4ce:	4a05      	ldr	r2, [pc, #20]	; (802a4e4 <LoRaMacHandleIndicationEvents+0x60>)
 802a4d0:	1881      	adds	r1, r0, r2
 802a4d2:	3a6c      	subs	r2, #108	; 0x6c
 802a4d4:	4694      	mov	ip, r2
 802a4d6:	4460      	add	r0, ip
 802a4d8:	4798      	blx	r3
    }
}
 802a4da:	bd10      	pop	{r4, pc}
 802a4dc:	2000bb1c 	.word	0x2000bb1c
 802a4e0:	00000491 	.word	0x00000491
 802a4e4:	0000048c 	.word	0x0000048c

0802a4e8 <CheckForMinimumAbpDatarate>:
}

#if (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
static bool CheckForMinimumAbpDatarate( bool adr, ActivationType_t activation, bool datarateChanged )
{
    if( ( adr == true ) &&
 802a4e8:	2800      	cmp	r0, #0
 802a4ea:	d002      	beq.n	802a4f2 <CheckForMinimumAbpDatarate+0xa>
 802a4ec:	2901      	cmp	r1, #1
 802a4ee:	d001      	beq.n	802a4f4 <CheckForMinimumAbpDatarate+0xc>
        ( activation == ACTIVATION_TYPE_ABP ) &&
        ( datarateChanged == false ) )
    {
        return true;
    }
    return false;
 802a4f0:	2000      	movs	r0, #0
}
 802a4f2:	4770      	bx	lr
        ( activation == ACTIVATION_TYPE_ABP ) &&
 802a4f4:	2a00      	cmp	r2, #0
 802a4f6:	d0fc      	beq.n	802a4f2 <CheckForMinimumAbpDatarate+0xa>
    return false;
 802a4f8:	2000      	movs	r0, #0
 802a4fa:	e7fa      	b.n	802a4f2 <CheckForMinimumAbpDatarate+0xa>

0802a4fc <LoRaMacCheckForRxAbort>:
#endif /* LORAMAC_VERSION */

static void LoRaMacCheckForRxAbort( void )
{
    // A error occurs during receiving
    if( ( MacCtx.MacState & LORAMAC_RX_ABORT ) == LORAMAC_RX_ABORT )
 802a4fc:	4a07      	ldr	r2, [pc, #28]	; (802a51c <LoRaMacCheckForRxAbort+0x20>)
 802a4fe:	23d0      	movs	r3, #208	; 0xd0
 802a500:	009b      	lsls	r3, r3, #2
 802a502:	58d3      	ldr	r3, [r2, r3]
 802a504:	061a      	lsls	r2, r3, #24
 802a506:	d508      	bpl.n	802a51a <LoRaMacCheckForRxAbort+0x1e>
    {
        MacCtx.MacState &= ~LORAMAC_RX_ABORT;
 802a508:	2280      	movs	r2, #128	; 0x80
 802a50a:	4393      	bics	r3, r2
 802a50c:	4903      	ldr	r1, [pc, #12]	; (802a51c <LoRaMacCheckForRxAbort+0x20>)
 802a50e:	22d0      	movs	r2, #208	; 0xd0
 802a510:	0092      	lsls	r2, r2, #2
 802a512:	508b      	str	r3, [r1, r2]
        MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 802a514:	2002      	movs	r0, #2
 802a516:	4383      	bics	r3, r0
 802a518:	508b      	str	r3, [r1, r2]
    }
}
 802a51a:	4770      	bx	lr
 802a51c:	2000bb1c 	.word	0x2000bb1c

0802a520 <CalculateBackOff>:

static void CalculateBackOff( void )
{
    // Make sure that the calculation of the backoff time for the aggregated time off will only be done in
    // case the value is zero. It will be set to zero in the function RegionNextChannel.
    if( Nvm.MacGroup1.AggregatedTimeOff == 0 )
 802a520:	4b07      	ldr	r3, [pc, #28]	; (802a540 <CalculateBackOff+0x20>)
 802a522:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802a524:	2b00      	cmp	r3, #0
 802a526:	d109      	bne.n	802a53c <CalculateBackOff+0x1c>
    {
        // Update aggregated time-off. This must be an assignment and no incremental
        // update as we do only calculate the time-off based on the last transmission
        Nvm.MacGroup1.AggregatedTimeOff = ( MacCtx.TxTimeOnAir * Nvm.MacGroup2.AggregatedDCycle - MacCtx.TxTimeOnAir );
 802a528:	4905      	ldr	r1, [pc, #20]	; (802a540 <CalculateBackOff+0x20>)
 802a52a:	3321      	adds	r3, #33	; 0x21
 802a52c:	33ff      	adds	r3, #255	; 0xff
 802a52e:	5aca      	ldrh	r2, [r1, r3]
 802a530:	4804      	ldr	r0, [pc, #16]	; (802a544 <CalculateBackOff+0x24>)
 802a532:	4b05      	ldr	r3, [pc, #20]	; (802a548 <CalculateBackOff+0x28>)
 802a534:	58c3      	ldr	r3, [r0, r3]
 802a536:	3a01      	subs	r2, #1
 802a538:	4353      	muls	r3, r2
 802a53a:	630b      	str	r3, [r1, #48]	; 0x30
    }
}
 802a53c:	4770      	bx	lr
 802a53e:	46c0      	nop			; (mov r8, r8)
 802a540:	2000a000 	.word	0x2000a000
 802a544:	2000bb1c 	.word	0x2000bb1c
 802a548:	0000041c 	.word	0x0000041c

0802a54c <SetTxContinuousWave>:

    return LORAMAC_STATUS_OK;
}
#elif (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
static LoRaMacStatus_t SetTxContinuousWave( uint16_t timeout, uint32_t frequency, uint8_t power )
{
 802a54c:	b510      	push	{r4, lr}
 802a54e:	0003      	movs	r3, r0
 802a550:	0008      	movs	r0, r1
    Radio.SetTxContinuousWave( frequency, power, timeout );
 802a552:	4907      	ldr	r1, [pc, #28]	; (802a570 <SetTxContinuousWave+0x24>)
 802a554:	6bcc      	ldr	r4, [r1, #60]	; 0x3c
 802a556:	b251      	sxtb	r1, r2
 802a558:	001a      	movs	r2, r3
 802a55a:	47a0      	blx	r4

    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 802a55c:	4905      	ldr	r1, [pc, #20]	; (802a574 <SetTxContinuousWave+0x28>)
 802a55e:	22d0      	movs	r2, #208	; 0xd0
 802a560:	0092      	lsls	r2, r2, #2
 802a562:	2302      	movs	r3, #2
 802a564:	5888      	ldr	r0, [r1, r2]
 802a566:	4303      	orrs	r3, r0
 802a568:	508b      	str	r3, [r1, r2]

    return LORAMAC_STATUS_OK;
}
 802a56a:	2000      	movs	r0, #0
 802a56c:	bd10      	pop	{r4, pc}
 802a56e:	46c0      	nop			; (mov r8, r8)
 802a570:	08035d8c 	.word	0x08035d8c
 802a574:	2000bb1c 	.word	0x2000bb1c

0802a578 <DetermineFrameType>:

    return LORAMAC_STATUS_OK;
}

static LoRaMacStatus_t DetermineFrameType( LoRaMacMessageData_t* macMsg, FType_t* fType )
{
 802a578:	b510      	push	{r4, lr}
 802a57a:	1e03      	subs	r3, r0, #0
    if( ( macMsg == NULL ) || ( fType == NULL ) )
 802a57c:	d029      	beq.n	802a5d2 <DetermineFrameType+0x5a>
 802a57e:	2900      	cmp	r1, #0
 802a580:	d029      	beq.n	802a5d6 <DetermineFrameType+0x5e>
     * +-------+  +----------+------+-------+--------------+
     * |   D   |  |    = 0   |   -  |  > 0  |       X      |
     * +-------+  +----------+------+-------+--------------+
     */

    if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen > 0 ) && ( macMsg->FPort > 0 ) )
 802a582:	7b02      	ldrb	r2, [r0, #12]
 802a584:	200f      	movs	r0, #15
 802a586:	0004      	movs	r4, r0
 802a588:	4014      	ands	r4, r2
 802a58a:	4210      	tst	r0, r2
 802a58c:	d007      	beq.n	802a59e <DetermineFrameType+0x26>
 802a58e:	2220      	movs	r2, #32
 802a590:	5c9a      	ldrb	r2, [r3, r2]
 802a592:	2a00      	cmp	r2, #0
 802a594:	d003      	beq.n	802a59e <DetermineFrameType+0x26>
    {
        *fType = FRAME_TYPE_A;
 802a596:	2300      	movs	r3, #0
 802a598:	700b      	strb	r3, [r1, #0]
    {
        // Should never happen.
        return LORAMAC_STATUS_ERROR;
    }

    return LORAMAC_STATUS_OK;
 802a59a:	2000      	movs	r0, #0
        *fType = FRAME_TYPE_A;
 802a59c:	e005      	b.n	802a5aa <DetermineFrameType+0x32>
    else if( macMsg->FRMPayloadSize == 0 )
 802a59e:	2228      	movs	r2, #40	; 0x28
 802a5a0:	5c98      	ldrb	r0, [r3, r2]
 802a5a2:	2800      	cmp	r0, #0
 802a5a4:	d102      	bne.n	802a5ac <DetermineFrameType+0x34>
        *fType = FRAME_TYPE_B;
 802a5a6:	2301      	movs	r3, #1
 802a5a8:	700b      	strb	r3, [r1, #0]
}
 802a5aa:	bd10      	pop	{r4, pc}
    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort == 0 ) )
 802a5ac:	2c00      	cmp	r4, #0
 802a5ae:	d106      	bne.n	802a5be <DetermineFrameType+0x46>
 802a5b0:	2220      	movs	r2, #32
 802a5b2:	5c98      	ldrb	r0, [r3, r2]
 802a5b4:	2800      	cmp	r0, #0
 802a5b6:	d102      	bne.n	802a5be <DetermineFrameType+0x46>
        *fType = FRAME_TYPE_C;
 802a5b8:	2302      	movs	r3, #2
 802a5ba:	700b      	strb	r3, [r1, #0]
 802a5bc:	e7f5      	b.n	802a5aa <DetermineFrameType+0x32>
    else if( ( macMsg->FHDR.FCtrl.Bits.FOptsLen == 0 ) && ( macMsg->FPort > 0 ) )
 802a5be:	2c00      	cmp	r4, #0
 802a5c0:	d10b      	bne.n	802a5da <DetermineFrameType+0x62>
 802a5c2:	2220      	movs	r2, #32
 802a5c4:	5c9b      	ldrb	r3, [r3, r2]
 802a5c6:	2b00      	cmp	r3, #0
 802a5c8:	d009      	beq.n	802a5de <DetermineFrameType+0x66>
        *fType = FRAME_TYPE_D;
 802a5ca:	2303      	movs	r3, #3
 802a5cc:	700b      	strb	r3, [r1, #0]
    return LORAMAC_STATUS_OK;
 802a5ce:	0020      	movs	r0, r4
        *fType = FRAME_TYPE_D;
 802a5d0:	e7eb      	b.n	802a5aa <DetermineFrameType+0x32>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802a5d2:	2003      	movs	r0, #3
 802a5d4:	e7e9      	b.n	802a5aa <DetermineFrameType+0x32>
 802a5d6:	2003      	movs	r0, #3
 802a5d8:	e7e7      	b.n	802a5aa <DetermineFrameType+0x32>
        return LORAMAC_STATUS_ERROR;
 802a5da:	2018      	movs	r0, #24
 802a5dc:	e7e5      	b.n	802a5aa <DetermineFrameType+0x32>
 802a5de:	2018      	movs	r0, #24
 802a5e0:	e7e3      	b.n	802a5aa <DetermineFrameType+0x32>

0802a5e2 <CheckRetrans>:
    return false;
}
#elif (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
static bool CheckRetrans( uint8_t counter, uint8_t limit )
{
    if( counter >= limit )
 802a5e2:	4288      	cmp	r0, r1
 802a5e4:	d201      	bcs.n	802a5ea <CheckRetrans+0x8>
    {
        return true;
    }
    return false;
 802a5e6:	2000      	movs	r0, #0
}
 802a5e8:	4770      	bx	lr
        return true;
 802a5ea:	2001      	movs	r0, #1
 802a5ec:	e7fc      	b.n	802a5e8 <CheckRetrans+0x6>
	...

0802a5f0 <CheckRetransUnconfirmedUplink>:

static bool CheckRetransUnconfirmedUplink( void )
{
 802a5f0:	b510      	push	{r4, lr}
    // Verify, if the max number of retransmissions have been reached
    if( CheckRetrans( MacCtx.ChannelsNbTransCounter,
 802a5f2:	4a0b      	ldr	r2, [pc, #44]	; (802a620 <CheckRetransUnconfirmedUplink+0x30>)
 802a5f4:	2368      	movs	r3, #104	; 0x68
 802a5f6:	5cd1      	ldrb	r1, [r2, r3]
 802a5f8:	4a0a      	ldr	r2, [pc, #40]	; (802a624 <CheckRetransUnconfirmedUplink+0x34>)
 802a5fa:	2383      	movs	r3, #131	; 0x83
 802a5fc:	00db      	lsls	r3, r3, #3
 802a5fe:	5cd0      	ldrb	r0, [r2, r3]
 802a600:	f7ff ffef 	bl	802a5e2 <CheckRetrans>
 802a604:	2800      	cmp	r0, #0
 802a606:	d108      	bne.n	802a61a <CheckRetransUnconfirmedUplink+0x2a>
                      Nvm.MacGroup2.MacParams.ChannelsNbTrans ) == true )
    {
        return true;
    }

    if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 802a608:	4a06      	ldr	r2, [pc, #24]	; (802a624 <CheckRetransUnconfirmedUplink+0x34>)
 802a60a:	4b07      	ldr	r3, [pc, #28]	; (802a628 <CheckRetransUnconfirmedUplink+0x38>)
 802a60c:	5cd3      	ldrb	r3, [r2, r3]
 802a60e:	079b      	lsls	r3, r3, #30
 802a610:	d503      	bpl.n	802a61a <CheckRetransUnconfirmedUplink+0x2a>
    {
        // Stop the retransmissions, if a valid downlink is received
        // a class A RX window. This holds also for class B and C.
        if( ( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 ) ||
 802a612:	4b06      	ldr	r3, [pc, #24]	; (802a62c <CheckRetransUnconfirmedUplink+0x3c>)
 802a614:	5cd3      	ldrb	r3, [r2, r3]
 802a616:	2b01      	cmp	r3, #1
 802a618:	d900      	bls.n	802a61c <CheckRetransUnconfirmedUplink+0x2c>
        {
            return true;
        }
    }
    return false;
}
 802a61a:	bd10      	pop	{r4, pc}
            return true;
 802a61c:	3001      	adds	r0, #1
 802a61e:	e7fc      	b.n	802a61a <CheckRetransUnconfirmedUplink+0x2a>
 802a620:	2000a000 	.word	0x2000a000
 802a624:	2000bb1c 	.word	0x2000bb1c
 802a628:	00000491 	.word	0x00000491
 802a62c:	0000048f 	.word	0x0000048f

0802a630 <CheckRetransConfirmedUplink>:

static bool CheckRetransConfirmedUplink( void )
{
 802a630:	b510      	push	{r4, lr}
    // Verify, if the max number of retransmissions have been reached
    if( CheckRetrans( MacCtx.ChannelsNbTransCounter,
 802a632:	4a09      	ldr	r2, [pc, #36]	; (802a658 <CheckRetransConfirmedUplink+0x28>)
 802a634:	2368      	movs	r3, #104	; 0x68
 802a636:	5cd1      	ldrb	r1, [r2, r3]
 802a638:	4a08      	ldr	r2, [pc, #32]	; (802a65c <CheckRetransConfirmedUplink+0x2c>)
 802a63a:	2383      	movs	r3, #131	; 0x83
 802a63c:	00db      	lsls	r3, r3, #3
 802a63e:	5cd0      	ldrb	r0, [r2, r3]
 802a640:	f7ff ffcf 	bl	802a5e2 <CheckRetrans>
 802a644:	2800      	cmp	r0, #0
 802a646:	d106      	bne.n	802a656 <CheckRetransConfirmedUplink+0x26>
                      Nvm.MacGroup2.MacParams.ChannelsNbTrans ) == true )
    {
        return true;
    }

    if( MacCtx.MacFlags.Bits.McpsInd == 1 )
 802a648:	4a04      	ldr	r2, [pc, #16]	; (802a65c <CheckRetransConfirmedUplink+0x2c>)
 802a64a:	4b05      	ldr	r3, [pc, #20]	; (802a660 <CheckRetransConfirmedUplink+0x30>)
 802a64c:	5cd3      	ldrb	r3, [r2, r3]
 802a64e:	079b      	lsls	r3, r3, #30
 802a650:	d501      	bpl.n	802a656 <CheckRetransConfirmedUplink+0x26>
    {
        if( MacCtx.McpsConfirm.AckReceived == true )
 802a652:	4b04      	ldr	r3, [pc, #16]	; (802a664 <CheckRetransConfirmedUplink+0x34>)
 802a654:	5cd0      	ldrb	r0, [r2, r3]
        {
            return true;
        }
    }
    return false;
}
 802a656:	bd10      	pop	{r4, pc}
 802a658:	2000a000 	.word	0x2000a000
 802a65c:	2000bb1c 	.word	0x2000bb1c
 802a660:	00000491 	.word	0x00000491
 802a664:	00000444 	.word	0x00000444

0802a668 <IncreaseAdrAckCounter>:

static uint32_t IncreaseAdrAckCounter( uint32_t counter )
{
    if( counter < ADR_ACK_COUNTER_MAX )
 802a668:	1c43      	adds	r3, r0, #1
 802a66a:	d000      	beq.n	802a66e <IncreaseAdrAckCounter+0x6>
    {
        counter++;
 802a66c:	3001      	adds	r0, #1
    }
    return counter;
}
 802a66e:	4770      	bx	lr

0802a670 <StopRetransmission>:
#endif /* LORAMAC_VERSION */

static bool StopRetransmission( void )
{
 802a670:	b510      	push	{r4, lr}
            }
        }
    }
#endif /* LORAMAC_VERSION */

    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||
 802a672:	4a12      	ldr	r2, [pc, #72]	; (802a6bc <StopRetransmission+0x4c>)
 802a674:	4b12      	ldr	r3, [pc, #72]	; (802a6c0 <StopRetransmission+0x50>)
 802a676:	5cd3      	ldrb	r3, [r2, r3]
 802a678:	079b      	lsls	r3, r3, #30
 802a67a:	d503      	bpl.n	802a684 <StopRetransmission+0x14>
        ( ( MacCtx.RxStatus.RxSlot != RX_SLOT_WIN_1 ) &&
 802a67c:	4b11      	ldr	r3, [pc, #68]	; (802a6c4 <StopRetransmission+0x54>)
 802a67e:	5cd3      	ldrb	r3, [r2, r3]
    if( ( MacCtx.MacFlags.Bits.McpsInd == 0 ) ||
 802a680:	2b01      	cmp	r3, #1
 802a682:	d90a      	bls.n	802a69a <StopRetransmission+0x2a>
          ( MacCtx.RxStatus.RxSlot != RX_SLOT_WIN_2 ) ) )
    {   // Maximum repetitions without downlink. Increase ADR Ack counter.
        // Only process the case when the MAC did not receive a downlink.
        if( Nvm.MacGroup2.AdrCtrlOn == true )
 802a684:	4a10      	ldr	r2, [pc, #64]	; (802a6c8 <StopRetransmission+0x58>)
 802a686:	238d      	movs	r3, #141	; 0x8d
 802a688:	005b      	lsls	r3, r3, #1
 802a68a:	5cd3      	ldrb	r3, [r2, r3]
 802a68c:	2b00      	cmp	r3, #0
 802a68e:	d004      	beq.n	802a69a <StopRetransmission+0x2a>
        {
#if (defined( LORAMAC_VERSION ) && ( LORAMAC_VERSION == 0x01000300 ))
            Nvm.MacGroup1.AdrAckCounter++;
#elif (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
            Nvm.MacGroup1.AdrAckCounter = IncreaseAdrAckCounter( Nvm.MacGroup1.AdrAckCounter );
 802a690:	0014      	movs	r4, r2
 802a692:	6a90      	ldr	r0, [r2, #40]	; 0x28
 802a694:	f7ff ffe8 	bl	802a668 <IncreaseAdrAckCounter>
 802a698:	62a0      	str	r0, [r4, #40]	; 0x28
#endif /* LORAMAC_VERSION */
        }
    }

    MacCtx.ChannelsNbTransCounter = 0;
 802a69a:	4b08      	ldr	r3, [pc, #32]	; (802a6bc <StopRetransmission+0x4c>)
 802a69c:	2200      	movs	r2, #0
 802a69e:	2183      	movs	r1, #131	; 0x83
 802a6a0:	00c9      	lsls	r1, r1, #3
 802a6a2:	545a      	strb	r2, [r3, r1]
    MacCtx.NodeAckRequested = false;
 802a6a4:	4909      	ldr	r1, [pc, #36]	; (802a6cc <StopRetransmission+0x5c>)
 802a6a6:	545a      	strb	r2, [r3, r1]
#if (defined( LORAMAC_VERSION ) && ( LORAMAC_VERSION == 0x01000300 ))
    MacCtx.AckTimeoutRetry = false;
#elif (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    MacCtx.RetransmitTimeoutRetry = false;
 802a6a8:	4909      	ldr	r1, [pc, #36]	; (802a6d0 <StopRetransmission+0x60>)
 802a6aa:	545a      	strb	r2, [r3, r1]
#endif /* LORAMAC_VERSION */
    MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 802a6ac:	39d9      	subs	r1, #217	; 0xd9
 802a6ae:	3202      	adds	r2, #2
 802a6b0:	5858      	ldr	r0, [r3, r1]
 802a6b2:	4390      	bics	r0, r2
 802a6b4:	5058      	str	r0, [r3, r1]

    return true;
}
 802a6b6:	2001      	movs	r0, #1
 802a6b8:	bd10      	pop	{r4, pc}
 802a6ba:	46c0      	nop			; (mov r8, r8)
 802a6bc:	2000bb1c 	.word	0x2000bb1c
 802a6c0:	00000491 	.word	0x00000491
 802a6c4:	0000048f 	.word	0x0000048f
 802a6c8:	2000a000 	.word	0x2000a000
 802a6cc:	0000041a 	.word	0x0000041a
 802a6d0:	00000419 	.word	0x00000419

0802a6d4 <OnMacProcessNotify>:

static void OnMacProcessNotify( void )
{
 802a6d4:	b510      	push	{r4, lr}
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->MacProcessNotify != NULL ) )
 802a6d6:	4a05      	ldr	r2, [pc, #20]	; (802a6ec <OnMacProcessNotify+0x18>)
 802a6d8:	23d2      	movs	r3, #210	; 0xd2
 802a6da:	009b      	lsls	r3, r3, #2
 802a6dc:	58d3      	ldr	r3, [r2, r3]
 802a6de:	2b00      	cmp	r3, #0
 802a6e0:	d003      	beq.n	802a6ea <OnMacProcessNotify+0x16>
 802a6e2:	695b      	ldr	r3, [r3, #20]
 802a6e4:	2b00      	cmp	r3, #0
 802a6e6:	d000      	beq.n	802a6ea <OnMacProcessNotify+0x16>
    {
        MacCtx.MacCallbacks->MacProcessNotify( );
 802a6e8:	4798      	blx	r3
    }
}
 802a6ea:	bd10      	pop	{r4, pc}
 802a6ec:	2000bb1c 	.word	0x2000bb1c

0802a6f0 <OnRadioRxError>:
{
 802a6f0:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.RxError = 1;
 802a6f2:	4a04      	ldr	r2, [pc, #16]	; (802a704 <OnRadioRxError+0x14>)
 802a6f4:	7813      	ldrb	r3, [r2, #0]
 802a6f6:	2104      	movs	r1, #4
 802a6f8:	430b      	orrs	r3, r1
 802a6fa:	7013      	strb	r3, [r2, #0]
    OnMacProcessNotify( );
 802a6fc:	f7ff ffea 	bl	802a6d4 <OnMacProcessNotify>
}
 802a700:	bd10      	pop	{r4, pc}
 802a702:	46c0      	nop			; (mov r8, r8)
 802a704:	2000bb18 	.word	0x2000bb18

0802a708 <CallNvmDataChangeCallback>:

static void CallNvmDataChangeCallback( uint16_t notifyFlags )
{
 802a708:	b510      	push	{r4, lr}
    if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->NvmDataChange  != NULL ) )
 802a70a:	4a05      	ldr	r2, [pc, #20]	; (802a720 <CallNvmDataChangeCallback+0x18>)
 802a70c:	23d2      	movs	r3, #210	; 0xd2
 802a70e:	009b      	lsls	r3, r3, #2
 802a710:	58d3      	ldr	r3, [r2, r3]
 802a712:	2b00      	cmp	r3, #0
 802a714:	d003      	beq.n	802a71e <CallNvmDataChangeCallback+0x16>
 802a716:	691b      	ldr	r3, [r3, #16]
 802a718:	2b00      	cmp	r3, #0
 802a71a:	d000      	beq.n	802a71e <CallNvmDataChangeCallback+0x16>
    {
        MacCtx.MacCallbacks->NvmDataChange ( notifyFlags );
 802a71c:	4798      	blx	r3
    }
}
 802a71e:	bd10      	pop	{r4, pc}
 802a720:	2000bb1c 	.word	0x2000bb1c

0802a724 <IsRequestPending>:
}
#endif /* LORAMAC_VERSION */

static uint8_t IsRequestPending( void )
{
    if( ( MacCtx.MacFlags.Bits.MlmeReq == 1 ) ||
 802a724:	4a05      	ldr	r2, [pc, #20]	; (802a73c <IsRequestPending+0x18>)
 802a726:	4b06      	ldr	r3, [pc, #24]	; (802a740 <IsRequestPending+0x1c>)
 802a728:	5cd3      	ldrb	r3, [r2, r3]
 802a72a:	2205      	movs	r2, #5
 802a72c:	0010      	movs	r0, r2
 802a72e:	4018      	ands	r0, r3
 802a730:	421a      	tst	r2, r3
 802a732:	d100      	bne.n	802a736 <IsRequestPending+0x12>
        ( MacCtx.MacFlags.Bits.McpsReq == 1 ) )
    {
        return 1;
    }
    return 0;
}
 802a734:	4770      	bx	lr
        return 1;
 802a736:	2001      	movs	r0, #1
 802a738:	e7fc      	b.n	802a734 <IsRequestPending+0x10>
 802a73a:	46c0      	nop			; (mov r8, r8)
 802a73c:	2000bb1c 	.word	0x2000bb1c
 802a740:	00000491 	.word	0x00000491

0802a744 <GetMaxAppPayloadWithoutFOptsLength>:
{
 802a744:	b500      	push	{lr}
 802a746:	b085      	sub	sp, #20
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802a748:	4a0c      	ldr	r2, [pc, #48]	; (802a77c <GetMaxAppPayloadWithoutFOptsLength+0x38>)
 802a74a:	237c      	movs	r3, #124	; 0x7c
 802a74c:	5cd1      	ldrb	r1, [r2, r3]
 802a74e:	ab02      	add	r3, sp, #8
 802a750:	7099      	strb	r1, [r3, #2]
    getPhy.Datarate = datarate;
 802a752:	7058      	strb	r0, [r3, #1]
    getPhy.Attribute = PHY_MAX_PAYLOAD;
 802a754:	210d      	movs	r1, #13
 802a756:	7019      	strb	r1, [r3, #0]
    if( Nvm.MacGroup2.MacParams.RepeaterSupport == true )
 802a758:	238c      	movs	r3, #140	; 0x8c
 802a75a:	5cd3      	ldrb	r3, [r2, r3]
 802a75c:	2b00      	cmp	r3, #0
 802a75e:	d002      	beq.n	802a766 <GetMaxAppPayloadWithoutFOptsLength+0x22>
        getPhy.Attribute = PHY_MAX_PAYLOAD_REPEATER;
 802a760:	ab02      	add	r3, sp, #8
 802a762:	220e      	movs	r2, #14
 802a764:	701a      	strb	r2, [r3, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802a766:	4a05      	ldr	r2, [pc, #20]	; (802a77c <GetMaxAppPayloadWithoutFOptsLength+0x38>)
 802a768:	2348      	movs	r3, #72	; 0x48
 802a76a:	5cd0      	ldrb	r0, [r2, r3]
 802a76c:	a902      	add	r1, sp, #8
 802a76e:	f004 fc3f 	bl	802eff0 <RegionGetPhyParam>
 802a772:	9001      	str	r0, [sp, #4]
    return phyParam.Value;
 802a774:	b2c0      	uxtb	r0, r0
}
 802a776:	b005      	add	sp, #20
 802a778:	bd00      	pop	{pc}
 802a77a:	46c0      	nop			; (mov r8, r8)
 802a77c:	2000a000 	.word	0x2000a000

0802a780 <ValidatePayloadLength>:
{
 802a780:	b570      	push	{r4, r5, r6, lr}
 802a782:	0005      	movs	r5, r0
 802a784:	0008      	movs	r0, r1
 802a786:	0014      	movs	r4, r2
    maxN = GetMaxAppPayloadWithoutFOptsLength( datarate );
 802a788:	f7ff ffdc 	bl	802a744 <GetMaxAppPayloadWithoutFOptsLength>
 802a78c:	b280      	uxth	r0, r0
    payloadSize = ( lenN + fOptsLen );
 802a78e:	1964      	adds	r4, r4, r5
    if( ( payloadSize <= maxN ) && ( payloadSize <= LORAMAC_PHY_MAXPAYLOAD ) )
 802a790:	42a0      	cmp	r0, r4
 802a792:	d303      	bcc.n	802a79c <ValidatePayloadLength+0x1c>
 802a794:	2cff      	cmp	r4, #255	; 0xff
 802a796:	d903      	bls.n	802a7a0 <ValidatePayloadLength+0x20>
    return false;
 802a798:	2000      	movs	r0, #0
 802a79a:	e000      	b.n	802a79e <ValidatePayloadLength+0x1e>
 802a79c:	2000      	movs	r0, #0
}
 802a79e:	bd70      	pop	{r4, r5, r6, pc}
        return true;
 802a7a0:	2001      	movs	r0, #1
 802a7a2:	e7fc      	b.n	802a79e <ValidatePayloadLength+0x1e>

0802a7a4 <ProcessRadioTxDone>:
{
 802a7a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 802a7a6:	b08f      	sub	sp, #60	; 0x3c
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 802a7a8:	4a3e      	ldr	r2, [pc, #248]	; (802a8a4 <ProcessRadioTxDone+0x100>)
 802a7aa:	238c      	movs	r3, #140	; 0x8c
 802a7ac:	005b      	lsls	r3, r3, #1
 802a7ae:	5cd3      	ldrb	r3, [r2, r3]
 802a7b0:	2b02      	cmp	r3, #2
 802a7b2:	d002      	beq.n	802a7ba <ProcessRadioTxDone+0x16>
        Radio.Sleep( );
 802a7b4:	4b3c      	ldr	r3, [pc, #240]	; (802a8a8 <ProcessRadioTxDone+0x104>)
 802a7b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802a7b8:	4798      	blx	r3
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 802a7ba:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 802a7be:	b672      	cpsid	i
    uint32_t offset = TimerGetCurrentTime( ) - TxDoneParams.CurTime;
 802a7c0:	f009 fea8 	bl	8034514 <UTIL_TIMER_GetCurrentTime>
 802a7c4:	4b39      	ldr	r3, [pc, #228]	; (802a8ac <ProcessRadioTxDone+0x108>)
 802a7c6:	681d      	ldr	r5, [r3, #0]
    TimerSetValue( &MacCtx.RxWindowTimer1, MacCtx.RxWindow1Delay - offset );
 802a7c8:	4c39      	ldr	r4, [pc, #228]	; (802a8b0 <ProcessRadioTxDone+0x10c>)
 802a7ca:	23ec      	movs	r3, #236	; 0xec
 802a7cc:	009b      	lsls	r3, r3, #2
 802a7ce:	58e1      	ldr	r1, [r4, r3]
 802a7d0:	1a2d      	subs	r5, r5, r0
 802a7d2:	1949      	adds	r1, r1, r5
 802a7d4:	3b30      	subs	r3, #48	; 0x30
 802a7d6:	18e7      	adds	r7, r4, r3
 802a7d8:	0038      	movs	r0, r7
 802a7da:	f009 ff83 	bl	80346e4 <UTIL_TIMER_SetPeriod>
    TimerStart( &MacCtx.RxWindowTimer1 );
 802a7de:	0038      	movs	r0, r7
 802a7e0:	f009 ff3a 	bl	8034658 <UTIL_TIMER_Start>
    TimerSetValue( &MacCtx.RxWindowTimer2, MacCtx.RxWindow2Delay - offset );
 802a7e4:	23ed      	movs	r3, #237	; 0xed
 802a7e6:	009b      	lsls	r3, r3, #2
 802a7e8:	58e1      	ldr	r1, [r4, r3]
 802a7ea:	1949      	adds	r1, r1, r5
 802a7ec:	3b1c      	subs	r3, #28
 802a7ee:	18e5      	adds	r5, r4, r3
 802a7f0:	0028      	movs	r0, r5
 802a7f2:	f009 ff77 	bl	80346e4 <UTIL_TIMER_SetPeriod>
    TimerStart( &MacCtx.RxWindowTimer2 );
 802a7f6:	0028      	movs	r0, r5
 802a7f8:	f009 ff2e 	bl	8034658 <UTIL_TIMER_Start>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 802a7fc:	f386 8810 	msr	PRIMASK, r6
    if( MacCtx.NodeAckRequested == true )
 802a800:	4b2c      	ldr	r3, [pc, #176]	; (802a8b4 <ProcessRadioTxDone+0x110>)
 802a802:	5ce3      	ldrb	r3, [r4, r3]
 802a804:	2b00      	cmp	r3, #0
 802a806:	d135      	bne.n	802a874 <ProcessRadioTxDone+0xd0>
        MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 802a808:	4a29      	ldr	r2, [pc, #164]	; (802a8b0 <ProcessRadioTxDone+0x10c>)
 802a80a:	4b2b      	ldr	r3, [pc, #172]	; (802a8b8 <ProcessRadioTxDone+0x114>)
 802a80c:	2100      	movs	r1, #0
 802a80e:	54d1      	strb	r1, [r2, r3]
    Nvm.MacGroup1.LastTxDoneTime = TxDoneParams.CurTime;
 802a810:	4b26      	ldr	r3, [pc, #152]	; (802a8ac <ProcessRadioTxDone+0x108>)
 802a812:	681b      	ldr	r3, [r3, #0]
 802a814:	4d23      	ldr	r5, [pc, #140]	; (802a8a4 <ProcessRadioTxDone+0x100>)
 802a816:	62eb      	str	r3, [r5, #44]	; 0x2c
    txDone.Channel = MacCtx.Channel;
 802a818:	4f25      	ldr	r7, [pc, #148]	; (802a8b0 <ProcessRadioTxDone+0x10c>)
 802a81a:	4a28      	ldr	r2, [pc, #160]	; (802a8bc <ProcessRadioTxDone+0x118>)
 802a81c:	5cba      	ldrb	r2, [r7, r2]
 802a81e:	ae04      	add	r6, sp, #16
 802a820:	7032      	strb	r2, [r6, #0]
    txDone.LastTxDoneTime = TxDoneParams.CurTime;
 802a822:	9305      	str	r3, [sp, #20]
    txDone.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 802a824:	a80c      	add	r0, sp, #48	; 0x30
 802a826:	f009 fde9 	bl	80343fc <SysTimeGetMcuTime>
 802a82a:	ac02      	add	r4, sp, #8
 802a82c:	002b      	movs	r3, r5
 802a82e:	3329      	adds	r3, #41	; 0x29
 802a830:	33ff      	adds	r3, #255	; 0xff
 802a832:	681b      	ldr	r3, [r3, #0]
 802a834:	9300      	str	r3, [sp, #0]
 802a836:	2392      	movs	r3, #146	; 0x92
 802a838:	005b      	lsls	r3, r3, #1
 802a83a:	58eb      	ldr	r3, [r5, r3]
 802a83c:	990c      	ldr	r1, [sp, #48]	; 0x30
 802a83e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802a840:	0020      	movs	r0, r4
 802a842:	f009 fd77 	bl	8034334 <SysTimeSub>
 802a846:	ab07      	add	r3, sp, #28
 802a848:	cc06      	ldmia	r4!, {r1, r2}
 802a84a:	c306      	stmia	r3!, {r1, r2}
    txDone.LastTxAirTime = MacCtx.TxTimeOnAir;
 802a84c:	4b1c      	ldr	r3, [pc, #112]	; (802a8c0 <ProcessRadioTxDone+0x11c>)
 802a84e:	58fb      	ldr	r3, [r7, r3]
 802a850:	9306      	str	r3, [sp, #24]
    txDone.Joined  = true;
 802a852:	2301      	movs	r3, #1
 802a854:	7073      	strb	r3, [r6, #1]
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 802a856:	3330      	adds	r3, #48	; 0x30
 802a858:	33ff      	adds	r3, #255	; 0xff
 802a85a:	5ceb      	ldrb	r3, [r5, r3]
 802a85c:	2b00      	cmp	r3, #0
 802a85e:	d101      	bne.n	802a864 <ProcessRadioTxDone+0xc0>
        txDone.Joined  = false;
 802a860:	2200      	movs	r2, #0
 802a862:	7062      	strb	r2, [r4, #1]
    RegionSetBandTxDone( Nvm.MacGroup2.Region, &txDone );
 802a864:	4a0f      	ldr	r2, [pc, #60]	; (802a8a4 <ProcessRadioTxDone+0x100>)
 802a866:	2348      	movs	r3, #72	; 0x48
 802a868:	5cd0      	ldrb	r0, [r2, r3]
 802a86a:	a904      	add	r1, sp, #16
 802a86c:	f004 fbd7 	bl	802f01e <RegionSetBandTxDone>
}
 802a870:	b00f      	add	sp, #60	; 0x3c
 802a872:	bdf0      	pop	{r4, r5, r6, r7, pc}
        getPhy.Attribute = PHY_RETRANSMIT_TIMEOUT;
 802a874:	a90a      	add	r1, sp, #40	; 0x28
 802a876:	2315      	movs	r3, #21
 802a878:	700b      	strb	r3, [r1, #0]
        phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802a87a:	4a0a      	ldr	r2, [pc, #40]	; (802a8a4 <ProcessRadioTxDone+0x100>)
 802a87c:	3333      	adds	r3, #51	; 0x33
 802a87e:	5cd0      	ldrb	r0, [r2, r3]
 802a880:	f004 fbb6 	bl	802eff0 <RegionGetPhyParam>
 802a884:	9009      	str	r0, [sp, #36]	; 0x24
        TimerSetValue( &MacCtx.RetransmitTimeoutTimer, MacCtx.RxWindow2Delay + phyParam.Value );
 802a886:	4c0a      	ldr	r4, [pc, #40]	; (802a8b0 <ProcessRadioTxDone+0x10c>)
 802a888:	23ed      	movs	r3, #237	; 0xed
 802a88a:	009b      	lsls	r3, r3, #2
 802a88c:	58e1      	ldr	r1, [r4, r3]
 802a88e:	1809      	adds	r1, r1, r0
 802a890:	334c      	adds	r3, #76	; 0x4c
 802a892:	469c      	mov	ip, r3
 802a894:	4464      	add	r4, ip
 802a896:	0020      	movs	r0, r4
 802a898:	f009 ff24 	bl	80346e4 <UTIL_TIMER_SetPeriod>
        TimerStart( &MacCtx.RetransmitTimeoutTimer );
 802a89c:	0020      	movs	r0, r4
 802a89e:	f009 fedb 	bl	8034658 <UTIL_TIMER_Start>
 802a8a2:	e7b5      	b.n	802a810 <ProcessRadioTxDone+0x6c>
 802a8a4:	2000a000 	.word	0x2000a000
 802a8a8:	08035d8c 	.word	0x08035d8c
 802a8ac:	2000c0d8 	.word	0x2000c0d8
 802a8b0:	2000bb1c 	.word	0x2000bb1c
 802a8b4:	0000041a 	.word	0x0000041a
 802a8b8:	00000441 	.word	0x00000441
 802a8bc:	0000041b 	.word	0x0000041b
 802a8c0:	0000041c 	.word	0x0000041c

0802a8c4 <OnRetransmitTimeoutTimerEvent>:
{
 802a8c4:	b510      	push	{r4, lr}
    TimerStop( &MacCtx.RetransmitTimeoutTimer );
 802a8c6:	4c09      	ldr	r4, [pc, #36]	; (802a8ec <OnRetransmitTimeoutTimerEvent+0x28>)
 802a8c8:	0020      	movs	r0, r4
 802a8ca:	f009 fe63 	bl	8034594 <UTIL_TIMER_Stop>
    if( MacCtx.NodeAckRequested == true )
 802a8ce:	4b08      	ldr	r3, [pc, #32]	; (802a8f0 <OnRetransmitTimeoutTimerEvent+0x2c>)
 802a8d0:	469c      	mov	ip, r3
 802a8d2:	4464      	add	r4, ip
 802a8d4:	4b07      	ldr	r3, [pc, #28]	; (802a8f4 <OnRetransmitTimeoutTimerEvent+0x30>)
 802a8d6:	5ce3      	ldrb	r3, [r4, r3]
 802a8d8:	2b00      	cmp	r3, #0
 802a8da:	d003      	beq.n	802a8e4 <OnRetransmitTimeoutTimerEvent+0x20>
        MacCtx.RetransmitTimeoutRetry = true;
 802a8dc:	4a06      	ldr	r2, [pc, #24]	; (802a8f8 <OnRetransmitTimeoutTimerEvent+0x34>)
 802a8de:	4b07      	ldr	r3, [pc, #28]	; (802a8fc <OnRetransmitTimeoutTimerEvent+0x38>)
 802a8e0:	2101      	movs	r1, #1
 802a8e2:	54d1      	strb	r1, [r2, r3]
    OnMacProcessNotify( );
 802a8e4:	f7ff fef6 	bl	802a6d4 <OnMacProcessNotify>
}
 802a8e8:	bd10      	pop	{r4, pc}
 802a8ea:	46c0      	nop			; (mov r8, r8)
 802a8ec:	2000bf1c 	.word	0x2000bf1c
 802a8f0:	fffffc00 	.word	0xfffffc00
 802a8f4:	0000041a 	.word	0x0000041a
 802a8f8:	2000bb1c 	.word	0x2000bb1c
 802a8fc:	00000419 	.word	0x00000419

0802a900 <PrepareRxDoneAbort>:
{
 802a900:	b510      	push	{r4, lr}
    MacCtx.MacState |= LORAMAC_RX_ABORT;
 802a902:	4b0e      	ldr	r3, [pc, #56]	; (802a93c <PrepareRxDoneAbort+0x3c>)
 802a904:	21d0      	movs	r1, #208	; 0xd0
 802a906:	0089      	lsls	r1, r1, #2
 802a908:	2280      	movs	r2, #128	; 0x80
 802a90a:	5858      	ldr	r0, [r3, r1]
 802a90c:	4302      	orrs	r2, r0
 802a90e:	505a      	str	r2, [r3, r1]
    if( MacCtx.NodeAckRequested == true )
 802a910:	4a0b      	ldr	r2, [pc, #44]	; (802a940 <PrepareRxDoneAbort+0x40>)
 802a912:	5c9b      	ldrb	r3, [r3, r2]
 802a914:	2b00      	cmp	r3, #0
 802a916:	d10c      	bne.n	802a932 <PrepareRxDoneAbort+0x32>
    MacCtx.MacFlags.Bits.McpsInd = 1;
 802a918:	4a08      	ldr	r2, [pc, #32]	; (802a93c <PrepareRxDoneAbort+0x3c>)
 802a91a:	4b0a      	ldr	r3, [pc, #40]	; (802a944 <PrepareRxDoneAbort+0x44>)
 802a91c:	5cd1      	ldrb	r1, [r2, r3]
 802a91e:	2002      	movs	r0, #2
 802a920:	4301      	orrs	r1, r0
 802a922:	54d1      	strb	r1, [r2, r3]
    MacCtx.MacFlags.Bits.MacDone = 1;
 802a924:	b2c9      	uxtb	r1, r1
 802a926:	2010      	movs	r0, #16
 802a928:	4301      	orrs	r1, r0
 802a92a:	54d1      	strb	r1, [r2, r3]
    UpdateRxSlotIdleState( );
 802a92c:	f7ff fd8c 	bl	802a448 <UpdateRxSlotIdleState>
}
 802a930:	bd10      	pop	{r4, pc}
        OnRetransmitTimeoutTimerEvent( NULL );
 802a932:	2000      	movs	r0, #0
 802a934:	f7ff ffc6 	bl	802a8c4 <OnRetransmitTimeoutTimerEvent>
 802a938:	e7ee      	b.n	802a918 <PrepareRxDoneAbort+0x18>
 802a93a:	46c0      	nop			; (mov r8, r8)
 802a93c:	2000bb1c 	.word	0x2000bb1c
 802a940:	0000041a 	.word	0x0000041a
 802a944:	00000491 	.word	0x00000491

0802a948 <LoRaMacCheckForBeaconAcquisition>:
{
 802a948:	b510      	push	{r4, lr}
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 802a94a:	200b      	movs	r0, #11
 802a94c:	f003 fd9c 	bl	802e488 <LoRaMacConfirmQueueIsCmdActive>
 802a950:	2800      	cmp	r0, #0
 802a952:	d012      	beq.n	802a97a <LoRaMacCheckForBeaconAcquisition+0x32>
        ( MacCtx.MacFlags.Bits.McpsReq == 0 ) )
 802a954:	4a0b      	ldr	r2, [pc, #44]	; (802a984 <LoRaMacCheckForBeaconAcquisition+0x3c>)
 802a956:	4b0c      	ldr	r3, [pc, #48]	; (802a988 <LoRaMacCheckForBeaconAcquisition+0x40>)
 802a958:	5cd3      	ldrb	r3, [r2, r3]
    if( ( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_ACQUISITION ) == true ) &&
 802a95a:	07da      	lsls	r2, r3, #31
 802a95c:	d40f      	bmi.n	802a97e <LoRaMacCheckForBeaconAcquisition+0x36>
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 802a95e:	2204      	movs	r2, #4
 802a960:	0010      	movs	r0, r2
 802a962:	4018      	ands	r0, r3
 802a964:	421a      	tst	r2, r3
 802a966:	d009      	beq.n	802a97c <LoRaMacCheckForBeaconAcquisition+0x34>
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 802a968:	4906      	ldr	r1, [pc, #24]	; (802a984 <LoRaMacCheckForBeaconAcquisition+0x3c>)
 802a96a:	22d0      	movs	r2, #208	; 0xd0
 802a96c:	0092      	lsls	r2, r2, #2
 802a96e:	2302      	movs	r3, #2
 802a970:	5888      	ldr	r0, [r1, r2]
 802a972:	4398      	bics	r0, r3
 802a974:	5088      	str	r0, [r1, r2]
            return 0x01;
 802a976:	2001      	movs	r0, #1
 802a978:	e000      	b.n	802a97c <LoRaMacCheckForBeaconAcquisition+0x34>
    return 0x00;
 802a97a:	2000      	movs	r0, #0
}
 802a97c:	bd10      	pop	{r4, pc}
    return 0x00;
 802a97e:	2000      	movs	r0, #0
 802a980:	e7fc      	b.n	802a97c <LoRaMacCheckForBeaconAcquisition+0x34>
 802a982:	46c0      	nop			; (mov r8, r8)
 802a984:	2000bb1c 	.word	0x2000bb1c
 802a988:	00000491 	.word	0x00000491

0802a98c <GetFCntDown>:
{
 802a98c:	b510      	push	{r4, lr}
    if( ( macMsg == NULL ) || ( fCntID == NULL ) ||
 802a98e:	2a00      	cmp	r2, #0
 802a990:	d027      	beq.n	802a9e2 <GetFCntDown+0x56>
 802a992:	9c02      	ldr	r4, [sp, #8]
 802a994:	2c00      	cmp	r4, #0
 802a996:	d026      	beq.n	802a9e6 <GetFCntDown+0x5a>
 802a998:	9c03      	ldr	r4, [sp, #12]
 802a99a:	2c00      	cmp	r4, #0
 802a99c:	d025      	beq.n	802a9ea <GetFCntDown+0x5e>
    switch( addrID )
 802a99e:	2800      	cmp	r0, #0
 802a9a0:	d015      	beq.n	802a9ce <GetFCntDown+0x42>
 802a9a2:	2801      	cmp	r0, #1
 802a9a4:	d123      	bne.n	802a9ee <GetFCntDown+0x62>
            if( lrWanVersion.Fields.Minor == 1 )
 802a9a6:	021b      	lsls	r3, r3, #8
 802a9a8:	0e1b      	lsrs	r3, r3, #24
 802a9aa:	2b01      	cmp	r3, #1
 802a9ac:	d003      	beq.n	802a9b6 <GetFCntDown+0x2a>
                *fCntID = FCNT_DOWN;
 802a9ae:	2303      	movs	r3, #3
 802a9b0:	9902      	ldr	r1, [sp, #8]
 802a9b2:	700b      	strb	r3, [r1, #0]
 802a9b4:	e00e      	b.n	802a9d4 <GetFCntDown+0x48>
                if( ( fType == FRAME_TYPE_A ) || ( fType == FRAME_TYPE_D ) )
 802a9b6:	2900      	cmp	r1, #0
 802a9b8:	d005      	beq.n	802a9c6 <GetFCntDown+0x3a>
 802a9ba:	2903      	cmp	r1, #3
 802a9bc:	d003      	beq.n	802a9c6 <GetFCntDown+0x3a>
                    *fCntID = N_FCNT_DOWN;
 802a9be:	2301      	movs	r3, #1
 802a9c0:	9902      	ldr	r1, [sp, #8]
 802a9c2:	700b      	strb	r3, [r1, #0]
 802a9c4:	e006      	b.n	802a9d4 <GetFCntDown+0x48>
                    *fCntID = A_FCNT_DOWN;
 802a9c6:	2302      	movs	r3, #2
 802a9c8:	9902      	ldr	r1, [sp, #8]
 802a9ca:	700b      	strb	r3, [r1, #0]
 802a9cc:	e002      	b.n	802a9d4 <GetFCntDown+0x48>
            *fCntID = MC_FCNT_DOWN_0;
 802a9ce:	2304      	movs	r3, #4
 802a9d0:	9902      	ldr	r1, [sp, #8]
 802a9d2:	700b      	strb	r3, [r1, #0]
    return LoRaMacCryptoGetFCntDown( *fCntID, macMsg->FHDR.FCnt, currentDown );
 802a9d4:	89d1      	ldrh	r1, [r2, #14]
 802a9d6:	9b02      	ldr	r3, [sp, #8]
 802a9d8:	7818      	ldrb	r0, [r3, #0]
 802a9da:	9a03      	ldr	r2, [sp, #12]
 802a9dc:	f003 ff98 	bl	802e910 <LoRaMacCryptoGetFCntDown>
}
 802a9e0:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 802a9e2:	2009      	movs	r0, #9
 802a9e4:	e7fc      	b.n	802a9e0 <GetFCntDown+0x54>
 802a9e6:	2009      	movs	r0, #9
 802a9e8:	e7fa      	b.n	802a9e0 <GetFCntDown+0x54>
 802a9ea:	2009      	movs	r0, #9
 802a9ec:	e7f8      	b.n	802a9e0 <GetFCntDown+0x54>
    switch( addrID )
 802a9ee:	2005      	movs	r0, #5
 802a9f0:	e7f6      	b.n	802a9e0 <GetFCntDown+0x54>

0802a9f2 <RemoveMacCommands>:
{
 802a9f2:	b510      	push	{r4, lr}
    if( rxSlot == RX_SLOT_WIN_1 || rxSlot == RX_SLOT_WIN_2  )
 802a9f4:	2801      	cmp	r0, #1
 802a9f6:	d900      	bls.n	802a9fa <RemoveMacCommands+0x8>
}
 802a9f8:	bd10      	pop	{r4, pc}
        if( request == MCPS_CONFIRMED )
 802a9fa:	2a01      	cmp	r2, #1
 802a9fc:	d104      	bne.n	802aa08 <RemoveMacCommands+0x16>
            if( fCtrl.Bits.Ack == 1 )
 802a9fe:	068b      	lsls	r3, r1, #26
 802aa00:	d5fa      	bpl.n	802a9f8 <RemoveMacCommands+0x6>
                LoRaMacCommandsRemoveStickyAnsCmds( );
 802aa02:	f003 fbe1 	bl	802e1c8 <LoRaMacCommandsRemoveStickyAnsCmds>
 802aa06:	e7f7      	b.n	802a9f8 <RemoveMacCommands+0x6>
            LoRaMacCommandsRemoveStickyAnsCmds( );
 802aa08:	f003 fbde 	bl	802e1c8 <LoRaMacCommandsRemoveStickyAnsCmds>
}
 802aa0c:	e7f4      	b.n	802a9f8 <RemoveMacCommands+0x6>
	...

0802aa10 <ProcessMacCommands>:
{
 802aa10:	b5f0      	push	{r4, r5, r6, r7, lr}
 802aa12:	46d6      	mov	lr, sl
 802aa14:	464f      	mov	r7, r9
 802aa16:	4646      	mov	r6, r8
 802aa18:	b5c0      	push	{r6, r7, lr}
 802aa1a:	b090      	sub	sp, #64	; 0x40
 802aa1c:	0005      	movs	r5, r0
 802aa1e:	000c      	movs	r4, r1
 802aa20:	4690      	mov	r8, r2
 802aa22:	9303      	str	r3, [sp, #12]
 802aa24:	ab18      	add	r3, sp, #96	; 0x60
 802aa26:	781a      	ldrb	r2, [r3, #0]
    uint8_t status = 0;
 802aa28:	2300      	movs	r3, #0
 802aa2a:	212f      	movs	r1, #47	; 0x2f
 802aa2c:	a802      	add	r0, sp, #8
 802aa2e:	4684      	mov	ip, r0
 802aa30:	4461      	add	r1, ip
 802aa32:	700b      	strb	r3, [r1, #0]
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 802aa34:	a90d      	add	r1, sp, #52	; 0x34
 802aa36:	800b      	strh	r3, [r1, #0]
    if( ( rxSlot != RX_SLOT_WIN_1 ) && ( rxSlot != RX_SLOT_WIN_2 ) )
 802aa38:	2a01      	cmp	r2, #1
 802aa3a:	d900      	bls.n	802aa3e <ProcessMacCommands+0x2e>
 802aa3c:	e2f3      	b.n	802b026 <ProcessMacCommands+0x616>
    bool adrBlockFound = false;
 802aa3e:	4699      	mov	r9, r3
    while( macIndex < commandsSize )
 802aa40:	4544      	cmp	r4, r8
 802aa42:	d300      	bcc.n	802aa46 <ProcessMacCommands+0x36>
 802aa44:	e2ef      	b.n	802b026 <ProcessMacCommands+0x616>
        if( ( LoRaMacCommandsGetCmdSize( payload[macIndex] ) + macIndex ) > commandsSize )
 802aa46:	192f      	adds	r7, r5, r4
 802aa48:	5d28      	ldrb	r0, [r5, r4]
 802aa4a:	f003 fc21 	bl	802e290 <LoRaMacCommandsGetCmdSize>
 802aa4e:	1820      	adds	r0, r4, r0
 802aa50:	4540      	cmp	r0, r8
 802aa52:	dd00      	ble.n	802aa56 <ProcessMacCommands+0x46>
 802aa54:	e2e7      	b.n	802b026 <ProcessMacCommands+0x616>
        switch( payload[macIndex++] )
 802aa56:	1c66      	adds	r6, r4, #1
 802aa58:	b2f6      	uxtb	r6, r6
 802aa5a:	783b      	ldrb	r3, [r7, #0]
 802aa5c:	2b13      	cmp	r3, #19
 802aa5e:	d900      	bls.n	802aa62 <ProcessMacCommands+0x52>
 802aa60:	e2e1      	b.n	802b026 <ProcessMacCommands+0x616>
 802aa62:	009b      	lsls	r3, r3, #2
 802aa64:	4ac0      	ldr	r2, [pc, #768]	; (802ad68 <ProcessMacCommands+0x358>)
 802aa66:	58d3      	ldr	r3, [r2, r3]
 802aa68:	469f      	mov	pc, r3
                if( LoRaMacConfirmQueueIsCmdActive( MLME_LINK_CHECK ) == true )
 802aa6a:	2005      	movs	r0, #5
 802aa6c:	f003 fd0c 	bl	802e488 <LoRaMacConfirmQueueIsCmdActive>
 802aa70:	2800      	cmp	r0, #0
 802aa72:	d101      	bne.n	802aa78 <ProcessMacCommands+0x68>
        switch( payload[macIndex++] )
 802aa74:	0034      	movs	r4, r6
 802aa76:	e7e3      	b.n	802aa40 <ProcessMacCommands+0x30>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_LINK_CHECK );
 802aa78:	2105      	movs	r1, #5
 802aa7a:	2000      	movs	r0, #0
 802aa7c:	f003 fcb4 	bl	802e3e8 <LoRaMacConfirmQueueSetStatus>
                    MacCtx.MlmeConfirm.DemodMargin = payload[macIndex++];
 802aa80:	1ca3      	adds	r3, r4, #2
 802aa82:	b2db      	uxtb	r3, r3
 802aa84:	5da8      	ldrb	r0, [r5, r6]
 802aa86:	4ab9      	ldr	r2, [pc, #740]	; (802ad6c <ProcessMacCommands+0x35c>)
 802aa88:	49b9      	ldr	r1, [pc, #740]	; (802ad70 <ProcessMacCommands+0x360>)
 802aa8a:	5450      	strb	r0, [r2, r1]
                    MacCtx.MlmeConfirm.NbGateways = payload[macIndex++];
 802aa8c:	3403      	adds	r4, #3
 802aa8e:	b2e4      	uxtb	r4, r4
 802aa90:	5ce9      	ldrb	r1, [r5, r3]
 802aa92:	4bb8      	ldr	r3, [pc, #736]	; (802ad74 <ProcessMacCommands+0x364>)
 802aa94:	54d1      	strb	r1, [r2, r3]
 802aa96:	e7d3      	b.n	802aa40 <ProcessMacCommands+0x30>
                int8_t linkAdrDatarate = DR_0;
 802aa98:	2300      	movs	r3, #0
 802aa9a:	220a      	movs	r2, #10
 802aa9c:	a902      	add	r1, sp, #8
 802aa9e:	468c      	mov	ip, r1
 802aaa0:	4462      	add	r2, ip
 802aaa2:	7013      	strb	r3, [r2, #0]
                int8_t linkAdrTxPower = TX_POWER_0;
 802aaa4:	220b      	movs	r2, #11
 802aaa6:	4462      	add	r2, ip
 802aaa8:	7013      	strb	r3, [r2, #0]
                uint8_t linkAdrNbRep = 0;
 802aaaa:	aa05      	add	r2, sp, #20
 802aaac:	7013      	strb	r3, [r2, #0]
                uint8_t linkAdrNbBytesParsed = 0;
 802aaae:	aa07      	add	r2, sp, #28
 802aab0:	7013      	strb	r3, [r2, #0]
                if( adrBlockFound == false )
 802aab2:	464b      	mov	r3, r9
 802aab4:	2b00      	cmp	r3, #0
 802aab6:	d03f      	beq.n	802ab38 <ProcessMacCommands+0x128>
                    macIndex += 4;
 802aab8:	3405      	adds	r4, #5
 802aaba:	b2e4      	uxtb	r4, r4
 802aabc:	e7c0      	b.n	802aa40 <ProcessMacCommands+0x30>
                            linkAdrReq.PayloadSize = 5;
 802aabe:	ab09      	add	r3, sp, #36	; 0x24
 802aac0:	2205      	movs	r2, #5
 802aac2:	721a      	strb	r2, [r3, #8]
 802aac4:	e058      	b.n	802ab78 <ProcessMacCommands+0x168>
                            if( linkAdrDatarate > Nvm.MacGroup1.ChannelsDatarate )
 802aac6:	4aac      	ldr	r2, [pc, #688]	; (802ad78 <ProcessMacCommands+0x368>)
 802aac8:	3332      	adds	r3, #50	; 0x32
 802aaca:	56d3      	ldrsb	r3, [r2, r3]
 802aacc:	220a      	movs	r2, #10
 802aace:	4462      	add	r2, ip
 802aad0:	7812      	ldrb	r2, [r2, #0]
 802aad2:	b252      	sxtb	r2, r2
 802aad4:	4293      	cmp	r3, r2
 802aad6:	da04      	bge.n	802aae2 <ProcessMacCommands+0xd2>
                                Nvm.MacGroup2.ChannelsDatarateChangedLinkAdrReq = true;
 802aad8:	49a7      	ldr	r1, [pc, #668]	; (802ad78 <ProcessMacCommands+0x368>)
 802aada:	231e      	movs	r3, #30
 802aadc:	33ff      	adds	r3, #255	; 0xff
 802aade:	3806      	subs	r0, #6
 802aae0:	54c8      	strb	r0, [r1, r3]
                            Nvm.MacGroup1.ChannelsDatarate = linkAdrDatarate;
 802aae2:	4ba5      	ldr	r3, [pc, #660]	; (802ad78 <ProcessMacCommands+0x368>)
 802aae4:	2139      	movs	r1, #57	; 0x39
 802aae6:	545a      	strb	r2, [r3, r1]
                            Nvm.MacGroup1.ChannelsTxPower = linkAdrTxPower;
 802aae8:	220b      	movs	r2, #11
 802aaea:	a902      	add	r1, sp, #8
 802aaec:	468c      	mov	ip, r1
 802aaee:	4462      	add	r2, ip
 802aaf0:	7811      	ldrb	r1, [r2, #0]
 802aaf2:	2238      	movs	r2, #56	; 0x38
 802aaf4:	5499      	strb	r1, [r3, r2]
                            Nvm.MacGroup2.MacParams.ChannelsNbTrans = linkAdrNbRep;
 802aaf6:	aa05      	add	r2, sp, #20
 802aaf8:	7811      	ldrb	r1, [r2, #0]
 802aafa:	2268      	movs	r2, #104	; 0x68
 802aafc:	5499      	strb	r1, [r3, r2]
 802aafe:	e054      	b.n	802abaa <ProcessMacCommands+0x19a>
                            LoRaMacCommandsAddCmd( MOTE_MAC_LINK_ADR_ANS, &status, 1 );
 802ab00:	2201      	movs	r2, #1
 802ab02:	212f      	movs	r1, #47	; 0x2f
 802ab04:	ab02      	add	r3, sp, #8
 802ab06:	469c      	mov	ip, r3
 802ab08:	4461      	add	r1, ip
 802ab0a:	2003      	movs	r0, #3
 802ab0c:	f003 fae8 	bl	802e0e0 <LoRaMacCommandsAddCmd>
                        for( uint8_t i = 0; i < ( linkAdrNbBytesParsed / 5 ); i++ )
 802ab10:	3401      	adds	r4, #1
 802ab12:	b2e4      	uxtb	r4, r4
 802ab14:	ab07      	add	r3, sp, #28
 802ab16:	781f      	ldrb	r7, [r3, #0]
 802ab18:	2105      	movs	r1, #5
 802ab1a:	0038      	movs	r0, r7
 802ab1c:	f7f5 fafc 	bl	8020118 <__udivsi3>
 802ab20:	b2c0      	uxtb	r0, r0
 802ab22:	42a0      	cmp	r0, r4
 802ab24:	d8ec      	bhi.n	802ab00 <ProcessMacCommands+0xf0>
                        macIndex += linkAdrNbBytesParsed - 1;
 802ab26:	19be      	adds	r6, r7, r6
 802ab28:	b2f6      	uxtb	r6, r6
 802ab2a:	1e74      	subs	r4, r6, #1
 802ab2c:	b2e4      	uxtb	r4, r4
                        if( macIndex >= commandsSize )
 802ab2e:	45a0      	cmp	r8, r4
 802ab30:	d93e      	bls.n	802abb0 <ProcessMacCommands+0x1a0>
                    } while( payload[macIndex++] == SRV_MAC_LINK_ADR_REQ );
 802ab32:	5d2b      	ldrb	r3, [r5, r4]
 802ab34:	2b03      	cmp	r3, #3
 802ab36:	d13a      	bne.n	802abae <ProcessMacCommands+0x19e>
                        linkAdrReq.Payload = &payload[macIndex - 1];
 802ab38:	1e73      	subs	r3, r6, #1
 802ab3a:	18eb      	adds	r3, r5, r3
 802ab3c:	aa09      	add	r2, sp, #36	; 0x24
 802ab3e:	930a      	str	r3, [sp, #40]	; 0x28
                        linkAdrReq.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 802ab40:	4b8d      	ldr	r3, [pc, #564]	; (802ad78 <ProcessMacCommands+0x368>)
 802ab42:	218d      	movs	r1, #141	; 0x8d
 802ab44:	0049      	lsls	r1, r1, #1
 802ab46:	5c59      	ldrb	r1, [r3, r1]
 802ab48:	7291      	strb	r1, [r2, #10]
                        linkAdrReq.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802ab4a:	207c      	movs	r0, #124	; 0x7c
 802ab4c:	5c18      	ldrb	r0, [r3, r0]
 802ab4e:	7250      	strb	r0, [r2, #9]
                        linkAdrReq.CurrentDatarate = Nvm.MacGroup1.ChannelsDatarate;
 802ab50:	2039      	movs	r0, #57	; 0x39
 802ab52:	5618      	ldrsb	r0, [r3, r0]
 802ab54:	72d0      	strb	r0, [r2, #11]
                        linkAdrReq.CurrentTxPower = Nvm.MacGroup1.ChannelsTxPower;
 802ab56:	2038      	movs	r0, #56	; 0x38
 802ab58:	5618      	ldrsb	r0, [r3, r0]
 802ab5a:	7310      	strb	r0, [r2, #12]
                        linkAdrReq.CurrentNbRep = Nvm.MacGroup2.MacParams.ChannelsNbTrans;
 802ab5c:	2068      	movs	r0, #104	; 0x68
 802ab5e:	5c18      	ldrb	r0, [r3, r0]
 802ab60:	7350      	strb	r0, [r2, #13]
                        linkAdrReq.Version = Nvm.MacGroup2.Version;
 802ab62:	2296      	movs	r2, #150	; 0x96
 802ab64:	0052      	lsls	r2, r2, #1
 802ab66:	589b      	ldr	r3, [r3, r2]
 802ab68:	9309      	str	r3, [sp, #36]	; 0x24
                        if( Nvm.MacGroup2.AdrCtrlOn == true )
 802ab6a:	2900      	cmp	r1, #0
 802ab6c:	d0a7      	beq.n	802aabe <ProcessMacCommands+0xae>
                            linkAdrReq.PayloadSize = commandsSize - ( macIndex - 1 );
 802ab6e:	4643      	mov	r3, r8
 802ab70:	1b9b      	subs	r3, r3, r6
 802ab72:	3301      	adds	r3, #1
 802ab74:	aa09      	add	r2, sp, #36	; 0x24
 802ab76:	7213      	strb	r3, [r2, #8]
                        status = RegionLinkAdrReq( Nvm.MacGroup2.Region, &linkAdrReq, &linkAdrDatarate,
 802ab78:	4a7f      	ldr	r2, [pc, #508]	; (802ad78 <ProcessMacCommands+0x368>)
 802ab7a:	2348      	movs	r3, #72	; 0x48
 802ab7c:	5cd0      	ldrb	r0, [r2, r3]
 802ab7e:	ab07      	add	r3, sp, #28
 802ab80:	9301      	str	r3, [sp, #4]
 802ab82:	ab05      	add	r3, sp, #20
 802ab84:	9300      	str	r3, [sp, #0]
 802ab86:	230b      	movs	r3, #11
 802ab88:	aa02      	add	r2, sp, #8
 802ab8a:	4694      	mov	ip, r2
 802ab8c:	4463      	add	r3, ip
 802ab8e:	220a      	movs	r2, #10
 802ab90:	4462      	add	r2, ip
 802ab92:	a909      	add	r1, sp, #36	; 0x24
 802ab94:	f004 fabf 	bl	802f116 <RegionLinkAdrReq>
 802ab98:	232f      	movs	r3, #47	; 0x2f
 802ab9a:	aa02      	add	r2, sp, #8
 802ab9c:	4694      	mov	ip, r2
 802ab9e:	4463      	add	r3, ip
 802aba0:	7018      	strb	r0, [r3, #0]
                        if( ( status & 0x07 ) == 0x07 )
 802aba2:	2307      	movs	r3, #7
 802aba4:	4018      	ands	r0, r3
 802aba6:	2807      	cmp	r0, #7
 802aba8:	d08d      	beq.n	802aac6 <ProcessMacCommands+0xb6>
{
 802abaa:	2400      	movs	r4, #0
 802abac:	e7b2      	b.n	802ab14 <ProcessMacCommands+0x104>
                    } while( payload[macIndex++] == SRV_MAC_LINK_ADR_REQ );
 802abae:	0034      	movs	r4, r6
                    if( macIndex < commandsSize )
 802abb0:	4544      	cmp	r4, r8
 802abb2:	d204      	bcs.n	802abbe <ProcessMacCommands+0x1ae>
                        macIndex--;
 802abb4:	3c01      	subs	r4, #1
 802abb6:	b2e4      	uxtb	r4, r4
                    adrBlockFound = true;
 802abb8:	2301      	movs	r3, #1
 802abba:	4699      	mov	r9, r3
 802abbc:	e740      	b.n	802aa40 <ProcessMacCommands+0x30>
 802abbe:	2301      	movs	r3, #1
 802abc0:	4699      	mov	r9, r3
                break;
 802abc2:	e73d      	b.n	802aa40 <ProcessMacCommands+0x30>
                Nvm.MacGroup2.MaxDCycle = payload[macIndex++] & 0x0F;
 802abc4:	3402      	adds	r4, #2
 802abc6:	b2e4      	uxtb	r4, r4
 802abc8:	5daa      	ldrb	r2, [r5, r6]
 802abca:	230f      	movs	r3, #15
 802abcc:	4013      	ands	r3, r2
 802abce:	496a      	ldr	r1, [pc, #424]	; (802ad78 <ProcessMacCommands+0x368>)
 802abd0:	221c      	movs	r2, #28
 802abd2:	32ff      	adds	r2, #255	; 0xff
 802abd4:	548b      	strb	r3, [r1, r2]
                Nvm.MacGroup2.AggregatedDCycle = 1 << Nvm.MacGroup2.MaxDCycle;
 802abd6:	3a1b      	subs	r2, #27
 802abd8:	3aff      	subs	r2, #255	; 0xff
 802abda:	409a      	lsls	r2, r3
 802abdc:	0013      	movs	r3, r2
 802abde:	2290      	movs	r2, #144	; 0x90
 802abe0:	0052      	lsls	r2, r2, #1
 802abe2:	528b      	strh	r3, [r1, r2]
                LoRaMacCommandsAddCmd( MOTE_MAC_DUTY_CYCLE_ANS, macCmdPayload, 0 );
 802abe4:	2200      	movs	r2, #0
 802abe6:	a90d      	add	r1, sp, #52	; 0x34
 802abe8:	2004      	movs	r0, #4
 802abea:	f003 fa79 	bl	802e0e0 <LoRaMacCommandsAddCmd>
                break;
 802abee:	e727      	b.n	802aa40 <ProcessMacCommands+0x30>
                status = 0x07;
 802abf0:	272f      	movs	r7, #47	; 0x2f
 802abf2:	ab02      	add	r3, sp, #8
 802abf4:	469c      	mov	ip, r3
 802abf6:	4467      	add	r7, ip
 802abf8:	2307      	movs	r3, #7
 802abfa:	703b      	strb	r3, [r7, #0]
                rxParamSetupReq.DrOffset = ( payload[macIndex] >> 4 ) & 0x07;
 802abfc:	5dab      	ldrb	r3, [r5, r6]
 802abfe:	091b      	lsrs	r3, r3, #4
 802ac00:	2207      	movs	r2, #7
 802ac02:	4692      	mov	sl, r2
 802ac04:	4013      	ands	r3, r2
 802ac06:	4662      	mov	r2, ip
 802ac08:	7753      	strb	r3, [r2, #29]
                rxParamSetupReq.Datarate = payload[macIndex] & 0x0F;
 802ac0a:	57aa      	ldrsb	r2, [r5, r6]
 802ac0c:	230f      	movs	r3, #15
 802ac0e:	4013      	ands	r3, r2
 802ac10:	4662      	mov	r2, ip
 802ac12:	7713      	strb	r3, [r2, #28]
                macIndex++;
 802ac14:	1ca3      	adds	r3, r4, #2
 802ac16:	b2db      	uxtb	r3, r3
                rxParamSetupReq.Frequency = ( uint32_t ) payload[macIndex++];
 802ac18:	1ce2      	adds	r2, r4, #3
 802ac1a:	b2d2      	uxtb	r2, r2
 802ac1c:	5ceb      	ldrb	r3, [r5, r3]
 802ac1e:	930a      	str	r3, [sp, #40]	; 0x28
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 802ac20:	1d20      	adds	r0, r4, #4
 802ac22:	b2c0      	uxtb	r0, r0
 802ac24:	5caa      	ldrb	r2, [r5, r2]
 802ac26:	0212      	lsls	r2, r2, #8
 802ac28:	4313      	orrs	r3, r2
 802ac2a:	930a      	str	r3, [sp, #40]	; 0x28
                rxParamSetupReq.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 802ac2c:	3405      	adds	r4, #5
 802ac2e:	b2e4      	uxtb	r4, r4
 802ac30:	5c2a      	ldrb	r2, [r5, r0]
 802ac32:	0412      	lsls	r2, r2, #16
 802ac34:	4313      	orrs	r3, r2
 802ac36:	930a      	str	r3, [sp, #40]	; 0x28
                rxParamSetupReq.Frequency *= 100;
 802ac38:	2264      	movs	r2, #100	; 0x64
 802ac3a:	4353      	muls	r3, r2
 802ac3c:	930a      	str	r3, [sp, #40]	; 0x28
                status = RegionRxParamSetupReq( Nvm.MacGroup2.Region, &rxParamSetupReq );
 802ac3e:	4a4e      	ldr	r2, [pc, #312]	; (802ad78 <ProcessMacCommands+0x368>)
 802ac40:	2348      	movs	r3, #72	; 0x48
 802ac42:	5cd0      	ldrb	r0, [r2, r3]
 802ac44:	a909      	add	r1, sp, #36	; 0x24
 802ac46:	f004 fa7f 	bl	802f148 <RegionRxParamSetupReq>
 802ac4a:	7038      	strb	r0, [r7, #0]
                if( ( status & 0x07 ) == 0x07 )
 802ac4c:	4653      	mov	r3, sl
 802ac4e:	4003      	ands	r3, r0
 802ac50:	2b07      	cmp	r3, #7
 802ac52:	d006      	beq.n	802ac62 <ProcessMacCommands+0x252>
                macCmdPayload[0] = status;
 802ac54:	a90d      	add	r1, sp, #52	; 0x34
 802ac56:	7008      	strb	r0, [r1, #0]
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_PARAM_SETUP_ANS, macCmdPayload, 1 );
 802ac58:	2201      	movs	r2, #1
 802ac5a:	2005      	movs	r0, #5
 802ac5c:	f003 fa40 	bl	802e0e0 <LoRaMacCommandsAddCmd>
                break;
 802ac60:	e6ee      	b.n	802aa40 <ProcessMacCommands+0x30>
                    Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = rxParamSetupReq.Datarate;
 802ac62:	aa09      	add	r2, sp, #36	; 0x24
 802ac64:	7811      	ldrb	r1, [r2, #0]
 802ac66:	4b44      	ldr	r3, [pc, #272]	; (802ad78 <ProcessMacCommands+0x368>)
 802ac68:	2670      	movs	r6, #112	; 0x70
 802ac6a:	5599      	strb	r1, [r3, r6]
                    Nvm.MacGroup2.MacParams.RxCChannel.Datarate = rxParamSetupReq.Datarate;
 802ac6c:	3608      	adds	r6, #8
 802ac6e:	5599      	strb	r1, [r3, r6]
                    Nvm.MacGroup2.MacParams.Rx2Channel.Frequency = rxParamSetupReq.Frequency;
 802ac70:	990a      	ldr	r1, [sp, #40]	; 0x28
 802ac72:	66d9      	str	r1, [r3, #108]	; 0x6c
                    Nvm.MacGroup2.MacParams.RxCChannel.Frequency = rxParamSetupReq.Frequency;
 802ac74:	6759      	str	r1, [r3, #116]	; 0x74
                    Nvm.MacGroup2.MacParams.Rx1DrOffset = rxParamSetupReq.DrOffset;
 802ac76:	7851      	ldrb	r1, [r2, #1]
 802ac78:	2269      	movs	r2, #105	; 0x69
 802ac7a:	5499      	strb	r1, [r3, r2]
 802ac7c:	e7ea      	b.n	802ac54 <ProcessMacCommands+0x244>
                if( ( MacCtx.MacCallbacks != NULL ) && ( MacCtx.MacCallbacks->GetBatteryLevel != NULL ) )
 802ac7e:	4a3b      	ldr	r2, [pc, #236]	; (802ad6c <ProcessMacCommands+0x35c>)
 802ac80:	23d2      	movs	r3, #210	; 0xd2
 802ac82:	009b      	lsls	r3, r3, #2
 802ac84:	58d3      	ldr	r3, [r2, r3]
 802ac86:	2b00      	cmp	r3, #0
 802ac88:	d015      	beq.n	802acb6 <ProcessMacCommands+0x2a6>
 802ac8a:	681b      	ldr	r3, [r3, #0]
 802ac8c:	2b00      	cmp	r3, #0
 802ac8e:	d014      	beq.n	802acba <ProcessMacCommands+0x2aa>
                    batteryLevel = MacCtx.MacCallbacks->GetBatteryLevel( );
 802ac90:	4798      	blx	r3
                macCmdPayload[0] = batteryLevel;
 802ac92:	ab02      	add	r3, sp, #8
 802ac94:	222c      	movs	r2, #44	; 0x2c
 802ac96:	189b      	adds	r3, r3, r2
 802ac98:	7018      	strb	r0, [r3, #0]
                macCmdPayload[1] = ( uint8_t )( snr & 0x3F );
 802ac9a:	233f      	movs	r3, #63	; 0x3f
 802ac9c:	9a03      	ldr	r2, [sp, #12]
 802ac9e:	4013      	ands	r3, r2
 802aca0:	aa02      	add	r2, sp, #8
 802aca2:	212d      	movs	r1, #45	; 0x2d
 802aca4:	1852      	adds	r2, r2, r1
 802aca6:	7013      	strb	r3, [r2, #0]
                LoRaMacCommandsAddCmd( MOTE_MAC_DEV_STATUS_ANS, macCmdPayload, 2 );
 802aca8:	2202      	movs	r2, #2
 802acaa:	a90d      	add	r1, sp, #52	; 0x34
 802acac:	2006      	movs	r0, #6
 802acae:	f003 fa17 	bl	802e0e0 <LoRaMacCommandsAddCmd>
        switch( payload[macIndex++] )
 802acb2:	0034      	movs	r4, r6
                break;
 802acb4:	e6c4      	b.n	802aa40 <ProcessMacCommands+0x30>
                uint8_t batteryLevel = BAT_LEVEL_NO_MEASURE;
 802acb6:	20ff      	movs	r0, #255	; 0xff
 802acb8:	e7eb      	b.n	802ac92 <ProcessMacCommands+0x282>
 802acba:	20ff      	movs	r0, #255	; 0xff
 802acbc:	e7e9      	b.n	802ac92 <ProcessMacCommands+0x282>
                status = 0x03;
 802acbe:	272f      	movs	r7, #47	; 0x2f
 802acc0:	ab02      	add	r3, sp, #8
 802acc2:	469c      	mov	ip, r3
 802acc4:	4467      	add	r7, ip
 802acc6:	2303      	movs	r3, #3
 802acc8:	703b      	strb	r3, [r7, #0]
                newChannelReq.ChannelId = payload[macIndex++];
 802acca:	1ca3      	adds	r3, r4, #2
 802accc:	b2db      	uxtb	r3, r3
 802acce:	57aa      	ldrsb	r2, [r5, r6]
 802acd0:	a907      	add	r1, sp, #28
 802acd2:	710a      	strb	r2, [r1, #4]
                newChannelReq.NewChannel = &chParam;
 802acd4:	aa09      	add	r2, sp, #36	; 0x24
 802acd6:	9207      	str	r2, [sp, #28]
                chParam.Frequency = ( uint32_t ) payload[macIndex++];
 802acd8:	1ce0      	adds	r0, r4, #3
 802acda:	b2c0      	uxtb	r0, r0
 802acdc:	5ceb      	ldrb	r3, [r5, r3]
 802acde:	469c      	mov	ip, r3
 802ace0:	9309      	str	r3, [sp, #36]	; 0x24
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 802ace2:	1d26      	adds	r6, r4, #4
 802ace4:	b2f6      	uxtb	r6, r6
 802ace6:	5c2b      	ldrb	r3, [r5, r0]
 802ace8:	021b      	lsls	r3, r3, #8
 802acea:	4660      	mov	r0, ip
 802acec:	4303      	orrs	r3, r0
 802acee:	9309      	str	r3, [sp, #36]	; 0x24
                chParam.Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 802acf0:	1d60      	adds	r0, r4, #5
 802acf2:	b2c0      	uxtb	r0, r0
 802acf4:	5dae      	ldrb	r6, [r5, r6]
 802acf6:	0436      	lsls	r6, r6, #16
 802acf8:	4333      	orrs	r3, r6
 802acfa:	9309      	str	r3, [sp, #36]	; 0x24
                chParam.Frequency *= 100;
 802acfc:	2664      	movs	r6, #100	; 0x64
 802acfe:	4373      	muls	r3, r6
 802ad00:	9309      	str	r3, [sp, #36]	; 0x24
                chParam.Rx1Frequency = 0;
 802ad02:	2300      	movs	r3, #0
 802ad04:	930a      	str	r3, [sp, #40]	; 0x28
                chParam.DrRange.Value = payload[macIndex++];
 802ad06:	3406      	adds	r4, #6
 802ad08:	b2e4      	uxtb	r4, r4
 802ad0a:	562b      	ldrsb	r3, [r5, r0]
 802ad0c:	7213      	strb	r3, [r2, #8]
                status = ( uint8_t )RegionNewChannelReq( Nvm.MacGroup2.Region, &newChannelReq );
 802ad0e:	4a1a      	ldr	r2, [pc, #104]	; (802ad78 <ProcessMacCommands+0x368>)
 802ad10:	2348      	movs	r3, #72	; 0x48
 802ad12:	5cd0      	ldrb	r0, [r2, r3]
 802ad14:	f004 fa27 	bl	802f166 <RegionNewChannelReq>
 802ad18:	b2c3      	uxtb	r3, r0
 802ad1a:	703b      	strb	r3, [r7, #0]
                if( ( int8_t )status >= 0 )
 802ad1c:	2800      	cmp	r0, #0
 802ad1e:	da00      	bge.n	802ad22 <ProcessMacCommands+0x312>
 802ad20:	e68e      	b.n	802aa40 <ProcessMacCommands+0x30>
                    macCmdPayload[0] = status;
 802ad22:	a90d      	add	r1, sp, #52	; 0x34
 802ad24:	700b      	strb	r3, [r1, #0]
                    LoRaMacCommandsAddCmd( MOTE_MAC_NEW_CHANNEL_ANS, macCmdPayload, 1 );
 802ad26:	2201      	movs	r2, #1
 802ad28:	2007      	movs	r0, #7
 802ad2a:	f003 f9d9 	bl	802e0e0 <LoRaMacCommandsAddCmd>
                break;
 802ad2e:	e687      	b.n	802aa40 <ProcessMacCommands+0x30>
                uint8_t delay = payload[macIndex++] & 0x0F;
 802ad30:	3402      	adds	r4, #2
 802ad32:	b2e4      	uxtb	r4, r4
 802ad34:	5dab      	ldrb	r3, [r5, r6]
 802ad36:	220f      	movs	r2, #15
 802ad38:	0011      	movs	r1, r2
 802ad3a:	4019      	ands	r1, r3
                if( delay == 0 )
 802ad3c:	421a      	tst	r2, r3
 802ad3e:	d100      	bne.n	802ad42 <ProcessMacCommands+0x332>
                    delay++;
 802ad40:	3101      	adds	r1, #1
                Nvm.MacGroup2.MacParams.ReceiveDelay1 = delay * 1000;
 802ad42:	014a      	lsls	r2, r1, #5
 802ad44:	1a52      	subs	r2, r2, r1
 802ad46:	0093      	lsls	r3, r2, #2
 802ad48:	185b      	adds	r3, r3, r1
 802ad4a:	00db      	lsls	r3, r3, #3
 802ad4c:	4a0a      	ldr	r2, [pc, #40]	; (802ad78 <ProcessMacCommands+0x368>)
 802ad4e:	6593      	str	r3, [r2, #88]	; 0x58
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 802ad50:	21fa      	movs	r1, #250	; 0xfa
 802ad52:	0089      	lsls	r1, r1, #2
 802ad54:	468c      	mov	ip, r1
 802ad56:	4463      	add	r3, ip
 802ad58:	65d3      	str	r3, [r2, #92]	; 0x5c
                LoRaMacCommandsAddCmd( MOTE_MAC_RX_TIMING_SETUP_ANS, macCmdPayload, 0 );
 802ad5a:	2200      	movs	r2, #0
 802ad5c:	a90d      	add	r1, sp, #52	; 0x34
 802ad5e:	2008      	movs	r0, #8
 802ad60:	f003 f9be 	bl	802e0e0 <LoRaMacCommandsAddCmd>
                break;
 802ad64:	e66c      	b.n	802aa40 <ProcessMacCommands+0x30>
 802ad66:	46c0      	nop			; (mov r8, r8)
 802ad68:	080353b8 	.word	0x080353b8
 802ad6c:	2000bb1c 	.word	0x2000bb1c
 802ad70:	0000045c 	.word	0x0000045c
 802ad74:	0000045d 	.word	0x0000045d
 802ad78:	2000a000 	.word	0x2000a000
                uint8_t eirpDwellTime = payload[macIndex++];
 802ad7c:	3402      	adds	r4, #2
 802ad7e:	b2e4      	uxtb	r4, r4
 802ad80:	5daa      	ldrb	r2, [r5, r6]
                txParamSetupReq.UplinkDwellTime = 0;
 802ad82:	ab05      	add	r3, sp, #20
 802ad84:	2100      	movs	r1, #0
 802ad86:	7019      	strb	r1, [r3, #0]
                txParamSetupReq.DownlinkDwellTime = 0;
 802ad88:	7059      	strb	r1, [r3, #1]
                if( ( eirpDwellTime & 0x20 ) == 0x20 )
 802ad8a:	0693      	lsls	r3, r2, #26
 802ad8c:	d502      	bpl.n	802ad94 <ProcessMacCommands+0x384>
                    txParamSetupReq.DownlinkDwellTime = 1;
 802ad8e:	ab05      	add	r3, sp, #20
 802ad90:	3101      	adds	r1, #1
 802ad92:	7059      	strb	r1, [r3, #1]
                if( ( eirpDwellTime & 0x10 ) == 0x10 )
 802ad94:	06d3      	lsls	r3, r2, #27
 802ad96:	d502      	bpl.n	802ad9e <ProcessMacCommands+0x38e>
                    txParamSetupReq.UplinkDwellTime = 1;
 802ad98:	ab05      	add	r3, sp, #20
 802ad9a:	2101      	movs	r1, #1
 802ad9c:	7019      	strb	r1, [r3, #0]
                txParamSetupReq.MaxEirp = eirpDwellTime & 0x0F;
 802ad9e:	230f      	movs	r3, #15
 802ada0:	4013      	ands	r3, r2
 802ada2:	a905      	add	r1, sp, #20
 802ada4:	708b      	strb	r3, [r1, #2]
                if( RegionTxParamSetupReq( Nvm.MacGroup2.Region, &txParamSetupReq ) != -1 )
 802ada6:	4aa3      	ldr	r2, [pc, #652]	; (802b034 <ProcessMacCommands+0x624>)
 802ada8:	2348      	movs	r3, #72	; 0x48
 802adaa:	5cd0      	ldrb	r0, [r2, r3]
 802adac:	f004 f9ea 	bl	802f184 <RegionTxParamSetupReq>
 802adb0:	1c43      	adds	r3, r0, #1
 802adb2:	d100      	bne.n	802adb6 <ProcessMacCommands+0x3a6>
 802adb4:	e644      	b.n	802aa40 <ProcessMacCommands+0x30>
                    Nvm.MacGroup2.MacParams.UplinkDwellTime = txParamSetupReq.UplinkDwellTime;
 802adb6:	ab05      	add	r3, sp, #20
 802adb8:	781f      	ldrb	r7, [r3, #0]
 802adba:	4e9e      	ldr	r6, [pc, #632]	; (802b034 <ProcessMacCommands+0x624>)
 802adbc:	227c      	movs	r2, #124	; 0x7c
 802adbe:	54b7      	strb	r7, [r6, r2]
                    Nvm.MacGroup2.MacParams.DownlinkDwellTime = txParamSetupReq.DownlinkDwellTime;
 802adc0:	7859      	ldrb	r1, [r3, #1]
 802adc2:	3201      	adds	r2, #1
 802adc4:	54b1      	strb	r1, [r6, r2]
                    Nvm.MacGroup2.MacParams.MaxEirp = LoRaMacMaxEirpTable[txParamSetupReq.MaxEirp];
 802adc6:	789b      	ldrb	r3, [r3, #2]
 802adc8:	4a9b      	ldr	r2, [pc, #620]	; (802b038 <ProcessMacCommands+0x628>)
 802adca:	5cd0      	ldrb	r0, [r2, r3]
 802adcc:	f7f5 fe20 	bl	8020a10 <__aeabi_ui2f>
 802add0:	2380      	movs	r3, #128	; 0x80
 802add2:	50f0      	str	r0, [r6, r3]
                    getPhy.Attribute = PHY_MIN_TX_DR;
 802add4:	3b7e      	subs	r3, #126	; 0x7e
 802add6:	aa02      	add	r2, sp, #8
 802add8:	7713      	strb	r3, [r2, #28]
                    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802adda:	7797      	strb	r7, [r2, #30]
                    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802addc:	2348      	movs	r3, #72	; 0x48
 802adde:	5cf0      	ldrb	r0, [r6, r3]
 802ade0:	a909      	add	r1, sp, #36	; 0x24
 802ade2:	f004 f905 	bl	802eff0 <RegionGetPhyParam>
 802ade6:	9007      	str	r0, [sp, #28]
                    Nvm.MacGroup1.ChannelsDatarate = MAX( Nvm.MacGroup1.ChannelsDatarate, ( int8_t )phyParam.Value );
 802ade8:	b240      	sxtb	r0, r0
 802adea:	2339      	movs	r3, #57	; 0x39
 802adec:	56f2      	ldrsb	r2, [r6, r3]
 802adee:	1c03      	adds	r3, r0, #0
 802adf0:	4290      	cmp	r0, r2
 802adf2:	da00      	bge.n	802adf6 <ProcessMacCommands+0x3e6>
 802adf4:	1c13      	adds	r3, r2, #0
 802adf6:	498f      	ldr	r1, [pc, #572]	; (802b034 <ProcessMacCommands+0x624>)
 802adf8:	2239      	movs	r2, #57	; 0x39
 802adfa:	548b      	strb	r3, [r1, r2]
                    LoRaMacCommandsAddCmd( MOTE_MAC_TX_PARAM_SETUP_ANS, macCmdPayload, 0 );
 802adfc:	2200      	movs	r2, #0
 802adfe:	a90d      	add	r1, sp, #52	; 0x34
 802ae00:	2009      	movs	r0, #9
 802ae02:	f003 f96d 	bl	802e0e0 <LoRaMacCommandsAddCmd>
                break;
 802ae06:	e61b      	b.n	802aa40 <ProcessMacCommands+0x30>
                status = 0x03;
 802ae08:	272f      	movs	r7, #47	; 0x2f
 802ae0a:	ab02      	add	r3, sp, #8
 802ae0c:	469c      	mov	ip, r3
 802ae0e:	4467      	add	r7, ip
 802ae10:	2303      	movs	r3, #3
 802ae12:	703b      	strb	r3, [r7, #0]
                dlChannelReq.ChannelId = payload[macIndex++];
 802ae14:	1ca3      	adds	r3, r4, #2
 802ae16:	b2db      	uxtb	r3, r3
 802ae18:	5daa      	ldrb	r2, [r5, r6]
 802ae1a:	a909      	add	r1, sp, #36	; 0x24
 802ae1c:	700a      	strb	r2, [r1, #0]
                dlChannelReq.Rx1Frequency = ( uint32_t ) payload[macIndex++];
 802ae1e:	1ce2      	adds	r2, r4, #3
 802ae20:	b2d2      	uxtb	r2, r2
 802ae22:	5ceb      	ldrb	r3, [r5, r3]
 802ae24:	604b      	str	r3, [r1, #4]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 8;
 802ae26:	1d20      	adds	r0, r4, #4
 802ae28:	b2c0      	uxtb	r0, r0
 802ae2a:	5caa      	ldrb	r2, [r5, r2]
 802ae2c:	0212      	lsls	r2, r2, #8
 802ae2e:	4313      	orrs	r3, r2
 802ae30:	604b      	str	r3, [r1, #4]
                dlChannelReq.Rx1Frequency |= ( uint32_t ) payload[macIndex++] << 16;
 802ae32:	3405      	adds	r4, #5
 802ae34:	b2e4      	uxtb	r4, r4
 802ae36:	5c2a      	ldrb	r2, [r5, r0]
 802ae38:	0412      	lsls	r2, r2, #16
 802ae3a:	4313      	orrs	r3, r2
 802ae3c:	604b      	str	r3, [r1, #4]
                dlChannelReq.Rx1Frequency *= 100;
 802ae3e:	2264      	movs	r2, #100	; 0x64
 802ae40:	4353      	muls	r3, r2
 802ae42:	604b      	str	r3, [r1, #4]
                status = ( uint8_t )RegionDlChannelReq( Nvm.MacGroup2.Region, &dlChannelReq );
 802ae44:	4a7b      	ldr	r2, [pc, #492]	; (802b034 <ProcessMacCommands+0x624>)
 802ae46:	2348      	movs	r3, #72	; 0x48
 802ae48:	5cd0      	ldrb	r0, [r2, r3]
 802ae4a:	f004 f9aa 	bl	802f1a2 <RegionDlChannelReq>
 802ae4e:	b2c3      	uxtb	r3, r0
 802ae50:	703b      	strb	r3, [r7, #0]
                if( ( int8_t )status >= 0 )
 802ae52:	2800      	cmp	r0, #0
 802ae54:	da00      	bge.n	802ae58 <ProcessMacCommands+0x448>
 802ae56:	e5f3      	b.n	802aa40 <ProcessMacCommands+0x30>
                    macCmdPayload[0] = status;
 802ae58:	a90d      	add	r1, sp, #52	; 0x34
 802ae5a:	700b      	strb	r3, [r1, #0]
                    LoRaMacCommandsAddCmd( MOTE_MAC_DL_CHANNEL_ANS, macCmdPayload, 1 );
 802ae5c:	2201      	movs	r2, #1
 802ae5e:	200a      	movs	r0, #10
 802ae60:	f003 f93e 	bl	802e0e0 <LoRaMacCommandsAddCmd>
                break;
 802ae64:	e5ec      	b.n	802aa40 <ProcessMacCommands+0x30>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_DEVICE_TIME ) == true )
 802ae66:	2009      	movs	r0, #9
 802ae68:	f003 fb0e 	bl	802e488 <LoRaMacConfirmQueueIsCmdActive>
 802ae6c:	2800      	cmp	r0, #0
 802ae6e:	d106      	bne.n	802ae7e <ProcessMacCommands+0x46e>
                    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;
 802ae70:	4a72      	ldr	r2, [pc, #456]	; (802b03c <ProcessMacCommands+0x62c>)
 802ae72:	2387      	movs	r3, #135	; 0x87
 802ae74:	00db      	lsls	r3, r3, #3
 802ae76:	2100      	movs	r1, #0
 802ae78:	54d1      	strb	r1, [r2, r3]
        switch( payload[macIndex++] )
 802ae7a:	0034      	movs	r4, r6
 802ae7c:	e5e0      	b.n	802aa40 <ProcessMacCommands+0x30>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_DEVICE_TIME );
 802ae7e:	2109      	movs	r1, #9
 802ae80:	2000      	movs	r0, #0
 802ae82:	f003 fab1 	bl	802e3e8 <LoRaMacConfirmQueueSetStatus>
                    SysTime_t gpsEpochTime = { 0 };
 802ae86:	ab05      	add	r3, sp, #20
 802ae88:	469a      	mov	sl, r3
 802ae8a:	2208      	movs	r2, #8
 802ae8c:	2100      	movs	r1, #0
 802ae8e:	0018      	movs	r0, r3
 802ae90:	f009 fe51 	bl	8034b36 <memset>
                    SysTime_t sysTime = { 0 };
 802ae94:	af07      	add	r7, sp, #28
 802ae96:	2208      	movs	r2, #8
 802ae98:	2100      	movs	r1, #0
 802ae9a:	0038      	movs	r0, r7
 802ae9c:	f009 fe4b 	bl	8034b36 <memset>
                    SysTime_t sysTimeCurrent = { 0 };
 802aea0:	2208      	movs	r2, #8
 802aea2:	2100      	movs	r1, #0
 802aea4:	a809      	add	r0, sp, #36	; 0x24
 802aea6:	f009 fe46 	bl	8034b36 <memset>
                    gpsEpochTime.Seconds = ( uint32_t )payload[macIndex++];
 802aeaa:	1ca1      	adds	r1, r4, #2
 802aeac:	b2c9      	uxtb	r1, r1
 802aeae:	5dab      	ldrb	r3, [r5, r6]
 802aeb0:	9305      	str	r3, [sp, #20]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 8;
 802aeb2:	1ce2      	adds	r2, r4, #3
 802aeb4:	b2d2      	uxtb	r2, r2
 802aeb6:	5c69      	ldrb	r1, [r5, r1]
 802aeb8:	0209      	lsls	r1, r1, #8
 802aeba:	430b      	orrs	r3, r1
 802aebc:	9305      	str	r3, [sp, #20]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 16;
 802aebe:	1d21      	adds	r1, r4, #4
 802aec0:	b2c9      	uxtb	r1, r1
 802aec2:	5caa      	ldrb	r2, [r5, r2]
 802aec4:	0412      	lsls	r2, r2, #16
 802aec6:	4313      	orrs	r3, r2
 802aec8:	9305      	str	r3, [sp, #20]
                    gpsEpochTime.Seconds |= ( uint32_t )payload[macIndex++] << 24;
 802aeca:	1d62      	adds	r2, r4, #5
 802aecc:	b2d2      	uxtb	r2, r2
 802aece:	5c68      	ldrb	r0, [r5, r1]
 802aed0:	0600      	lsls	r0, r0, #24
 802aed2:	4318      	orrs	r0, r3
 802aed4:	9005      	str	r0, [sp, #20]
                    gpsEpochTime.SubSeconds = payload[macIndex++];
 802aed6:	3406      	adds	r4, #6
 802aed8:	b2e4      	uxtb	r4, r4
 802aeda:	5ca9      	ldrb	r1, [r5, r2]
 802aedc:	4653      	mov	r3, sl
 802aede:	8099      	strh	r1, [r3, #4]
                    gpsEpochTime.SubSeconds = ( int16_t )( ( ( int32_t )gpsEpochTime.SubSeconds * 1000 ) >> 8 );
 802aee0:	014a      	lsls	r2, r1, #5
 802aee2:	1a52      	subs	r2, r2, r1
 802aee4:	0093      	lsls	r3, r2, #2
 802aee6:	185b      	adds	r3, r3, r1
 802aee8:	115b      	asrs	r3, r3, #5
 802aeea:	4652      	mov	r2, sl
 802aeec:	8093      	strh	r3, [r2, #4]
                    sysTime = gpsEpochTime;
 802aeee:	003b      	movs	r3, r7
 802aef0:	ca42      	ldmia	r2!, {r1, r6}
 802aef2:	c342      	stmia	r3!, {r1, r6}
                    sysTime.Seconds += UNIX_GPS_EPOCH_OFFSET;
 802aef4:	4b52      	ldr	r3, [pc, #328]	; (802b040 <ProcessMacCommands+0x630>)
 802aef6:	469c      	mov	ip, r3
 802aef8:	4460      	add	r0, ip
 802aefa:	9007      	str	r0, [sp, #28]
                    sysTimeCurrent = SysTimeGet( );
 802aefc:	a809      	add	r0, sp, #36	; 0x24
 802aefe:	f009 fa5b 	bl	80343b8 <SysTimeGet>
                    sysTime = SysTimeAdd( sysTimeCurrent, SysTimeSub( sysTime, MacCtx.LastTxSysTime ) );
 802af02:	4e4e      	ldr	r6, [pc, #312]	; (802b03c <ProcessMacCommands+0x62c>)
 802af04:	23cf      	movs	r3, #207	; 0xcf
 802af06:	009b      	lsls	r3, r3, #2
 802af08:	18f3      	adds	r3, r6, r3
 802af0a:	681b      	ldr	r3, [r3, #0]
 802af0c:	9300      	str	r3, [sp, #0]
 802af0e:	23ce      	movs	r3, #206	; 0xce
 802af10:	009b      	lsls	r3, r3, #2
 802af12:	58f3      	ldr	r3, [r6, r3]
 802af14:	9907      	ldr	r1, [sp, #28]
 802af16:	9a08      	ldr	r2, [sp, #32]
 802af18:	a80e      	add	r0, sp, #56	; 0x38
 802af1a:	f009 fa0b 	bl	8034334 <SysTimeSub>
 802af1e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 802af20:	9300      	str	r3, [sp, #0]
 802af22:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802af24:	9909      	ldr	r1, [sp, #36]	; 0x24
 802af26:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 802af28:	0038      	movs	r0, r7
 802af2a:	f009 f9db 	bl	80342e4 <SysTimeAdd>
                    SysTimeSet( sysTime );
 802af2e:	9807      	ldr	r0, [sp, #28]
 802af30:	9908      	ldr	r1, [sp, #32]
 802af32:	f009 fa1f 	bl	8034374 <SysTimeSet>
                    LoRaMacClassBDeviceTimeAns( );
 802af36:	f003 f82a 	bl	802df8e <LoRaMacClassBDeviceTimeAns>
                    MacCtx.McpsIndication.DeviceTimeAnsReceived = true;
 802af3a:	2387      	movs	r3, #135	; 0x87
 802af3c:	00db      	lsls	r3, r3, #3
 802af3e:	2201      	movs	r2, #1
 802af40:	54f2      	strb	r2, [r6, r3]
 802af42:	e57d      	b.n	802aa40 <ProcessMacCommands+0x30>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_PING_SLOT_INFO ) == true )
 802af44:	200c      	movs	r0, #12
 802af46:	f003 fa9f 	bl	802e488 <LoRaMacConfirmQueueIsCmdActive>
 802af4a:	2800      	cmp	r0, #0
 802af4c:	d101      	bne.n	802af52 <ProcessMacCommands+0x542>
        switch( payload[macIndex++] )
 802af4e:	0034      	movs	r4, r6
 802af50:	e576      	b.n	802aa40 <ProcessMacCommands+0x30>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_PING_SLOT_INFO );
 802af52:	210c      	movs	r1, #12
 802af54:	2000      	movs	r0, #0
 802af56:	f003 fa47 	bl	802e3e8 <LoRaMacConfirmQueueSetStatus>
                    if( ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_PING_SLOT ) && ( MacCtx.RxSlot != RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ) )
 802af5a:	4a38      	ldr	r2, [pc, #224]	; (802b03c <ProcessMacCommands+0x62c>)
 802af5c:	2392      	movs	r3, #146	; 0x92
 802af5e:	00db      	lsls	r3, r3, #3
 802af60:	5cd3      	ldrb	r3, [r2, r3]
 802af62:	3b04      	subs	r3, #4
 802af64:	b2db      	uxtb	r3, r3
 802af66:	2b01      	cmp	r3, #1
 802af68:	d801      	bhi.n	802af6e <ProcessMacCommands+0x55e>
        switch( payload[macIndex++] )
 802af6a:	0034      	movs	r4, r6
 802af6c:	e568      	b.n	802aa40 <ProcessMacCommands+0x30>
                        LoRaMacClassBPingSlotInfoAns( );
 802af6e:	f003 f80a 	bl	802df86 <LoRaMacClassBPingSlotInfoAns>
        switch( payload[macIndex++] )
 802af72:	0034      	movs	r4, r6
 802af74:	e564      	b.n	802aa40 <ProcessMacCommands+0x30>
                frequency = ( uint32_t )payload[macIndex++];
 802af76:	1ca2      	adds	r2, r4, #2
 802af78:	b2d2      	uxtb	r2, r2
 802af7a:	5da9      	ldrb	r1, [r5, r6]
                frequency |= ( uint32_t )payload[macIndex++] << 8;
 802af7c:	1ce3      	adds	r3, r4, #3
 802af7e:	b2db      	uxtb	r3, r3
 802af80:	5caa      	ldrb	r2, [r5, r2]
 802af82:	0212      	lsls	r2, r2, #8
 802af84:	4311      	orrs	r1, r2
                frequency |= ( uint32_t )payload[macIndex++] << 16;
 802af86:	1d22      	adds	r2, r4, #4
 802af88:	b2d2      	uxtb	r2, r2
 802af8a:	5ceb      	ldrb	r3, [r5, r3]
 802af8c:	041b      	lsls	r3, r3, #16
 802af8e:	4319      	orrs	r1, r3
                frequency *= 100;
 802af90:	2364      	movs	r3, #100	; 0x64
 802af92:	4359      	muls	r1, r3
                datarate = payload[macIndex++] & 0x0F;
 802af94:	3405      	adds	r4, #5
 802af96:	b2e4      	uxtb	r4, r4
 802af98:	5cab      	ldrb	r3, [r5, r2]
 802af9a:	200f      	movs	r0, #15
 802af9c:	4018      	ands	r0, r3
                status = LoRaMacClassBPingSlotChannelReq( datarate, frequency );
 802af9e:	f002 fff3 	bl	802df88 <LoRaMacClassBPingSlotChannelReq>
                macCmdPayload[0] = status;
 802afa2:	a90d      	add	r1, sp, #52	; 0x34
 802afa4:	7008      	strb	r0, [r1, #0]
                LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_CHANNEL_ANS, macCmdPayload, 1 );
 802afa6:	2201      	movs	r2, #1
 802afa8:	2011      	movs	r0, #17
 802afaa:	f003 f899 	bl	802e0e0 <LoRaMacCommandsAddCmd>
                break;
 802afae:	e547      	b.n	802aa40 <ProcessMacCommands+0x30>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_BEACON_TIMING ) == true )
 802afb0:	200d      	movs	r0, #13
 802afb2:	f003 fa69 	bl	802e488 <LoRaMacConfirmQueueIsCmdActive>
 802afb6:	2800      	cmp	r0, #0
 802afb8:	d101      	bne.n	802afbe <ProcessMacCommands+0x5ae>
        switch( payload[macIndex++] )
 802afba:	0034      	movs	r4, r6
 802afbc:	e540      	b.n	802aa40 <ProcessMacCommands+0x30>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_BEACON_TIMING );
 802afbe:	210d      	movs	r1, #13
 802afc0:	2000      	movs	r0, #0
 802afc2:	f003 fa11 	bl	802e3e8 <LoRaMacConfirmQueueSetStatus>
                    beaconTimingDelay = ( uint16_t )payload[macIndex++];
 802afc6:	1ca3      	adds	r3, r4, #2
 802afc8:	b2db      	uxtb	r3, r3
 802afca:	5da9      	ldrb	r1, [r5, r6]
                    beaconTimingDelay |= ( uint16_t )payload[macIndex++] << 8;
 802afcc:	1ce2      	adds	r2, r4, #3
 802afce:	b2d2      	uxtb	r2, r2
 802afd0:	5ce8      	ldrb	r0, [r5, r3]
 802afd2:	0200      	lsls	r0, r0, #8
 802afd4:	4308      	orrs	r0, r1
                    beaconTimingChannel = payload[macIndex++];
 802afd6:	3404      	adds	r4, #4
 802afd8:	b2e4      	uxtb	r4, r4
 802afda:	5ca9      	ldrb	r1, [r5, r2]
                    LoRaMacClassBBeaconTimingAns( beaconTimingDelay, beaconTimingChannel, RxDoneParams.LastRxDone );
 802afdc:	4b19      	ldr	r3, [pc, #100]	; (802b044 <ProcessMacCommands+0x634>)
 802afde:	681a      	ldr	r2, [r3, #0]
 802afe0:	f002 ffd4 	bl	802df8c <LoRaMacClassBBeaconTimingAns>
 802afe4:	e52c      	b.n	802aa40 <ProcessMacCommands+0x30>
                    frequency = ( uint32_t )payload[macIndex++];
 802afe6:	1ca2      	adds	r2, r4, #2
 802afe8:	b2d2      	uxtb	r2, r2
 802afea:	5da8      	ldrb	r0, [r5, r6]
                    frequency |= ( uint32_t )payload[macIndex++] << 8;
 802afec:	1ce3      	adds	r3, r4, #3
 802afee:	b2db      	uxtb	r3, r3
 802aff0:	5caa      	ldrb	r2, [r5, r2]
 802aff2:	0212      	lsls	r2, r2, #8
 802aff4:	4310      	orrs	r0, r2
                    frequency |= ( uint32_t )payload[macIndex++] << 16;
 802aff6:	3404      	adds	r4, #4
 802aff8:	b2e4      	uxtb	r4, r4
 802affa:	5ceb      	ldrb	r3, [r5, r3]
 802affc:	041b      	lsls	r3, r3, #16
 802affe:	4318      	orrs	r0, r3
                    frequency *= 100;
 802b000:	2364      	movs	r3, #100	; 0x64
 802b002:	4358      	muls	r0, r3
                    if( LoRaMacClassBBeaconFreqReq( frequency ) == true )
 802b004:	f002 ffc4 	bl	802df90 <LoRaMacClassBBeaconFreqReq>
 802b008:	2800      	cmp	r0, #0
 802b00a:	d008      	beq.n	802b01e <ProcessMacCommands+0x60e>
                        macCmdPayload[0] = 1;
 802b00c:	ab0d      	add	r3, sp, #52	; 0x34
 802b00e:	2201      	movs	r2, #1
 802b010:	701a      	strb	r2, [r3, #0]
                    LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_FREQ_ANS, macCmdPayload, 1 );
 802b012:	2201      	movs	r2, #1
 802b014:	a90d      	add	r1, sp, #52	; 0x34
 802b016:	2013      	movs	r0, #19
 802b018:	f003 f862 	bl	802e0e0 <LoRaMacCommandsAddCmd>
                break;
 802b01c:	e510      	b.n	802aa40 <ProcessMacCommands+0x30>
                        macCmdPayload[0] = 0;
 802b01e:	ab0d      	add	r3, sp, #52	; 0x34
 802b020:	2200      	movs	r2, #0
 802b022:	701a      	strb	r2, [r3, #0]
 802b024:	e7f5      	b.n	802b012 <ProcessMacCommands+0x602>
}
 802b026:	b010      	add	sp, #64	; 0x40
 802b028:	bce0      	pop	{r5, r6, r7}
 802b02a:	46ba      	mov	sl, r7
 802b02c:	46b1      	mov	r9, r6
 802b02e:	46a8      	mov	r8, r5
 802b030:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802b032:	46c0      	nop			; (mov r8, r8)
 802b034:	2000a000 	.word	0x2000a000
 802b038:	08035690 	.word	0x08035690
 802b03c:	2000bb1c 	.word	0x2000bb1c
 802b040:	12d53d80 	.word	0x12d53d80
 802b044:	2000c0c8 	.word	0x2000c0c8

0802b048 <ProcessRadioRxDone>:
{
 802b048:	b5f0      	push	{r4, r5, r6, r7, lr}
 802b04a:	46d6      	mov	lr, sl
 802b04c:	464f      	mov	r7, r9
 802b04e:	4646      	mov	r6, r8
 802b050:	b5c0      	push	{r6, r7, lr}
 802b052:	b0a6      	sub	sp, #152	; 0x98
    uint8_t *payload = RxDoneParams.Payload;
 802b054:	4bca      	ldr	r3, [pc, #808]	; (802b380 <ProcessRadioRxDone+0x338>)
 802b056:	685e      	ldr	r6, [r3, #4]
    uint16_t size = RxDoneParams.Size;
 802b058:	891d      	ldrh	r5, [r3, #8]
    int16_t rssi = RxDoneParams.Rssi;
 802b05a:	210a      	movs	r1, #10
 802b05c:	5e5a      	ldrsh	r2, [r3, r1]
 802b05e:	4690      	mov	r8, r2
    int8_t snr = RxDoneParams.Snr;
 802b060:	270c      	movs	r7, #12
 802b062:	57df      	ldrsb	r7, [r3, r7]
    uint32_t downLinkCounter = 0;
 802b064:	2300      	movs	r3, #0
 802b066:	9309      	str	r3, [sp, #36]	; 0x24
    uint32_t address = Nvm.MacGroup2.DevAddr;
 802b068:	49c6      	ldr	r1, [pc, #792]	; (802b384 <ProcessRadioRxDone+0x33c>)
 802b06a:	22e4      	movs	r2, #228	; 0xe4
 802b06c:	588a      	ldr	r2, [r1, r2]
 802b06e:	4691      	mov	r9, r2
    LoRaMacRadioEvents.Events.RxProcessPending = 0;
 802b070:	49c5      	ldr	r1, [pc, #788]	; (802b388 <ProcessRadioRxDone+0x340>)
 802b072:	780a      	ldrb	r2, [r1, #0]
 802b074:	2001      	movs	r0, #1
 802b076:	4382      	bics	r2, r0
 802b078:	700a      	strb	r2, [r1, #0]
    MacCtx.McpsConfirm.AckReceived = false;
 802b07a:	4cc4      	ldr	r4, [pc, #784]	; (802b38c <ProcessRadioRxDone+0x344>)
 802b07c:	4ac4      	ldr	r2, [pc, #784]	; (802b390 <ProcessRadioRxDone+0x348>)
 802b07e:	54a3      	strb	r3, [r4, r2]
    MacCtx.RxStatus.Rssi = rssi;
 802b080:	4ac4      	ldr	r2, [pc, #784]	; (802b394 <ProcessRadioRxDone+0x34c>)
 802b082:	4641      	mov	r1, r8
 802b084:	52a1      	strh	r1, [r4, r2]
    MacCtx.RxStatus.Snr = snr;
 802b086:	4ac4      	ldr	r2, [pc, #784]	; (802b398 <ProcessRadioRxDone+0x350>)
 802b088:	54a7      	strb	r7, [r4, r2]
    MacCtx.RxStatus.RxSlot = MacCtx.RxSlot;
 802b08a:	3202      	adds	r2, #2
 802b08c:	5ca2      	ldrb	r2, [r4, r2]
 802b08e:	49c3      	ldr	r1, [pc, #780]	; (802b39c <ProcessRadioRxDone+0x354>)
 802b090:	468a      	mov	sl, r1
 802b092:	5462      	strb	r2, [r4, r1]
    MacCtx.McpsIndication.Port = 0;
 802b094:	4ac2      	ldr	r2, [pc, #776]	; (802b3a0 <ProcessRadioRxDone+0x358>)
 802b096:	54a3      	strb	r3, [r4, r2]
    MacCtx.McpsIndication.Multicast = 0;
 802b098:	4ac2      	ldr	r2, [pc, #776]	; (802b3a4 <ProcessRadioRxDone+0x35c>)
 802b09a:	54a3      	strb	r3, [r4, r2]
    MacCtx.McpsIndication.IsUplinkTxPending = 0;
 802b09c:	4ac2      	ldr	r2, [pc, #776]	; (802b3a8 <ProcessRadioRxDone+0x360>)
 802b09e:	54a3      	strb	r3, [r4, r2]
    MacCtx.McpsIndication.Buffer = NULL;
 802b0a0:	3203      	adds	r2, #3
 802b0a2:	50a3      	str	r3, [r4, r2]
    MacCtx.McpsIndication.BufferSize = 0;
 802b0a4:	4ac1      	ldr	r2, [pc, #772]	; (802b3ac <ProcessRadioRxDone+0x364>)
 802b0a6:	54a3      	strb	r3, [r4, r2]
    MacCtx.McpsIndication.RxData = false;
 802b0a8:	4ac1      	ldr	r2, [pc, #772]	; (802b3b0 <ProcessRadioRxDone+0x368>)
 802b0aa:	54a3      	strb	r3, [r4, r2]
    MacCtx.McpsIndication.AckReceived = false;
 802b0ac:	4ac1      	ldr	r2, [pc, #772]	; (802b3b4 <ProcessRadioRxDone+0x36c>)
 802b0ae:	54a3      	strb	r3, [r4, r2]
    MacCtx.McpsIndication.DownLinkCounter = 0;
 802b0b0:	3202      	adds	r2, #2
 802b0b2:	50a3      	str	r3, [r4, r2]
    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 802b0b4:	3a10      	subs	r2, #16
 802b0b6:	54a3      	strb	r3, [r4, r2]
    MacCtx.McpsIndication.DevAddress = 0;
 802b0b8:	4abf      	ldr	r2, [pc, #764]	; (802b3b8 <ProcessRadioRxDone+0x370>)
 802b0ba:	50a3      	str	r3, [r4, r2]
    MacCtx.McpsIndication.DeviceTimeAnsReceived = false;
 802b0bc:	3204      	adds	r2, #4
 802b0be:	54a3      	strb	r3, [r4, r2]
    MacCtx.McpsIndication.ResponseTimeout = 0;
 802b0c0:	4abe      	ldr	r2, [pc, #760]	; (802b3bc <ProcessRadioRxDone+0x374>)
 802b0c2:	50a3      	str	r3, [r4, r2]
    Radio.Sleep( );
 802b0c4:	4bbe      	ldr	r3, [pc, #760]	; (802b3c0 <ProcessRadioRxDone+0x378>)
 802b0c6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802b0c8:	4798      	blx	r3
    if( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 )
 802b0ca:	4653      	mov	r3, sl
 802b0cc:	5ce3      	ldrb	r3, [r4, r3]
 802b0ce:	2b00      	cmp	r3, #0
 802b0d0:	d048      	beq.n	802b164 <ProcessRadioRxDone+0x11c>
    if( LoRaMacClassBRxBeacon( payload, size ) == true )
 802b0d2:	0029      	movs	r1, r5
 802b0d4:	0030      	movs	r0, r6
 802b0d6:	f002 ff43 	bl	802df60 <LoRaMacClassBRxBeacon>
 802b0da:	2800      	cmp	r0, #0
 802b0dc:	d146      	bne.n	802b16c <ProcessRadioRxDone+0x124>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 802b0de:	4aa9      	ldr	r2, [pc, #676]	; (802b384 <ProcessRadioRxDone+0x33c>)
 802b0e0:	238c      	movs	r3, #140	; 0x8c
 802b0e2:	005b      	lsls	r3, r3, #1
 802b0e4:	5cd3      	ldrb	r3, [r2, r3]
 802b0e6:	2b01      	cmp	r3, #1
 802b0e8:	d04c      	beq.n	802b184 <ProcessRadioRxDone+0x13c>
    if( size == 0 )
 802b0ea:	2d00      	cmp	r5, #0
 802b0ec:	d068      	beq.n	802b1c0 <ProcessRadioRxDone+0x178>
    macHdr.Value = payload[pktHeaderLen++];
 802b0ee:	7834      	ldrb	r4, [r6, #0]
    switch( macHdr.Bits.MType )
 802b0f0:	0963      	lsrs	r3, r4, #5
 802b0f2:	2b05      	cmp	r3, #5
 802b0f4:	d100      	bne.n	802b0f8 <ProcessRadioRxDone+0xb0>
 802b0f6:	e13a      	b.n	802b36e <ProcessRadioRxDone+0x326>
 802b0f8:	d869      	bhi.n	802b1ce <ProcessRadioRxDone+0x186>
 802b0fa:	2b01      	cmp	r3, #1
 802b0fc:	d100      	bne.n	802b100 <ProcessRadioRxDone+0xb8>
 802b0fe:	e097      	b.n	802b230 <ProcessRadioRxDone+0x1e8>
 802b100:	2b03      	cmp	r3, #3
 802b102:	d000      	beq.n	802b106 <ProcessRadioRxDone+0xbe>
 802b104:	e374      	b.n	802b7f0 <ProcessRadioRxDone+0x7a8>
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802b106:	4a9f      	ldr	r2, [pc, #636]	; (802b384 <ProcessRadioRxDone+0x33c>)
 802b108:	237d      	movs	r3, #125	; 0x7d
 802b10a:	5cd1      	ldrb	r1, [r2, r3]
 802b10c:	ab21      	add	r3, sp, #132	; 0x84
 802b10e:	7099      	strb	r1, [r3, #2]
            getPhy.Datarate = MacCtx.McpsIndication.RxDatarate;
 802b110:	489e      	ldr	r0, [pc, #632]	; (802b38c <ProcessRadioRxDone+0x344>)
 802b112:	49ac      	ldr	r1, [pc, #688]	; (802b3c4 <ProcessRadioRxDone+0x37c>)
 802b114:	5641      	ldrsb	r1, [r0, r1]
 802b116:	7059      	strb	r1, [r3, #1]
            getPhy.Attribute = PHY_MAX_PAYLOAD;
 802b118:	210d      	movs	r1, #13
 802b11a:	7019      	strb	r1, [r3, #0]
            if( Nvm.MacGroup2.MacParams.RepeaterSupport == true )
 802b11c:	238c      	movs	r3, #140	; 0x8c
 802b11e:	5cd3      	ldrb	r3, [r2, r3]
 802b120:	2b00      	cmp	r3, #0
 802b122:	d002      	beq.n	802b12a <ProcessRadioRxDone+0xe2>
                getPhy.Attribute = PHY_MAX_PAYLOAD_REPEATER;
 802b124:	ab21      	add	r3, sp, #132	; 0x84
 802b126:	220e      	movs	r2, #14
 802b128:	701a      	strb	r2, [r3, #0]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802b12a:	4a96      	ldr	r2, [pc, #600]	; (802b384 <ProcessRadioRxDone+0x33c>)
 802b12c:	2348      	movs	r3, #72	; 0x48
 802b12e:	5cd0      	ldrb	r0, [r2, r3]
 802b130:	a921      	add	r1, sp, #132	; 0x84
 802b132:	f003 ff5d 	bl	802eff0 <RegionGetPhyParam>
 802b136:	9020      	str	r0, [sp, #128]	; 0x80
            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||
 802b138:	002b      	movs	r3, r5
 802b13a:	3b0d      	subs	r3, #13
 802b13c:	b21b      	sxth	r3, r3
 802b13e:	1c1a      	adds	r2, r3, #0
 802b140:	2b00      	cmp	r3, #0
 802b142:	da00      	bge.n	802b146 <ProcessRadioRxDone+0xfe>
 802b144:	e119      	b.n	802b37a <ProcessRadioRxDone+0x332>
 802b146:	b212      	sxth	r2, r2
 802b148:	9b20      	ldr	r3, [sp, #128]	; 0x80
 802b14a:	b21b      	sxth	r3, r3
 802b14c:	429a      	cmp	r2, r3
 802b14e:	dc02      	bgt.n	802b156 <ProcessRadioRxDone+0x10e>
 802b150:	2d0b      	cmp	r5, #11
 802b152:	d900      	bls.n	802b156 <ProcessRadioRxDone+0x10e>
 802b154:	e146      	b.n	802b3e4 <ProcessRadioRxDone+0x39c>
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802b156:	4a8d      	ldr	r2, [pc, #564]	; (802b38c <ProcessRadioRxDone+0x344>)
 802b158:	4b9b      	ldr	r3, [pc, #620]	; (802b3c8 <ProcessRadioRxDone+0x380>)
 802b15a:	2101      	movs	r1, #1
 802b15c:	54d1      	strb	r1, [r2, r3]
                PrepareRxDoneAbort( );
 802b15e:	f7ff fbcf 	bl	802a900 <PrepareRxDoneAbort>
                return;
 802b162:	e009      	b.n	802b178 <ProcessRadioRxDone+0x130>
        TimerStop( &MacCtx.RxWindowTimer2 );
 802b164:	4899      	ldr	r0, [pc, #612]	; (802b3cc <ProcessRadioRxDone+0x384>)
 802b166:	f009 fa15 	bl	8034594 <UTIL_TIMER_Stop>
 802b16a:	e7b2      	b.n	802b0d2 <ProcessRadioRxDone+0x8a>
        MacCtx.MlmeIndication.BeaconInfo.Rssi = rssi;
 802b16c:	4b87      	ldr	r3, [pc, #540]	; (802b38c <ProcessRadioRxDone+0x344>)
 802b16e:	4a98      	ldr	r2, [pc, #608]	; (802b3d0 <ProcessRadioRxDone+0x388>)
 802b170:	4641      	mov	r1, r8
 802b172:	5299      	strh	r1, [r3, r2]
        MacCtx.MlmeIndication.BeaconInfo.Snr = snr;
 802b174:	3202      	adds	r2, #2
 802b176:	549f      	strb	r7, [r3, r2]
}
 802b178:	b026      	add	sp, #152	; 0x98
 802b17a:	bce0      	pop	{r5, r6, r7}
 802b17c:	46ba      	mov	sl, r7
 802b17e:	46b1      	mov	r9, r6
 802b180:	46a8      	mov	r8, r5
 802b182:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( LoRaMacClassBIsPingExpected( ) == true )
 802b184:	f002 fef0 	bl	802df68 <LoRaMacClassBIsPingExpected>
 802b188:	2800      	cmp	r0, #0
 802b18a:	d00a      	beq.n	802b1a2 <ProcessRadioRxDone+0x15a>
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 802b18c:	2000      	movs	r0, #0
 802b18e:	f002 fee0 	bl	802df52 <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 802b192:	2000      	movs	r0, #0
 802b194:	f002 fee2 	bl	802df5c <LoRaMacClassBPingSlotTimerEvent>
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;
 802b198:	4a7c      	ldr	r2, [pc, #496]	; (802b38c <ProcessRadioRxDone+0x344>)
 802b19a:	4b80      	ldr	r3, [pc, #512]	; (802b39c <ProcessRadioRxDone+0x354>)
 802b19c:	2104      	movs	r1, #4
 802b19e:	54d1      	strb	r1, [r2, r3]
 802b1a0:	e7a3      	b.n	802b0ea <ProcessRadioRxDone+0xa2>
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 802b1a2:	f002 fee3 	bl	802df6c <LoRaMacClassBIsMulticastExpected>
 802b1a6:	2800      	cmp	r0, #0
 802b1a8:	d09f      	beq.n	802b0ea <ProcessRadioRxDone+0xa2>
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 802b1aa:	2000      	movs	r0, #0
 802b1ac:	f002 fed2 	bl	802df54 <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 802b1b0:	2000      	movs	r0, #0
 802b1b2:	f002 fed4 	bl	802df5e <LoRaMacClassBMulticastSlotTimerEvent>
            MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;
 802b1b6:	4a75      	ldr	r2, [pc, #468]	; (802b38c <ProcessRadioRxDone+0x344>)
 802b1b8:	4b78      	ldr	r3, [pc, #480]	; (802b39c <ProcessRadioRxDone+0x354>)
 802b1ba:	2105      	movs	r1, #5
 802b1bc:	54d1      	strb	r1, [r2, r3]
 802b1be:	e794      	b.n	802b0ea <ProcessRadioRxDone+0xa2>
        MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802b1c0:	4a72      	ldr	r2, [pc, #456]	; (802b38c <ProcessRadioRxDone+0x344>)
 802b1c2:	4b81      	ldr	r3, [pc, #516]	; (802b3c8 <ProcessRadioRxDone+0x380>)
 802b1c4:	2101      	movs	r1, #1
 802b1c6:	54d1      	strb	r1, [r2, r3]
        PrepareRxDoneAbort( );
 802b1c8:	f7ff fb9a 	bl	802a900 <PrepareRxDoneAbort>
        return;
 802b1cc:	e7d4      	b.n	802b178 <ProcessRadioRxDone+0x130>
    switch( macHdr.Bits.MType )
 802b1ce:	2b07      	cmp	r3, #7
 802b1d0:	d000      	beq.n	802b1d4 <ProcessRadioRxDone+0x18c>
 802b1d2:	e30d      	b.n	802b7f0 <ProcessRadioRxDone+0x7a8>
            memcpy1( MacCtx.RxPayload, &payload[pktHeaderLen], size - pktHeaderLen );
 802b1d4:	1c71      	adds	r1, r6, #1
 802b1d6:	1e6a      	subs	r2, r5, #1
 802b1d8:	b292      	uxth	r2, r2
 802b1da:	4c7e      	ldr	r4, [pc, #504]	; (802b3d4 <ProcessRadioRxDone+0x38c>)
 802b1dc:	0020      	movs	r0, r4
 802b1de:	f006 ff90 	bl	8032102 <memcpy1>
            MacCtx.McpsIndication.McpsIndication = MCPS_PROPRIETARY;
 802b1e2:	4b7d      	ldr	r3, [pc, #500]	; (802b3d8 <ProcessRadioRxDone+0x390>)
 802b1e4:	18e1      	adds	r1, r4, r3
 802b1e6:	2384      	movs	r3, #132	; 0x84
 802b1e8:	00db      	lsls	r3, r3, #3
 802b1ea:	2203      	movs	r2, #3
 802b1ec:	54ca      	strb	r2, [r1, r3]
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 802b1ee:	4b76      	ldr	r3, [pc, #472]	; (802b3c8 <ProcessRadioRxDone+0x380>)
 802b1f0:	2200      	movs	r2, #0
 802b1f2:	54ca      	strb	r2, [r1, r3]
            MacCtx.McpsIndication.Buffer = MacCtx.RxPayload;
 802b1f4:	3307      	adds	r3, #7
 802b1f6:	50cc      	str	r4, [r1, r3]
            MacCtx.McpsIndication.BufferSize = size - pktHeaderLen;
 802b1f8:	3d01      	subs	r5, #1
 802b1fa:	4b6c      	ldr	r3, [pc, #432]	; (802b3ac <ProcessRadioRxDone+0x364>)
 802b1fc:	54cd      	strb	r5, [r1, r3]
            MacCtx.MacFlags.Bits.McpsInd = 1;
 802b1fe:	4a77      	ldr	r2, [pc, #476]	; (802b3dc <ProcessRadioRxDone+0x394>)
 802b200:	5c8b      	ldrb	r3, [r1, r2]
 802b202:	2002      	movs	r0, #2
 802b204:	4303      	orrs	r3, r0
 802b206:	548b      	strb	r3, [r1, r2]
    if( ( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 ) ||
 802b208:	4a60      	ldr	r2, [pc, #384]	; (802b38c <ProcessRadioRxDone+0x344>)
 802b20a:	4b64      	ldr	r3, [pc, #400]	; (802b39c <ProcessRadioRxDone+0x354>)
 802b20c:	5cd3      	ldrb	r3, [r2, r3]
 802b20e:	2b01      	cmp	r3, #1
 802b210:	d800      	bhi.n	802b214 <ProcessRadioRxDone+0x1cc>
 802b212:	e2f4      	b.n	802b7fe <ProcessRadioRxDone+0x7b6>
    if( MacCtx.RxStatus.RxSlot != RX_SLOT_WIN_CLASS_C )
 802b214:	4a5d      	ldr	r2, [pc, #372]	; (802b38c <ProcessRadioRxDone+0x344>)
 802b216:	4b61      	ldr	r3, [pc, #388]	; (802b39c <ProcessRadioRxDone+0x354>)
 802b218:	5cd3      	ldrb	r3, [r2, r3]
 802b21a:	2b02      	cmp	r3, #2
 802b21c:	d005      	beq.n	802b22a <ProcessRadioRxDone+0x1e2>
        MacCtx.MacFlags.Bits.MacDone = 1;
 802b21e:	0011      	movs	r1, r2
 802b220:	4a6e      	ldr	r2, [pc, #440]	; (802b3dc <ProcessRadioRxDone+0x394>)
 802b222:	5c8b      	ldrb	r3, [r1, r2]
 802b224:	2010      	movs	r0, #16
 802b226:	4303      	orrs	r3, r0
 802b228:	548b      	strb	r3, [r1, r2]
    UpdateRxSlotIdleState( );
 802b22a:	f7ff f90d 	bl	802a448 <UpdateRxSlotIdleState>
 802b22e:	e7a3      	b.n	802b178 <ProcessRadioRxDone+0x130>
            if( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE )
 802b230:	2d10      	cmp	r5, #16
 802b232:	d931      	bls.n	802b298 <ProcessRadioRxDone+0x250>
            macMsgJoinAccept.Buffer = payload;
 802b234:	960a      	str	r6, [sp, #40]	; 0x28
            macMsgJoinAccept.BufSize = size;
 802b236:	b2ed      	uxtb	r5, r5
 802b238:	ab0a      	add	r3, sp, #40	; 0x28
 802b23a:	711d      	strb	r5, [r3, #4]
            if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 802b23c:	4a51      	ldr	r2, [pc, #324]	; (802b384 <ProcessRadioRxDone+0x33c>)
 802b23e:	2398      	movs	r3, #152	; 0x98
 802b240:	005b      	lsls	r3, r3, #1
 802b242:	5cd3      	ldrb	r3, [r2, r3]
 802b244:	2b00      	cmp	r3, #0
 802b246:	d12e      	bne.n	802b2a6 <ProcessRadioRxDone+0x25e>
            SecureElementGetJoinEui( joinEui );
 802b248:	a806      	add	r0, sp, #24
 802b24a:	f006 fe39 	bl	8031ec0 <SecureElementGetJoinEui>
            macCryptoStatus = LoRaMacCryptoHandleJoinAccept( JOIN_REQ, joinEui, &macMsgJoinAccept );
 802b24e:	ae0a      	add	r6, sp, #40	; 0x28
 802b250:	0032      	movs	r2, r6
 802b252:	a906      	add	r1, sp, #24
 802b254:	20ff      	movs	r0, #255	; 0xff
 802b256:	f003 fcc7 	bl	802ebe8 <LoRaMacCryptoHandleJoinAccept>
 802b25a:	0004      	movs	r4, r0
            verifyRxDr.DatarateParams.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 802b25c:	7c33      	ldrb	r3, [r6, #16]
 802b25e:	071b      	lsls	r3, r3, #28
 802b260:	0f1b      	lsrs	r3, r3, #28
 802b262:	aa02      	add	r2, sp, #8
 802b264:	7313      	strb	r3, [r2, #12]
            verifyRxDr.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802b266:	4b47      	ldr	r3, [pc, #284]	; (802b384 <ProcessRadioRxDone+0x33c>)
 802b268:	227d      	movs	r2, #125	; 0x7d
 802b26a:	5c9a      	ldrb	r2, [r3, r2]
 802b26c:	a902      	add	r1, sp, #8
 802b26e:	734a      	strb	r2, [r1, #13]
            rxDrValid = RegionVerify( Nvm.MacGroup2.Region, &verifyRxDr, PHY_RX_DR );
 802b270:	2248      	movs	r2, #72	; 0x48
 802b272:	5c98      	ldrb	r0, [r3, r2]
 802b274:	3a41      	subs	r2, #65	; 0x41
 802b276:	a905      	add	r1, sp, #20
 802b278:	f003 feed 	bl	802f056 <RegionVerify>
            if( ( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus ) && ( rxDrValid == true ) )
 802b27c:	2c00      	cmp	r4, #0
 802b27e:	d101      	bne.n	802b284 <ProcessRadioRxDone+0x23c>
 802b280:	2800      	cmp	r0, #0
 802b282:	d117      	bne.n	802b2b4 <ProcessRadioRxDone+0x26c>
                if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 802b284:	2001      	movs	r0, #1
 802b286:	f003 f8ff 	bl	802e488 <LoRaMacConfirmQueueIsCmdActive>
 802b28a:	2800      	cmp	r0, #0
 802b28c:	d0bc      	beq.n	802b208 <ProcessRadioRxDone+0x1c0>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL, MLME_JOIN );
 802b28e:	2101      	movs	r1, #1
 802b290:	2007      	movs	r0, #7
 802b292:	f003 f8a9 	bl	802e3e8 <LoRaMacConfirmQueueSetStatus>
 802b296:	e7b7      	b.n	802b208 <ProcessRadioRxDone+0x1c0>
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802b298:	4a3c      	ldr	r2, [pc, #240]	; (802b38c <ProcessRadioRxDone+0x344>)
 802b29a:	4b4b      	ldr	r3, [pc, #300]	; (802b3c8 <ProcessRadioRxDone+0x380>)
 802b29c:	2101      	movs	r1, #1
 802b29e:	54d1      	strb	r1, [r2, r3]
                PrepareRxDoneAbort( );
 802b2a0:	f7ff fb2e 	bl	802a900 <PrepareRxDoneAbort>
                return;
 802b2a4:	e768      	b.n	802b178 <ProcessRadioRxDone+0x130>
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802b2a6:	4a39      	ldr	r2, [pc, #228]	; (802b38c <ProcessRadioRxDone+0x344>)
 802b2a8:	4b47      	ldr	r3, [pc, #284]	; (802b3c8 <ProcessRadioRxDone+0x380>)
 802b2aa:	2101      	movs	r1, #1
 802b2ac:	54d1      	strb	r1, [r2, r3]
                PrepareRxDoneAbort( );
 802b2ae:	f7ff fb27 	bl	802a900 <PrepareRxDoneAbort>
                return;
 802b2b2:	e761      	b.n	802b178 <ProcessRadioRxDone+0x130>
                Nvm.MacGroup2.NetID = ( uint32_t ) macMsgJoinAccept.NetID[0];
 802b2b4:	7a73      	ldrb	r3, [r6, #9]
 802b2b6:	4c33      	ldr	r4, [pc, #204]	; (802b384 <ProcessRadioRxDone+0x33c>)
 802b2b8:	22e0      	movs	r2, #224	; 0xe0
 802b2ba:	50a3      	str	r3, [r4, r2]
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[1] << 8 );
 802b2bc:	7ab1      	ldrb	r1, [r6, #10]
 802b2be:	0209      	lsls	r1, r1, #8
 802b2c0:	430b      	orrs	r3, r1
 802b2c2:	50a3      	str	r3, [r4, r2]
                Nvm.MacGroup2.NetID |= ( ( uint32_t ) macMsgJoinAccept.NetID[2] << 16 );
 802b2c4:	7af1      	ldrb	r1, [r6, #11]
 802b2c6:	0409      	lsls	r1, r1, #16
 802b2c8:	430b      	orrs	r3, r1
 802b2ca:	50a3      	str	r3, [r4, r2]
                Nvm.MacGroup2.DevAddr = macMsgJoinAccept.DevAddr;
 802b2cc:	23e4      	movs	r3, #228	; 0xe4
 802b2ce:	68f2      	ldr	r2, [r6, #12]
 802b2d0:	50e2      	str	r2, [r4, r3]
                SecureElementSetDevAddr( ACTIVATION_TYPE_OTAA, Nvm.MacGroup2.DevAddr );
 802b2d2:	0011      	movs	r1, r2
 802b2d4:	2002      	movs	r0, #2
 802b2d6:	f006 fe08 	bl	8031eea <SecureElementSetDevAddr>
                Nvm.MacGroup2.MacParams.Rx1DrOffset = macMsgJoinAccept.DLSettings.Bits.RX1DRoffset;
 802b2da:	7c33      	ldrb	r3, [r6, #16]
 802b2dc:	065a      	lsls	r2, r3, #25
 802b2de:	0f52      	lsrs	r2, r2, #29
 802b2e0:	2169      	movs	r1, #105	; 0x69
 802b2e2:	5462      	strb	r2, [r4, r1]
                Nvm.MacGroup2.MacParams.Rx2Channel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 802b2e4:	071b      	lsls	r3, r3, #28
 802b2e6:	0f1b      	lsrs	r3, r3, #28
 802b2e8:	2270      	movs	r2, #112	; 0x70
 802b2ea:	54a3      	strb	r3, [r4, r2]
                Nvm.MacGroup2.MacParams.RxCChannel.Datarate = macMsgJoinAccept.DLSettings.Bits.RX2DataRate;
 802b2ec:	3208      	adds	r2, #8
 802b2ee:	54a3      	strb	r3, [r4, r2]
                Nvm.MacGroup2.MacParams.ReceiveDelay1 = macMsgJoinAccept.RxDelay;
 802b2f0:	7c73      	ldrb	r3, [r6, #17]
 802b2f2:	65a3      	str	r3, [r4, #88]	; 0x58
                if( Nvm.MacGroup2.MacParams.ReceiveDelay1 == 0 )
 802b2f4:	2b00      	cmp	r3, #0
 802b2f6:	d102      	bne.n	802b2fe <ProcessRadioRxDone+0x2b6>
                    Nvm.MacGroup2.MacParams.ReceiveDelay1 = 1;
 802b2f8:	4b22      	ldr	r3, [pc, #136]	; (802b384 <ProcessRadioRxDone+0x33c>)
 802b2fa:	3a77      	subs	r2, #119	; 0x77
 802b2fc:	659a      	str	r2, [r3, #88]	; 0x58
                Nvm.MacGroup2.MacParams.ReceiveDelay1 *= 1000;
 802b2fe:	4c21      	ldr	r4, [pc, #132]	; (802b384 <ProcessRadioRxDone+0x33c>)
 802b300:	6da1      	ldr	r1, [r4, #88]	; 0x58
 802b302:	014a      	lsls	r2, r1, #5
 802b304:	1a52      	subs	r2, r2, r1
 802b306:	0093      	lsls	r3, r2, #2
 802b308:	185b      	adds	r3, r3, r1
 802b30a:	00db      	lsls	r3, r3, #3
 802b30c:	65a3      	str	r3, [r4, #88]	; 0x58
                Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay1 + 1000;
 802b30e:	22fa      	movs	r2, #250	; 0xfa
 802b310:	0092      	lsls	r2, r2, #2
 802b312:	4694      	mov	ip, r2
 802b314:	4463      	add	r3, ip
 802b316:	65e3      	str	r3, [r4, #92]	; 0x5c
                Nvm.MacGroup2.MacParams.ChannelsNbTrans = 1;
 802b318:	2368      	movs	r3, #104	; 0x68
 802b31a:	2201      	movs	r2, #1
 802b31c:	54e2      	strb	r2, [r4, r3]
                Nvm.MacGroup2.Version.Fields.Minor = 0;
 802b31e:	33c6      	adds	r3, #198	; 0xc6
 802b320:	2200      	movs	r2, #0
 802b322:	54e2      	strb	r2, [r4, r3]
                applyCFList.Payload = macMsgJoinAccept.CFList;
 802b324:	3bfc      	subs	r3, #252	; 0xfc
 802b326:	aa02      	add	r2, sp, #8
 802b328:	4694      	mov	ip, r2
 802b32a:	4463      	add	r3, ip
 802b32c:	9324      	str	r3, [sp, #144]	; 0x90
                applyCFList.Size = size - 17;
 802b32e:	3d11      	subs	r5, #17
 802b330:	0013      	movs	r3, r2
 802b332:	228c      	movs	r2, #140	; 0x8c
 802b334:	189b      	adds	r3, r3, r2
 802b336:	701d      	strb	r5, [r3, #0]
                applyCFList.JoinChannel = MacCtx.Channel;
 802b338:	4a14      	ldr	r2, [pc, #80]	; (802b38c <ProcessRadioRxDone+0x344>)
 802b33a:	4b29      	ldr	r3, [pc, #164]	; (802b3e0 <ProcessRadioRxDone+0x398>)
 802b33c:	5cd3      	ldrb	r3, [r2, r3]
 802b33e:	4662      	mov	r2, ip
 802b340:	2184      	movs	r1, #132	; 0x84
 802b342:	1852      	adds	r2, r2, r1
 802b344:	7013      	strb	r3, [r2, #0]
                RegionApplyCFList( Nvm.MacGroup2.Region, &applyCFList );
 802b346:	2348      	movs	r3, #72	; 0x48
 802b348:	5ce0      	ldrb	r0, [r4, r3]
 802b34a:	a923      	add	r1, sp, #140	; 0x8c
 802b34c:	f003 fe93 	bl	802f076 <RegionApplyCFList>
                Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_OTAA;
 802b350:	2398      	movs	r3, #152	; 0x98
 802b352:	005b      	lsls	r3, r3, #1
 802b354:	2202      	movs	r2, #2
 802b356:	54e2      	strb	r2, [r4, r3]
                if( LoRaMacConfirmQueueIsCmdActive( joinType ) == true )
 802b358:	2001      	movs	r0, #1
 802b35a:	f003 f895 	bl	802e488 <LoRaMacConfirmQueueIsCmdActive>
 802b35e:	2800      	cmp	r0, #0
 802b360:	d100      	bne.n	802b364 <ProcessRadioRxDone+0x31c>
 802b362:	e751      	b.n	802b208 <ProcessRadioRxDone+0x1c0>
                    LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, joinType );
 802b364:	2101      	movs	r1, #1
 802b366:	2000      	movs	r0, #0
 802b368:	f003 f83e 	bl	802e3e8 <LoRaMacConfirmQueueSetStatus>
 802b36c:	e74c      	b.n	802b208 <ProcessRadioRxDone+0x1c0>
            MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 802b36e:	4a07      	ldr	r2, [pc, #28]	; (802b38c <ProcessRadioRxDone+0x344>)
 802b370:	2384      	movs	r3, #132	; 0x84
 802b372:	00db      	lsls	r3, r3, #3
 802b374:	2101      	movs	r1, #1
 802b376:	54d1      	strb	r1, [r2, r3]
 802b378:	e6c5      	b.n	802b106 <ProcessRadioRxDone+0xbe>
            if( ( MAX( 0, ( int16_t )( ( int16_t ) size - ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE ) ) > ( int16_t )phyParam.Value ) ||
 802b37a:	2200      	movs	r2, #0
 802b37c:	e6e3      	b.n	802b146 <ProcessRadioRxDone+0xfe>
 802b37e:	46c0      	nop			; (mov r8, r8)
 802b380:	2000c0c8 	.word	0x2000c0c8
 802b384:	2000a000 	.word	0x2000a000
 802b388:	2000bb18 	.word	0x2000bb18
 802b38c:	2000bb1c 	.word	0x2000bb1c
 802b390:	00000444 	.word	0x00000444
 802b394:	0000048c 	.word	0x0000048c
 802b398:	0000048e 	.word	0x0000048e
 802b39c:	0000048f 	.word	0x0000048f
 802b3a0:	00000423 	.word	0x00000423
 802b3a4:	00000422 	.word	0x00000422
 802b3a8:	00000425 	.word	0x00000425
 802b3ac:	0000042c 	.word	0x0000042c
 802b3b0:	0000042d 	.word	0x0000042d
 802b3b4:	0000042e 	.word	0x0000042e
 802b3b8:	00000434 	.word	0x00000434
 802b3bc:	0000043c 	.word	0x0000043c
 802b3c0:	08035d8c 	.word	0x08035d8c
 802b3c4:	00000424 	.word	0x00000424
 802b3c8:	00000421 	.word	0x00000421
 802b3cc:	2000beb4 	.word	0x2000beb4
 802b3d0:	0000047e 	.word	0x0000047e
 802b3d4:	2000bd54 	.word	0x2000bd54
 802b3d8:	fffffdc8 	.word	0xfffffdc8
 802b3dc:	00000491 	.word	0x00000491
 802b3e0:	0000041b 	.word	0x0000041b
            macMsgData.Buffer = payload;
 802b3e4:	9614      	str	r6, [sp, #80]	; 0x50
            macMsgData.BufSize = size;
 802b3e6:	ab02      	add	r3, sp, #8
 802b3e8:	224c      	movs	r2, #76	; 0x4c
 802b3ea:	189b      	adds	r3, r3, r2
 802b3ec:	701d      	strb	r5, [r3, #0]
            macMsgData.FRMPayload = MacCtx.RxPayload;
 802b3ee:	4bc7      	ldr	r3, [pc, #796]	; (802b70c <ProcessRadioRxDone+0x6c4>)
 802b3f0:	931d      	str	r3, [sp, #116]	; 0x74
            macMsgData.FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD;
 802b3f2:	2328      	movs	r3, #40	; 0x28
 802b3f4:	32b3      	adds	r2, #179	; 0xb3
 802b3f6:	a902      	add	r1, sp, #8
 802b3f8:	2048      	movs	r0, #72	; 0x48
 802b3fa:	1809      	adds	r1, r1, r0
 802b3fc:	54ca      	strb	r2, [r1, r3]
            if( LORAMAC_PARSER_SUCCESS != LoRaMacParserData( &macMsgData ) )
 802b3fe:	a814      	add	r0, sp, #80	; 0x50
 802b400:	f003 fcbf 	bl	802ed82 <LoRaMacParserData>
 802b404:	2800      	cmp	r0, #0
 802b406:	d148      	bne.n	802b49a <ProcessRadioRxDone+0x452>
            if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 802b408:	4ac1      	ldr	r2, [pc, #772]	; (802b710 <ProcessRadioRxDone+0x6c8>)
 802b40a:	238c      	movs	r3, #140	; 0x8c
 802b40c:	005b      	lsls	r3, r3, #1
 802b40e:	5cd3      	ldrb	r3, [r2, r3]
 802b410:	2b01      	cmp	r3, #1
 802b412:	d049      	beq.n	802b4a8 <ProcessRadioRxDone+0x460>
            MacCtx.McpsIndication.DevAddress = macMsgData.FHDR.DevAddr;
 802b414:	9b16      	ldr	r3, [sp, #88]	; 0x58
 802b416:	9303      	str	r3, [sp, #12]
 802b418:	4abe      	ldr	r2, [pc, #760]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b41a:	4bbf      	ldr	r3, [pc, #764]	; (802b718 <ProcessRadioRxDone+0x6d0>)
 802b41c:	9903      	ldr	r1, [sp, #12]
 802b41e:	50d1      	str	r1, [r2, r3]
            if( LORAMAC_STATUS_OK != DetermineFrameType( &macMsgData, &fType ) )
 802b420:	a906      	add	r1, sp, #24
 802b422:	a814      	add	r0, sp, #80	; 0x50
 802b424:	f7ff f8a8 	bl	802a578 <DetermineFrameType>
 802b428:	1e05      	subs	r5, r0, #0
 802b42a:	d169      	bne.n	802b500 <ProcessRadioRxDone+0x4b8>
            downLinkCounter = 0;
 802b42c:	2300      	movs	r3, #0
 802b42e:	9309      	str	r3, [sp, #36]	; 0x24
            for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 802b430:	2800      	cmp	r0, #0
 802b432:	d06c      	beq.n	802b50e <ProcessRadioRxDone+0x4c6>
    AddressIdentifier_t addrID = UNICAST_DEV_ADDR;
 802b434:	2601      	movs	r6, #1
            if( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) ||
 802b436:	2d01      	cmp	r5, #1
 802b438:	d10a      	bne.n	802b450 <ProcessRadioRxDone+0x408>
 802b43a:	ab06      	add	r3, sp, #24
 802b43c:	781b      	ldrb	r3, [r3, #0]
 802b43e:	2b03      	cmp	r3, #3
 802b440:	d000      	beq.n	802b444 <ProcessRadioRxDone+0x3fc>
 802b442:	e096      	b.n	802b572 <ProcessRadioRxDone+0x52a>
                                        ( macMsgData.FHDR.FCtrl.Bits.Ack != 0 ) ||
 802b444:	ab14      	add	r3, sp, #80	; 0x50
 802b446:	7b1b      	ldrb	r3, [r3, #12]
 802b448:	2260      	movs	r2, #96	; 0x60
 802b44a:	421a      	tst	r2, r3
 802b44c:	d000      	beq.n	802b450 <ProcessRadioRxDone+0x408>
 802b44e:	e090      	b.n	802b572 <ProcessRadioRxDone+0x52a>
            macCryptoStatus = GetFCntDown( addrID, fType, &macMsgData, Nvm.MacGroup2.Version, &fCntID, &downLinkCounter );
 802b450:	4aaf      	ldr	r2, [pc, #700]	; (802b710 <ProcessRadioRxDone+0x6c8>)
 802b452:	2396      	movs	r3, #150	; 0x96
 802b454:	005b      	lsls	r3, r3, #1
 802b456:	58d3      	ldr	r3, [r2, r3]
 802b458:	aa06      	add	r2, sp, #24
 802b45a:	7811      	ldrb	r1, [r2, #0]
 802b45c:	aa09      	add	r2, sp, #36	; 0x24
 802b45e:	9201      	str	r2, [sp, #4]
 802b460:	221b      	movs	r2, #27
 802b462:	a802      	add	r0, sp, #8
 802b464:	4684      	mov	ip, r0
 802b466:	4462      	add	r2, ip
 802b468:	9200      	str	r2, [sp, #0]
 802b46a:	aa14      	add	r2, sp, #80	; 0x50
 802b46c:	0030      	movs	r0, r6
 802b46e:	f7ff fa8d 	bl	802a98c <GetFCntDown>
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 802b472:	2800      	cmp	r0, #0
 802b474:	d100      	bne.n	802b478 <ProcessRadioRxDone+0x430>
 802b476:	e088      	b.n	802b58a <ProcessRadioRxDone+0x542>
                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED )
 802b478:	2807      	cmp	r0, #7
 802b47a:	d100      	bne.n	802b47e <ProcessRadioRxDone+0x436>
 802b47c:	e080      	b.n	802b580 <ProcessRadioRxDone+0x538>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802b47e:	4aa5      	ldr	r2, [pc, #660]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b480:	4ba6      	ldr	r3, [pc, #664]	; (802b71c <ProcessRadioRxDone+0x6d4>)
 802b482:	2101      	movs	r1, #1
 802b484:	54d1      	strb	r1, [r2, r3]
                MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 802b486:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802b488:	4ba2      	ldr	r3, [pc, #648]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b48a:	2186      	movs	r1, #134	; 0x86
 802b48c:	00c9      	lsls	r1, r1, #3
 802b48e:	505a      	str	r2, [r3, r1]
                MacCtx.MlmeIndication.DownLinkCounter = downLinkCounter;
 802b490:	49a3      	ldr	r1, [pc, #652]	; (802b720 <ProcessRadioRxDone+0x6d8>)
 802b492:	505a      	str	r2, [r3, r1]
                PrepareRxDoneAbort( );
 802b494:	f7ff fa34 	bl	802a900 <PrepareRxDoneAbort>
                return;
 802b498:	e66e      	b.n	802b178 <ProcessRadioRxDone+0x130>
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802b49a:	4a9e      	ldr	r2, [pc, #632]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b49c:	4b9f      	ldr	r3, [pc, #636]	; (802b71c <ProcessRadioRxDone+0x6d4>)
 802b49e:	2101      	movs	r1, #1
 802b4a0:	54d1      	strb	r1, [r2, r3]
                PrepareRxDoneAbort( );
 802b4a2:	f7ff fa2d 	bl	802a900 <PrepareRxDoneAbort>
                return;
 802b4a6:	e667      	b.n	802b178 <ProcessRadioRxDone+0x130>
                if( LoRaMacClassBIsPingExpected( ) == true )
 802b4a8:	f002 fd5e 	bl	802df68 <LoRaMacClassBIsPingExpected>
 802b4ac:	2800      	cmp	r0, #0
 802b4ae:	d011      	beq.n	802b4d4 <ProcessRadioRxDone+0x48c>
                    LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 802b4b0:	2000      	movs	r0, #0
 802b4b2:	f002 fd4e 	bl	802df52 <LoRaMacClassBSetPingSlotState>
                    LoRaMacClassBPingSlotTimerEvent( NULL );
 802b4b6:	2000      	movs	r0, #0
 802b4b8:	f002 fd50 	bl	802df5c <LoRaMacClassBPingSlotTimerEvent>
                    MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT;
 802b4bc:	4a95      	ldr	r2, [pc, #596]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b4be:	4b99      	ldr	r3, [pc, #612]	; (802b724 <ProcessRadioRxDone+0x6dc>)
 802b4c0:	2104      	movs	r1, #4
 802b4c2:	54d1      	strb	r1, [r2, r3]
                    LoRaMacClassBSetFPendingBit( macMsgData.FHDR.DevAddr, ( uint8_t ) macMsgData.FHDR.FCtrl.Bits.FPending );
 802b4c4:	ab14      	add	r3, sp, #80	; 0x50
 802b4c6:	7b19      	ldrb	r1, [r3, #12]
 802b4c8:	06c9      	lsls	r1, r1, #27
 802b4ca:	0fc9      	lsrs	r1, r1, #31
 802b4cc:	9816      	ldr	r0, [sp, #88]	; 0x58
 802b4ce:	f002 fd64 	bl	802df9a <LoRaMacClassBSetFPendingBit>
 802b4d2:	e79f      	b.n	802b414 <ProcessRadioRxDone+0x3cc>
                else if( LoRaMacClassBIsMulticastExpected( ) == true )
 802b4d4:	f002 fd4a 	bl	802df6c <LoRaMacClassBIsMulticastExpected>
 802b4d8:	2800      	cmp	r0, #0
 802b4da:	d09b      	beq.n	802b414 <ProcessRadioRxDone+0x3cc>
                    LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 802b4dc:	2000      	movs	r0, #0
 802b4de:	f002 fd39 	bl	802df54 <LoRaMacClassBSetMulticastSlotState>
                    LoRaMacClassBMulticastSlotTimerEvent( NULL );
 802b4e2:	2000      	movs	r0, #0
 802b4e4:	f002 fd3b 	bl	802df5e <LoRaMacClassBMulticastSlotTimerEvent>
                    MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT;
 802b4e8:	4a8a      	ldr	r2, [pc, #552]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b4ea:	4b8e      	ldr	r3, [pc, #568]	; (802b724 <ProcessRadioRxDone+0x6dc>)
 802b4ec:	2105      	movs	r1, #5
 802b4ee:	54d1      	strb	r1, [r2, r3]
                    LoRaMacClassBSetFPendingBit( macMsgData.FHDR.DevAddr, ( uint8_t ) macMsgData.FHDR.FCtrl.Bits.FPending );
 802b4f0:	ab14      	add	r3, sp, #80	; 0x50
 802b4f2:	7b19      	ldrb	r1, [r3, #12]
 802b4f4:	06c9      	lsls	r1, r1, #27
 802b4f6:	0fc9      	lsrs	r1, r1, #31
 802b4f8:	9816      	ldr	r0, [sp, #88]	; 0x58
 802b4fa:	f002 fd4e 	bl	802df9a <LoRaMacClassBSetFPendingBit>
 802b4fe:	e789      	b.n	802b414 <ProcessRadioRxDone+0x3cc>
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802b500:	4a84      	ldr	r2, [pc, #528]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b502:	4b86      	ldr	r3, [pc, #536]	; (802b71c <ProcessRadioRxDone+0x6d4>)
 802b504:	2101      	movs	r1, #1
 802b506:	54d1      	strb	r1, [r2, r3]
                PrepareRxDoneAbort( );
 802b508:	f7ff f9fa 	bl	802a900 <PrepareRxDoneAbort>
                return;
 802b50c:	e634      	b.n	802b178 <ProcessRadioRxDone+0x130>
                if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&
 802b50e:	0002      	movs	r2, r0
 802b510:	0043      	lsls	r3, r0, #1
 802b512:	181b      	adds	r3, r3, r0
 802b514:	0119      	lsls	r1, r3, #4
 802b516:	4b7e      	ldr	r3, [pc, #504]	; (802b710 <ProcessRadioRxDone+0x6c8>)
 802b518:	185b      	adds	r3, r3, r1
 802b51a:	33ec      	adds	r3, #236	; 0xec
 802b51c:	681b      	ldr	r3, [r3, #0]
 802b51e:	9916      	ldr	r1, [sp, #88]	; 0x58
 802b520:	428b      	cmp	r3, r1
 802b522:	d002      	beq.n	802b52a <ProcessRadioRxDone+0x4e2>
            for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 802b524:	3001      	adds	r0, #1
 802b526:	b2c0      	uxtb	r0, r0
 802b528:	e782      	b.n	802b430 <ProcessRadioRxDone+0x3e8>
                    ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true ) )
 802b52a:	0041      	lsls	r1, r0, #1
 802b52c:	1809      	adds	r1, r1, r0
 802b52e:	010e      	lsls	r6, r1, #4
 802b530:	4977      	ldr	r1, [pc, #476]	; (802b710 <ProcessRadioRxDone+0x6c8>)
 802b532:	1989      	adds	r1, r1, r6
 802b534:	31e9      	adds	r1, #233	; 0xe9
 802b536:	7809      	ldrb	r1, [r1, #0]
                if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address == macMsgData.FHDR.DevAddr ) &&
 802b538:	2900      	cmp	r1, #0
 802b53a:	d0f3      	beq.n	802b524 <ProcessRadioRxDone+0x4dc>
                    addrID = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.GroupID;
 802b53c:	4874      	ldr	r0, [pc, #464]	; (802b710 <ProcessRadioRxDone+0x6c8>)
 802b53e:	2130      	movs	r1, #48	; 0x30
 802b540:	434a      	muls	r2, r1
 802b542:	1882      	adds	r2, r0, r2
 802b544:	0011      	movs	r1, r2
 802b546:	31ea      	adds	r1, #234	; 0xea
 802b548:	780e      	ldrb	r6, [r1, #0]
                    downLinkCounter = *( Nvm.MacGroup2.MulticastChannelList[i].DownLinkCounter );
 802b54a:	320d      	adds	r2, #13
 802b54c:	32ff      	adds	r2, #255	; 0xff
 802b54e:	6812      	ldr	r2, [r2, #0]
 802b550:	6812      	ldr	r2, [r2, #0]
 802b552:	9209      	str	r2, [sp, #36]	; 0x24
                    if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 802b554:	228c      	movs	r2, #140	; 0x8c
 802b556:	0052      	lsls	r2, r2, #1
 802b558:	5c82      	ldrb	r2, [r0, r2]
 802b55a:	2a02      	cmp	r2, #2
 802b55c:	d002      	beq.n	802b564 <ProcessRadioRxDone+0x51c>
                    address = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address;
 802b55e:	4699      	mov	r9, r3
                    multicast = 1;
 802b560:	2501      	movs	r5, #1
 802b562:	e768      	b.n	802b436 <ProcessRadioRxDone+0x3ee>
                        MacCtx.RxStatus.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;
 802b564:	496b      	ldr	r1, [pc, #428]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b566:	4a6f      	ldr	r2, [pc, #444]	; (802b724 <ProcessRadioRxDone+0x6dc>)
 802b568:	2003      	movs	r0, #3
 802b56a:	5488      	strb	r0, [r1, r2]
                    address = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.Address;
 802b56c:	4699      	mov	r9, r3
                    multicast = 1;
 802b56e:	2501      	movs	r5, #1
 802b570:	e761      	b.n	802b436 <ProcessRadioRxDone+0x3ee>
                MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802b572:	4a68      	ldr	r2, [pc, #416]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b574:	4b69      	ldr	r3, [pc, #420]	; (802b71c <ProcessRadioRxDone+0x6d4>)
 802b576:	2101      	movs	r1, #1
 802b578:	54d1      	strb	r1, [r2, r3]
                PrepareRxDoneAbort( );
 802b57a:	f7ff f9c1 	bl	802a900 <PrepareRxDoneAbort>
                return;
 802b57e:	e5fb      	b.n	802b178 <ProcessRadioRxDone+0x130>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED;
 802b580:	4a64      	ldr	r2, [pc, #400]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b582:	4b66      	ldr	r3, [pc, #408]	; (802b71c <ProcessRadioRxDone+0x6d4>)
 802b584:	2108      	movs	r1, #8
 802b586:	54d1      	strb	r1, [r2, r3]
 802b588:	e77d      	b.n	802b486 <ProcessRadioRxDone+0x43e>
            macCryptoStatus = LoRaMacCryptoUnsecureMessage( addrID, address, fCntID, downLinkCounter, &macMsgData );
 802b58a:	231b      	movs	r3, #27
 802b58c:	aa02      	add	r2, sp, #8
 802b58e:	4694      	mov	ip, r2
 802b590:	4463      	add	r3, ip
 802b592:	781a      	ldrb	r2, [r3, #0]
 802b594:	ab14      	add	r3, sp, #80	; 0x50
 802b596:	9300      	str	r3, [sp, #0]
 802b598:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802b59a:	4649      	mov	r1, r9
 802b59c:	0030      	movs	r0, r6
 802b59e:	f003 fa6f 	bl	802ea80 <LoRaMacCryptoUnsecureMessage>
            if( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 802b5a2:	2800      	cmp	r0, #0
 802b5a4:	d164      	bne.n	802b670 <ProcessRadioRxDone+0x628>
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 802b5a6:	4b5b      	ldr	r3, [pc, #364]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b5a8:	2100      	movs	r1, #0
 802b5aa:	4a5c      	ldr	r2, [pc, #368]	; (802b71c <ProcessRadioRxDone+0x6d4>)
 802b5ac:	5499      	strb	r1, [r3, r2]
            MacCtx.McpsIndication.Multicast = multicast;
 802b5ae:	4a5e      	ldr	r2, [pc, #376]	; (802b728 <ProcessRadioRxDone+0x6e0>)
 802b5b0:	549d      	strb	r5, [r3, r2]
            MacCtx.McpsIndication.Buffer = NULL;
 802b5b2:	3206      	adds	r2, #6
 802b5b4:	5099      	str	r1, [r3, r2]
            MacCtx.McpsIndication.BufferSize = 0;
 802b5b6:	4a5d      	ldr	r2, [pc, #372]	; (802b72c <ProcessRadioRxDone+0x6e4>)
 802b5b8:	5499      	strb	r1, [r3, r2]
            MacCtx.McpsIndication.DownLinkCounter = downLinkCounter;
 802b5ba:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802b5bc:	2086      	movs	r0, #134	; 0x86
 802b5be:	00c0      	lsls	r0, r0, #3
 802b5c0:	501a      	str	r2, [r3, r0]
            MacCtx.MlmeIndication.DownLinkCounter = downLinkCounter;
 802b5c2:	4857      	ldr	r0, [pc, #348]	; (802b720 <ProcessRadioRxDone+0x6d8>)
 802b5c4:	501a      	str	r2, [r3, r0]
            MacCtx.McpsIndication.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 802b5c6:	aa14      	add	r2, sp, #80	; 0x50
 802b5c8:	7b12      	ldrb	r2, [r2, #12]
 802b5ca:	0692      	lsls	r2, r2, #26
 802b5cc:	0fd2      	lsrs	r2, r2, #31
 802b5ce:	4858      	ldr	r0, [pc, #352]	; (802b730 <ProcessRadioRxDone+0x6e8>)
 802b5d0:	541a      	strb	r2, [r3, r0]
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 802b5d2:	4858      	ldr	r0, [pc, #352]	; (802b734 <ProcessRadioRxDone+0x6ec>)
 802b5d4:	5419      	strb	r1, [r3, r0]
            MacCtx.McpsConfirm.AckReceived = macMsgData.FHDR.FCtrl.Bits.Ack;
 802b5d6:	4958      	ldr	r1, [pc, #352]	; (802b738 <ProcessRadioRxDone+0x6f0>)
 802b5d8:	545a      	strb	r2, [r3, r1]
            if( ( MacCtx.RxStatus.RxSlot == RX_SLOT_WIN_1 ) ||
 802b5da:	4a52      	ldr	r2, [pc, #328]	; (802b724 <ProcessRadioRxDone+0x6dc>)
 802b5dc:	5c98      	ldrb	r0, [r3, r2]
 802b5de:	2801      	cmp	r0, #1
 802b5e0:	d954      	bls.n	802b68c <ProcessRadioRxDone+0x644>
            if( multicast == 1 )
 802b5e2:	2d01      	cmp	r5, #1
 802b5e4:	d05a      	beq.n	802b69c <ProcessRadioRxDone+0x654>
                if( macHdr.Bits.MType == FRAME_TYPE_DATA_CONFIRMED_DOWN )
 802b5e6:	231f      	movs	r3, #31
 802b5e8:	439c      	bics	r4, r3
 802b5ea:	2ca0      	cmp	r4, #160	; 0xa0
 802b5ec:	d05c      	beq.n	802b6a8 <ProcessRadioRxDone+0x660>
                    Nvm.MacGroup1.SrvAckRequested = false;
 802b5ee:	2300      	movs	r3, #0
 802b5f0:	4947      	ldr	r1, [pc, #284]	; (802b710 <ProcessRadioRxDone+0x6c8>)
 802b5f2:	223a      	movs	r2, #58	; 0x3a
 802b5f4:	548b      	strb	r3, [r1, r2]
                    MacCtx.McpsIndication.McpsIndication = MCPS_UNCONFIRMED;
 802b5f6:	4947      	ldr	r1, [pc, #284]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b5f8:	2284      	movs	r2, #132	; 0x84
 802b5fa:	00d2      	lsls	r2, r2, #3
 802b5fc:	548b      	strb	r3, [r1, r2]
            if( ( ( Nvm.MacGroup1.SrvAckRequested == true ) || ( macMsgData.FHDR.FCtrl.Bits.FPending > 0 ) ) && ( Nvm.MacGroup2.DeviceClass == CLASS_A ) )
 802b5fe:	4a44      	ldr	r2, [pc, #272]	; (802b710 <ProcessRadioRxDone+0x6c8>)
 802b600:	233a      	movs	r3, #58	; 0x3a
 802b602:	5cd3      	ldrb	r3, [r2, r3]
 802b604:	2b00      	cmp	r3, #0
 802b606:	d103      	bne.n	802b610 <ProcessRadioRxDone+0x5c8>
 802b608:	ab14      	add	r3, sp, #80	; 0x50
 802b60a:	7b1b      	ldrb	r3, [r3, #12]
 802b60c:	06db      	lsls	r3, r3, #27
 802b60e:	d509      	bpl.n	802b624 <ProcessRadioRxDone+0x5dc>
 802b610:	4a3f      	ldr	r2, [pc, #252]	; (802b710 <ProcessRadioRxDone+0x6c8>)
 802b612:	238c      	movs	r3, #140	; 0x8c
 802b614:	005b      	lsls	r3, r3, #1
 802b616:	5cd3      	ldrb	r3, [r2, r3]
 802b618:	2b00      	cmp	r3, #0
 802b61a:	d103      	bne.n	802b624 <ProcessRadioRxDone+0x5dc>
                MacCtx.McpsIndication.IsUplinkTxPending = 1;
 802b61c:	4a3d      	ldr	r2, [pc, #244]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b61e:	4b47      	ldr	r3, [pc, #284]	; (802b73c <ProcessRadioRxDone+0x6f4>)
 802b620:	2101      	movs	r1, #1
 802b622:	54d1      	strb	r1, [r2, r3]
            RemoveMacCommands( MacCtx.RxStatus.RxSlot, macMsgData.FHDR.FCtrl, MacCtx.McpsConfirm.McpsRequest );
 802b624:	4a3b      	ldr	r2, [pc, #236]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b626:	2388      	movs	r3, #136	; 0x88
 802b628:	00db      	lsls	r3, r3, #3
 802b62a:	5cd2      	ldrb	r2, [r2, r3]
 802b62c:	ab14      	add	r3, sp, #80	; 0x50
 802b62e:	7b19      	ldrb	r1, [r3, #12]
 802b630:	f7ff f9df 	bl	802a9f2 <RemoveMacCommands>
            switch( fType )
 802b634:	ab06      	add	r3, sp, #24
 802b636:	781b      	ldrb	r3, [r3, #0]
 802b638:	2b02      	cmp	r3, #2
 802b63a:	d100      	bne.n	802b63e <ProcessRadioRxDone+0x5f6>
 802b63c:	e0af      	b.n	802b79e <ProcessRadioRxDone+0x756>
 802b63e:	d851      	bhi.n	802b6e4 <ProcessRadioRxDone+0x69c>
 802b640:	2b00      	cmp	r3, #0
 802b642:	d100      	bne.n	802b646 <ProcessRadioRxDone+0x5fe>
 802b644:	e084      	b.n	802b750 <ProcessRadioRxDone+0x708>
 802b646:	2b01      	cmp	r3, #1
 802b648:	d000      	beq.n	802b64c <ProcessRadioRxDone+0x604>
 802b64a:	e0b9      	b.n	802b7c0 <ProcessRadioRxDone+0x778>
                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.RxStatus.RxSlot );
 802b64c:	ac14      	add	r4, sp, #80	; 0x50
 802b64e:	7b22      	ldrb	r2, [r4, #12]
 802b650:	0712      	lsls	r2, r2, #28
 802b652:	0f12      	lsrs	r2, r2, #28
 802b654:	4d2f      	ldr	r5, [pc, #188]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b656:	4b33      	ldr	r3, [pc, #204]	; (802b724 <ProcessRadioRxDone+0x6dc>)
 802b658:	5ceb      	ldrb	r3, [r5, r3]
 802b65a:	9300      	str	r3, [sp, #0]
 802b65c:	003b      	movs	r3, r7
 802b65e:	2100      	movs	r1, #0
 802b660:	a818      	add	r0, sp, #96	; 0x60
 802b662:	f7ff f9d5 	bl	802aa10 <ProcessMacCommands>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 802b666:	2320      	movs	r3, #32
 802b668:	5ce2      	ldrb	r2, [r4, r3]
 802b66a:	4b35      	ldr	r3, [pc, #212]	; (802b740 <ProcessRadioRxDone+0x6f8>)
 802b66c:	54ea      	strb	r2, [r5, r3]
                    break;
 802b66e:	e08a      	b.n	802b786 <ProcessRadioRxDone+0x73e>
                if( macCryptoStatus == LORAMAC_CRYPTO_FAIL_ADDRESS )
 802b670:	2802      	cmp	r0, #2
 802b672:	d006      	beq.n	802b682 <ProcessRadioRxDone+0x63a>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL;
 802b674:	4a27      	ldr	r2, [pc, #156]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b676:	4b29      	ldr	r3, [pc, #164]	; (802b71c <ProcessRadioRxDone+0x6d4>)
 802b678:	210b      	movs	r1, #11
 802b67a:	54d1      	strb	r1, [r2, r3]
                PrepareRxDoneAbort( );
 802b67c:	f7ff f940 	bl	802a900 <PrepareRxDoneAbort>
                return;
 802b680:	e57a      	b.n	802b178 <ProcessRadioRxDone+0x130>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL;
 802b682:	4a24      	ldr	r2, [pc, #144]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b684:	4b25      	ldr	r3, [pc, #148]	; (802b71c <ProcessRadioRxDone+0x6d4>)
 802b686:	210a      	movs	r1, #10
 802b688:	54d1      	strb	r1, [r2, r3]
 802b68a:	e7f7      	b.n	802b67c <ProcessRadioRxDone+0x634>
                Nvm.MacGroup1.AdrAckCounter = 0;
 802b68c:	4b20      	ldr	r3, [pc, #128]	; (802b710 <ProcessRadioRxDone+0x6c8>)
 802b68e:	2200      	movs	r2, #0
 802b690:	629a      	str	r2, [r3, #40]	; 0x28
                Nvm.MacGroup2.DownlinkReceived = true;
 802b692:	321f      	adds	r2, #31
 802b694:	32ff      	adds	r2, #255	; 0xff
 802b696:	2101      	movs	r1, #1
 802b698:	5499      	strb	r1, [r3, r2]
 802b69a:	e7a2      	b.n	802b5e2 <ProcessRadioRxDone+0x59a>
                MacCtx.McpsIndication.McpsIndication = MCPS_MULTICAST;
 802b69c:	4a1d      	ldr	r2, [pc, #116]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b69e:	2384      	movs	r3, #132	; 0x84
 802b6a0:	00db      	lsls	r3, r3, #3
 802b6a2:	2102      	movs	r1, #2
 802b6a4:	54d1      	strb	r1, [r2, r3]
 802b6a6:	e7aa      	b.n	802b5fe <ProcessRadioRxDone+0x5b6>
                    Nvm.MacGroup1.SrvAckRequested = true;
 802b6a8:	4b19      	ldr	r3, [pc, #100]	; (802b710 <ProcessRadioRxDone+0x6c8>)
 802b6aa:	223a      	movs	r2, #58	; 0x3a
 802b6ac:	2101      	movs	r1, #1
 802b6ae:	5499      	strb	r1, [r3, r2]
                    if( Nvm.MacGroup2.Version.Fields.Minor == 0 )
 802b6b0:	32f4      	adds	r2, #244	; 0xf4
 802b6b2:	5c9b      	ldrb	r3, [r3, r2]
 802b6b4:	2b00      	cmp	r3, #0
 802b6b6:	d102      	bne.n	802b6be <ProcessRadioRxDone+0x676>
                        Nvm.MacGroup1.LastRxMic = macMsgData.MIC;
 802b6b8:	4b15      	ldr	r3, [pc, #84]	; (802b710 <ProcessRadioRxDone+0x6c8>)
 802b6ba:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 802b6bc:	635a      	str	r2, [r3, #52]	; 0x34
                    MacCtx.McpsIndication.McpsIndication = MCPS_CONFIRMED;
 802b6be:	4a15      	ldr	r2, [pc, #84]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b6c0:	2384      	movs	r3, #132	; 0x84
 802b6c2:	00db      	lsls	r3, r3, #3
 802b6c4:	2101      	movs	r1, #1
 802b6c6:	54d1      	strb	r1, [r2, r3]
                    if( ( MacCtx.RxStatus.RxSlot != RX_SLOT_WIN_1 ) &&
 802b6c8:	2801      	cmp	r0, #1
 802b6ca:	d998      	bls.n	802b5fe <ProcessRadioRxDone+0x5b6>
                        MacCtx.McpsIndication.ResponseTimeout = Nvm.MacGroup2.MacParams.RxBCTimeout;
 802b6cc:	4a10      	ldr	r2, [pc, #64]	; (802b710 <ProcessRadioRxDone+0x6c8>)
 802b6ce:	2390      	movs	r3, #144	; 0x90
 802b6d0:	58d1      	ldr	r1, [r2, r3]
 802b6d2:	4b10      	ldr	r3, [pc, #64]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b6d4:	4a1b      	ldr	r2, [pc, #108]	; (802b744 <ProcessRadioRxDone+0x6fc>)
 802b6d6:	5099      	str	r1, [r3, r2]
                        MacCtx.ResponseTimeoutStartTime = RxDoneParams.LastRxDone;
 802b6d8:	4a1b      	ldr	r2, [pc, #108]	; (802b748 <ProcessRadioRxDone+0x700>)
 802b6da:	6811      	ldr	r1, [r2, #0]
 802b6dc:	2293      	movs	r2, #147	; 0x93
 802b6de:	00d2      	lsls	r2, r2, #3
 802b6e0:	5099      	str	r1, [r3, r2]
 802b6e2:	e78c      	b.n	802b5fe <ProcessRadioRxDone+0x5b6>
 802b6e4:	2b03      	cmp	r3, #3
 802b6e6:	d16b      	bne.n	802b7c0 <ProcessRadioRxDone+0x778>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 802b6e8:	aa14      	add	r2, sp, #80	; 0x50
 802b6ea:	2320      	movs	r3, #32
 802b6ec:	5cd0      	ldrb	r0, [r2, r3]
 802b6ee:	4b09      	ldr	r3, [pc, #36]	; (802b714 <ProcessRadioRxDone+0x6cc>)
 802b6f0:	4913      	ldr	r1, [pc, #76]	; (802b740 <ProcessRadioRxDone+0x6f8>)
 802b6f2:	5458      	strb	r0, [r3, r1]
                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;
 802b6f4:	3105      	adds	r1, #5
 802b6f6:	981d      	ldr	r0, [sp, #116]	; 0x74
 802b6f8:	5058      	str	r0, [r3, r1]
                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;
 802b6fa:	2128      	movs	r1, #40	; 0x28
 802b6fc:	5c51      	ldrb	r1, [r2, r1]
 802b6fe:	4a0b      	ldr	r2, [pc, #44]	; (802b72c <ProcessRadioRxDone+0x6e4>)
 802b700:	5499      	strb	r1, [r3, r2]
                    MacCtx.McpsIndication.RxData = true;
 802b702:	4a12      	ldr	r2, [pc, #72]	; (802b74c <ProcessRadioRxDone+0x704>)
 802b704:	2101      	movs	r1, #1
 802b706:	5499      	strb	r1, [r3, r2]
                    break;
 802b708:	e03d      	b.n	802b786 <ProcessRadioRxDone+0x73e>
 802b70a:	46c0      	nop			; (mov r8, r8)
 802b70c:	2000bd54 	.word	0x2000bd54
 802b710:	2000a000 	.word	0x2000a000
 802b714:	2000bb1c 	.word	0x2000bb1c
 802b718:	00000434 	.word	0x00000434
 802b71c:	00000421 	.word	0x00000421
 802b720:	0000046c 	.word	0x0000046c
 802b724:	0000048f 	.word	0x0000048f
 802b728:	00000422 	.word	0x00000422
 802b72c:	0000042c 	.word	0x0000042c
 802b730:	0000042e 	.word	0x0000042e
 802b734:	00000441 	.word	0x00000441
 802b738:	00000444 	.word	0x00000444
 802b73c:	00000425 	.word	0x00000425
 802b740:	00000423 	.word	0x00000423
 802b744:	0000043c 	.word	0x0000043c
 802b748:	2000c0c8 	.word	0x2000c0c8
 802b74c:	0000042d 	.word	0x0000042d
                    ProcessMacCommands( macMsgData.FHDR.FOpts, 0, macMsgData.FHDR.FCtrl.Bits.FOptsLen, snr, MacCtx.RxStatus.RxSlot );
 802b750:	ad14      	add	r5, sp, #80	; 0x50
 802b752:	7b2a      	ldrb	r2, [r5, #12]
 802b754:	0712      	lsls	r2, r2, #28
 802b756:	0f12      	lsrs	r2, r2, #28
 802b758:	4c30      	ldr	r4, [pc, #192]	; (802b81c <ProcessRadioRxDone+0x7d4>)
 802b75a:	4b31      	ldr	r3, [pc, #196]	; (802b820 <ProcessRadioRxDone+0x7d8>)
 802b75c:	5ce3      	ldrb	r3, [r4, r3]
 802b75e:	9300      	str	r3, [sp, #0]
 802b760:	003b      	movs	r3, r7
 802b762:	2100      	movs	r1, #0
 802b764:	a818      	add	r0, sp, #96	; 0x60
 802b766:	f7ff f953 	bl	802aa10 <ProcessMacCommands>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 802b76a:	2320      	movs	r3, #32
 802b76c:	5cea      	ldrb	r2, [r5, r3]
 802b76e:	4b2d      	ldr	r3, [pc, #180]	; (802b824 <ProcessRadioRxDone+0x7dc>)
 802b770:	54e2      	strb	r2, [r4, r3]
                    MacCtx.McpsIndication.Buffer = macMsgData.FRMPayload;
 802b772:	3305      	adds	r3, #5
 802b774:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 802b776:	50e2      	str	r2, [r4, r3]
                    MacCtx.McpsIndication.BufferSize = macMsgData.FRMPayloadSize;
 802b778:	2328      	movs	r3, #40	; 0x28
 802b77a:	5cea      	ldrb	r2, [r5, r3]
 802b77c:	4b2a      	ldr	r3, [pc, #168]	; (802b828 <ProcessRadioRxDone+0x7e0>)
 802b77e:	54e2      	strb	r2, [r4, r3]
                    MacCtx.McpsIndication.RxData = true;
 802b780:	4b2a      	ldr	r3, [pc, #168]	; (802b82c <ProcessRadioRxDone+0x7e4>)
 802b782:	2201      	movs	r2, #1
 802b784:	54e2      	strb	r2, [r4, r3]
            if( ( macMsgData.FPort == LORAMAC_CERT_FPORT ) && ( Nvm.MacGroup2.IsCertPortOn == false ) )
 802b786:	aa14      	add	r2, sp, #80	; 0x50
 802b788:	2320      	movs	r3, #32
 802b78a:	5cd3      	ldrb	r3, [r2, r3]
 802b78c:	2be0      	cmp	r3, #224	; 0xe0
 802b78e:	d01e      	beq.n	802b7ce <ProcessRadioRxDone+0x786>
            MacCtx.MacFlags.Bits.McpsInd = 1;
 802b790:	4922      	ldr	r1, [pc, #136]	; (802b81c <ProcessRadioRxDone+0x7d4>)
 802b792:	4a27      	ldr	r2, [pc, #156]	; (802b830 <ProcessRadioRxDone+0x7e8>)
 802b794:	5c8b      	ldrb	r3, [r1, r2]
 802b796:	2002      	movs	r0, #2
 802b798:	4303      	orrs	r3, r0
 802b79a:	548b      	strb	r3, [r1, r2]
            break;
 802b79c:	e534      	b.n	802b208 <ProcessRadioRxDone+0x1c0>
                    ProcessMacCommands( macMsgData.FRMPayload, 0, macMsgData.FRMPayloadSize, snr, MacCtx.RxStatus.RxSlot );
 802b79e:	ac14      	add	r4, sp, #80	; 0x50
 802b7a0:	2328      	movs	r3, #40	; 0x28
 802b7a2:	5ce2      	ldrb	r2, [r4, r3]
 802b7a4:	4d1d      	ldr	r5, [pc, #116]	; (802b81c <ProcessRadioRxDone+0x7d4>)
 802b7a6:	4b1e      	ldr	r3, [pc, #120]	; (802b820 <ProcessRadioRxDone+0x7d8>)
 802b7a8:	5ceb      	ldrb	r3, [r5, r3]
 802b7aa:	9300      	str	r3, [sp, #0]
 802b7ac:	003b      	movs	r3, r7
 802b7ae:	2100      	movs	r1, #0
 802b7b0:	981d      	ldr	r0, [sp, #116]	; 0x74
 802b7b2:	f7ff f92d 	bl	802aa10 <ProcessMacCommands>
                    MacCtx.McpsIndication.Port = macMsgData.FPort;
 802b7b6:	2320      	movs	r3, #32
 802b7b8:	5ce2      	ldrb	r2, [r4, r3]
 802b7ba:	4b1a      	ldr	r3, [pc, #104]	; (802b824 <ProcessRadioRxDone+0x7dc>)
 802b7bc:	54ea      	strb	r2, [r5, r3]
                    break;
 802b7be:	e7e2      	b.n	802b786 <ProcessRadioRxDone+0x73e>
                    MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802b7c0:	4a16      	ldr	r2, [pc, #88]	; (802b81c <ProcessRadioRxDone+0x7d4>)
 802b7c2:	4b1c      	ldr	r3, [pc, #112]	; (802b834 <ProcessRadioRxDone+0x7ec>)
 802b7c4:	2101      	movs	r1, #1
 802b7c6:	54d1      	strb	r1, [r2, r3]
                    PrepareRxDoneAbort( );
 802b7c8:	f7ff f89a 	bl	802a900 <PrepareRxDoneAbort>
                    break;
 802b7cc:	e7db      	b.n	802b786 <ProcessRadioRxDone+0x73e>
            if( ( macMsgData.FPort == LORAMAC_CERT_FPORT ) && ( Nvm.MacGroup2.IsCertPortOn == false ) )
 802b7ce:	491a      	ldr	r1, [pc, #104]	; (802b838 <ProcessRadioRxDone+0x7f0>)
 802b7d0:	2220      	movs	r2, #32
 802b7d2:	32ff      	adds	r2, #255	; 0xff
 802b7d4:	5c8a      	ldrb	r2, [r1, r2]
 802b7d6:	2a00      	cmp	r2, #0
 802b7d8:	d1da      	bne.n	802b790 <ProcessRadioRxDone+0x748>
                MacCtx.McpsIndication.Port = macMsgData.FPort;
 802b7da:	4a10      	ldr	r2, [pc, #64]	; (802b81c <ProcessRadioRxDone+0x7d4>)
 802b7dc:	4911      	ldr	r1, [pc, #68]	; (802b824 <ProcessRadioRxDone+0x7dc>)
 802b7de:	5453      	strb	r3, [r2, r1]
                MacCtx.McpsIndication.Buffer = NULL;
 802b7e0:	2300      	movs	r3, #0
 802b7e2:	3105      	adds	r1, #5
 802b7e4:	5053      	str	r3, [r2, r1]
                MacCtx.McpsIndication.BufferSize = 0;
 802b7e6:	4910      	ldr	r1, [pc, #64]	; (802b828 <ProcessRadioRxDone+0x7e0>)
 802b7e8:	5453      	strb	r3, [r2, r1]
                MacCtx.McpsIndication.RxData = false;
 802b7ea:	4910      	ldr	r1, [pc, #64]	; (802b82c <ProcessRadioRxDone+0x7e4>)
 802b7ec:	5453      	strb	r3, [r2, r1]
 802b7ee:	e7cf      	b.n	802b790 <ProcessRadioRxDone+0x748>
            MacCtx.McpsIndication.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802b7f0:	4a0a      	ldr	r2, [pc, #40]	; (802b81c <ProcessRadioRxDone+0x7d4>)
 802b7f2:	4b10      	ldr	r3, [pc, #64]	; (802b834 <ProcessRadioRxDone+0x7ec>)
 802b7f4:	2101      	movs	r1, #1
 802b7f6:	54d1      	strb	r1, [r2, r3]
            PrepareRxDoneAbort( );
 802b7f8:	f7ff f882 	bl	802a900 <PrepareRxDoneAbort>
            break;
 802b7fc:	e504      	b.n	802b208 <ProcessRadioRxDone+0x1c0>
        if( MacCtx.NodeAckRequested == true )
 802b7fe:	4b0f      	ldr	r3, [pc, #60]	; (802b83c <ProcessRadioRxDone+0x7f4>)
 802b800:	5cd3      	ldrb	r3, [r2, r3]
 802b802:	2b00      	cmp	r3, #0
 802b804:	d100      	bne.n	802b808 <ProcessRadioRxDone+0x7c0>
 802b806:	e505      	b.n	802b214 <ProcessRadioRxDone+0x1cc>
            if( MacCtx.McpsConfirm.AckReceived == true )
 802b808:	4b0d      	ldr	r3, [pc, #52]	; (802b840 <ProcessRadioRxDone+0x7f8>)
 802b80a:	5cd3      	ldrb	r3, [r2, r3]
 802b80c:	2b00      	cmp	r3, #0
 802b80e:	d100      	bne.n	802b812 <ProcessRadioRxDone+0x7ca>
 802b810:	e500      	b.n	802b214 <ProcessRadioRxDone+0x1cc>
                OnRetransmitTimeoutTimerEvent( NULL );
 802b812:	2000      	movs	r0, #0
 802b814:	f7ff f856 	bl	802a8c4 <OnRetransmitTimeoutTimerEvent>
 802b818:	e4fc      	b.n	802b214 <ProcessRadioRxDone+0x1cc>
 802b81a:	46c0      	nop			; (mov r8, r8)
 802b81c:	2000bb1c 	.word	0x2000bb1c
 802b820:	0000048f 	.word	0x0000048f
 802b824:	00000423 	.word	0x00000423
 802b828:	0000042c 	.word	0x0000042c
 802b82c:	0000042d 	.word	0x0000042d
 802b830:	00000491 	.word	0x00000491
 802b834:	00000421 	.word	0x00000421
 802b838:	2000a000 	.word	0x2000a000
 802b83c:	0000041a 	.word	0x0000041a
 802b840:	00000444 	.word	0x00000444

0802b844 <ProcessRadioTxTimeout>:
{
 802b844:	b510      	push	{r4, lr}
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 802b846:	4a10      	ldr	r2, [pc, #64]	; (802b888 <ProcessRadioTxTimeout+0x44>)
 802b848:	238c      	movs	r3, #140	; 0x8c
 802b84a:	005b      	lsls	r3, r3, #1
 802b84c:	5cd3      	ldrb	r3, [r2, r3]
 802b84e:	2b02      	cmp	r3, #2
 802b850:	d002      	beq.n	802b858 <ProcessRadioTxTimeout+0x14>
        Radio.Sleep( );
 802b852:	4b0e      	ldr	r3, [pc, #56]	; (802b88c <ProcessRadioTxTimeout+0x48>)
 802b854:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802b856:	4798      	blx	r3
    UpdateRxSlotIdleState( );
 802b858:	f7fe fdf6 	bl	802a448 <UpdateRxSlotIdleState>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT;
 802b85c:	4c0c      	ldr	r4, [pc, #48]	; (802b890 <ProcessRadioTxTimeout+0x4c>)
 802b85e:	4b0d      	ldr	r3, [pc, #52]	; (802b894 <ProcessRadioTxTimeout+0x50>)
 802b860:	2202      	movs	r2, #2
 802b862:	54e2      	strb	r2, [r4, r3]
    LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_TIMEOUT );
 802b864:	2002      	movs	r0, #2
 802b866:	f002 fdf1 	bl	802e44c <LoRaMacConfirmQueueSetStatusCmn>
    if( MacCtx.NodeAckRequested == true )
 802b86a:	4b0b      	ldr	r3, [pc, #44]	; (802b898 <ProcessRadioTxTimeout+0x54>)
 802b86c:	5ce3      	ldrb	r3, [r4, r3]
 802b86e:	2b00      	cmp	r3, #0
 802b870:	d003      	beq.n	802b87a <ProcessRadioTxTimeout+0x36>
        MacCtx.RetransmitTimeoutRetry = true;
 802b872:	4a07      	ldr	r2, [pc, #28]	; (802b890 <ProcessRadioTxTimeout+0x4c>)
 802b874:	4b09      	ldr	r3, [pc, #36]	; (802b89c <ProcessRadioTxTimeout+0x58>)
 802b876:	2101      	movs	r1, #1
 802b878:	54d1      	strb	r1, [r2, r3]
    MacCtx.MacFlags.Bits.MacDone = 1;
 802b87a:	4905      	ldr	r1, [pc, #20]	; (802b890 <ProcessRadioTxTimeout+0x4c>)
 802b87c:	4a08      	ldr	r2, [pc, #32]	; (802b8a0 <ProcessRadioTxTimeout+0x5c>)
 802b87e:	5c8b      	ldrb	r3, [r1, r2]
 802b880:	2010      	movs	r0, #16
 802b882:	4303      	orrs	r3, r0
 802b884:	548b      	strb	r3, [r1, r2]
}
 802b886:	bd10      	pop	{r4, pc}
 802b888:	2000a000 	.word	0x2000a000
 802b88c:	08035d8c 	.word	0x08035d8c
 802b890:	2000bb1c 	.word	0x2000bb1c
 802b894:	00000441 	.word	0x00000441
 802b898:	0000041a 	.word	0x0000041a
 802b89c:	00000419 	.word	0x00000419
 802b8a0:	00000491 	.word	0x00000491

0802b8a4 <CheckForClassBCollision>:
{
 802b8a4:	b510      	push	{r4, lr}
    if( LoRaMacClassBIsBeaconExpected( ) == true )
 802b8a6:	f002 fb5d 	bl	802df64 <LoRaMacClassBIsBeaconExpected>
 802b8aa:	2800      	cmp	r0, #0
 802b8ac:	d111      	bne.n	802b8d2 <CheckForClassBCollision+0x2e>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 802b8ae:	4a0b      	ldr	r2, [pc, #44]	; (802b8dc <CheckForClassBCollision+0x38>)
 802b8b0:	238c      	movs	r3, #140	; 0x8c
 802b8b2:	005b      	lsls	r3, r3, #1
 802b8b4:	5cd3      	ldrb	r3, [r2, r3]
 802b8b6:	2b01      	cmp	r3, #1
 802b8b8:	d001      	beq.n	802b8be <CheckForClassBCollision+0x1a>
    return LORAMAC_STATUS_OK;
 802b8ba:	2000      	movs	r0, #0
}
 802b8bc:	bd10      	pop	{r4, pc}
        if( LoRaMacClassBIsPingExpected( ) == true )
 802b8be:	f002 fb53 	bl	802df68 <LoRaMacClassBIsPingExpected>
 802b8c2:	2800      	cmp	r0, #0
 802b8c4:	d107      	bne.n	802b8d6 <CheckForClassBCollision+0x32>
        else if( LoRaMacClassBIsMulticastExpected( ) == true )
 802b8c6:	f002 fb51 	bl	802df6c <LoRaMacClassBIsMulticastExpected>
 802b8ca:	2800      	cmp	r0, #0
 802b8cc:	d0f6      	beq.n	802b8bc <CheckForClassBCollision+0x18>
            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;
 802b8ce:	200f      	movs	r0, #15
 802b8d0:	e7f4      	b.n	802b8bc <CheckForClassBCollision+0x18>
        return LORAMAC_STATUS_BUSY_BEACON_RESERVED_TIME;
 802b8d2:	200e      	movs	r0, #14
 802b8d4:	e7f2      	b.n	802b8bc <CheckForClassBCollision+0x18>
            return LORAMAC_STATUS_BUSY_PING_SLOT_WINDOW_TIME;
 802b8d6:	200f      	movs	r0, #15
 802b8d8:	e7f0      	b.n	802b8bc <CheckForClassBCollision+0x18>
 802b8da:	46c0      	nop			; (mov r8, r8)
 802b8dc:	2000a000 	.word	0x2000a000

0802b8e0 <HandleRadioRxErrorTimeout>:
{
 802b8e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802b8e2:	0006      	movs	r6, r0
 802b8e4:	000d      	movs	r5, r1
    if( Nvm.MacGroup2.DeviceClass != CLASS_C )
 802b8e6:	4a36      	ldr	r2, [pc, #216]	; (802b9c0 <HandleRadioRxErrorTimeout+0xe0>)
 802b8e8:	238c      	movs	r3, #140	; 0x8c
 802b8ea:	005b      	lsls	r3, r3, #1
 802b8ec:	5cd3      	ldrb	r3, [r2, r3]
 802b8ee:	2b02      	cmp	r3, #2
 802b8f0:	d002      	beq.n	802b8f8 <HandleRadioRxErrorTimeout+0x18>
        Radio.Sleep( );
 802b8f2:	4b34      	ldr	r3, [pc, #208]	; (802b9c4 <HandleRadioRxErrorTimeout+0xe4>)
 802b8f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802b8f6:	4798      	blx	r3
    if( LoRaMacClassBIsBeaconExpected( ) == true )
 802b8f8:	f002 fb34 	bl	802df64 <LoRaMacClassBIsBeaconExpected>
 802b8fc:	1e04      	subs	r4, r0, #0
 802b8fe:	d12d      	bne.n	802b95c <HandleRadioRxErrorTimeout+0x7c>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 802b900:	4a2f      	ldr	r2, [pc, #188]	; (802b9c0 <HandleRadioRxErrorTimeout+0xe0>)
 802b902:	238c      	movs	r3, #140	; 0x8c
 802b904:	005b      	lsls	r3, r3, #1
 802b906:	5cd3      	ldrb	r3, [r2, r3]
 802b908:	2b01      	cmp	r3, #1
 802b90a:	d02e      	beq.n	802b96a <HandleRadioRxErrorTimeout+0x8a>
    if( classBRx == false )
 802b90c:	2c00      	cmp	r4, #0
 802b90e:	d153      	bne.n	802b9b8 <HandleRadioRxErrorTimeout+0xd8>
        if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 802b910:	4a2d      	ldr	r2, [pc, #180]	; (802b9c8 <HandleRadioRxErrorTimeout+0xe8>)
 802b912:	2392      	movs	r3, #146	; 0x92
 802b914:	00db      	lsls	r3, r3, #3
 802b916:	5cd3      	ldrb	r3, [r2, r3]
 802b918:	2b00      	cmp	r3, #0
 802b91a:	d13d      	bne.n	802b998 <HandleRadioRxErrorTimeout+0xb8>
            if( MacCtx.NodeAckRequested == true )
 802b91c:	4b2b      	ldr	r3, [pc, #172]	; (802b9cc <HandleRadioRxErrorTimeout+0xec>)
 802b91e:	5cd3      	ldrb	r3, [r2, r3]
 802b920:	2b00      	cmp	r3, #0
 802b922:	d001      	beq.n	802b928 <HandleRadioRxErrorTimeout+0x48>
                MacCtx.McpsConfirm.Status = rx1EventInfoStatus;
 802b924:	4b2a      	ldr	r3, [pc, #168]	; (802b9d0 <HandleRadioRxErrorTimeout+0xf0>)
 802b926:	54d6      	strb	r6, [r2, r3]
            LoRaMacConfirmQueueSetStatusCmn( rx1EventInfoStatus );
 802b928:	0030      	movs	r0, r6
 802b92a:	f002 fd8f 	bl	802e44c <LoRaMacConfirmQueueSetStatusCmn>
            if( TimerGetElapsedTime( Nvm.MacGroup1.LastTxDoneTime ) >= MacCtx.RxWindow2Delay )
 802b92e:	4b24      	ldr	r3, [pc, #144]	; (802b9c0 <HandleRadioRxErrorTimeout+0xe0>)
 802b930:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 802b932:	f008 fdf9 	bl	8034528 <UTIL_TIMER_GetElapsedTime>
 802b936:	4a24      	ldr	r2, [pc, #144]	; (802b9c8 <HandleRadioRxErrorTimeout+0xe8>)
 802b938:	23ed      	movs	r3, #237	; 0xed
 802b93a:	009b      	lsls	r3, r3, #2
 802b93c:	58d3      	ldr	r3, [r2, r3]
 802b93e:	4298      	cmp	r0, r3
 802b940:	d33a      	bcc.n	802b9b8 <HandleRadioRxErrorTimeout+0xd8>
                TimerStop( &MacCtx.RxWindowTimer2 );
 802b942:	4c24      	ldr	r4, [pc, #144]	; (802b9d4 <HandleRadioRxErrorTimeout+0xf4>)
 802b944:	0020      	movs	r0, r4
 802b946:	f008 fe25 	bl	8034594 <UTIL_TIMER_Stop>
                MacCtx.MacFlags.Bits.MacDone = 1;
 802b94a:	4b23      	ldr	r3, [pc, #140]	; (802b9d8 <HandleRadioRxErrorTimeout+0xf8>)
 802b94c:	469c      	mov	ip, r3
 802b94e:	4464      	add	r4, ip
 802b950:	4a22      	ldr	r2, [pc, #136]	; (802b9dc <HandleRadioRxErrorTimeout+0xfc>)
 802b952:	5ca3      	ldrb	r3, [r4, r2]
 802b954:	2110      	movs	r1, #16
 802b956:	430b      	orrs	r3, r1
 802b958:	54a3      	strb	r3, [r4, r2]
 802b95a:	e02d      	b.n	802b9b8 <HandleRadioRxErrorTimeout+0xd8>
        LoRaMacClassBSetBeaconState( BEACON_STATE_TIMEOUT );
 802b95c:	2002      	movs	r0, #2
 802b95e:	f002 faf7 	bl	802df50 <LoRaMacClassBSetBeaconState>
        LoRaMacClassBBeaconTimerEvent( NULL );
 802b962:	2000      	movs	r0, #0
 802b964:	f002 faf9 	bl	802df5a <LoRaMacClassBBeaconTimerEvent>
        classBRx = true;
 802b968:	e7ca      	b.n	802b900 <HandleRadioRxErrorTimeout+0x20>
        if( LoRaMacClassBIsPingExpected( ) == true )
 802b96a:	f002 fafd 	bl	802df68 <LoRaMacClassBIsPingExpected>
 802b96e:	1e07      	subs	r7, r0, #0
 802b970:	d10a      	bne.n	802b988 <HandleRadioRxErrorTimeout+0xa8>
        if( LoRaMacClassBIsMulticastExpected( ) == true )
 802b972:	f002 fafb 	bl	802df6c <LoRaMacClassBIsMulticastExpected>
 802b976:	2800      	cmp	r0, #0
 802b978:	d0c8      	beq.n	802b90c <HandleRadioRxErrorTimeout+0x2c>
            LoRaMacClassBSetMulticastSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 802b97a:	2000      	movs	r0, #0
 802b97c:	f002 faea 	bl	802df54 <LoRaMacClassBSetMulticastSlotState>
            LoRaMacClassBMulticastSlotTimerEvent( NULL );
 802b980:	2000      	movs	r0, #0
 802b982:	f002 faec 	bl	802df5e <LoRaMacClassBMulticastSlotTimerEvent>
    if( classBRx == false )
 802b986:	e017      	b.n	802b9b8 <HandleRadioRxErrorTimeout+0xd8>
            LoRaMacClassBSetPingSlotState( PINGSLOT_STATE_CALC_PING_OFFSET );
 802b988:	2000      	movs	r0, #0
 802b98a:	f002 fae2 	bl	802df52 <LoRaMacClassBSetPingSlotState>
            LoRaMacClassBPingSlotTimerEvent( NULL );
 802b98e:	2000      	movs	r0, #0
 802b990:	f002 fae4 	bl	802df5c <LoRaMacClassBPingSlotTimerEvent>
            classBRx = true;
 802b994:	003c      	movs	r4, r7
 802b996:	e7ec      	b.n	802b972 <HandleRadioRxErrorTimeout+0x92>
            if( MacCtx.NodeAckRequested == true )
 802b998:	4a0b      	ldr	r2, [pc, #44]	; (802b9c8 <HandleRadioRxErrorTimeout+0xe8>)
 802b99a:	4b0c      	ldr	r3, [pc, #48]	; (802b9cc <HandleRadioRxErrorTimeout+0xec>)
 802b99c:	5cd3      	ldrb	r3, [r2, r3]
 802b99e:	2b00      	cmp	r3, #0
 802b9a0:	d001      	beq.n	802b9a6 <HandleRadioRxErrorTimeout+0xc6>
                MacCtx.McpsConfirm.Status = rx2EventInfoStatus;
 802b9a2:	4b0b      	ldr	r3, [pc, #44]	; (802b9d0 <HandleRadioRxErrorTimeout+0xf0>)
 802b9a4:	54d5      	strb	r5, [r2, r3]
            LoRaMacConfirmQueueSetStatusCmn( rx2EventInfoStatus );
 802b9a6:	0028      	movs	r0, r5
 802b9a8:	f002 fd50 	bl	802e44c <LoRaMacConfirmQueueSetStatusCmn>
            MacCtx.MacFlags.Bits.MacDone = 1;
 802b9ac:	4906      	ldr	r1, [pc, #24]	; (802b9c8 <HandleRadioRxErrorTimeout+0xe8>)
 802b9ae:	4a0b      	ldr	r2, [pc, #44]	; (802b9dc <HandleRadioRxErrorTimeout+0xfc>)
 802b9b0:	5c8b      	ldrb	r3, [r1, r2]
 802b9b2:	2010      	movs	r0, #16
 802b9b4:	4303      	orrs	r3, r0
 802b9b6:	548b      	strb	r3, [r1, r2]
    UpdateRxSlotIdleState( );
 802b9b8:	f7fe fd46 	bl	802a448 <UpdateRxSlotIdleState>
}
 802b9bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802b9be:	46c0      	nop			; (mov r8, r8)
 802b9c0:	2000a000 	.word	0x2000a000
 802b9c4:	08035d8c 	.word	0x08035d8c
 802b9c8:	2000bb1c 	.word	0x2000bb1c
 802b9cc:	0000041a 	.word	0x0000041a
 802b9d0:	00000441 	.word	0x00000441
 802b9d4:	2000beb4 	.word	0x2000beb4
 802b9d8:	fffffc68 	.word	0xfffffc68
 802b9dc:	00000491 	.word	0x00000491

0802b9e0 <ProcessRadioRxError>:
{
 802b9e0:	b510      	push	{r4, lr}
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_ERROR, LORAMAC_EVENT_INFO_STATUS_RX2_ERROR );
 802b9e2:	2106      	movs	r1, #6
 802b9e4:	2005      	movs	r0, #5
 802b9e6:	f7ff ff7b 	bl	802b8e0 <HandleRadioRxErrorTimeout>
}
 802b9ea:	bd10      	pop	{r4, pc}

0802b9ec <ProcessRadioRxTimeout>:
{
 802b9ec:	b510      	push	{r4, lr}
    HandleRadioRxErrorTimeout( LORAMAC_EVENT_INFO_STATUS_RX1_TIMEOUT, LORAMAC_EVENT_INFO_STATUS_RX2_TIMEOUT );
 802b9ee:	2104      	movs	r1, #4
 802b9f0:	2003      	movs	r0, #3
 802b9f2:	f7ff ff75 	bl	802b8e0 <HandleRadioRxErrorTimeout>
}
 802b9f6:	bd10      	pop	{r4, pc}

0802b9f8 <LoRaMacHandleIrqEvents>:
{
 802b9f8:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 802b9fa:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 802b9fe:	b672      	cpsid	i
    events = LoRaMacRadioEvents;
 802ba00:	4a11      	ldr	r2, [pc, #68]	; (802ba48 <LoRaMacHandleIrqEvents+0x50>)
 802ba02:	6813      	ldr	r3, [r2, #0]
    LoRaMacRadioEvents.Value = 0;
 802ba04:	2000      	movs	r0, #0
 802ba06:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 802ba08:	f381 8810 	msr	PRIMASK, r1
    if( events.Value != 0 )
 802ba0c:	2b00      	cmp	r3, #0
 802ba0e:	d00a      	beq.n	802ba26 <LoRaMacHandleIrqEvents+0x2e>
        if( events.Events.TxDone == 1 )
 802ba10:	b2dc      	uxtb	r4, r3
 802ba12:	069b      	lsls	r3, r3, #26
 802ba14:	d408      	bmi.n	802ba28 <LoRaMacHandleIrqEvents+0x30>
        if( events.Events.RxDone == 1 )
 802ba16:	06e3      	lsls	r3, r4, #27
 802ba18:	d409      	bmi.n	802ba2e <LoRaMacHandleIrqEvents+0x36>
        if( events.Events.TxTimeout == 1 )
 802ba1a:	0723      	lsls	r3, r4, #28
 802ba1c:	d40a      	bmi.n	802ba34 <LoRaMacHandleIrqEvents+0x3c>
        if( events.Events.RxError == 1 )
 802ba1e:	0763      	lsls	r3, r4, #29
 802ba20:	d40b      	bmi.n	802ba3a <LoRaMacHandleIrqEvents+0x42>
        if( events.Events.RxTimeout == 1 )
 802ba22:	07a3      	lsls	r3, r4, #30
 802ba24:	d40c      	bmi.n	802ba40 <LoRaMacHandleIrqEvents+0x48>
}
 802ba26:	bd10      	pop	{r4, pc}
            ProcessRadioTxDone( );
 802ba28:	f7fe febc 	bl	802a7a4 <ProcessRadioTxDone>
 802ba2c:	e7f3      	b.n	802ba16 <LoRaMacHandleIrqEvents+0x1e>
            ProcessRadioRxDone( );
 802ba2e:	f7ff fb0b 	bl	802b048 <ProcessRadioRxDone>
 802ba32:	e7f2      	b.n	802ba1a <LoRaMacHandleIrqEvents+0x22>
            ProcessRadioTxTimeout( );
 802ba34:	f7ff ff06 	bl	802b844 <ProcessRadioTxTimeout>
 802ba38:	e7f1      	b.n	802ba1e <LoRaMacHandleIrqEvents+0x26>
            ProcessRadioRxError( );
 802ba3a:	f7ff ffd1 	bl	802b9e0 <ProcessRadioRxError>
 802ba3e:	e7f0      	b.n	802ba22 <LoRaMacHandleIrqEvents+0x2a>
            ProcessRadioRxTimeout( );
 802ba40:	f7ff ffd4 	bl	802b9ec <ProcessRadioRxTimeout>
}
 802ba44:	e7ef      	b.n	802ba26 <LoRaMacHandleIrqEvents+0x2e>
 802ba46:	46c0      	nop			; (mov r8, r8)
 802ba48:	2000bb18 	.word	0x2000bb18

0802ba4c <LoRaMacHandleResponseTimeout>:
{
 802ba4c:	b510      	push	{r4, lr}
 802ba4e:	0004      	movs	r4, r0
 802ba50:	1e08      	subs	r0, r1, #0
    if( startTimeInMs != 0 )
 802ba52:	d101      	bne.n	802ba58 <LoRaMacHandleResponseTimeout+0xc>
    return false;
 802ba54:	2000      	movs	r0, #0
}
 802ba56:	bd10      	pop	{r4, pc}
        TimerTime_t elapsedTime = TimerGetElapsedTime( startTimeInMs );
 802ba58:	f008 fd66 	bl	8034528 <UTIL_TIMER_GetElapsedTime>
        if( elapsedTime > timeoutInMs )
 802ba5c:	42a0      	cmp	r0, r4
 802ba5e:	d801      	bhi.n	802ba64 <LoRaMacHandleResponseTimeout+0x18>
    return false;
 802ba60:	2000      	movs	r0, #0
 802ba62:	e7f8      	b.n	802ba56 <LoRaMacHandleResponseTimeout+0xa>
            Nvm.MacGroup1.SrvAckRequested = false;
 802ba64:	4a02      	ldr	r2, [pc, #8]	; (802ba70 <LoRaMacHandleResponseTimeout+0x24>)
 802ba66:	233a      	movs	r3, #58	; 0x3a
 802ba68:	2100      	movs	r1, #0
 802ba6a:	54d1      	strb	r1, [r2, r3]
            return true;
 802ba6c:	2001      	movs	r0, #1
 802ba6e:	e7f2      	b.n	802ba56 <LoRaMacHandleResponseTimeout+0xa>
 802ba70:	2000a000 	.word	0x2000a000

0802ba74 <LoRaMacHandleMlmeRequest>:
{
 802ba74:	b510      	push	{r4, lr}
    if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 802ba76:	4a15      	ldr	r2, [pc, #84]	; (802bacc <LoRaMacHandleMlmeRequest+0x58>)
 802ba78:	4b15      	ldr	r3, [pc, #84]	; (802bad0 <LoRaMacHandleMlmeRequest+0x5c>)
 802ba7a:	5cd3      	ldrb	r3, [r2, r3]
 802ba7c:	075b      	lsls	r3, r3, #29
 802ba7e:	d400      	bmi.n	802ba82 <LoRaMacHandleMlmeRequest+0xe>
}
 802ba80:	bd10      	pop	{r4, pc}
        if( LoRaMacConfirmQueueIsCmdActive( MLME_JOIN ) == true )
 802ba82:	2001      	movs	r0, #1
 802ba84:	f002 fd00 	bl	802e488 <LoRaMacConfirmQueueIsCmdActive>
 802ba88:	2800      	cmp	r0, #0
 802ba8a:	d011      	beq.n	802bab0 <LoRaMacHandleMlmeRequest+0x3c>
            if( LoRaMacConfirmQueueGetStatus( MLME_JOIN ) == LORAMAC_EVENT_INFO_STATUS_OK )
 802ba8c:	2001      	movs	r0, #1
 802ba8e:	f002 fcc3 	bl	802e418 <LoRaMacConfirmQueueGetStatus>
 802ba92:	2800      	cmp	r0, #0
 802ba94:	d104      	bne.n	802baa0 <LoRaMacHandleMlmeRequest+0x2c>
                MacCtx.ChannelsNbTransCounter = 0;
 802ba96:	4a0d      	ldr	r2, [pc, #52]	; (802bacc <LoRaMacHandleMlmeRequest+0x58>)
 802ba98:	2383      	movs	r3, #131	; 0x83
 802ba9a:	00db      	lsls	r3, r3, #3
 802ba9c:	2100      	movs	r1, #0
 802ba9e:	54d1      	strb	r1, [r2, r3]
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 802baa0:	490a      	ldr	r1, [pc, #40]	; (802bacc <LoRaMacHandleMlmeRequest+0x58>)
 802baa2:	22d0      	movs	r2, #208	; 0xd0
 802baa4:	0092      	lsls	r2, r2, #2
 802baa6:	2302      	movs	r3, #2
 802baa8:	5888      	ldr	r0, [r1, r2]
 802baaa:	4398      	bics	r0, r3
 802baac:	5088      	str	r0, [r1, r2]
 802baae:	e7e7      	b.n	802ba80 <LoRaMacHandleMlmeRequest+0xc>
        else if( LoRaMacConfirmQueueIsCmdActive( MLME_TXCW ) == true )
 802bab0:	2006      	movs	r0, #6
 802bab2:	f002 fce9 	bl	802e488 <LoRaMacConfirmQueueIsCmdActive>
 802bab6:	2800      	cmp	r0, #0
 802bab8:	d0e2      	beq.n	802ba80 <LoRaMacHandleMlmeRequest+0xc>
            MacCtx.MacState &= ~LORAMAC_TX_RUNNING;
 802baba:	4904      	ldr	r1, [pc, #16]	; (802bacc <LoRaMacHandleMlmeRequest+0x58>)
 802babc:	22d0      	movs	r2, #208	; 0xd0
 802babe:	0092      	lsls	r2, r2, #2
 802bac0:	2302      	movs	r3, #2
 802bac2:	5888      	ldr	r0, [r1, r2]
 802bac4:	4398      	bics	r0, r3
 802bac6:	5088      	str	r0, [r1, r2]
}
 802bac8:	e7da      	b.n	802ba80 <LoRaMacHandleMlmeRequest+0xc>
 802baca:	46c0      	nop			; (mov r8, r8)
 802bacc:	2000bb1c 	.word	0x2000bb1c
 802bad0:	00000491 	.word	0x00000491

0802bad4 <SerializeTxFrame>:
{
 802bad4:	b510      	push	{r4, lr}
    switch( MacCtx.TxMsg.Type )
 802bad6:	4a12      	ldr	r2, [pc, #72]	; (802bb20 <SerializeTxFrame+0x4c>)
 802bad8:	2382      	movs	r3, #130	; 0x82
 802bada:	005b      	lsls	r3, r3, #1
 802badc:	5cd3      	ldrb	r3, [r2, r3]
 802bade:	2b00      	cmp	r3, #0
 802bae0:	d003      	beq.n	802baea <SerializeTxFrame+0x16>
 802bae2:	2b04      	cmp	r3, #4
 802bae4:	d00c      	beq.n	802bb00 <SerializeTxFrame+0x2c>
 802bae6:	2003      	movs	r0, #3
}
 802bae8:	bd10      	pop	{r4, pc}
            serializeStatus = LoRaMacSerializerJoinRequest( &MacCtx.TxMsg.Message.JoinReq );
 802baea:	480e      	ldr	r0, [pc, #56]	; (802bb24 <SerializeTxFrame+0x50>)
 802baec:	f003 f9a9 	bl	802ee42 <LoRaMacSerializerJoinRequest>
            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )
 802baf0:	2800      	cmp	r0, #0
 802baf2:	d110      	bne.n	802bb16 <SerializeTxFrame+0x42>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.JoinReq.BufSize;
 802baf4:	4b0a      	ldr	r3, [pc, #40]	; (802bb20 <SerializeTxFrame+0x4c>)
 802baf6:	2286      	movs	r2, #134	; 0x86
 802baf8:	0052      	lsls	r2, r2, #1
 802bafa:	5c9a      	ldrb	r2, [r3, r2]
 802bafc:	801a      	strh	r2, [r3, #0]
            break;
 802bafe:	e7f3      	b.n	802bae8 <SerializeTxFrame+0x14>
            serializeStatus = LoRaMacSerializerData( &MacCtx.TxMsg.Message.Data );
 802bb00:	4808      	ldr	r0, [pc, #32]	; (802bb24 <SerializeTxFrame+0x50>)
 802bb02:	f003 f9d4 	bl	802eeae <LoRaMacSerializerData>
            if( LORAMAC_SERIALIZER_SUCCESS != serializeStatus )
 802bb06:	2800      	cmp	r0, #0
 802bb08:	d107      	bne.n	802bb1a <SerializeTxFrame+0x46>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;
 802bb0a:	4b05      	ldr	r3, [pc, #20]	; (802bb20 <SerializeTxFrame+0x4c>)
 802bb0c:	2286      	movs	r2, #134	; 0x86
 802bb0e:	0052      	lsls	r2, r2, #1
 802bb10:	5c9a      	ldrb	r2, [r3, r2]
 802bb12:	801a      	strh	r2, [r3, #0]
            break;
 802bb14:	e7e8      	b.n	802bae8 <SerializeTxFrame+0x14>
                return LORAMAC_STATUS_CRYPTO_ERROR;
 802bb16:	2011      	movs	r0, #17
 802bb18:	e7e6      	b.n	802bae8 <SerializeTxFrame+0x14>
                return LORAMAC_STATUS_CRYPTO_ERROR;
 802bb1a:	2011      	movs	r0, #17
 802bb1c:	e7e4      	b.n	802bae8 <SerializeTxFrame+0x14>
 802bb1e:	46c0      	nop			; (mov r8, r8)
 802bb20:	2000bb1c 	.word	0x2000bb1c
 802bb24:	2000bc24 	.word	0x2000bc24

0802bb28 <ComputeRxWindowParameters>:
{
 802bb28:	b5f0      	push	{r4, r5, r6, r7, lr}
 802bb2a:	46c6      	mov	lr, r8
 802bb2c:	b500      	push	{lr}
 802bb2e:	b082      	sub	sp, #8
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 802bb30:	4c23      	ldr	r4, [pc, #140]	; (802bbc0 <ComputeRxWindowParameters+0x98>)
 802bb32:	2648      	movs	r6, #72	; 0x48
 802bb34:	5da3      	ldrb	r3, [r4, r6]
 802bb36:	4698      	mov	r8, r3
                                     RegionApplyDrOffset( Nvm.MacGroup2.Region,
 802bb38:	2369      	movs	r3, #105	; 0x69
 802bb3a:	56e3      	ldrsb	r3, [r4, r3]
 802bb3c:	2239      	movs	r2, #57	; 0x39
 802bb3e:	56a2      	ldrsb	r2, [r4, r2]
 802bb40:	217d      	movs	r1, #125	; 0x7d
 802bb42:	5c61      	ldrb	r1, [r4, r1]
 802bb44:	4640      	mov	r0, r8
 802bb46:	f003 fb5e 	bl	802f206 <RegionApplyDrOffset>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 802bb4a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 802bb4c:	2750      	movs	r7, #80	; 0x50
 802bb4e:	5de2      	ldrb	r2, [r4, r7]
 802bb50:	b241      	sxtb	r1, r0
 802bb52:	4d1c      	ldr	r5, [pc, #112]	; (802bbc4 <ComputeRxWindowParameters+0x9c>)
 802bb54:	9500      	str	r5, [sp, #0]
 802bb56:	4640      	mov	r0, r8
 802bb58:	f003 faaa 	bl	802f0b0 <RegionComputeRxWindowParameters>
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 802bb5c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 802bb5e:	5de2      	ldrb	r2, [r4, r7]
 802bb60:	2170      	movs	r1, #112	; 0x70
 802bb62:	5661      	ldrsb	r1, [r4, r1]
 802bb64:	5da0      	ldrb	r0, [r4, r6]
 802bb66:	002e      	movs	r6, r5
 802bb68:	3618      	adds	r6, #24
 802bb6a:	9600      	str	r6, [sp, #0]
 802bb6c:	f003 faa0 	bl	802f0b0 <RegionComputeRxWindowParameters>
    MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.ReceiveDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 802bb70:	4b15      	ldr	r3, [pc, #84]	; (802bbc8 <ComputeRxWindowParameters+0xa0>)
 802bb72:	469c      	mov	ip, r3
 802bb74:	4465      	add	r5, ip
 802bb76:	22f1      	movs	r2, #241	; 0xf1
 802bb78:	0092      	lsls	r2, r2, #2
 802bb7a:	58a8      	ldr	r0, [r5, r2]
 802bb7c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802bb7e:	181a      	adds	r2, r3, r0
 802bb80:	21ec      	movs	r1, #236	; 0xec
 802bb82:	0089      	lsls	r1, r1, #2
 802bb84:	506a      	str	r2, [r5, r1]
    MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.ReceiveDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 802bb86:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 802bb88:	312c      	adds	r1, #44	; 0x2c
 802bb8a:	5869      	ldr	r1, [r5, r1]
 802bb8c:	1852      	adds	r2, r2, r1
 802bb8e:	24ed      	movs	r4, #237	; 0xed
 802bb90:	00a4      	lsls	r4, r4, #2
 802bb92:	512a      	str	r2, [r5, r4]
    if( MacCtx.TxMsg.Type != LORAMAC_MSG_TYPE_DATA )
 802bb94:	2282      	movs	r2, #130	; 0x82
 802bb96:	0052      	lsls	r2, r2, #1
 802bb98:	5cab      	ldrb	r3, [r5, r2]
 802bb9a:	2b04      	cmp	r3, #4
 802bb9c:	d00b      	beq.n	802bbb6 <ComputeRxWindowParameters+0x8e>
        MacCtx.RxWindow1Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay1 + MacCtx.RxWindow1Config.WindowOffset;
 802bb9e:	4a08      	ldr	r2, [pc, #32]	; (802bbc0 <ComputeRxWindowParameters+0x98>)
 802bba0:	6e13      	ldr	r3, [r2, #96]	; 0x60
 802bba2:	469c      	mov	ip, r3
 802bba4:	4460      	add	r0, ip
 802bba6:	4b09      	ldr	r3, [pc, #36]	; (802bbcc <ComputeRxWindowParameters+0xa4>)
 802bba8:	3c04      	subs	r4, #4
 802bbaa:	5118      	str	r0, [r3, r4]
        MacCtx.RxWindow2Delay = Nvm.MacGroup2.MacParams.JoinAcceptDelay2 + MacCtx.RxWindow2Config.WindowOffset;
 802bbac:	6e52      	ldr	r2, [r2, #100]	; 0x64
 802bbae:	1889      	adds	r1, r1, r2
 802bbb0:	22ed      	movs	r2, #237	; 0xed
 802bbb2:	0092      	lsls	r2, r2, #2
 802bbb4:	5099      	str	r1, [r3, r2]
}
 802bbb6:	b002      	add	sp, #8
 802bbb8:	bc80      	pop	{r7}
 802bbba:	46b8      	mov	r8, r7
 802bbbc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802bbbe:	46c0      	nop			; (mov r8, r8)
 802bbc0:	2000a000 	.word	0x2000a000
 802bbc4:	2000bed4 	.word	0x2000bed4
 802bbc8:	fffffc48 	.word	0xfffffc48
 802bbcc:	2000bb1c 	.word	0x2000bb1c

0802bbd0 <VerifyTxFrame>:
{
 802bbd0:	b510      	push	{r4, lr}
 802bbd2:	b082      	sub	sp, #8
    size_t macCmdsSize = 0;
 802bbd4:	2300      	movs	r3, #0
 802bbd6:	9301      	str	r3, [sp, #4]
    if( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE )
 802bbd8:	4a0e      	ldr	r2, [pc, #56]	; (802bc14 <VerifyTxFrame+0x44>)
 802bbda:	3331      	adds	r3, #49	; 0x31
 802bbdc:	33ff      	adds	r3, #255	; 0xff
 802bbde:	5cd4      	ldrb	r4, [r2, r3]
 802bbe0:	2c00      	cmp	r4, #0
 802bbe2:	d102      	bne.n	802bbea <VerifyTxFrame+0x1a>
}
 802bbe4:	0020      	movs	r0, r4
 802bbe6:	b002      	add	sp, #8
 802bbe8:	bd10      	pop	{r4, pc}
        if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 802bbea:	a801      	add	r0, sp, #4
 802bbec:	f002 fb08 	bl	802e200 <LoRaMacCommandsGetSizeSerializedCmds>
 802bbf0:	1e04      	subs	r4, r0, #0
 802bbf2:	d10d      	bne.n	802bc10 <VerifyTxFrame+0x40>
        if( ValidatePayloadLength( MacCtx.AppDataSize, Nvm.MacGroup1.ChannelsDatarate, macCmdsSize ) == false )
 802bbf4:	9b01      	ldr	r3, [sp, #4]
 802bbf6:	b2da      	uxtb	r2, r3
 802bbf8:	4906      	ldr	r1, [pc, #24]	; (802bc14 <VerifyTxFrame+0x44>)
 802bbfa:	2339      	movs	r3, #57	; 0x39
 802bbfc:	56c9      	ldrsb	r1, [r1, r3]
 802bbfe:	4806      	ldr	r0, [pc, #24]	; (802bc18 <VerifyTxFrame+0x48>)
 802bc00:	4b06      	ldr	r3, [pc, #24]	; (802bc1c <VerifyTxFrame+0x4c>)
 802bc02:	5cc0      	ldrb	r0, [r0, r3]
 802bc04:	f7fe fdbc 	bl	802a780 <ValidatePayloadLength>
 802bc08:	2800      	cmp	r0, #0
 802bc0a:	d1eb      	bne.n	802bbe4 <VerifyTxFrame+0x14>
            return LORAMAC_STATUS_LENGTH_ERROR;
 802bc0c:	2408      	movs	r4, #8
 802bc0e:	e7e9      	b.n	802bbe4 <VerifyTxFrame+0x14>
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802bc10:	2413      	movs	r4, #19
 802bc12:	e7e7      	b.n	802bbe4 <VerifyTxFrame+0x14>
 802bc14:	2000a000 	.word	0x2000a000
 802bc18:	2000bb1c 	.word	0x2000bb1c
 802bc1c:	00000237 	.word	0x00000237

0802bc20 <SecureFrame>:
{
 802bc20:	b530      	push	{r4, r5, lr}
 802bc22:	b083      	sub	sp, #12
 802bc24:	0004      	movs	r4, r0
 802bc26:	000d      	movs	r5, r1
    uint32_t fCntUp = 0;
 802bc28:	2300      	movs	r3, #0
 802bc2a:	9301      	str	r3, [sp, #4]
    switch( MacCtx.TxMsg.Type )
 802bc2c:	4a1b      	ldr	r2, [pc, #108]	; (802bc9c <SecureFrame+0x7c>)
 802bc2e:	3305      	adds	r3, #5
 802bc30:	33ff      	adds	r3, #255	; 0xff
 802bc32:	5cd3      	ldrb	r3, [r2, r3]
 802bc34:	2b00      	cmp	r3, #0
 802bc36:	d004      	beq.n	802bc42 <SecureFrame+0x22>
 802bc38:	2b04      	cmp	r3, #4
 802bc3a:	d00d      	beq.n	802bc58 <SecureFrame+0x38>
 802bc3c:	2003      	movs	r0, #3
}
 802bc3e:	b003      	add	sp, #12
 802bc40:	bd30      	pop	{r4, r5, pc}
            macCryptoStatus = LoRaMacCryptoPrepareJoinRequest( &MacCtx.TxMsg.Message.JoinReq );
 802bc42:	4817      	ldr	r0, [pc, #92]	; (802bca0 <SecureFrame+0x80>)
 802bc44:	f002 feaa 	bl	802e99c <LoRaMacCryptoPrepareJoinRequest>
            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )
 802bc48:	2800      	cmp	r0, #0
 802bc4a:	d121      	bne.n	802bc90 <SecureFrame+0x70>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.JoinReq.BufSize;
 802bc4c:	4b13      	ldr	r3, [pc, #76]	; (802bc9c <SecureFrame+0x7c>)
 802bc4e:	2286      	movs	r2, #134	; 0x86
 802bc50:	0052      	lsls	r2, r2, #1
 802bc52:	5c9a      	ldrb	r2, [r3, r2]
 802bc54:	801a      	strh	r2, [r3, #0]
            break;
 802bc56:	e7f2      	b.n	802bc3e <SecureFrame+0x1e>
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 802bc58:	a801      	add	r0, sp, #4
 802bc5a:	f002 fe4b 	bl	802e8f4 <LoRaMacCryptoGetFCntUp>
 802bc5e:	2800      	cmp	r0, #0
 802bc60:	d118      	bne.n	802bc94 <SecureFrame+0x74>
            if( MacCtx.ChannelsNbTransCounter >= 1 )
 802bc62:	4a0e      	ldr	r2, [pc, #56]	; (802bc9c <SecureFrame+0x7c>)
 802bc64:	2383      	movs	r3, #131	; 0x83
 802bc66:	00db      	lsls	r3, r3, #3
 802bc68:	5cd3      	ldrb	r3, [r2, r3]
 802bc6a:	2b00      	cmp	r3, #0
 802bc6c:	d002      	beq.n	802bc74 <SecureFrame+0x54>
                fCntUp -= 1;
 802bc6e:	9b01      	ldr	r3, [sp, #4]
 802bc70:	3b01      	subs	r3, #1
 802bc72:	9301      	str	r3, [sp, #4]
            macCryptoStatus = LoRaMacCryptoSecureMessage( fCntUp, txDr, txCh, &MacCtx.TxMsg.Message.Data );
 802bc74:	4b0a      	ldr	r3, [pc, #40]	; (802bca0 <SecureFrame+0x80>)
 802bc76:	002a      	movs	r2, r5
 802bc78:	0021      	movs	r1, r4
 802bc7a:	9801      	ldr	r0, [sp, #4]
 802bc7c:	f002 feb8 	bl	802e9f0 <LoRaMacCryptoSecureMessage>
            if( LORAMAC_CRYPTO_SUCCESS != macCryptoStatus )
 802bc80:	2800      	cmp	r0, #0
 802bc82:	d109      	bne.n	802bc98 <SecureFrame+0x78>
            MacCtx.PktBufferLen = MacCtx.TxMsg.Message.Data.BufSize;
 802bc84:	4b05      	ldr	r3, [pc, #20]	; (802bc9c <SecureFrame+0x7c>)
 802bc86:	2286      	movs	r2, #134	; 0x86
 802bc88:	0052      	lsls	r2, r2, #1
 802bc8a:	5c9a      	ldrb	r2, [r3, r2]
 802bc8c:	801a      	strh	r2, [r3, #0]
            break;
 802bc8e:	e7d6      	b.n	802bc3e <SecureFrame+0x1e>
                return LORAMAC_STATUS_CRYPTO_ERROR;
 802bc90:	2011      	movs	r0, #17
 802bc92:	e7d4      	b.n	802bc3e <SecureFrame+0x1e>
                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;
 802bc94:	2012      	movs	r0, #18
 802bc96:	e7d2      	b.n	802bc3e <SecureFrame+0x1e>
                return LORAMAC_STATUS_CRYPTO_ERROR;
 802bc98:	2011      	movs	r0, #17
 802bc9a:	e7d0      	b.n	802bc3e <SecureFrame+0x1e>
 802bc9c:	2000bb1c 	.word	0x2000bb1c
 802bca0:	2000bc24 	.word	0x2000bc24

0802bca4 <SendFrameOnChannel>:
{
 802bca4:	b5f0      	push	{r4, r5, r6, r7, lr}
 802bca6:	b087      	sub	sp, #28
 802bca8:	0006      	movs	r6, r0
    int8_t txPower = 0;
 802bcaa:	2300      	movs	r3, #0
 802bcac:	466a      	mov	r2, sp
 802bcae:	71d3      	strb	r3, [r2, #7]
    txConfig.Channel = channel;
 802bcb0:	a902      	add	r1, sp, #8
 802bcb2:	7008      	strb	r0, [r1, #0]
    txConfig.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 802bcb4:	4d35      	ldr	r5, [pc, #212]	; (802bd8c <SendFrameOnChannel+0xe8>)
 802bcb6:	2739      	movs	r7, #57	; 0x39
 802bcb8:	57eb      	ldrsb	r3, [r5, r7]
 802bcba:	704b      	strb	r3, [r1, #1]
    txConfig.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 802bcbc:	2338      	movs	r3, #56	; 0x38
 802bcbe:	56eb      	ldrsb	r3, [r5, r3]
 802bcc0:	708b      	strb	r3, [r1, #2]
    txConfig.MaxEirp = Nvm.MacGroup2.MacParams.MaxEirp;
 802bcc2:	2380      	movs	r3, #128	; 0x80
 802bcc4:	58eb      	ldr	r3, [r5, r3]
 802bcc6:	604b      	str	r3, [r1, #4]
    txConfig.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 802bcc8:	2384      	movs	r3, #132	; 0x84
 802bcca:	58eb      	ldr	r3, [r5, r3]
 802bccc:	608b      	str	r3, [r1, #8]
    txConfig.PktLen = MacCtx.PktBufferLen;
 802bcce:	4c30      	ldr	r4, [pc, #192]	; (802bd90 <SendFrameOnChannel+0xec>)
 802bcd0:	8823      	ldrh	r3, [r4, #0]
 802bcd2:	818b      	strh	r3, [r1, #12]
    txConfig.NetworkActivation = Nvm.MacGroup2.NetworkActivation;
 802bcd4:	2398      	movs	r3, #152	; 0x98
 802bcd6:	005b      	lsls	r3, r3, #1
 802bcd8:	5ceb      	ldrb	r3, [r5, r3]
 802bcda:	738b      	strb	r3, [r1, #14]
    RegionTxConfig( Nvm.MacGroup2.Region, &txConfig, &txPower, &MacCtx.TxTimeOnAir );
 802bcdc:	4b2d      	ldr	r3, [pc, #180]	; (802bd94 <SendFrameOnChannel+0xf0>)
 802bcde:	18e3      	adds	r3, r4, r3
 802bce0:	2248      	movs	r2, #72	; 0x48
 802bce2:	5ca8      	ldrb	r0, [r5, r2]
 802bce4:	466a      	mov	r2, sp
 802bce6:	3207      	adds	r2, #7
 802bce8:	f003 fa04 	bl	802f0f4 <RegionTxConfig>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802bcec:	4b2a      	ldr	r3, [pc, #168]	; (802bd98 <SendFrameOnChannel+0xf4>)
 802bcee:	2201      	movs	r2, #1
 802bcf0:	54e2      	strb	r2, [r4, r3]
    MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 802bcf2:	5dea      	ldrb	r2, [r5, r7]
 802bcf4:	4b29      	ldr	r3, [pc, #164]	; (802bd9c <SendFrameOnChannel+0xf8>)
 802bcf6:	54e2      	strb	r2, [r4, r3]
    MacCtx.McpsConfirm.TxPower = txPower;
 802bcf8:	466b      	mov	r3, sp
 802bcfa:	79da      	ldrb	r2, [r3, #7]
 802bcfc:	4b28      	ldr	r3, [pc, #160]	; (802bda0 <SendFrameOnChannel+0xfc>)
 802bcfe:	54e2      	strb	r2, [r4, r3]
    MacCtx.McpsConfirm.Channel = channel;
 802bd00:	330d      	adds	r3, #13
 802bd02:	50e6      	str	r6, [r4, r3]
    MacCtx.McpsConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 802bd04:	4b23      	ldr	r3, [pc, #140]	; (802bd94 <SendFrameOnChannel+0xf0>)
 802bd06:	58e3      	ldr	r3, [r4, r3]
 802bd08:	2289      	movs	r2, #137	; 0x89
 802bd0a:	00d2      	lsls	r2, r2, #3
 802bd0c:	50a3      	str	r3, [r4, r2]
    MacCtx.MlmeConfirm.TxTimeOnAir = MacCtx.TxTimeOnAir;
 802bd0e:	3210      	adds	r2, #16
 802bd10:	50a3      	str	r3, [r4, r2]
    if( LoRaMacClassBIsBeaconModeActive( ) == true )
 802bd12:	f002 f92d 	bl	802df70 <LoRaMacClassBIsBeaconModeActive>
 802bd16:	2800      	cmp	r0, #0
 802bd18:	d12b      	bne.n	802bd72 <SendFrameOnChannel+0xce>
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 802bd1a:	4a1c      	ldr	r2, [pc, #112]	; (802bd8c <SendFrameOnChannel+0xe8>)
 802bd1c:	238c      	movs	r3, #140	; 0x8c
 802bd1e:	005b      	lsls	r3, r3, #1
 802bd20:	5cd3      	ldrb	r3, [r2, r3]
 802bd22:	2b01      	cmp	r3, #1
 802bd24:	d02e      	beq.n	802bd84 <SendFrameOnChannel+0xe0>
    LoRaMacClassBHaltBeaconing( );
 802bd26:	f002 f926 	bl	802df76 <LoRaMacClassBHaltBeaconing>
    status = SecureFrame( Nvm.MacGroup1.ChannelsDatarate, MacCtx.Channel );
 802bd2a:	4a19      	ldr	r2, [pc, #100]	; (802bd90 <SendFrameOnChannel+0xec>)
 802bd2c:	4b1d      	ldr	r3, [pc, #116]	; (802bda4 <SendFrameOnChannel+0x100>)
 802bd2e:	5cd1      	ldrb	r1, [r2, r3]
 802bd30:	4a16      	ldr	r2, [pc, #88]	; (802bd8c <SendFrameOnChannel+0xe8>)
 802bd32:	2339      	movs	r3, #57	; 0x39
 802bd34:	5cd0      	ldrb	r0, [r2, r3]
 802bd36:	f7ff ff73 	bl	802bc20 <SecureFrame>
 802bd3a:	1e04      	subs	r4, r0, #0
    if( status != LORAMAC_STATUS_OK )
 802bd3c:	d116      	bne.n	802bd6c <SendFrameOnChannel+0xc8>
    MacCtx.MacState |= LORAMAC_TX_RUNNING;
 802bd3e:	4814      	ldr	r0, [pc, #80]	; (802bd90 <SendFrameOnChannel+0xec>)
 802bd40:	22d0      	movs	r2, #208	; 0xd0
 802bd42:	0092      	lsls	r2, r2, #2
 802bd44:	2302      	movs	r3, #2
 802bd46:	5881      	ldr	r1, [r0, r2]
 802bd48:	430b      	orrs	r3, r1
 802bd4a:	5083      	str	r3, [r0, r2]
    MacCtx.ChannelsNbTransCounter++;
 802bd4c:	32d8      	adds	r2, #216	; 0xd8
 802bd4e:	5c83      	ldrb	r3, [r0, r2]
 802bd50:	3301      	adds	r3, #1
 802bd52:	b2db      	uxtb	r3, r3
 802bd54:	5483      	strb	r3, [r0, r2]
    MacCtx.McpsConfirm.NbTrans = MacCtx.ChannelsNbTransCounter;
 802bd56:	4a14      	ldr	r2, [pc, #80]	; (802bda8 <SendFrameOnChannel+0x104>)
 802bd58:	5483      	strb	r3, [r0, r2]
    MacCtx.ResponseTimeoutStartTime = 0;
 802bd5a:	2393      	movs	r3, #147	; 0x93
 802bd5c:	00db      	lsls	r3, r3, #3
 802bd5e:	2200      	movs	r2, #0
 802bd60:	50c2      	str	r2, [r0, r3]
    Radio.Send( MacCtx.PktBuffer, MacCtx.PktBufferLen );
 802bd62:	4b12      	ldr	r3, [pc, #72]	; (802bdac <SendFrameOnChannel+0x108>)
 802bd64:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802bd66:	7801      	ldrb	r1, [r0, #0]
 802bd68:	3002      	adds	r0, #2
 802bd6a:	4798      	blx	r3
}
 802bd6c:	0020      	movs	r0, r4
 802bd6e:	b007      	add	sp, #28
 802bd70:	bdf0      	pop	{r4, r5, r6, r7, pc}
        TimerTime_t collisionTime = LoRaMacClassBIsUplinkCollision( MacCtx.TxTimeOnAir );
 802bd72:	4a07      	ldr	r2, [pc, #28]	; (802bd90 <SendFrameOnChannel+0xec>)
 802bd74:	4b07      	ldr	r3, [pc, #28]	; (802bd94 <SendFrameOnChannel+0xf0>)
 802bd76:	58d0      	ldr	r0, [r2, r3]
 802bd78:	f002 f90c 	bl	802df94 <LoRaMacClassBIsUplinkCollision>
        if( collisionTime > 0 )
 802bd7c:	2800      	cmp	r0, #0
 802bd7e:	d0cc      	beq.n	802bd1a <SendFrameOnChannel+0x76>
            return LORAMAC_STATUS_BUSY_UPLINK_COLLISION;
 802bd80:	2410      	movs	r4, #16
 802bd82:	e7f3      	b.n	802bd6c <SendFrameOnChannel+0xc8>
        LoRaMacClassBStopRxSlots( );
 802bd84:	f002 f908 	bl	802df98 <LoRaMacClassBStopRxSlots>
 802bd88:	e7cd      	b.n	802bd26 <SendFrameOnChannel+0x82>
 802bd8a:	46c0      	nop			; (mov r8, r8)
 802bd8c:	2000a000 	.word	0x2000a000
 802bd90:	2000bb1c 	.word	0x2000bb1c
 802bd94:	0000041c 	.word	0x0000041c
 802bd98:	00000441 	.word	0x00000441
 802bd9c:	00000442 	.word	0x00000442
 802bda0:	00000443 	.word	0x00000443
 802bda4:	0000041b 	.word	0x0000041b
 802bda8:	00000445 	.word	0x00000445
 802bdac:	08035d8c 	.word	0x08035d8c

0802bdb0 <ScheduleTx>:
{
 802bdb0:	b5f0      	push	{r4, r5, r6, r7, lr}
 802bdb2:	b08f      	sub	sp, #60	; 0x3c
 802bdb4:	9003      	str	r0, [sp, #12]
    status = CheckForClassBCollision( );
 802bdb6:	f7ff fd75 	bl	802b8a4 <CheckForClassBCollision>
 802bdba:	1e04      	subs	r4, r0, #0
    if( status != LORAMAC_STATUS_OK )
 802bdbc:	d002      	beq.n	802bdc4 <ScheduleTx+0x14>
}
 802bdbe:	0020      	movs	r0, r4
 802bdc0:	b00f      	add	sp, #60	; 0x3c
 802bdc2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    CalculateBackOff( );
 802bdc4:	f7fe fbac 	bl	802a520 <CalculateBackOff>
    status = SerializeTxFrame( );
 802bdc8:	f7ff fe84 	bl	802bad4 <SerializeTxFrame>
 802bdcc:	1e04      	subs	r4, r0, #0
    if( status != LORAMAC_STATUS_OK )
 802bdce:	d1f6      	bne.n	802bdbe <ScheduleTx+0xe>
    nextChan.AggrTimeOff = Nvm.MacGroup1.AggregatedTimeOff;
 802bdd0:	4e35      	ldr	r6, [pc, #212]	; (802bea8 <ScheduleTx+0xf8>)
 802bdd2:	af06      	add	r7, sp, #24
 802bdd4:	6b33      	ldr	r3, [r6, #48]	; 0x30
 802bdd6:	9306      	str	r3, [sp, #24]
    nextChan.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 802bdd8:	2339      	movs	r3, #57	; 0x39
 802bdda:	56f3      	ldrsb	r3, [r6, r3]
 802bddc:	723b      	strb	r3, [r7, #8]
    nextChan.DutyCycleEnabled = Nvm.MacGroup2.DutyCycleOn;
 802bdde:	238e      	movs	r3, #142	; 0x8e
 802bde0:	005b      	lsls	r3, r3, #1
 802bde2:	5cf3      	ldrb	r3, [r6, r3]
 802bde4:	72bb      	strb	r3, [r7, #10]
    nextChan.ElapsedTimeSinceStartUp = SysTimeSub( SysTimeGetMcuTime( ), Nvm.MacGroup2.InitializationTime );
 802bde6:	a80c      	add	r0, sp, #48	; 0x30
 802bde8:	f008 fb08 	bl	80343fc <SysTimeGetMcuTime>
 802bdec:	ad04      	add	r5, sp, #16
 802bdee:	0033      	movs	r3, r6
 802bdf0:	3329      	adds	r3, #41	; 0x29
 802bdf2:	33ff      	adds	r3, #255	; 0xff
 802bdf4:	681b      	ldr	r3, [r3, #0]
 802bdf6:	9300      	str	r3, [sp, #0]
 802bdf8:	2392      	movs	r3, #146	; 0x92
 802bdfa:	005b      	lsls	r3, r3, #1
 802bdfc:	58f3      	ldr	r3, [r6, r3]
 802bdfe:	990c      	ldr	r1, [sp, #48]	; 0x30
 802be00:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 802be02:	0028      	movs	r0, r5
 802be04:	f008 fa96 	bl	8034334 <SysTimeSub>
 802be08:	aa09      	add	r2, sp, #36	; 0x24
 802be0a:	cd0a      	ldmia	r5!, {r1, r3}
 802be0c:	c20a      	stmia	r2!, {r1, r3}
    nextChan.LastAggrTx = Nvm.MacGroup1.LastTxDoneTime;
 802be0e:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 802be10:	9307      	str	r3, [sp, #28]
    nextChan.LastTxIsJoinRequest = false;
 802be12:	2300      	movs	r3, #0
 802be14:	753b      	strb	r3, [r7, #20]
    nextChan.Joined = true;
 802be16:	3301      	adds	r3, #1
 802be18:	727b      	strb	r3, [r7, #9]
    nextChan.PktLen = MacCtx.PktBufferLen;
 802be1a:	4b24      	ldr	r3, [pc, #144]	; (802beac <ScheduleTx+0xfc>)
 802be1c:	881b      	ldrh	r3, [r3, #0]
 802be1e:	82fb      	strh	r3, [r7, #22]
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 802be20:	2398      	movs	r3, #152	; 0x98
 802be22:	005b      	lsls	r3, r3, #1
 802be24:	5cf3      	ldrb	r3, [r6, r3]
 802be26:	2b00      	cmp	r3, #0
 802be28:	d103      	bne.n	802be32 <ScheduleTx+0x82>
        nextChan.LastTxIsJoinRequest = true;
 802be2a:	2201      	movs	r2, #1
 802be2c:	752a      	strb	r2, [r5, #20]
        nextChan.Joined = false;
 802be2e:	2200      	movs	r2, #0
 802be30:	726a      	strb	r2, [r5, #9]
    status = RegionNextChannel( Nvm.MacGroup2.Region, &nextChan, &MacCtx.Channel, &MacCtx.DutyCycleWaitTime, &Nvm.MacGroup1.AggregatedTimeOff );
 802be32:	4b1f      	ldr	r3, [pc, #124]	; (802beb0 <ScheduleTx+0x100>)
 802be34:	001a      	movs	r2, r3
 802be36:	3a79      	subs	r2, #121	; 0x79
 802be38:	491b      	ldr	r1, [pc, #108]	; (802bea8 <ScheduleTx+0xf8>)
 802be3a:	2048      	movs	r0, #72	; 0x48
 802be3c:	5c08      	ldrb	r0, [r1, r0]
 802be3e:	3130      	adds	r1, #48	; 0x30
 802be40:	9100      	str	r1, [sp, #0]
 802be42:	a906      	add	r1, sp, #24
 802be44:	f003 f9cc 	bl	802f1e0 <RegionNextChannel>
    if( status != LORAMAC_STATUS_OK )
 802be48:	2800      	cmp	r0, #0
 802be4a:	d01d      	beq.n	802be88 <ScheduleTx+0xd8>
        if( status == LORAMAC_STATUS_DUTYCYCLE_RESTRICTED )
 802be4c:	280b      	cmp	r0, #11
 802be4e:	d129      	bne.n	802bea4 <ScheduleTx+0xf4>
            if( MacCtx.DutyCycleWaitTime != 0 )
 802be50:	4a16      	ldr	r2, [pc, #88]	; (802beac <ScheduleTx+0xfc>)
 802be52:	4b18      	ldr	r3, [pc, #96]	; (802beb4 <ScheduleTx+0x104>)
 802be54:	58d1      	ldr	r1, [r2, r3]
 802be56:	2900      	cmp	r1, #0
 802be58:	d016      	beq.n	802be88 <ScheduleTx+0xd8>
                if( allowDelayedTx == true )
 802be5a:	9b03      	ldr	r3, [sp, #12]
 802be5c:	2b00      	cmp	r3, #0
 802be5e:	d101      	bne.n	802be64 <ScheduleTx+0xb4>
                return status;
 802be60:	0004      	movs	r4, r0
 802be62:	e7ac      	b.n	802bdbe <ScheduleTx+0xe>
                    MacCtx.MacState |= LORAMAC_TX_DELAYED;
 802be64:	0015      	movs	r5, r2
 802be66:	22d0      	movs	r2, #208	; 0xd0
 802be68:	0092      	lsls	r2, r2, #2
 802be6a:	2320      	movs	r3, #32
 802be6c:	58a8      	ldr	r0, [r5, r2]
 802be6e:	4303      	orrs	r3, r0
 802be70:	50ab      	str	r3, [r5, r2]
                    TimerSetValue( &MacCtx.TxDelayedTimer, MacCtx.DutyCycleWaitTime );
 802be72:	23da      	movs	r3, #218	; 0xda
 802be74:	009b      	lsls	r3, r3, #2
 802be76:	469c      	mov	ip, r3
 802be78:	4465      	add	r5, ip
 802be7a:	0028      	movs	r0, r5
 802be7c:	f008 fc32 	bl	80346e4 <UTIL_TIMER_SetPeriod>
                    TimerStart( &MacCtx.TxDelayedTimer );
 802be80:	0028      	movs	r0, r5
 802be82:	f008 fbe9 	bl	8034658 <UTIL_TIMER_Start>
                    return LORAMAC_STATUS_OK;
 802be86:	e79a      	b.n	802bdbe <ScheduleTx+0xe>
    ComputeRxWindowParameters( );
 802be88:	f7ff fe4e 	bl	802bb28 <ComputeRxWindowParameters>
    status = VerifyTxFrame( );
 802be8c:	f7ff fea0 	bl	802bbd0 <VerifyTxFrame>
 802be90:	1e04      	subs	r4, r0, #0
    if( status != LORAMAC_STATUS_OK )
 802be92:	d000      	beq.n	802be96 <ScheduleTx+0xe6>
 802be94:	e793      	b.n	802bdbe <ScheduleTx+0xe>
    return SendFrameOnChannel( MacCtx.Channel );
 802be96:	4a05      	ldr	r2, [pc, #20]	; (802beac <ScheduleTx+0xfc>)
 802be98:	4b07      	ldr	r3, [pc, #28]	; (802beb8 <ScheduleTx+0x108>)
 802be9a:	5cd0      	ldrb	r0, [r2, r3]
 802be9c:	f7ff ff02 	bl	802bca4 <SendFrameOnChannel>
 802bea0:	0004      	movs	r4, r0
 802bea2:	e78c      	b.n	802bdbe <ScheduleTx+0xe>
            return status;
 802bea4:	0004      	movs	r4, r0
 802bea6:	e78a      	b.n	802bdbe <ScheduleTx+0xe>
 802bea8:	2000a000 	.word	0x2000a000
 802beac:	2000bb1c 	.word	0x2000bb1c
 802beb0:	2000bfb0 	.word	0x2000bfb0
 802beb4:	00000494 	.word	0x00000494
 802beb8:	0000041b 	.word	0x0000041b

0802bebc <OnTxDelayedTimerEvent>:
{
 802bebc:	b510      	push	{r4, lr}
    TimerStop( &MacCtx.TxDelayedTimer );
 802bebe:	4c19      	ldr	r4, [pc, #100]	; (802bf24 <OnTxDelayedTimerEvent+0x68>)
 802bec0:	0020      	movs	r0, r4
 802bec2:	f008 fb67 	bl	8034594 <UTIL_TIMER_Stop>
    MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 802bec6:	4b18      	ldr	r3, [pc, #96]	; (802bf28 <OnTxDelayedTimerEvent+0x6c>)
 802bec8:	469c      	mov	ip, r3
 802beca:	4464      	add	r4, ip
 802becc:	22d0      	movs	r2, #208	; 0xd0
 802bece:	0092      	lsls	r2, r2, #2
 802bed0:	2320      	movs	r3, #32
 802bed2:	58a1      	ldr	r1, [r4, r2]
 802bed4:	4399      	bics	r1, r3
 802bed6:	50a1      	str	r1, [r4, r2]
    if( LoRaMacHandleResponseTimeout( Nvm.MacGroup2.MacParams.RxBCTimeout,
 802bed8:	2393      	movs	r3, #147	; 0x93
 802beda:	00db      	lsls	r3, r3, #3
 802bedc:	58e1      	ldr	r1, [r4, r3]
 802bede:	4a13      	ldr	r2, [pc, #76]	; (802bf2c <OnTxDelayedTimerEvent+0x70>)
 802bee0:	2390      	movs	r3, #144	; 0x90
 802bee2:	58d0      	ldr	r0, [r2, r3]
 802bee4:	f7ff fdb2 	bl	802ba4c <LoRaMacHandleResponseTimeout>
 802bee8:	2800      	cmp	r0, #0
 802beea:	d000      	beq.n	802beee <OnTxDelayedTimerEvent+0x32>
}
 802beec:	bd10      	pop	{r4, pc}
    switch( ScheduleTx( true ) )
 802beee:	3001      	adds	r0, #1
 802bef0:	f7ff ff5e 	bl	802bdb0 <ScheduleTx>
 802bef4:	2800      	cmp	r0, #0
 802bef6:	d0f9      	beq.n	802beec <OnTxDelayedTimerEvent+0x30>
 802bef8:	280b      	cmp	r0, #11
 802befa:	d0f7      	beq.n	802beec <OnTxDelayedTimerEvent+0x30>
            MacCtx.McpsConfirm.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 802befc:	4a0b      	ldr	r2, [pc, #44]	; (802bf2c <OnTxDelayedTimerEvent+0x70>)
 802befe:	2339      	movs	r3, #57	; 0x39
 802bf00:	5cd1      	ldrb	r1, [r2, r3]
 802bf02:	4b0b      	ldr	r3, [pc, #44]	; (802bf30 <OnTxDelayedTimerEvent+0x74>)
 802bf04:	4a0b      	ldr	r2, [pc, #44]	; (802bf34 <OnTxDelayedTimerEvent+0x78>)
 802bf06:	5499      	strb	r1, [r3, r2]
            MacCtx.McpsConfirm.NbTrans = MacCtx.ChannelsNbTransCounter;
 802bf08:	3a2a      	subs	r2, #42	; 0x2a
 802bf0a:	5c99      	ldrb	r1, [r3, r2]
 802bf0c:	4a0a      	ldr	r2, [pc, #40]	; (802bf38 <OnTxDelayedTimerEvent+0x7c>)
 802bf0e:	5499      	strb	r1, [r3, r2]
            MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR;
 802bf10:	4a0a      	ldr	r2, [pc, #40]	; (802bf3c <OnTxDelayedTimerEvent+0x80>)
 802bf12:	2109      	movs	r1, #9
 802bf14:	5499      	strb	r1, [r3, r2]
            LoRaMacConfirmQueueSetStatusCmn( LORAMAC_EVENT_INFO_STATUS_TX_DR_PAYLOAD_SIZE_ERROR );
 802bf16:	2009      	movs	r0, #9
 802bf18:	f002 fa98 	bl	802e44c <LoRaMacConfirmQueueSetStatusCmn>
            StopRetransmission( );
 802bf1c:	f7fe fba8 	bl	802a670 <StopRetransmission>
            break;
 802bf20:	e7e4      	b.n	802beec <OnTxDelayedTimerEvent+0x30>
 802bf22:	46c0      	nop			; (mov r8, r8)
 802bf24:	2000be84 	.word	0x2000be84
 802bf28:	fffffc98 	.word	0xfffffc98
 802bf2c:	2000a000 	.word	0x2000a000
 802bf30:	2000bb1c 	.word	0x2000bb1c
 802bf34:	00000442 	.word	0x00000442
 802bf38:	00000445 	.word	0x00000445
 802bf3c:	00000441 	.word	0x00000441

0802bf40 <LoRaMacHandleMcpsRequest>:
{
 802bf40:	b510      	push	{r4, lr}
    if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 802bf42:	4a1f      	ldr	r2, [pc, #124]	; (802bfc0 <LoRaMacHandleMcpsRequest+0x80>)
 802bf44:	4b1f      	ldr	r3, [pc, #124]	; (802bfc4 <LoRaMacHandleMcpsRequest+0x84>)
 802bf46:	5cd3      	ldrb	r3, [r2, r3]
 802bf48:	07db      	lsls	r3, r3, #31
 802bf4a:	d510      	bpl.n	802bf6e <LoRaMacHandleMcpsRequest+0x2e>
        if( ( MacCtx.McpsConfirm.McpsRequest == MCPS_UNCONFIRMED ) ||
 802bf4c:	2388      	movs	r3, #136	; 0x88
 802bf4e:	00db      	lsls	r3, r3, #3
 802bf50:	5cd3      	ldrb	r3, [r2, r3]
 802bf52:	2b00      	cmp	r3, #0
 802bf54:	d005      	beq.n	802bf62 <LoRaMacHandleMcpsRequest+0x22>
 802bf56:	2b03      	cmp	r3, #3
 802bf58:	d003      	beq.n	802bf62 <LoRaMacHandleMcpsRequest+0x22>
        else if( MacCtx.McpsConfirm.McpsRequest == MCPS_CONFIRMED )
 802bf5a:	2b01      	cmp	r3, #1
 802bf5c:	d008      	beq.n	802bf70 <LoRaMacHandleMcpsRequest+0x30>
        bool waitForRetransmission = false;
 802bf5e:	2000      	movs	r0, #0
 802bf60:	e003      	b.n	802bf6a <LoRaMacHandleMcpsRequest+0x2a>
            stopRetransmission = CheckRetransUnconfirmedUplink( );
 802bf62:	f7fe fb45 	bl	802a5f0 <CheckRetransUnconfirmedUplink>
        if( stopRetransmission == true )
 802bf66:	2800      	cmp	r0, #0
 802bf68:	d10a      	bne.n	802bf80 <LoRaMacHandleMcpsRequest+0x40>
        else if( waitForRetransmission == false )
 802bf6a:	2800      	cmp	r0, #0
 802bf6c:	d01a      	beq.n	802bfa4 <LoRaMacHandleMcpsRequest+0x64>
}
 802bf6e:	bd10      	pop	{r4, pc}
            if( MacCtx.RetransmitTimeoutRetry == true )
 802bf70:	4a13      	ldr	r2, [pc, #76]	; (802bfc0 <LoRaMacHandleMcpsRequest+0x80>)
 802bf72:	4b15      	ldr	r3, [pc, #84]	; (802bfc8 <LoRaMacHandleMcpsRequest+0x88>)
 802bf74:	5cd3      	ldrb	r3, [r2, r3]
 802bf76:	2b00      	cmp	r3, #0
 802bf78:	d012      	beq.n	802bfa0 <LoRaMacHandleMcpsRequest+0x60>
                stopRetransmission = CheckRetransConfirmedUplink( );
 802bf7a:	f7fe fb59 	bl	802a630 <CheckRetransConfirmedUplink>
 802bf7e:	e7f2      	b.n	802bf66 <LoRaMacHandleMcpsRequest+0x26>
            TimerStop( &MacCtx.TxDelayedTimer );
 802bf80:	4c12      	ldr	r4, [pc, #72]	; (802bfcc <LoRaMacHandleMcpsRequest+0x8c>)
 802bf82:	0020      	movs	r0, r4
 802bf84:	f008 fb06 	bl	8034594 <UTIL_TIMER_Stop>
            MacCtx.MacState &= ~LORAMAC_TX_DELAYED;
 802bf88:	4b11      	ldr	r3, [pc, #68]	; (802bfd0 <LoRaMacHandleMcpsRequest+0x90>)
 802bf8a:	469c      	mov	ip, r3
 802bf8c:	4464      	add	r4, ip
 802bf8e:	22d0      	movs	r2, #208	; 0xd0
 802bf90:	0092      	lsls	r2, r2, #2
 802bf92:	2320      	movs	r3, #32
 802bf94:	58a1      	ldr	r1, [r4, r2]
 802bf96:	4399      	bics	r1, r3
 802bf98:	50a1      	str	r1, [r4, r2]
            StopRetransmission( );
 802bf9a:	f7fe fb69 	bl	802a670 <StopRetransmission>
 802bf9e:	e7e6      	b.n	802bf6e <LoRaMacHandleMcpsRequest+0x2e>
                waitForRetransmission = true;
 802bfa0:	2001      	movs	r0, #1
 802bfa2:	e7e2      	b.n	802bf6a <LoRaMacHandleMcpsRequest+0x2a>
            MacCtx.MacFlags.Bits.MacDone = 0;
 802bfa4:	4b06      	ldr	r3, [pc, #24]	; (802bfc0 <LoRaMacHandleMcpsRequest+0x80>)
 802bfa6:	4907      	ldr	r1, [pc, #28]	; (802bfc4 <LoRaMacHandleMcpsRequest+0x84>)
 802bfa8:	5c5a      	ldrb	r2, [r3, r1]
 802bfaa:	3010      	adds	r0, #16
 802bfac:	4382      	bics	r2, r0
 802bfae:	545a      	strb	r2, [r3, r1]
            MacCtx.RetransmitTimeoutRetry = false;
 802bfb0:	4a05      	ldr	r2, [pc, #20]	; (802bfc8 <LoRaMacHandleMcpsRequest+0x88>)
 802bfb2:	2100      	movs	r1, #0
 802bfb4:	5499      	strb	r1, [r3, r2]
            OnTxDelayedTimerEvent( NULL );
 802bfb6:	2000      	movs	r0, #0
 802bfb8:	f7ff ff80 	bl	802bebc <OnTxDelayedTimerEvent>
}
 802bfbc:	e7d7      	b.n	802bf6e <LoRaMacHandleMcpsRequest+0x2e>
 802bfbe:	46c0      	nop			; (mov r8, r8)
 802bfc0:	2000bb1c 	.word	0x2000bb1c
 802bfc4:	00000491 	.word	0x00000491
 802bfc8:	00000419 	.word	0x00000419
 802bfcc:	2000be84 	.word	0x2000be84
 802bfd0:	fffffc98 	.word	0xfffffc98

0802bfd4 <LoRaMacHandleRequestEvents>:
{
 802bfd4:	b570      	push	{r4, r5, r6, lr}
    if( MacCtx.MacState == LORAMAC_IDLE )
 802bfd6:	4a23      	ldr	r2, [pc, #140]	; (802c064 <LoRaMacHandleRequestEvents+0x90>)
 802bfd8:	23d0      	movs	r3, #208	; 0xd0
 802bfda:	009b      	lsls	r3, r3, #2
 802bfdc:	58d3      	ldr	r3, [r2, r3]
 802bfde:	2b00      	cmp	r3, #0
 802bfe0:	d130      	bne.n	802c044 <LoRaMacHandleRequestEvents+0x70>
        if( MacCtx.MacFlags.Bits.McpsReq == 1 )
 802bfe2:	4b21      	ldr	r3, [pc, #132]	; (802c068 <LoRaMacHandleRequestEvents+0x94>)
 802bfe4:	5cd4      	ldrb	r4, [r2, r3]
 802bfe6:	2301      	movs	r3, #1
 802bfe8:	001d      	movs	r5, r3
 802bfea:	4025      	ands	r5, r4
 802bfec:	4223      	tst	r3, r4
 802bfee:	d005      	beq.n	802bffc <LoRaMacHandleRequestEvents+0x28>
            MacCtx.MacFlags.Bits.McpsReq = 0;
 802bff0:	0011      	movs	r1, r2
 802bff2:	4a1d      	ldr	r2, [pc, #116]	; (802c068 <LoRaMacHandleRequestEvents+0x94>)
 802bff4:	0023      	movs	r3, r4
 802bff6:	2001      	movs	r0, #1
 802bff8:	4383      	bics	r3, r0
 802bffa:	548b      	strb	r3, [r1, r2]
        if( MacCtx.MacFlags.Bits.MlmeReq == 1 )
 802bffc:	4a19      	ldr	r2, [pc, #100]	; (802c064 <LoRaMacHandleRequestEvents+0x90>)
 802bffe:	4b1a      	ldr	r3, [pc, #104]	; (802c068 <LoRaMacHandleRequestEvents+0x94>)
 802c000:	5cd3      	ldrb	r3, [r2, r3]
 802c002:	075b      	lsls	r3, r3, #29
 802c004:	d505      	bpl.n	802c012 <LoRaMacHandleRequestEvents+0x3e>
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 802c006:	0011      	movs	r1, r2
 802c008:	4a17      	ldr	r2, [pc, #92]	; (802c068 <LoRaMacHandleRequestEvents+0x94>)
 802c00a:	5c8b      	ldrb	r3, [r1, r2]
 802c00c:	2004      	movs	r0, #4
 802c00e:	4383      	bics	r3, r0
 802c010:	548b      	strb	r3, [r1, r2]
        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );
 802c012:	2001      	movs	r0, #1
 802c014:	f7fe fa2e 	bl	802a474 <LoRaMacEnableRequests>
        if( reqEvents.Bits.McpsReq == 1 )
 802c018:	2d00      	cmp	r5, #0
 802c01a:	d009      	beq.n	802c030 <LoRaMacHandleRequestEvents+0x5c>
            MacCtx.MacPrimitives->MacMcpsConfirm( &MacCtx.McpsConfirm );
 802c01c:	4811      	ldr	r0, [pc, #68]	; (802c064 <LoRaMacHandleRequestEvents+0x90>)
 802c01e:	23d1      	movs	r3, #209	; 0xd1
 802c020:	009b      	lsls	r3, r3, #2
 802c022:	58c3      	ldr	r3, [r0, r3]
 802c024:	681b      	ldr	r3, [r3, #0]
 802c026:	2288      	movs	r2, #136	; 0x88
 802c028:	00d2      	lsls	r2, r2, #3
 802c02a:	4694      	mov	ip, r2
 802c02c:	4460      	add	r0, ip
 802c02e:	4798      	blx	r3
        if( reqEvents.Bits.MlmeReq == 1 )
 802c030:	0763      	lsls	r3, r4, #29
 802c032:	d408      	bmi.n	802c046 <LoRaMacHandleRequestEvents+0x72>
        LoRaMacClassBResumeBeaconing( );
 802c034:	f001 ffa0 	bl	802df78 <LoRaMacClassBResumeBeaconing>
        MacCtx.MacFlags.Bits.MacDone = 0;
 802c038:	490a      	ldr	r1, [pc, #40]	; (802c064 <LoRaMacHandleRequestEvents+0x90>)
 802c03a:	4a0b      	ldr	r2, [pc, #44]	; (802c068 <LoRaMacHandleRequestEvents+0x94>)
 802c03c:	5c8b      	ldrb	r3, [r1, r2]
 802c03e:	2010      	movs	r0, #16
 802c040:	4383      	bics	r3, r0
 802c042:	548b      	strb	r3, [r1, r2]
}
 802c044:	bd70      	pop	{r4, r5, r6, pc}
            LoRaMacConfirmQueueHandleCb( &MacCtx.MlmeConfirm );
 802c046:	4809      	ldr	r0, [pc, #36]	; (802c06c <LoRaMacHandleRequestEvents+0x98>)
 802c048:	f002 fa2a 	bl	802e4a0 <LoRaMacConfirmQueueHandleCb>
            if( LoRaMacConfirmQueueGetCnt( ) > 0 )
 802c04c:	f002 fa5e 	bl	802e50c <LoRaMacConfirmQueueGetCnt>
 802c050:	2800      	cmp	r0, #0
 802c052:	d0ef      	beq.n	802c034 <LoRaMacHandleRequestEvents+0x60>
                MacCtx.MacFlags.Bits.MlmeReq = 1;
 802c054:	4903      	ldr	r1, [pc, #12]	; (802c064 <LoRaMacHandleRequestEvents+0x90>)
 802c056:	4a04      	ldr	r2, [pc, #16]	; (802c068 <LoRaMacHandleRequestEvents+0x94>)
 802c058:	5c8b      	ldrb	r3, [r1, r2]
 802c05a:	2004      	movs	r0, #4
 802c05c:	4303      	orrs	r3, r0
 802c05e:	548b      	strb	r3, [r1, r2]
 802c060:	e7e8      	b.n	802c034 <LoRaMacHandleRequestEvents+0x60>
 802c062:	46c0      	nop			; (mov r8, r8)
 802c064:	2000bb1c 	.word	0x2000bb1c
 802c068:	00000491 	.word	0x00000491
 802c06c:	2000bf70 	.word	0x2000bf70

0802c070 <OpenContinuousRxCWindow>:
{
 802c070:	b570      	push	{r4, r5, r6, lr}
 802c072:	b082      	sub	sp, #8
                                     Nvm.MacGroup2.MacParams.RxCChannel.Datarate,
 802c074:	4c18      	ldr	r4, [pc, #96]	; (802c0d8 <OpenContinuousRxCWindow+0x68>)
    RegionComputeRxWindowParameters( Nvm.MacGroup2.Region,
 802c076:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 802c078:	2250      	movs	r2, #80	; 0x50
 802c07a:	5ca2      	ldrb	r2, [r4, r2]
 802c07c:	2178      	movs	r1, #120	; 0x78
 802c07e:	5661      	ldrsb	r1, [r4, r1]
 802c080:	2648      	movs	r6, #72	; 0x48
 802c082:	5da0      	ldrb	r0, [r4, r6]
 802c084:	4d15      	ldr	r5, [pc, #84]	; (802c0dc <OpenContinuousRxCWindow+0x6c>)
 802c086:	9500      	str	r5, [sp, #0]
 802c088:	f003 f812 	bl	802f0b0 <RegionComputeRxWindowParameters>
    MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;
 802c08c:	4b14      	ldr	r3, [pc, #80]	; (802c0e0 <OpenContinuousRxCWindow+0x70>)
 802c08e:	18ea      	adds	r2, r5, r3
 802c090:	4b14      	ldr	r3, [pc, #80]	; (802c0e4 <OpenContinuousRxCWindow+0x74>)
 802c092:	2102      	movs	r1, #2
 802c094:	54d1      	strb	r1, [r2, r3]
    MacCtx.RxWindowCConfig.NetworkActivation = Nvm.MacGroup2.NetworkActivation;
 802c096:	2398      	movs	r3, #152	; 0x98
 802c098:	005b      	lsls	r3, r3, #1
 802c09a:	5ce1      	ldrb	r1, [r4, r3]
 802c09c:	23ff      	movs	r3, #255	; 0xff
 802c09e:	009b      	lsls	r3, r3, #2
 802c0a0:	54d1      	strb	r1, [r2, r3]
    MacCtx.RxWindowCConfig.RxContinuous = true;
 802c0a2:	4b11      	ldr	r3, [pc, #68]	; (802c0e8 <OpenContinuousRxCWindow+0x78>)
 802c0a4:	2101      	movs	r1, #1
 802c0a6:	54d1      	strb	r1, [r2, r3]
    if( RegionRxConfig( Nvm.MacGroup2.Region, &MacCtx.RxWindowCConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 802c0a8:	4b10      	ldr	r3, [pc, #64]	; (802c0ec <OpenContinuousRxCWindow+0x7c>)
 802c0aa:	469c      	mov	ip, r3
 802c0ac:	4462      	add	r2, ip
 802c0ae:	5da0      	ldrb	r0, [r4, r6]
 802c0b0:	0029      	movs	r1, r5
 802c0b2:	f003 f80f 	bl	802f0d4 <RegionRxConfig>
 802c0b6:	2800      	cmp	r0, #0
 802c0b8:	d00c      	beq.n	802c0d4 <OpenContinuousRxCWindow+0x64>
        MacCtx.MlmeIndication.RxDatarate = MacCtx.McpsIndication.RxDatarate;
 802c0ba:	4c0d      	ldr	r4, [pc, #52]	; (802c0f0 <OpenContinuousRxCWindow+0x80>)
 802c0bc:	4b0b      	ldr	r3, [pc, #44]	; (802c0ec <OpenContinuousRxCWindow+0x7c>)
 802c0be:	5ce2      	ldrb	r2, [r4, r3]
 802c0c0:	4b0c      	ldr	r3, [pc, #48]	; (802c0f4 <OpenContinuousRxCWindow+0x84>)
 802c0c2:	54e2      	strb	r2, [r4, r3]
        Radio.Rx( 0 ); // Continuous mode
 802c0c4:	4b0c      	ldr	r3, [pc, #48]	; (802c0f8 <OpenContinuousRxCWindow+0x88>)
 802c0c6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802c0c8:	2000      	movs	r0, #0
 802c0ca:	4798      	blx	r3
        MacCtx.RxSlot = MacCtx.RxWindowCConfig.RxSlot;
 802c0cc:	4b05      	ldr	r3, [pc, #20]	; (802c0e4 <OpenContinuousRxCWindow+0x74>)
 802c0ce:	5ce2      	ldrb	r2, [r4, r3]
 802c0d0:	3395      	adds	r3, #149	; 0x95
 802c0d2:	54e2      	strb	r2, [r4, r3]
}
 802c0d4:	b002      	add	sp, #8
 802c0d6:	bd70      	pop	{r4, r5, r6, pc}
 802c0d8:	2000a000 	.word	0x2000a000
 802c0dc:	2000bf04 	.word	0x2000bf04
 802c0e0:	fffffc18 	.word	0xfffffc18
 802c0e4:	000003fb 	.word	0x000003fb
 802c0e8:	000003fa 	.word	0x000003fa
 802c0ec:	00000424 	.word	0x00000424
 802c0f0:	2000bb1c 	.word	0x2000bb1c
 802c0f4:	0000046a 	.word	0x0000046a
 802c0f8:	08035d8c 	.word	0x08035d8c

0802c0fc <RxWindowSetup>:
{
 802c0fc:	b570      	push	{r4, r5, r6, lr}
 802c0fe:	000c      	movs	r4, r1
    TimerStop( rxTimer );
 802c100:	f008 fa48 	bl	8034594 <UTIL_TIMER_Stop>
    Radio.Standby( );
 802c104:	4b0d      	ldr	r3, [pc, #52]	; (802c13c <RxWindowSetup+0x40>)
 802c106:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802c108:	4798      	blx	r3
    if( RegionRxConfig( Nvm.MacGroup2.Region, rxConfig, ( int8_t* )&MacCtx.McpsIndication.RxDatarate ) == true )
 802c10a:	4a0d      	ldr	r2, [pc, #52]	; (802c140 <RxWindowSetup+0x44>)
 802c10c:	2348      	movs	r3, #72	; 0x48
 802c10e:	5cd0      	ldrb	r0, [r2, r3]
 802c110:	4a0c      	ldr	r2, [pc, #48]	; (802c144 <RxWindowSetup+0x48>)
 802c112:	0021      	movs	r1, r4
 802c114:	f002 ffde 	bl	802f0d4 <RegionRxConfig>
 802c118:	2800      	cmp	r0, #0
 802c11a:	d00d      	beq.n	802c138 <RxWindowSetup+0x3c>
        MacCtx.MlmeIndication.RxDatarate = MacCtx.McpsIndication.RxDatarate;
 802c11c:	4d0a      	ldr	r5, [pc, #40]	; (802c148 <RxWindowSetup+0x4c>)
 802c11e:	4b0b      	ldr	r3, [pc, #44]	; (802c14c <RxWindowSetup+0x50>)
 802c120:	5cea      	ldrb	r2, [r5, r3]
 802c122:	4b0b      	ldr	r3, [pc, #44]	; (802c150 <RxWindowSetup+0x54>)
 802c124:	54ea      	strb	r2, [r5, r3]
        Radio.Rx( Nvm.MacGroup2.MacParams.MaxRxWindow );
 802c126:	4b05      	ldr	r3, [pc, #20]	; (802c13c <RxWindowSetup+0x40>)
 802c128:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802c12a:	4a05      	ldr	r2, [pc, #20]	; (802c140 <RxWindowSetup+0x44>)
 802c12c:	6d50      	ldr	r0, [r2, #84]	; 0x54
 802c12e:	4798      	blx	r3
        MacCtx.RxSlot = rxConfig->RxSlot;
 802c130:	7ce2      	ldrb	r2, [r4, #19]
 802c132:	2392      	movs	r3, #146	; 0x92
 802c134:	00db      	lsls	r3, r3, #3
 802c136:	54ea      	strb	r2, [r5, r3]
}
 802c138:	bd70      	pop	{r4, r5, r6, pc}
 802c13a:	46c0      	nop			; (mov r8, r8)
 802c13c:	08035d8c 	.word	0x08035d8c
 802c140:	2000a000 	.word	0x2000a000
 802c144:	2000bf40 	.word	0x2000bf40
 802c148:	2000bb1c 	.word	0x2000bb1c
 802c14c:	00000424 	.word	0x00000424
 802c150:	0000046a 	.word	0x0000046a

0802c154 <OnRxWindow2TimerEvent>:
{
 802c154:	b510      	push	{r4, lr}
    if( MacCtx.RxSlot == RX_SLOT_WIN_1 )
 802c156:	4a17      	ldr	r2, [pc, #92]	; (802c1b4 <OnRxWindow2TimerEvent+0x60>)
 802c158:	2392      	movs	r3, #146	; 0x92
 802c15a:	00db      	lsls	r3, r3, #3
 802c15c:	5cd3      	ldrb	r3, [r2, r3]
 802c15e:	2b00      	cmp	r3, #0
 802c160:	d100      	bne.n	802c164 <OnRxWindow2TimerEvent+0x10>
}
 802c162:	bd10      	pop	{r4, pc}
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 802c164:	0010      	movs	r0, r2
 802c166:	4b14      	ldr	r3, [pc, #80]	; (802c1b8 <OnRxWindow2TimerEvent+0x64>)
 802c168:	5cd2      	ldrb	r2, [r2, r3]
 802c16a:	3b4b      	subs	r3, #75	; 0x4b
 802c16c:	54c2      	strb	r2, [r0, r3]
    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
 802c16e:	4b13      	ldr	r3, [pc, #76]	; (802c1bc <OnRxWindow2TimerEvent+0x68>)
 802c170:	22f5      	movs	r2, #245	; 0xf5
 802c172:	0092      	lsls	r2, r2, #2
 802c174:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 802c176:	5081      	str	r1, [r0, r2]
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802c178:	227d      	movs	r2, #125	; 0x7d
 802c17a:	5c99      	ldrb	r1, [r3, r2]
 802c17c:	22f8      	movs	r2, #248	; 0xf8
 802c17e:	0092      	lsls	r2, r2, #2
 802c180:	5481      	strb	r1, [r0, r2]
    MacCtx.RxWindow2Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 802c182:	228c      	movs	r2, #140	; 0x8c
 802c184:	5c99      	ldrb	r1, [r3, r2]
 802c186:	4a0e      	ldr	r2, [pc, #56]	; (802c1c0 <OnRxWindow2TimerEvent+0x6c>)
 802c188:	5481      	strb	r1, [r0, r2]
    MacCtx.RxWindow2Config.RxContinuous = false;
 802c18a:	4a0e      	ldr	r2, [pc, #56]	; (802c1c4 <OnRxWindow2TimerEvent+0x70>)
 802c18c:	2100      	movs	r1, #0
 802c18e:	5481      	strb	r1, [r0, r2]
    MacCtx.RxWindow2Config.RxSlot = RX_SLOT_WIN_2;
 802c190:	4a0d      	ldr	r2, [pc, #52]	; (802c1c8 <OnRxWindow2TimerEvent+0x74>)
 802c192:	3101      	adds	r1, #1
 802c194:	5481      	strb	r1, [r0, r2]
    MacCtx.RxWindow2Config.NetworkActivation = Nvm.MacGroup2.NetworkActivation;
 802c196:	2298      	movs	r2, #152	; 0x98
 802c198:	0052      	lsls	r2, r2, #1
 802c19a:	5c9a      	ldrb	r2, [r3, r2]
 802c19c:	23f9      	movs	r3, #249	; 0xf9
 802c19e:	009b      	lsls	r3, r3, #2
 802c1a0:	54c2      	strb	r2, [r0, r3]
    RxWindowSetup( &MacCtx.RxWindowTimer2, &MacCtx.RxWindow2Config );
 802c1a2:	3b14      	subs	r3, #20
 802c1a4:	18c1      	adds	r1, r0, r3
 802c1a6:	3b38      	subs	r3, #56	; 0x38
 802c1a8:	469c      	mov	ip, r3
 802c1aa:	4460      	add	r0, ip
 802c1ac:	f7ff ffa6 	bl	802c0fc <RxWindowSetup>
 802c1b0:	e7d7      	b.n	802c162 <OnRxWindow2TimerEvent+0xe>
 802c1b2:	46c0      	nop			; (mov r8, r8)
 802c1b4:	2000bb1c 	.word	0x2000bb1c
 802c1b8:	0000041b 	.word	0x0000041b
 802c1bc:	2000a000 	.word	0x2000a000
 802c1c0:	000003e1 	.word	0x000003e1
 802c1c4:	000003e2 	.word	0x000003e2
 802c1c8:	000003e3 	.word	0x000003e3

0802c1cc <OnRxWindow1TimerEvent>:
{
 802c1cc:	b510      	push	{r4, lr}
    MacCtx.RxWindow1Config.Channel = MacCtx.Channel;
 802c1ce:	4813      	ldr	r0, [pc, #76]	; (802c21c <OnRxWindow1TimerEvent+0x50>)
 802c1d0:	4b13      	ldr	r3, [pc, #76]	; (802c220 <OnRxWindow1TimerEvent+0x54>)
 802c1d2:	5cc2      	ldrb	r2, [r0, r3]
 802c1d4:	3b63      	subs	r3, #99	; 0x63
 802c1d6:	54c2      	strb	r2, [r0, r3]
    MacCtx.RxWindow1Config.DrOffset = Nvm.MacGroup2.MacParams.Rx1DrOffset;
 802c1d8:	4b12      	ldr	r3, [pc, #72]	; (802c224 <OnRxWindow1TimerEvent+0x58>)
 802c1da:	2269      	movs	r2, #105	; 0x69
 802c1dc:	5699      	ldrsb	r1, [r3, r2]
 802c1de:	4a12      	ldr	r2, [pc, #72]	; (802c228 <OnRxWindow1TimerEvent+0x5c>)
 802c1e0:	5481      	strb	r1, [r0, r2]
    MacCtx.RxWindow1Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802c1e2:	227d      	movs	r2, #125	; 0x7d
 802c1e4:	5c99      	ldrb	r1, [r3, r2]
 802c1e6:	22f2      	movs	r2, #242	; 0xf2
 802c1e8:	0092      	lsls	r2, r2, #2
 802c1ea:	5481      	strb	r1, [r0, r2]
    MacCtx.RxWindow1Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 802c1ec:	228c      	movs	r2, #140	; 0x8c
 802c1ee:	5c99      	ldrb	r1, [r3, r2]
 802c1f0:	4a0e      	ldr	r2, [pc, #56]	; (802c22c <OnRxWindow1TimerEvent+0x60>)
 802c1f2:	5481      	strb	r1, [r0, r2]
    MacCtx.RxWindow1Config.RxContinuous = false;
 802c1f4:	2200      	movs	r2, #0
 802c1f6:	490e      	ldr	r1, [pc, #56]	; (802c230 <OnRxWindow1TimerEvent+0x64>)
 802c1f8:	5442      	strb	r2, [r0, r1]
    MacCtx.RxWindow1Config.RxSlot = RX_SLOT_WIN_1;
 802c1fa:	490e      	ldr	r1, [pc, #56]	; (802c234 <OnRxWindow1TimerEvent+0x68>)
 802c1fc:	5442      	strb	r2, [r0, r1]
    MacCtx.RxWindow1Config.NetworkActivation = Nvm.MacGroup2.NetworkActivation;
 802c1fe:	3231      	adds	r2, #49	; 0x31
 802c200:	32ff      	adds	r2, #255	; 0xff
 802c202:	5c9a      	ldrb	r2, [r3, r2]
 802c204:	23f3      	movs	r3, #243	; 0xf3
 802c206:	009b      	lsls	r3, r3, #2
 802c208:	54c2      	strb	r2, [r0, r3]
    RxWindowSetup( &MacCtx.RxWindowTimer1, &MacCtx.RxWindow1Config );
 802c20a:	3b14      	subs	r3, #20
 802c20c:	18c1      	adds	r1, r0, r3
 802c20e:	3b38      	subs	r3, #56	; 0x38
 802c210:	469c      	mov	ip, r3
 802c212:	4460      	add	r0, ip
 802c214:	f7ff ff72 	bl	802c0fc <RxWindowSetup>
}
 802c218:	bd10      	pop	{r4, pc}
 802c21a:	46c0      	nop			; (mov r8, r8)
 802c21c:	2000bb1c 	.word	0x2000bb1c
 802c220:	0000041b 	.word	0x0000041b
 802c224:	2000a000 	.word	0x2000a000
 802c228:	000003bb 	.word	0x000003bb
 802c22c:	000003c9 	.word	0x000003c9
 802c230:	000003ca 	.word	0x000003ca
 802c234:	000003cb 	.word	0x000003cb

0802c238 <LoRaMacHandleNvm>:
{
 802c238:	b570      	push	{r4, r5, r6, lr}
 802c23a:	0004      	movs	r4, r0
    if( MacCtx.MacState != LORAMAC_IDLE )
 802c23c:	4a3a      	ldr	r2, [pc, #232]	; (802c328 <LoRaMacHandleNvm+0xf0>)
 802c23e:	23d0      	movs	r3, #208	; 0xd0
 802c240:	009b      	lsls	r3, r3, #2
 802c242:	58d3      	ldr	r3, [r2, r3]
 802c244:	2b00      	cmp	r3, #0
 802c246:	d000      	beq.n	802c24a <LoRaMacHandleNvm+0x12>
}
 802c248:	bd70      	pop	{r4, r5, r6, pc}
    crc = Crc32( ( uint8_t* ) &nvmData->Crypto, sizeof( nvmData->Crypto ) -
 802c24a:	2124      	movs	r1, #36	; 0x24
 802c24c:	f005 ff7a 	bl	8032144 <Crc32>
    if( crc != nvmData->Crypto.Crc32 )
 802c250:	6a63      	ldr	r3, [r4, #36]	; 0x24
 802c252:	4283      	cmp	r3, r0
 802c254:	d066      	beq.n	802c324 <LoRaMacHandleNvm+0xec>
        nvmData->Crypto.Crc32 = crc;
 802c256:	6260      	str	r0, [r4, #36]	; 0x24
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CRYPTO;
 802c258:	2501      	movs	r5, #1
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup1, sizeof( nvmData->MacGroup1 ) -
 802c25a:	0020      	movs	r0, r4
 802c25c:	3028      	adds	r0, #40	; 0x28
 802c25e:	211c      	movs	r1, #28
 802c260:	f005 ff70 	bl	8032144 <Crc32>
    if( crc != nvmData->MacGroup1.Crc32 )
 802c264:	6c63      	ldr	r3, [r4, #68]	; 0x44
 802c266:	4283      	cmp	r3, r0
 802c268:	d003      	beq.n	802c272 <LoRaMacHandleNvm+0x3a>
        nvmData->MacGroup1.Crc32 = crc;
 802c26a:	6460      	str	r0, [r4, #68]	; 0x44
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP1;
 802c26c:	2302      	movs	r3, #2
 802c26e:	431d      	orrs	r5, r3
 802c270:	b2ad      	uxth	r5, r5
    crc = Crc32( ( uint8_t* ) &nvmData->MacGroup2, sizeof( nvmData->MacGroup2 ) -
 802c272:	0020      	movs	r0, r4
 802c274:	3048      	adds	r0, #72	; 0x48
 802c276:	2180      	movs	r1, #128	; 0x80
 802c278:	0049      	lsls	r1, r1, #1
 802c27a:	f005 ff63 	bl	8032144 <Crc32>
    if( crc != nvmData->MacGroup2.Crc32 )
 802c27e:	23a4      	movs	r3, #164	; 0xa4
 802c280:	005b      	lsls	r3, r3, #1
 802c282:	58e3      	ldr	r3, [r4, r3]
 802c284:	4283      	cmp	r3, r0
 802c286:	d005      	beq.n	802c294 <LoRaMacHandleNvm+0x5c>
        nvmData->MacGroup2.Crc32 = crc;
 802c288:	23a4      	movs	r3, #164	; 0xa4
 802c28a:	005b      	lsls	r3, r3, #1
 802c28c:	50e0      	str	r0, [r4, r3]
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_MAC_GROUP2;
 802c28e:	2304      	movs	r3, #4
 802c290:	431d      	orrs	r5, r3
 802c292:	b2ad      	uxth	r5, r5
    crc = Crc32( ( uint8_t* ) &nvmData->SecureElement, sizeof( nvmData->SecureElement ) -
 802c294:	0020      	movs	r0, r4
 802c296:	304d      	adds	r0, #77	; 0x4d
 802c298:	30ff      	adds	r0, #255	; 0xff
 802c29a:	2104      	movs	r1, #4
 802c29c:	f005 ff52 	bl	8032144 <Crc32>
    if( crc != nvmData->SecureElement.Crc32 )
 802c2a0:	23a8      	movs	r3, #168	; 0xa8
 802c2a2:	005b      	lsls	r3, r3, #1
 802c2a4:	58e3      	ldr	r3, [r4, r3]
 802c2a6:	4283      	cmp	r3, r0
 802c2a8:	d005      	beq.n	802c2b6 <LoRaMacHandleNvm+0x7e>
        nvmData->SecureElement.Crc32 = crc;
 802c2aa:	23a8      	movs	r3, #168	; 0xa8
 802c2ac:	005b      	lsls	r3, r3, #1
 802c2ae:	50e0      	str	r0, [r4, r3]
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_SECURE_ELEMENT;
 802c2b0:	2308      	movs	r3, #8
 802c2b2:	431d      	orrs	r5, r3
 802c2b4:	b2ad      	uxth	r5, r5
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup1, sizeof( nvmData->RegionGroup1 ) -
 802c2b6:	0020      	movs	r0, r4
 802c2b8:	3055      	adds	r0, #85	; 0x55
 802c2ba:	30ff      	adds	r0, #255	; 0xff
 802c2bc:	2110      	movs	r1, #16
 802c2be:	f005 ff41 	bl	8032144 <Crc32>
    if( crc != nvmData->RegionGroup1.Crc32 )
 802c2c2:	23b2      	movs	r3, #178	; 0xb2
 802c2c4:	005b      	lsls	r3, r3, #1
 802c2c6:	58e3      	ldr	r3, [r4, r3]
 802c2c8:	4283      	cmp	r3, r0
 802c2ca:	d005      	beq.n	802c2d8 <LoRaMacHandleNvm+0xa0>
        nvmData->RegionGroup1.Crc32 = crc;
 802c2cc:	23b2      	movs	r3, #178	; 0xb2
 802c2ce:	005b      	lsls	r3, r3, #1
 802c2d0:	50e0      	str	r0, [r4, r3]
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP1;
 802c2d2:	2310      	movs	r3, #16
 802c2d4:	431d      	orrs	r5, r3
 802c2d6:	b2ad      	uxth	r5, r5
    crc = Crc32( ( uint8_t* ) &nvmData->RegionGroup2, sizeof( nvmData->RegionGroup2 ) -
 802c2d8:	0020      	movs	r0, r4
 802c2da:	3069      	adds	r0, #105	; 0x69
 802c2dc:	30ff      	adds	r0, #255	; 0xff
 802c2de:	21de      	movs	r1, #222	; 0xde
 802c2e0:	0089      	lsls	r1, r1, #2
 802c2e2:	f005 ff2f 	bl	8032144 <Crc32>
    if( crc != nvmData->RegionGroup2.Crc32 )
 802c2e6:	239c      	movs	r3, #156	; 0x9c
 802c2e8:	00db      	lsls	r3, r3, #3
 802c2ea:	58e3      	ldr	r3, [r4, r3]
 802c2ec:	4283      	cmp	r3, r0
 802c2ee:	d005      	beq.n	802c2fc <LoRaMacHandleNvm+0xc4>
        nvmData->RegionGroup2.Crc32 = crc;
 802c2f0:	239c      	movs	r3, #156	; 0x9c
 802c2f2:	00db      	lsls	r3, r3, #3
 802c2f4:	50e0      	str	r0, [r4, r3]
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_REGION_GROUP2;
 802c2f6:	2320      	movs	r3, #32
 802c2f8:	431d      	orrs	r5, r3
 802c2fa:	b2ad      	uxth	r5, r5
    crc = Crc32( ( uint8_t* ) &nvmData->ClassB, sizeof( nvmData->ClassB ) -
 802c2fc:	4b0b      	ldr	r3, [pc, #44]	; (802c32c <LoRaMacHandleNvm+0xf4>)
 802c2fe:	18e0      	adds	r0, r4, r3
 802c300:	2114      	movs	r1, #20
 802c302:	f005 ff1f 	bl	8032144 <Crc32>
    if( crc != nvmData->ClassB.Crc32 )
 802c306:	239f      	movs	r3, #159	; 0x9f
 802c308:	00db      	lsls	r3, r3, #3
 802c30a:	58e3      	ldr	r3, [r4, r3]
 802c30c:	4283      	cmp	r3, r0
 802c30e:	d005      	beq.n	802c31c <LoRaMacHandleNvm+0xe4>
        nvmData->ClassB.Crc32 = crc;
 802c310:	239f      	movs	r3, #159	; 0x9f
 802c312:	00db      	lsls	r3, r3, #3
 802c314:	50e0      	str	r0, [r4, r3]
        notifyFlags |= LORAMAC_NVM_NOTIFY_FLAG_CLASS_B;
 802c316:	2340      	movs	r3, #64	; 0x40
 802c318:	431d      	orrs	r5, r3
 802c31a:	b2ad      	uxth	r5, r5
    CallNvmDataChangeCallback( notifyFlags );
 802c31c:	0028      	movs	r0, r5
 802c31e:	f7fe f9f3 	bl	802a708 <CallNvmDataChangeCallback>
 802c322:	e791      	b.n	802c248 <LoRaMacHandleNvm+0x10>
    uint16_t notifyFlags = LORAMAC_NVM_NOTIFY_FLAG_NONE;
 802c324:	2500      	movs	r5, #0
 802c326:	e798      	b.n	802c25a <LoRaMacHandleNvm+0x22>
 802c328:	2000bb1c 	.word	0x2000bb1c
 802c32c:	000004e4 	.word	0x000004e4

0802c330 <RestoreNvmData>:
{
 802c330:	b570      	push	{r4, r5, r6, lr}
    if( MacCtx.MacState != LORAMAC_STOPPED )
 802c332:	4a46      	ldr	r2, [pc, #280]	; (802c44c <RestoreNvmData+0x11c>)
 802c334:	23d0      	movs	r3, #208	; 0xd0
 802c336:	009b      	lsls	r3, r3, #2
 802c338:	58d3      	ldr	r3, [r2, r3]
 802c33a:	2b01      	cmp	r3, #1
 802c33c:	d001      	beq.n	802c342 <RestoreNvmData+0x12>
        return LORAMAC_STATUS_BUSY;
 802c33e:	2001      	movs	r0, #1
}
 802c340:	bd70      	pop	{r4, r5, r6, pc}
    crc = Crc32( ( uint8_t* ) &(NvmBackup.Crypto), sizeof( NvmBackup.Crypto ) -
 802c342:	4c43      	ldr	r4, [pc, #268]	; (802c450 <RestoreNvmData+0x120>)
 802c344:	2124      	movs	r1, #36	; 0x24
 802c346:	0020      	movs	r0, r4
 802c348:	f005 fefc 	bl	8032144 <Crc32>
    if( crc != NvmBackup.Crypto.Crc32 )
 802c34c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 802c34e:	4283      	cmp	r3, r0
 802c350:	d001      	beq.n	802c356 <RestoreNvmData+0x26>
        return LORAMAC_STATUS_NVM_DATA_INCONSISTENT;
 802c352:	2017      	movs	r0, #23
 802c354:	e7f4      	b.n	802c340 <RestoreNvmData+0x10>
    crc = Crc32( ( uint8_t* ) &(NvmBackup.MacGroup1), sizeof( NvmBackup.MacGroup1 ) -
 802c356:	4c3f      	ldr	r4, [pc, #252]	; (802c454 <RestoreNvmData+0x124>)
 802c358:	211c      	movs	r1, #28
 802c35a:	0020      	movs	r0, r4
 802c35c:	f005 fef2 	bl	8032144 <Crc32>
    if( crc != NvmBackup.MacGroup1.Crc32 )
 802c360:	69e3      	ldr	r3, [r4, #28]
 802c362:	4283      	cmp	r3, r0
 802c364:	d001      	beq.n	802c36a <RestoreNvmData+0x3a>
        return LORAMAC_STATUS_NVM_DATA_INCONSISTENT;
 802c366:	2017      	movs	r0, #23
 802c368:	e7ea      	b.n	802c340 <RestoreNvmData+0x10>
    crc = Crc32( ( uint8_t* ) &(NvmBackup.MacGroup2), sizeof( NvmBackup.MacGroup2 ) -
 802c36a:	2180      	movs	r1, #128	; 0x80
 802c36c:	4c3a      	ldr	r4, [pc, #232]	; (802c458 <RestoreNvmData+0x128>)
 802c36e:	0049      	lsls	r1, r1, #1
 802c370:	0020      	movs	r0, r4
 802c372:	f005 fee7 	bl	8032144 <Crc32>
    if( crc != NvmBackup.MacGroup2.Crc32 )
 802c376:	3c48      	subs	r4, #72	; 0x48
 802c378:	23a4      	movs	r3, #164	; 0xa4
 802c37a:	005b      	lsls	r3, r3, #1
 802c37c:	58e3      	ldr	r3, [r4, r3]
 802c37e:	4283      	cmp	r3, r0
 802c380:	d001      	beq.n	802c386 <RestoreNvmData+0x56>
        return LORAMAC_STATUS_NVM_DATA_INCONSISTENT;
 802c382:	2017      	movs	r0, #23
 802c384:	e7dc      	b.n	802c340 <RestoreNvmData+0x10>
    crc = Crc32( ( uint8_t* ) &(NvmBackup.SecureElement), sizeof( NvmBackup.SecureElement ) -
 802c386:	4c35      	ldr	r4, [pc, #212]	; (802c45c <RestoreNvmData+0x12c>)
 802c388:	2104      	movs	r1, #4
 802c38a:	0020      	movs	r0, r4
 802c38c:	f005 feda 	bl	8032144 <Crc32>
    if( crc != NvmBackup.SecureElement.Crc32 )
 802c390:	3c4d      	subs	r4, #77	; 0x4d
 802c392:	3cff      	subs	r4, #255	; 0xff
 802c394:	23a8      	movs	r3, #168	; 0xa8
 802c396:	005b      	lsls	r3, r3, #1
 802c398:	58e3      	ldr	r3, [r4, r3]
 802c39a:	4283      	cmp	r3, r0
 802c39c:	d001      	beq.n	802c3a2 <RestoreNvmData+0x72>
        return LORAMAC_STATUS_NVM_DATA_INCONSISTENT;
 802c39e:	2017      	movs	r0, #23
 802c3a0:	e7ce      	b.n	802c340 <RestoreNvmData+0x10>
    crc = Crc32( ( uint8_t* ) &(NvmBackup.RegionGroup1), sizeof( NvmBackup.RegionGroup1 ) -
 802c3a2:	4c2f      	ldr	r4, [pc, #188]	; (802c460 <RestoreNvmData+0x130>)
 802c3a4:	2110      	movs	r1, #16
 802c3a6:	0020      	movs	r0, r4
 802c3a8:	f005 fecc 	bl	8032144 <Crc32>
    if( crc != NvmBackup.RegionGroup1.Crc32 )
 802c3ac:	3c55      	subs	r4, #85	; 0x55
 802c3ae:	3cff      	subs	r4, #255	; 0xff
 802c3b0:	23b2      	movs	r3, #178	; 0xb2
 802c3b2:	005b      	lsls	r3, r3, #1
 802c3b4:	58e3      	ldr	r3, [r4, r3]
 802c3b6:	4283      	cmp	r3, r0
 802c3b8:	d001      	beq.n	802c3be <RestoreNvmData+0x8e>
        return LORAMAC_STATUS_NVM_DATA_INCONSISTENT;
 802c3ba:	2017      	movs	r0, #23
 802c3bc:	e7c0      	b.n	802c340 <RestoreNvmData+0x10>
    crc = Crc32( ( uint8_t* ) &(NvmBackup.RegionGroup2), sizeof( NvmBackup.RegionGroup2 ) -
 802c3be:	21de      	movs	r1, #222	; 0xde
 802c3c0:	4c28      	ldr	r4, [pc, #160]	; (802c464 <RestoreNvmData+0x134>)
 802c3c2:	0089      	lsls	r1, r1, #2
 802c3c4:	0020      	movs	r0, r4
 802c3c6:	f005 febd 	bl	8032144 <Crc32>
    if( crc != NvmBackup.RegionGroup2.Crc32 )
 802c3ca:	3c69      	subs	r4, #105	; 0x69
 802c3cc:	3cff      	subs	r4, #255	; 0xff
 802c3ce:	239c      	movs	r3, #156	; 0x9c
 802c3d0:	00db      	lsls	r3, r3, #3
 802c3d2:	58e3      	ldr	r3, [r4, r3]
 802c3d4:	4283      	cmp	r3, r0
 802c3d6:	d001      	beq.n	802c3dc <RestoreNvmData+0xac>
        return LORAMAC_STATUS_NVM_DATA_INCONSISTENT;
 802c3d8:	2017      	movs	r0, #23
 802c3da:	e7b1      	b.n	802c340 <RestoreNvmData+0x10>
    crc = Crc32( ( uint8_t* ) &(NvmBackup.ClassB), sizeof( NvmBackup.ClassB ) -
 802c3dc:	4c22      	ldr	r4, [pc, #136]	; (802c468 <RestoreNvmData+0x138>)
 802c3de:	2114      	movs	r1, #20
 802c3e0:	0020      	movs	r0, r4
 802c3e2:	f005 feaf 	bl	8032144 <Crc32>
    if( crc != NvmBackup.ClassB.Crc32 )
 802c3e6:	4b21      	ldr	r3, [pc, #132]	; (802c46c <RestoreNvmData+0x13c>)
 802c3e8:	469c      	mov	ip, r3
 802c3ea:	4464      	add	r4, ip
 802c3ec:	239f      	movs	r3, #159	; 0x9f
 802c3ee:	00db      	lsls	r3, r3, #3
 802c3f0:	58e3      	ldr	r3, [r4, r3]
 802c3f2:	4283      	cmp	r3, r0
 802c3f4:	d001      	beq.n	802c3fa <RestoreNvmData+0xca>
        return LORAMAC_STATUS_NVM_DATA_INCONSISTENT;
 802c3f6:	2017      	movs	r0, #23
 802c3f8:	e7a2      	b.n	802c340 <RestoreNvmData+0x10>
    memcpy1( ( uint8_t* ) &Nvm, ( uint8_t* ) &NvmBackup, sizeof( LoRaMacNvmData_t ) );
 802c3fa:	4e1d      	ldr	r6, [pc, #116]	; (802c470 <RestoreNvmData+0x140>)
 802c3fc:	4d14      	ldr	r5, [pc, #80]	; (802c450 <RestoreNvmData+0x120>)
 802c3fe:	4c1d      	ldr	r4, [pc, #116]	; (802c474 <RestoreNvmData+0x144>)
 802c400:	0032      	movs	r2, r6
 802c402:	0029      	movs	r1, r5
 802c404:	0020      	movs	r0, r4
 802c406:	f005 fe7c 	bl	8032102 <memcpy1>
    memset1( ( uint8_t* ) &NvmBackup, 0, sizeof( LoRaMacNvmData_t ) );
 802c40a:	0032      	movs	r2, r6
 802c40c:	2100      	movs	r1, #0
 802c40e:	0028      	movs	r0, r5
 802c410:	f005 fe8f 	bl	8032132 <memset1>
    MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;
 802c414:	4b0d      	ldr	r3, [pc, #52]	; (802c44c <RestoreNvmData+0x11c>)
 802c416:	4a18      	ldr	r2, [pc, #96]	; (802c478 <RestoreNvmData+0x148>)
 802c418:	5c99      	ldrb	r1, [r3, r2]
 802c41a:	3a33      	subs	r2, #51	; 0x33
 802c41c:	5499      	strb	r1, [r3, r2]
    MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;
 802c41e:	3204      	adds	r2, #4
 802c420:	6f61      	ldr	r1, [r4, #116]	; 0x74
 802c422:	5099      	str	r1, [r3, r2]
    MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802c424:	227d      	movs	r2, #125	; 0x7d
 802c426:	5ca1      	ldrb	r1, [r4, r2]
 802c428:	22fe      	movs	r2, #254	; 0xfe
 802c42a:	0092      	lsls	r2, r2, #2
 802c42c:	5499      	strb	r1, [r3, r2]
    MacCtx.RxWindowCConfig.RxContinuous = true;
 802c42e:	4a13      	ldr	r2, [pc, #76]	; (802c47c <RestoreNvmData+0x14c>)
 802c430:	2101      	movs	r1, #1
 802c432:	5499      	strb	r1, [r3, r2]
    MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;
 802c434:	4a12      	ldr	r2, [pc, #72]	; (802c480 <RestoreNvmData+0x150>)
 802c436:	3101      	adds	r1, #1
 802c438:	5499      	strb	r1, [r3, r2]
    Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 802c43a:	4b12      	ldr	r3, [pc, #72]	; (802c484 <RestoreNvmData+0x154>)
 802c43c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 802c43e:	221a      	movs	r2, #26
 802c440:	32ff      	adds	r2, #255	; 0xff
 802c442:	5ca0      	ldrb	r0, [r4, r2]
 802c444:	4798      	blx	r3
    return LORAMAC_STATUS_OK;
 802c446:	2000      	movs	r0, #0
 802c448:	e77a      	b.n	802c340 <RestoreNvmData+0x10>
 802c44a:	46c0      	nop			; (mov r8, r8)
 802c44c:	2000bb1c 	.word	0x2000bb1c
 802c450:	2000a4fc 	.word	0x2000a4fc
 802c454:	2000a524 	.word	0x2000a524
 802c458:	2000a544 	.word	0x2000a544
 802c45c:	2000a648 	.word	0x2000a648
 802c460:	2000a650 	.word	0x2000a650
 802c464:	2000a664 	.word	0x2000a664
 802c468:	2000a9e0 	.word	0x2000a9e0
 802c46c:	fffffb1c 	.word	0xfffffb1c
 802c470:	000004fc 	.word	0x000004fc
 802c474:	2000a000 	.word	0x2000a000
 802c478:	0000041b 	.word	0x0000041b
 802c47c:	000003fa 	.word	0x000003fa
 802c480:	000003fb 	.word	0x000003fb
 802c484:	08035d8c 	.word	0x08035d8c

0802c488 <OnRadioRxTimeout>:
{
 802c488:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.RxTimeout = 1;
 802c48a:	4a07      	ldr	r2, [pc, #28]	; (802c4a8 <OnRadioRxTimeout+0x20>)
 802c48c:	7813      	ldrb	r3, [r2, #0]
 802c48e:	2102      	movs	r1, #2
 802c490:	430b      	orrs	r3, r1
 802c492:	7013      	strb	r3, [r2, #0]
    OnMacProcessNotify( );
 802c494:	f7fe f91e 	bl	802a6d4 <OnMacProcessNotify>
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxTimeOut\r\n" );
 802c498:	4b04      	ldr	r3, [pc, #16]	; (802c4ac <OnRadioRxTimeout+0x24>)
 802c49a:	2201      	movs	r2, #1
 802c49c:	2100      	movs	r1, #0
 802c49e:	2002      	movs	r0, #2
 802c4a0:	f007 fce6 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
}
 802c4a4:	bd10      	pop	{r4, pc}
 802c4a6:	46c0      	nop			; (mov r8, r8)
 802c4a8:	2000bb18 	.word	0x2000bb18
 802c4ac:	08035408 	.word	0x08035408

0802c4b0 <OnRadioTxTimeout>:
{
 802c4b0:	b510      	push	{r4, lr}
    LoRaMacRadioEvents.Events.TxTimeout = 1;
 802c4b2:	4a07      	ldr	r2, [pc, #28]	; (802c4d0 <OnRadioTxTimeout+0x20>)
 802c4b4:	7813      	ldrb	r3, [r2, #0]
 802c4b6:	2108      	movs	r1, #8
 802c4b8:	430b      	orrs	r3, r1
 802c4ba:	7013      	strb	r3, [r2, #0]
    OnMacProcessNotify( );
 802c4bc:	f7fe f90a 	bl	802a6d4 <OnMacProcessNotify>
    MW_LOG(TS_ON, VLEVEL_M, "MAC txTimeOut\r\n" );
 802c4c0:	4b04      	ldr	r3, [pc, #16]	; (802c4d4 <OnRadioTxTimeout+0x24>)
 802c4c2:	2201      	movs	r2, #1
 802c4c4:	2100      	movs	r1, #0
 802c4c6:	2002      	movs	r0, #2
 802c4c8:	f007 fcd2 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
}
 802c4cc:	bd10      	pop	{r4, pc}
 802c4ce:	46c0      	nop			; (mov r8, r8)
 802c4d0:	2000bb18 	.word	0x2000bb18
 802c4d4:	08035418 	.word	0x08035418

0802c4d8 <OnRadioRxDone>:
{
 802c4d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 802c4da:	46c6      	mov	lr, r8
 802c4dc:	b500      	push	{lr}
 802c4de:	4680      	mov	r8, r0
 802c4e0:	000f      	movs	r7, r1
 802c4e2:	0016      	movs	r6, r2
 802c4e4:	001d      	movs	r5, r3
    RxDoneParams.LastRxDone = TimerGetCurrentTime( );
 802c4e6:	f008 f815 	bl	8034514 <UTIL_TIMER_GetCurrentTime>
 802c4ea:	4c0d      	ldr	r4, [pc, #52]	; (802c520 <OnRadioRxDone+0x48>)
 802c4ec:	6020      	str	r0, [r4, #0]
    RxDoneParams.Payload = payload;
 802c4ee:	4643      	mov	r3, r8
 802c4f0:	6063      	str	r3, [r4, #4]
    RxDoneParams.Size = size;
 802c4f2:	8127      	strh	r7, [r4, #8]
    RxDoneParams.Rssi = rssi;
 802c4f4:	8166      	strh	r6, [r4, #10]
    RxDoneParams.Snr = snr;
 802c4f6:	7325      	strb	r5, [r4, #12]
    LoRaMacRadioEvents.Events.RxDone = 1;
 802c4f8:	4b0a      	ldr	r3, [pc, #40]	; (802c524 <OnRadioRxDone+0x4c>)
 802c4fa:	781a      	ldrb	r2, [r3, #0]
 802c4fc:	2110      	movs	r1, #16
 802c4fe:	430a      	orrs	r2, r1
 802c500:	701a      	strb	r2, [r3, #0]
    LoRaMacRadioEvents.Events.RxProcessPending = 1;
 802c502:	b2d2      	uxtb	r2, r2
 802c504:	2101      	movs	r1, #1
 802c506:	430a      	orrs	r2, r1
 802c508:	701a      	strb	r2, [r3, #0]
    OnMacProcessNotify( );
 802c50a:	f7fe f8e3 	bl	802a6d4 <OnMacProcessNotify>
    MW_LOG(TS_ON, VLEVEL_M, "MAC rxDone\r\n" );
 802c50e:	4b06      	ldr	r3, [pc, #24]	; (802c528 <OnRadioRxDone+0x50>)
 802c510:	2201      	movs	r2, #1
 802c512:	2100      	movs	r1, #0
 802c514:	2002      	movs	r0, #2
 802c516:	f007 fcab 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
}
 802c51a:	bc80      	pop	{r7}
 802c51c:	46b8      	mov	r8, r7
 802c51e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802c520:	2000c0c8 	.word	0x2000c0c8
 802c524:	2000bb18 	.word	0x2000bb18
 802c528:	08035428 	.word	0x08035428

0802c52c <OnRadioTxDone>:
{
 802c52c:	b510      	push	{r4, lr}
 802c52e:	b082      	sub	sp, #8
    TxDoneParams.CurTime = TimerGetCurrentTime( );
 802c530:	f007 fff0 	bl	8034514 <UTIL_TIMER_GetCurrentTime>
 802c534:	4b0d      	ldr	r3, [pc, #52]	; (802c56c <OnRadioTxDone+0x40>)
 802c536:	6018      	str	r0, [r3, #0]
    MacCtx.LastTxSysTime = SysTimeGet( );
 802c538:	466c      	mov	r4, sp
 802c53a:	0020      	movs	r0, r4
 802c53c:	f007 ff3c 	bl	80343b8 <SysTimeGet>
 802c540:	4b0b      	ldr	r3, [pc, #44]	; (802c570 <OnRadioTxDone+0x44>)
 802c542:	22ce      	movs	r2, #206	; 0xce
 802c544:	0092      	lsls	r2, r2, #2
 802c546:	4694      	mov	ip, r2
 802c548:	4463      	add	r3, ip
 802c54a:	cc06      	ldmia	r4!, {r1, r2}
 802c54c:	c306      	stmia	r3!, {r1, r2}
    LoRaMacRadioEvents.Events.TxDone = 1;
 802c54e:	4a09      	ldr	r2, [pc, #36]	; (802c574 <OnRadioTxDone+0x48>)
 802c550:	7813      	ldrb	r3, [r2, #0]
 802c552:	2120      	movs	r1, #32
 802c554:	430b      	orrs	r3, r1
 802c556:	7013      	strb	r3, [r2, #0]
    OnMacProcessNotify( );
 802c558:	f7fe f8bc 	bl	802a6d4 <OnMacProcessNotify>
    MW_LOG(TS_ON, VLEVEL_M, "MAC txDone\r\n" );
 802c55c:	4b06      	ldr	r3, [pc, #24]	; (802c578 <OnRadioTxDone+0x4c>)
 802c55e:	2201      	movs	r2, #1
 802c560:	2100      	movs	r1, #0
 802c562:	2002      	movs	r0, #2
 802c564:	f007 fc84 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
}
 802c568:	b002      	add	sp, #8
 802c56a:	bd10      	pop	{r4, pc}
 802c56c:	2000c0d8 	.word	0x2000c0d8
 802c570:	2000bb1c 	.word	0x2000bb1c
 802c574:	2000bb18 	.word	0x2000bb18
 802c578:	08035438 	.word	0x08035438

0802c57c <ResetMacParameters>:
{
 802c57c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802c57e:	46c6      	mov	lr, r8
 802c580:	b500      	push	{lr}
 802c582:	b090      	sub	sp, #64	; 0x40
    if( isRejoin == false )
 802c584:	2800      	cmp	r0, #0
 802c586:	d104      	bne.n	802c592 <ResetMacParameters+0x16>
        Nvm.MacGroup2.NetworkActivation = ACTIVATION_TYPE_NONE;
 802c588:	4a64      	ldr	r2, [pc, #400]	; (802c71c <ResetMacParameters+0x1a0>)
 802c58a:	2398      	movs	r3, #152	; 0x98
 802c58c:	005b      	lsls	r3, r3, #1
 802c58e:	2100      	movs	r1, #0
 802c590:	54d1      	strb	r1, [r2, r3]
    Nvm.MacGroup1.AdrAckCounter = 0;
 802c592:	4c62      	ldr	r4, [pc, #392]	; (802c71c <ResetMacParameters+0x1a0>)
 802c594:	2500      	movs	r5, #0
 802c596:	62a5      	str	r5, [r4, #40]	; 0x28
    MacCtx.ChannelsNbTransCounter = 0;
 802c598:	4e61      	ldr	r6, [pc, #388]	; (802c720 <ResetMacParameters+0x1a4>)
 802c59a:	2383      	movs	r3, #131	; 0x83
 802c59c:	00db      	lsls	r3, r3, #3
 802c59e:	54f5      	strb	r5, [r6, r3]
    MacCtx.RetransmitTimeoutRetry = false;
 802c5a0:	4b60      	ldr	r3, [pc, #384]	; (802c724 <ResetMacParameters+0x1a8>)
 802c5a2:	54f5      	strb	r5, [r6, r3]
    MacCtx.ResponseTimeoutStartTime = 0;
 802c5a4:	337f      	adds	r3, #127	; 0x7f
 802c5a6:	50f5      	str	r5, [r6, r3]
    Nvm.MacGroup2.MaxDCycle = 0;
 802c5a8:	231c      	movs	r3, #28
 802c5aa:	33ff      	adds	r3, #255	; 0xff
 802c5ac:	54e5      	strb	r5, [r4, r3]
    Nvm.MacGroup2.AggregatedDCycle = 1;
 802c5ae:	3305      	adds	r3, #5
 802c5b0:	2201      	movs	r2, #1
 802c5b2:	52e2      	strh	r2, [r4, r3]
    Nvm.MacGroup1.ChannelsTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 802c5b4:	3b44      	subs	r3, #68	; 0x44
 802c5b6:	56e2      	ldrsb	r2, [r4, r3]
 802c5b8:	3ba4      	subs	r3, #164	; 0xa4
 802c5ba:	54e2      	strb	r2, [r4, r3]
    Nvm.MacGroup1.ChannelsDatarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 802c5bc:	33a5      	adds	r3, #165	; 0xa5
 802c5be:	56e2      	ldrsb	r2, [r4, r3]
 802c5c0:	3ba4      	subs	r3, #164	; 0xa4
 802c5c2:	54e2      	strb	r2, [r4, r3]
    Nvm.MacGroup2.MacParams.Rx1DrOffset = Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset;
 802c5c4:	3378      	adds	r3, #120	; 0x78
 802c5c6:	5ce2      	ldrb	r2, [r4, r3]
 802c5c8:	3b48      	subs	r3, #72	; 0x48
 802c5ca:	54e2      	strb	r2, [r4, r3]
    Nvm.MacGroup2.MacParams.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 802c5cc:	0023      	movs	r3, r4
 802c5ce:	336c      	adds	r3, #108	; 0x6c
 802c5d0:	0022      	movs	r2, r4
 802c5d2:	32b4      	adds	r2, #180	; 0xb4
 802c5d4:	ca03      	ldmia	r2!, {r0, r1}
 802c5d6:	c303      	stmia	r3!, {r0, r1}
    Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 802c5d8:	0023      	movs	r3, r4
 802c5da:	3374      	adds	r3, #116	; 0x74
 802c5dc:	0022      	movs	r2, r4
 802c5de:	32bc      	adds	r2, #188	; 0xbc
 802c5e0:	ca03      	ldmia	r2!, {r0, r1}
 802c5e2:	c303      	stmia	r3!, {r0, r1}
    Nvm.MacGroup2.MacParams.UplinkDwellTime = Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime;
 802c5e4:	23c4      	movs	r3, #196	; 0xc4
 802c5e6:	5ce2      	ldrb	r2, [r4, r3]
 802c5e8:	3b48      	subs	r3, #72	; 0x48
 802c5ea:	54e2      	strb	r2, [r4, r3]
    Nvm.MacGroup2.MacParams.DownlinkDwellTime = Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime;
 802c5ec:	3349      	adds	r3, #73	; 0x49
 802c5ee:	5ce3      	ldrb	r3, [r4, r3]
 802c5f0:	227d      	movs	r2, #125	; 0x7d
 802c5f2:	4690      	mov	r8, r2
 802c5f4:	54a3      	strb	r3, [r4, r2]
    Nvm.MacGroup2.MacParams.MaxEirp = Nvm.MacGroup2.MacParamsDefaults.MaxEirp;
 802c5f6:	23c8      	movs	r3, #200	; 0xc8
 802c5f8:	58e2      	ldr	r2, [r4, r3]
 802c5fa:	3b48      	subs	r3, #72	; 0x48
 802c5fc:	50e2      	str	r2, [r4, r3]
    Nvm.MacGroup2.MacParams.AntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 802c5fe:	334c      	adds	r3, #76	; 0x4c
 802c600:	58e2      	ldr	r2, [r4, r3]
 802c602:	3b48      	subs	r3, #72	; 0x48
 802c604:	50e2      	str	r2, [r4, r3]
    Nvm.MacGroup2.MacParams.AdrAckLimit = Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit;
 802c606:	334c      	adds	r3, #76	; 0x4c
 802c608:	5ae2      	ldrh	r2, [r4, r3]
 802c60a:	3b48      	subs	r3, #72	; 0x48
 802c60c:	52e2      	strh	r2, [r4, r3]
    Nvm.MacGroup2.MacParams.AdrAckDelay = Nvm.MacGroup2.MacParamsDefaults.AdrAckDelay;
 802c60e:	334a      	adds	r3, #74	; 0x4a
 802c610:	5ae2      	ldrh	r2, [r4, r3]
 802c612:	3b48      	subs	r3, #72	; 0x48
 802c614:	52e2      	strh	r2, [r4, r3]
    MacCtx.NodeAckRequested = false;
 802c616:	4b44      	ldr	r3, [pc, #272]	; (802c728 <ResetMacParameters+0x1ac>)
 802c618:	54f5      	strb	r5, [r6, r3]
    Nvm.MacGroup1.SrvAckRequested = false;
 802c61a:	233a      	movs	r3, #58	; 0x3a
 802c61c:	54e5      	strb	r5, [r4, r3]
    Nvm.MacGroup2.ChannelsDatarateChangedLinkAdrReq = false;
 802c61e:	231e      	movs	r3, #30
 802c620:	33ff      	adds	r3, #255	; 0xff
 802c622:	54e5      	strb	r5, [r4, r3]
    Nvm.MacGroup2.DownlinkReceived = false;
 802c624:	3301      	adds	r3, #1
 802c626:	54e5      	strb	r5, [r4, r3]
    Nvm.MacGroup2.Rejoin0UplinksLimit = 0;
 802c628:	3316      	adds	r3, #22
 802c62a:	50e5      	str	r5, [r4, r3]
    Nvm.MacGroup2.ForceRejoinMaxRetries = 0;
 802c62c:	3304      	adds	r3, #4
 802c62e:	54e5      	strb	r5, [r4, r3]
    Nvm.MacGroup2.ForceRejoinType = 0;
 802c630:	233a      	movs	r3, #58	; 0x3a
 802c632:	33ff      	adds	r3, #255	; 0xff
 802c634:	54e5      	strb	r5, [r4, r3]
    Nvm.MacGroup2.Rejoin0CycleInSec = 0;
 802c636:	3303      	adds	r3, #3
 802c638:	50e5      	str	r5, [r4, r3]
    Nvm.MacGroup2.Rejoin1CycleInSec = 0;
 802c63a:	3304      	adds	r3, #4
 802c63c:	50e5      	str	r5, [r4, r3]
    Nvm.MacGroup2.IsRejoin0RequestQueued = 0;
 802c63e:	2346      	movs	r3, #70	; 0x46
 802c640:	33ff      	adds	r3, #255	; 0xff
 802c642:	54e5      	strb	r5, [r4, r3]
    Nvm.MacGroup2.IsRejoin1RequestQueued = 0;
 802c644:	3301      	adds	r3, #1
 802c646:	54e5      	strb	r5, [r4, r3]
    Nvm.MacGroup2.IsRejoin2RequestQueued = 0;
 802c648:	2348      	movs	r3, #72	; 0x48
 802c64a:	33ff      	adds	r3, #255	; 0xff
 802c64c:	54e5      	strb	r5, [r4, r3]
    params.Type = INIT_TYPE_RESET_TO_DEFAULT_CHANNELS;
 802c64e:	a901      	add	r1, sp, #4
 802c650:	2701      	movs	r7, #1
 802c652:	2301      	movs	r3, #1
 802c654:	730b      	strb	r3, [r1, #12]
    params.NvmGroup1 = &Nvm.RegionGroup1;
 802c656:	0023      	movs	r3, r4
 802c658:	3355      	adds	r3, #85	; 0x55
 802c65a:	33ff      	adds	r3, #255	; 0xff
 802c65c:	9301      	str	r3, [sp, #4]
    params.NvmGroup2 = &Nvm.RegionGroup2;
 802c65e:	0023      	movs	r3, r4
 802c660:	3369      	adds	r3, #105	; 0x69
 802c662:	33ff      	adds	r3, #255	; 0xff
 802c664:	604b      	str	r3, [r1, #4]
    params.Bands = &RegionBands;
 802c666:	4b31      	ldr	r3, [pc, #196]	; (802c72c <ResetMacParameters+0x1b0>)
 802c668:	608b      	str	r3, [r1, #8]
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 802c66a:	2348      	movs	r3, #72	; 0x48
 802c66c:	5ce0      	ldrb	r0, [r4, r3]
 802c66e:	f002 fce4 	bl	802f03a <RegionInitDefaults>
    MacCtx.Channel = 0;
 802c672:	4b2f      	ldr	r3, [pc, #188]	; (802c730 <ResetMacParameters+0x1b4>)
 802c674:	54f5      	strb	r5, [r6, r3]
    MacCtx.RxWindow2Config.Channel = MacCtx.Channel;
 802c676:	3b4b      	subs	r3, #75	; 0x4b
 802c678:	54f5      	strb	r5, [r6, r3]
    MacCtx.RxWindow2Config.Frequency = Nvm.MacGroup2.MacParams.Rx2Channel.Frequency;
 802c67a:	3304      	adds	r3, #4
 802c67c:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 802c67e:	50f2      	str	r2, [r6, r3]
    MacCtx.RxWindow2Config.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802c680:	4643      	mov	r3, r8
 802c682:	5ce2      	ldrb	r2, [r4, r3]
 802c684:	23f8      	movs	r3, #248	; 0xf8
 802c686:	009b      	lsls	r3, r3, #2
 802c688:	54f2      	strb	r2, [r6, r3]
    MacCtx.RxWindow2Config.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 802c68a:	238c      	movs	r3, #140	; 0x8c
 802c68c:	5ce2      	ldrb	r2, [r4, r3]
 802c68e:	4b29      	ldr	r3, [pc, #164]	; (802c734 <ResetMacParameters+0x1b8>)
 802c690:	54f2      	strb	r2, [r6, r3]
    MacCtx.RxWindow2Config.RxContinuous = false;
 802c692:	4b29      	ldr	r3, [pc, #164]	; (802c738 <ResetMacParameters+0x1bc>)
 802c694:	54f5      	strb	r5, [r6, r3]
    MacCtx.RxWindow2Config.RxSlot = RX_SLOT_WIN_2;
 802c696:	4b29      	ldr	r3, [pc, #164]	; (802c73c <ResetMacParameters+0x1c0>)
 802c698:	54f7      	strb	r7, [r6, r3]
    MacCtx.RxWindow2Config.NetworkActivation = Nvm.MacGroup2.NetworkActivation;
 802c69a:	2398      	movs	r3, #152	; 0x98
 802c69c:	005b      	lsls	r3, r3, #1
 802c69e:	5ce2      	ldrb	r2, [r4, r3]
 802c6a0:	23f9      	movs	r3, #249	; 0xf9
 802c6a2:	009b      	lsls	r3, r3, #2
 802c6a4:	54f2      	strb	r2, [r6, r3]
    MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 802c6a6:	3304      	adds	r3, #4
 802c6a8:	18f3      	adds	r3, r6, r3
 802c6aa:	22f4      	movs	r2, #244	; 0xf4
 802c6ac:	0092      	lsls	r2, r2, #2
 802c6ae:	18b2      	adds	r2, r6, r2
 802c6b0:	ca13      	ldmia	r2!, {r0, r1, r4}
 802c6b2:	c313      	stmia	r3!, {r0, r1, r4}
 802c6b4:	ca13      	ldmia	r2!, {r0, r1, r4}
 802c6b6:	c313      	stmia	r3!, {r0, r1, r4}
    MacCtx.RxWindowCConfig.RxContinuous = true;
 802c6b8:	4b21      	ldr	r3, [pc, #132]	; (802c740 <ResetMacParameters+0x1c4>)
 802c6ba:	54f7      	strb	r7, [r6, r3]
    MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;
 802c6bc:	4b21      	ldr	r3, [pc, #132]	; (802c744 <ResetMacParameters+0x1c8>)
 802c6be:	2202      	movs	r2, #2
 802c6c0:	54f2      	strb	r2, [r6, r3]
    classBCallbacks.GetTemperatureLevel = NULL;
 802c6c2:	950e      	str	r5, [sp, #56]	; 0x38
    classBCallbacks.MacProcessNotify = NULL;
 802c6c4:	950f      	str	r5, [sp, #60]	; 0x3c
    if( MacCtx.MacCallbacks != NULL )
 802c6c6:	3bb3      	subs	r3, #179	; 0xb3
 802c6c8:	58f3      	ldr	r3, [r6, r3]
 802c6ca:	2b00      	cmp	r3, #0
 802c6cc:	d003      	beq.n	802c6d6 <ResetMacParameters+0x15a>
        classBCallbacks.GetTemperatureLevel = MacCtx.MacCallbacks->GetTemperatureLevel;
 802c6ce:	685a      	ldr	r2, [r3, #4]
 802c6d0:	920e      	str	r2, [sp, #56]	; 0x38
        classBCallbacks.MacProcessNotify = MacCtx.MacCallbacks->MacProcessNotify;
 802c6d2:	695b      	ldr	r3, [r3, #20]
 802c6d4:	930f      	str	r3, [sp, #60]	; 0x3c
    classBParams.MlmeIndication = &MacCtx.MlmeIndication;
 802c6d6:	4b1c      	ldr	r3, [pc, #112]	; (802c748 <ResetMacParameters+0x1cc>)
 802c6d8:	9305      	str	r3, [sp, #20]
    classBParams.McpsIndication = &MacCtx.McpsIndication;
 802c6da:	001a      	movs	r2, r3
 802c6dc:	3a48      	subs	r2, #72	; 0x48
 802c6de:	9206      	str	r2, [sp, #24]
    classBParams.MlmeConfirm = &MacCtx.MlmeConfirm;
 802c6e0:	001a      	movs	r2, r3
 802c6e2:	3a14      	subs	r2, #20
 802c6e4:	9207      	str	r2, [sp, #28]
    classBParams.LoRaMacFlags = &MacCtx.MacFlags;
 802c6e6:	3329      	adds	r3, #41	; 0x29
 802c6e8:	9308      	str	r3, [sp, #32]
    classBParams.LoRaMacDevAddr = &Nvm.MacGroup2.DevAddr;
 802c6ea:	4a18      	ldr	r2, [pc, #96]	; (802c74c <ResetMacParameters+0x1d0>)
 802c6ec:	9209      	str	r2, [sp, #36]	; 0x24
    classBParams.LoRaMacRegion = &Nvm.MacGroup2.Region;
 802c6ee:	0013      	movs	r3, r2
 802c6f0:	3b9c      	subs	r3, #156	; 0x9c
 802c6f2:	930a      	str	r3, [sp, #40]	; 0x28
    classBParams.LoRaMacParams = &Nvm.MacGroup2.MacParams;
 802c6f4:	0013      	movs	r3, r2
 802c6f6:	3b98      	subs	r3, #152	; 0x98
 802c6f8:	930b      	str	r3, [sp, #44]	; 0x2c
    classBParams.MulticastChannels = &Nvm.MacGroup2.MulticastChannelList[0];
 802c6fa:	1d13      	adds	r3, r2, #4
 802c6fc:	930c      	str	r3, [sp, #48]	; 0x30
    classBParams.NetworkActivation = &Nvm.MacGroup2.NetworkActivation;
 802c6fe:	0013      	movs	r3, r2
 802c700:	334c      	adds	r3, #76	; 0x4c
 802c702:	930d      	str	r3, [sp, #52]	; 0x34
    LoRaMacClassBInit( &classBParams, &classBCallbacks, &Nvm.ClassB );
 802c704:	2380      	movs	r3, #128	; 0x80
 802c706:	00db      	lsls	r3, r3, #3
 802c708:	469c      	mov	ip, r3
 802c70a:	4462      	add	r2, ip
 802c70c:	a90e      	add	r1, sp, #56	; 0x38
 802c70e:	a805      	add	r0, sp, #20
 802c710:	f001 fc1d 	bl	802df4e <LoRaMacClassBInit>
}
 802c714:	b010      	add	sp, #64	; 0x40
 802c716:	bc80      	pop	{r7}
 802c718:	46b8      	mov	r8, r7
 802c71a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802c71c:	2000a000 	.word	0x2000a000
 802c720:	2000bb1c 	.word	0x2000bb1c
 802c724:	00000419 	.word	0x00000419
 802c728:	0000041a 	.word	0x0000041a
 802c72c:	2000c038 	.word	0x2000c038
 802c730:	0000041b 	.word	0x0000041b
 802c734:	000003e1 	.word	0x000003e1
 802c738:	000003e2 	.word	0x000003e2
 802c73c:	000003e3 	.word	0x000003e3
 802c740:	000003fa 	.word	0x000003fa
 802c744:	000003fb 	.word	0x000003fb
 802c748:	2000bf84 	.word	0x2000bf84
 802c74c:	2000a0e4 	.word	0x2000a0e4

0802c750 <SwitchClass>:
{
 802c750:	b570      	push	{r4, r5, r6, lr}
 802c752:	0004      	movs	r4, r0
    switch( Nvm.MacGroup2.DeviceClass )
 802c754:	4a4e      	ldr	r2, [pc, #312]	; (802c890 <SwitchClass+0x140>)
 802c756:	238c      	movs	r3, #140	; 0x8c
 802c758:	005b      	lsls	r3, r3, #1
 802c75a:	5cd5      	ldrb	r5, [r2, r3]
 802c75c:	2d01      	cmp	r5, #1
 802c75e:	d100      	bne.n	802c762 <SwitchClass+0x12>
 802c760:	e07a      	b.n	802c858 <SwitchClass+0x108>
 802c762:	2d02      	cmp	r5, #2
 802c764:	d100      	bne.n	802c768 <SwitchClass+0x18>
 802c766:	e081      	b.n	802c86c <SwitchClass+0x11c>
 802c768:	2d00      	cmp	r5, #0
 802c76a:	d001      	beq.n	802c770 <SwitchClass+0x20>
 802c76c:	2003      	movs	r0, #3
}
 802c76e:	bd70      	pop	{r4, r5, r6, pc}
            if( deviceClass == CLASS_A )
 802c770:	2800      	cmp	r0, #0
 802c772:	d129      	bne.n	802c7c8 <SwitchClass+0x78>
                Nvm.MacGroup2.MacParams.RxCChannel = Nvm.MacGroup2.MacParams.Rx2Channel;
 802c774:	0013      	movs	r3, r2
 802c776:	3274      	adds	r2, #116	; 0x74
 802c778:	336c      	adds	r3, #108	; 0x6c
 802c77a:	cb03      	ldmia	r3!, {r0, r1}
 802c77c:	c203      	stmia	r2!, {r0, r1}
                status = LORAMAC_STATUS_OK;
 802c77e:	0020      	movs	r0, r4
            if( deviceClass == CLASS_B )
 802c780:	2c01      	cmp	r4, #1
 802c782:	d023      	beq.n	802c7cc <SwitchClass+0x7c>
            if( deviceClass == CLASS_C )
 802c784:	2c02      	cmp	r4, #2
 802c786:	d1f2      	bne.n	802c76e <SwitchClass+0x1e>
                Nvm.MacGroup2.DeviceClass = deviceClass;
 802c788:	4a41      	ldr	r2, [pc, #260]	; (802c890 <SwitchClass+0x140>)
 802c78a:	238c      	movs	r3, #140	; 0x8c
 802c78c:	005b      	lsls	r3, r3, #1
 802c78e:	54d4      	strb	r4, [r2, r3]
                MacCtx.RxWindowCConfig = MacCtx.RxWindow2Config;
 802c790:	4940      	ldr	r1, [pc, #256]	; (802c894 <SwitchClass+0x144>)
 802c792:	23fa      	movs	r3, #250	; 0xfa
 802c794:	009b      	lsls	r3, r3, #2
 802c796:	18cb      	adds	r3, r1, r3
 802c798:	22f4      	movs	r2, #244	; 0xf4
 802c79a:	0092      	lsls	r2, r2, #2
 802c79c:	188a      	adds	r2, r1, r2
 802c79e:	ca51      	ldmia	r2!, {r0, r4, r6}
 802c7a0:	c351      	stmia	r3!, {r0, r4, r6}
 802c7a2:	ca51      	ldmia	r2!, {r0, r4, r6}
 802c7a4:	c351      	stmia	r3!, {r0, r4, r6}
                MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C;
 802c7a6:	4b3c      	ldr	r3, [pc, #240]	; (802c898 <SwitchClass+0x148>)
 802c7a8:	2202      	movs	r2, #2
 802c7aa:	54ca      	strb	r2, [r1, r3]
                for( int8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 802c7ac:	2300      	movs	r3, #0
 802c7ae:	2b00      	cmp	r3, #0
 802c7b0:	dd16      	ble.n	802c7e0 <SwitchClass+0x90>
                MacCtx.NodeAckRequested = false;
 802c7b2:	4a38      	ldr	r2, [pc, #224]	; (802c894 <SwitchClass+0x144>)
 802c7b4:	4b39      	ldr	r3, [pc, #228]	; (802c89c <SwitchClass+0x14c>)
 802c7b6:	2100      	movs	r1, #0
 802c7b8:	54d1      	strb	r1, [r2, r3]
                Radio.Sleep( );
 802c7ba:	4b39      	ldr	r3, [pc, #228]	; (802c8a0 <SwitchClass+0x150>)
 802c7bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802c7be:	4798      	blx	r3
                OpenContinuousRxCWindow( );
 802c7c0:	f7ff fc56 	bl	802c070 <OpenContinuousRxCWindow>
                status = LORAMAC_STATUS_OK;
 802c7c4:	0028      	movs	r0, r5
 802c7c6:	e7d2      	b.n	802c76e <SwitchClass+0x1e>
    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;
 802c7c8:	2003      	movs	r0, #3
 802c7ca:	e7d9      	b.n	802c780 <SwitchClass+0x30>
                status = LoRaMacClassBSwitchClass( deviceClass );
 802c7cc:	0020      	movs	r0, r4
 802c7ce:	f001 fbd4 	bl	802df7a <LoRaMacClassBSwitchClass>
                if( status == LORAMAC_STATUS_OK )
 802c7d2:	2800      	cmp	r0, #0
 802c7d4:	d1d6      	bne.n	802c784 <SwitchClass+0x34>
                    Nvm.MacGroup2.DeviceClass = deviceClass;
 802c7d6:	4a2e      	ldr	r2, [pc, #184]	; (802c890 <SwitchClass+0x140>)
 802c7d8:	238c      	movs	r3, #140	; 0x8c
 802c7da:	005b      	lsls	r3, r3, #1
 802c7dc:	54d4      	strb	r4, [r2, r3]
 802c7de:	e7d1      	b.n	802c784 <SwitchClass+0x34>
                    if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true ) &&
 802c7e0:	0018      	movs	r0, r3
 802c7e2:	005a      	lsls	r2, r3, #1
 802c7e4:	18d2      	adds	r2, r2, r3
 802c7e6:	0111      	lsls	r1, r2, #4
 802c7e8:	4a29      	ldr	r2, [pc, #164]	; (802c890 <SwitchClass+0x140>)
 802c7ea:	1852      	adds	r2, r2, r1
 802c7ec:	32e9      	adds	r2, #233	; 0xe9
 802c7ee:	7812      	ldrb	r2, [r2, #0]
 802c7f0:	2a00      	cmp	r2, #0
 802c7f2:	d006      	beq.n	802c802 <SwitchClass+0xb2>
                        ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.Class == CLASS_C ) )
 802c7f4:	4a26      	ldr	r2, [pc, #152]	; (802c890 <SwitchClass+0x140>)
 802c7f6:	1852      	adds	r2, r2, r1
 802c7f8:	3201      	adds	r2, #1
 802c7fa:	32ff      	adds	r2, #255	; 0xff
 802c7fc:	7812      	ldrb	r2, [r2, #0]
                    if( ( Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.IsEnabled == true ) &&
 802c7fe:	2a02      	cmp	r2, #2
 802c800:	d002      	beq.n	802c808 <SwitchClass+0xb8>
                for( int8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 802c802:	3301      	adds	r3, #1
 802c804:	b25b      	sxtb	r3, r3
 802c806:	e7d2      	b.n	802c7ae <SwitchClass+0x5e>
                        Nvm.MacGroup2.MacParams.RxCChannel.Frequency = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.Params.ClassC.Frequency;
 802c808:	4921      	ldr	r1, [pc, #132]	; (802c890 <SwitchClass+0x140>)
 802c80a:	005b      	lsls	r3, r3, #1
 802c80c:	181a      	adds	r2, r3, r0
 802c80e:	0112      	lsls	r2, r2, #4
 802c810:	188a      	adds	r2, r1, r2
 802c812:	3205      	adds	r2, #5
 802c814:	32ff      	adds	r2, #255	; 0xff
 802c816:	6812      	ldr	r2, [r2, #0]
 802c818:	674a      	str	r2, [r1, #116]	; 0x74
                        Nvm.MacGroup2.MacParams.RxCChannel.Datarate = Nvm.MacGroup2.MulticastChannelList[i].ChannelParams.RxParams.Params.ClassC.Datarate;
 802c81a:	181b      	adds	r3, r3, r0
 802c81c:	011b      	lsls	r3, r3, #4
 802c81e:	18cb      	adds	r3, r1, r3
 802c820:	3309      	adds	r3, #9
 802c822:	33ff      	adds	r3, #255	; 0xff
 802c824:	7818      	ldrb	r0, [r3, #0]
 802c826:	2378      	movs	r3, #120	; 0x78
 802c828:	54c8      	strb	r0, [r1, r3]
                        MacCtx.RxWindowCConfig.Channel = MacCtx.Channel;
 802c82a:	4b1a      	ldr	r3, [pc, #104]	; (802c894 <SwitchClass+0x144>)
 802c82c:	481d      	ldr	r0, [pc, #116]	; (802c8a4 <SwitchClass+0x154>)
 802c82e:	5c1c      	ldrb	r4, [r3, r0]
 802c830:	3833      	subs	r0, #51	; 0x33
 802c832:	541c      	strb	r4, [r3, r0]
                        MacCtx.RxWindowCConfig.Frequency = Nvm.MacGroup2.MacParams.RxCChannel.Frequency;
 802c834:	3004      	adds	r0, #4
 802c836:	501a      	str	r2, [r3, r0]
                        MacCtx.RxWindowCConfig.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802c838:	227d      	movs	r2, #125	; 0x7d
 802c83a:	5c88      	ldrb	r0, [r1, r2]
 802c83c:	22fe      	movs	r2, #254	; 0xfe
 802c83e:	0092      	lsls	r2, r2, #2
 802c840:	5498      	strb	r0, [r3, r2]
                        MacCtx.RxWindowCConfig.RepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 802c842:	228c      	movs	r2, #140	; 0x8c
 802c844:	5c89      	ldrb	r1, [r1, r2]
 802c846:	4a18      	ldr	r2, [pc, #96]	; (802c8a8 <SwitchClass+0x158>)
 802c848:	5499      	strb	r1, [r3, r2]
                        MacCtx.RxWindowCConfig.RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST;
 802c84a:	4a13      	ldr	r2, [pc, #76]	; (802c898 <SwitchClass+0x148>)
 802c84c:	2103      	movs	r1, #3
 802c84e:	5499      	strb	r1, [r3, r2]
                        MacCtx.RxWindowCConfig.RxContinuous = true;
 802c850:	4a16      	ldr	r2, [pc, #88]	; (802c8ac <SwitchClass+0x15c>)
 802c852:	3902      	subs	r1, #2
 802c854:	5499      	strb	r1, [r3, r2]
                        break;
 802c856:	e7ac      	b.n	802c7b2 <SwitchClass+0x62>
            status = LoRaMacClassBSwitchClass( deviceClass );
 802c858:	f001 fb8f 	bl	802df7a <LoRaMacClassBSwitchClass>
            if( status == LORAMAC_STATUS_OK )
 802c85c:	2800      	cmp	r0, #0
 802c85e:	d000      	beq.n	802c862 <SwitchClass+0x112>
 802c860:	e785      	b.n	802c76e <SwitchClass+0x1e>
                Nvm.MacGroup2.DeviceClass = deviceClass;
 802c862:	4a0b      	ldr	r2, [pc, #44]	; (802c890 <SwitchClass+0x140>)
 802c864:	238c      	movs	r3, #140	; 0x8c
 802c866:	005b      	lsls	r3, r3, #1
 802c868:	54d4      	strb	r4, [r2, r3]
 802c86a:	e780      	b.n	802c76e <SwitchClass+0x1e>
            if( deviceClass == CLASS_A )
 802c86c:	2800      	cmp	r0, #0
 802c86e:	d10d      	bne.n	802c88c <SwitchClass+0x13c>
                MacCtx.RxSlot = RX_SLOT_NONE;
 802c870:	4a08      	ldr	r2, [pc, #32]	; (802c894 <SwitchClass+0x144>)
 802c872:	2392      	movs	r3, #146	; 0x92
 802c874:	00db      	lsls	r3, r3, #3
 802c876:	2106      	movs	r1, #6
 802c878:	54d1      	strb	r1, [r2, r3]
                Nvm.MacGroup2.DeviceClass = deviceClass;
 802c87a:	4a05      	ldr	r2, [pc, #20]	; (802c890 <SwitchClass+0x140>)
 802c87c:	238c      	movs	r3, #140	; 0x8c
 802c87e:	005b      	lsls	r3, r3, #1
 802c880:	54d0      	strb	r0, [r2, r3]
                Radio.Sleep( );
 802c882:	4b07      	ldr	r3, [pc, #28]	; (802c8a0 <SwitchClass+0x150>)
 802c884:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802c886:	4798      	blx	r3
                status = LORAMAC_STATUS_OK;
 802c888:	0020      	movs	r0, r4
 802c88a:	e770      	b.n	802c76e <SwitchClass+0x1e>
    LoRaMacStatus_t status = LORAMAC_STATUS_PARAMETER_INVALID;
 802c88c:	2003      	movs	r0, #3
 802c88e:	e76e      	b.n	802c76e <SwitchClass+0x1e>
 802c890:	2000a000 	.word	0x2000a000
 802c894:	2000bb1c 	.word	0x2000bb1c
 802c898:	000003fb 	.word	0x000003fb
 802c89c:	0000041a 	.word	0x0000041a
 802c8a0:	08035d8c 	.word	0x08035d8c
 802c8a4:	0000041b 	.word	0x0000041b
 802c8a8:	000003f9 	.word	0x000003f9
 802c8ac:	000003fa 	.word	0x000003fa

0802c8b0 <SendReJoinReq>:
{
 802c8b0:	b510      	push	{r4, lr}
    switch( joinReqType )
 802c8b2:	28ff      	cmp	r0, #255	; 0xff
 802c8b4:	d003      	beq.n	802c8be <SendReJoinReq+0xe>
    bool allowDelayedTx = true;
 802c8b6:	2001      	movs	r0, #1
    status = ScheduleTx( allowDelayedTx );
 802c8b8:	f7ff fa7a 	bl	802bdb0 <ScheduleTx>
}
 802c8bc:	bd10      	pop	{r4, pc}
            SwitchClass( CLASS_A );
 802c8be:	2000      	movs	r0, #0
 802c8c0:	f7ff ff46 	bl	802c750 <SwitchClass>
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_JOIN_REQUEST;
 802c8c4:	4c0c      	ldr	r4, [pc, #48]	; (802c8f8 <SendReJoinReq+0x48>)
 802c8c6:	2300      	movs	r3, #0
 802c8c8:	2282      	movs	r2, #130	; 0x82
 802c8ca:	0052      	lsls	r2, r2, #1
 802c8cc:	54a3      	strb	r3, [r4, r2]
            MacCtx.TxMsg.Message.JoinReq.Buffer = MacCtx.PktBuffer;
 802c8ce:	1ca1      	adds	r1, r4, #2
 802c8d0:	3204      	adds	r2, #4
 802c8d2:	50a1      	str	r1, [r4, r2]
            MacCtx.TxMsg.Message.JoinReq.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 802c8d4:	3204      	adds	r2, #4
 802c8d6:	21ff      	movs	r1, #255	; 0xff
 802c8d8:	54a1      	strb	r1, [r4, r2]
            MacCtx.TxMsg.Message.JoinReq.MHDR.Value = macHdr.Value;
 802c8da:	220e      	movs	r2, #14
 802c8dc:	32ff      	adds	r2, #255	; 0xff
 802c8de:	54a3      	strb	r3, [r4, r2]
            SecureElementGetJoinEui( MacCtx.TxMsg.Message.JoinReq.JoinEUI );
 802c8e0:	0020      	movs	r0, r4
 802c8e2:	300f      	adds	r0, #15
 802c8e4:	30ff      	adds	r0, #255	; 0xff
 802c8e6:	f005 faeb 	bl	8031ec0 <SecureElementGetJoinEui>
            SecureElementGetDevEui( MacCtx.TxMsg.Message.JoinReq.DevEUI );
 802c8ea:	0020      	movs	r0, r4
 802c8ec:	3017      	adds	r0, #23
 802c8ee:	30ff      	adds	r0, #255	; 0xff
 802c8f0:	f005 fab1 	bl	8031e56 <SecureElementGetDevEui>
            allowDelayedTx = false;
 802c8f4:	2000      	movs	r0, #0
            break;
 802c8f6:	e7df      	b.n	802c8b8 <SendReJoinReq+0x8>
 802c8f8:	2000bb1c 	.word	0x2000bb1c

0802c8fc <PrepareFrame>:
{
 802c8fc:	b5f0      	push	{r4, r5, r6, r7, lr}
 802c8fe:	b085      	sub	sp, #20
 802c900:	0007      	movs	r7, r0
 802c902:	9100      	str	r1, [sp, #0]
 802c904:	9201      	str	r2, [sp, #4]
 802c906:	001e      	movs	r6, r3
 802c908:	ab0a      	add	r3, sp, #40	; 0x28
 802c90a:	881c      	ldrh	r4, [r3, #0]
    MacCtx.PktBufferLen = 0;
 802c90c:	4a63      	ldr	r2, [pc, #396]	; (802ca9c <PrepareFrame+0x1a0>)
 802c90e:	2300      	movs	r3, #0
 802c910:	8013      	strh	r3, [r2, #0]
    MacCtx.NodeAckRequested = false;
 802c912:	2000      	movs	r0, #0
 802c914:	4962      	ldr	r1, [pc, #392]	; (802caa0 <PrepareFrame+0x1a4>)
 802c916:	5450      	strb	r0, [r2, r1]
    uint32_t fCntUp = 0;
 802c918:	9303      	str	r3, [sp, #12]
    size_t macCmdsSize = 0;
 802c91a:	9302      	str	r3, [sp, #8]
    if( fBuffer == NULL )
 802c91c:	2e00      	cmp	r6, #0
 802c91e:	d019      	beq.n	802c954 <PrepareFrame+0x58>
    memcpy1( MacCtx.AppData, ( uint8_t* ) fBuffer, fBufferSize );
 802c920:	4d60      	ldr	r5, [pc, #384]	; (802caa4 <PrepareFrame+0x1a8>)
 802c922:	0022      	movs	r2, r4
 802c924:	0031      	movs	r1, r6
 802c926:	0028      	movs	r0, r5
 802c928:	f005 fbeb 	bl	8032102 <memcpy1>
    MacCtx.AppDataSize = fBufferSize;
 802c92c:	b2e0      	uxtb	r0, r4
 802c92e:	002b      	movs	r3, r5
 802c930:	3b39      	subs	r3, #57	; 0x39
 802c932:	3bff      	subs	r3, #255	; 0xff
 802c934:	4a5c      	ldr	r2, [pc, #368]	; (802caa8 <PrepareFrame+0x1ac>)
 802c936:	5498      	strb	r0, [r3, r2]
    MacCtx.PktBuffer[0] = macHdr->Value;
 802c938:	783a      	ldrb	r2, [r7, #0]
 802c93a:	709a      	strb	r2, [r3, #2]
    switch( macHdr->Bits.MType )
 802c93c:	783a      	ldrb	r2, [r7, #0]
 802c93e:	0952      	lsrs	r2, r2, #5
 802c940:	2a04      	cmp	r2, #4
 802c942:	d009      	beq.n	802c958 <PrepareFrame+0x5c>
 802c944:	2a07      	cmp	r2, #7
 802c946:	d100      	bne.n	802c94a <PrepareFrame+0x4e>
 802c948:	e08a      	b.n	802ca60 <PrepareFrame+0x164>
 802c94a:	2a02      	cmp	r2, #2
 802c94c:	d008      	beq.n	802c960 <PrepareFrame+0x64>
 802c94e:	2002      	movs	r0, #2
}
 802c950:	b005      	add	sp, #20
 802c952:	bdf0      	pop	{r4, r5, r6, r7, pc}
        fBufferSize = 0;
 802c954:	2400      	movs	r4, #0
 802c956:	e7e3      	b.n	802c920 <PrepareFrame+0x24>
            MacCtx.NodeAckRequested = true;
 802c958:	4a50      	ldr	r2, [pc, #320]	; (802ca9c <PrepareFrame+0x1a0>)
 802c95a:	4b51      	ldr	r3, [pc, #324]	; (802caa0 <PrepareFrame+0x1a4>)
 802c95c:	2101      	movs	r1, #1
 802c95e:	54d1      	strb	r1, [r2, r3]
            MacCtx.TxMsg.Type = LORAMAC_MSG_TYPE_DATA;
 802c960:	4b4e      	ldr	r3, [pc, #312]	; (802ca9c <PrepareFrame+0x1a0>)
 802c962:	2282      	movs	r2, #130	; 0x82
 802c964:	0052      	lsls	r2, r2, #1
 802c966:	2104      	movs	r1, #4
 802c968:	5499      	strb	r1, [r3, r2]
            MacCtx.TxMsg.Message.Data.Buffer = MacCtx.PktBuffer;
 802c96a:	1c99      	adds	r1, r3, #2
 802c96c:	3204      	adds	r2, #4
 802c96e:	5099      	str	r1, [r3, r2]
            MacCtx.TxMsg.Message.Data.BufSize = LORAMAC_PHY_MAXPAYLOAD;
 802c970:	3204      	adds	r2, #4
 802c972:	21ff      	movs	r1, #255	; 0xff
 802c974:	5499      	strb	r1, [r3, r2]
            MacCtx.TxMsg.Message.Data.MHDR.Value = macHdr->Value;
 802c976:	7839      	ldrb	r1, [r7, #0]
 802c978:	220e      	movs	r2, #14
 802c97a:	32ff      	adds	r2, #255	; 0xff
 802c97c:	5499      	strb	r1, [r3, r2]
            MacCtx.TxMsg.Message.Data.FPort = fPort;
 802c97e:	321b      	adds	r2, #27
 802c980:	9901      	ldr	r1, [sp, #4]
 802c982:	5499      	strb	r1, [r3, r2]
            MacCtx.TxMsg.Message.Data.FHDR.DevAddr = Nvm.MacGroup2.DevAddr;
 802c984:	4949      	ldr	r1, [pc, #292]	; (802caac <PrepareFrame+0x1b0>)
 802c986:	3a44      	subs	r2, #68	; 0x44
 802c988:	5889      	ldr	r1, [r1, r2]
 802c98a:	322c      	adds	r2, #44	; 0x2c
 802c98c:	5099      	str	r1, [r3, r2]
            MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 802c98e:	9a00      	ldr	r2, [sp, #0]
 802c990:	7811      	ldrb	r1, [r2, #0]
 802c992:	228a      	movs	r2, #138	; 0x8a
 802c994:	0052      	lsls	r2, r2, #1
 802c996:	5499      	strb	r1, [r3, r2]
            MacCtx.TxMsg.Message.Data.FRMPayloadSize = MacCtx.AppDataSize;
 802c998:	321c      	adds	r2, #28
 802c99a:	5498      	strb	r0, [r3, r2]
            MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.AppData;
 802c99c:	0019      	movs	r1, r3
 802c99e:	3139      	adds	r1, #57	; 0x39
 802c9a0:	31ff      	adds	r1, #255	; 0xff
 802c9a2:	3a04      	subs	r2, #4
 802c9a4:	5099      	str	r1, [r3, r2]
            if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoGetFCntUp( &fCntUp ) )
 802c9a6:	a803      	add	r0, sp, #12
 802c9a8:	f001 ffa4 	bl	802e8f4 <LoRaMacCryptoGetFCntUp>
 802c9ac:	2800      	cmp	r0, #0
 802c9ae:	d169      	bne.n	802ca84 <PrepareFrame+0x188>
            MacCtx.TxMsg.Message.Data.FHDR.FCnt = ( uint16_t )fCntUp;
 802c9b0:	9a03      	ldr	r2, [sp, #12]
 802c9b2:	4b3a      	ldr	r3, [pc, #232]	; (802ca9c <PrepareFrame+0x1a0>)
 802c9b4:	218b      	movs	r1, #139	; 0x8b
 802c9b6:	0049      	lsls	r1, r1, #1
 802c9b8:	525a      	strh	r2, [r3, r1]
            MacCtx.McpsConfirm.NbTrans = 0;
 802c9ba:	2100      	movs	r1, #0
 802c9bc:	483c      	ldr	r0, [pc, #240]	; (802cab0 <PrepareFrame+0x1b4>)
 802c9be:	5419      	strb	r1, [r3, r0]
            MacCtx.McpsConfirm.AckReceived = false;
 802c9c0:	483c      	ldr	r0, [pc, #240]	; (802cab4 <PrepareFrame+0x1b8>)
 802c9c2:	5419      	strb	r1, [r3, r0]
            MacCtx.McpsConfirm.UpLinkCounter = fCntUp;
 802c9c4:	493c      	ldr	r1, [pc, #240]	; (802cab8 <PrepareFrame+0x1bc>)
 802c9c6:	505a      	str	r2, [r3, r1]
            if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 802c9c8:	a802      	add	r0, sp, #8
 802c9ca:	f001 fc19 	bl	802e200 <LoRaMacCommandsGetSizeSerializedCmds>
 802c9ce:	2800      	cmp	r0, #0
 802c9d0:	d15a      	bne.n	802ca88 <PrepareFrame+0x18c>
            if( macCmdsSize > 0 )
 802c9d2:	9b02      	ldr	r3, [sp, #8]
 802c9d4:	2b00      	cmp	r3, #0
 802c9d6:	d0bb      	beq.n	802c950 <PrepareFrame+0x54>
                availableSize = GetMaxAppPayloadWithoutFOptsLength( Nvm.MacGroup1.ChannelsDatarate );
 802c9d8:	4a34      	ldr	r2, [pc, #208]	; (802caac <PrepareFrame+0x1b0>)
 802c9da:	2339      	movs	r3, #57	; 0x39
 802c9dc:	56d0      	ldrsb	r0, [r2, r3]
 802c9de:	f7fd feb1 	bl	802a744 <GetMaxAppPayloadWithoutFOptsLength>
                if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize <= LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )
 802c9e2:	4a2e      	ldr	r2, [pc, #184]	; (802ca9c <PrepareFrame+0x1a0>)
 802c9e4:	4b30      	ldr	r3, [pc, #192]	; (802caa8 <PrepareFrame+0x1ac>)
 802c9e6:	5cd3      	ldrb	r3, [r2, r3]
 802c9e8:	2b00      	cmp	r3, #0
 802c9ea:	d002      	beq.n	802c9f2 <PrepareFrame+0xf6>
 802c9ec:	9a02      	ldr	r2, [sp, #8]
 802c9ee:	2a0f      	cmp	r2, #15
 802c9f0:	d918      	bls.n	802ca24 <PrepareFrame+0x128>
                else if( ( MacCtx.AppDataSize > 0 ) && ( macCmdsSize > LORA_MAC_COMMAND_MAX_FOPTS_LENGTH ) )
 802c9f2:	2b00      	cmp	r3, #0
 802c9f4:	d002      	beq.n	802c9fc <PrepareFrame+0x100>
 802c9f6:	9b02      	ldr	r3, [sp, #8]
 802c9f8:	2b0f      	cmp	r3, #15
 802c9fa:	d829      	bhi.n	802ca50 <PrepareFrame+0x154>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 802c9fc:	4a2f      	ldr	r2, [pc, #188]	; (802cabc <PrepareFrame+0x1c0>)
 802c9fe:	a902      	add	r1, sp, #8
 802ca00:	f001 fc0c 	bl	802e21c <LoRaMacCommandsSerializeCmds>
 802ca04:	2800      	cmp	r0, #0
 802ca06:	d145      	bne.n	802ca94 <PrepareFrame+0x198>
                    MacCtx.TxMsg.Message.Data.FPort = 0;
 802ca08:	4b24      	ldr	r3, [pc, #144]	; (802ca9c <PrepareFrame+0x1a0>)
 802ca0a:	2294      	movs	r2, #148	; 0x94
 802ca0c:	0052      	lsls	r2, r2, #1
 802ca0e:	2100      	movs	r1, #0
 802ca10:	5499      	strb	r1, [r3, r2]
                    MacCtx.TxMsg.Message.Data.FRMPayload = MacCtx.MacCommandsBuffer;
 802ca12:	4a2b      	ldr	r2, [pc, #172]	; (802cac0 <PrepareFrame+0x1c4>)
 802ca14:	1899      	adds	r1, r3, r2
 802ca16:	2296      	movs	r2, #150	; 0x96
 802ca18:	0052      	lsls	r2, r2, #1
 802ca1a:	5099      	str	r1, [r3, r2]
                    MacCtx.TxMsg.Message.Data.FRMPayloadSize = macCmdsSize;
 802ca1c:	3204      	adds	r2, #4
 802ca1e:	9902      	ldr	r1, [sp, #8]
 802ca20:	5499      	strb	r1, [r3, r2]
 802ca22:	e795      	b.n	802c950 <PrepareFrame+0x54>
                    if( LoRaMacCommandsSerializeCmds( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH, &macCmdsSize, MacCtx.TxMsg.Message.Data.FHDR.FOpts ) != LORAMAC_COMMANDS_SUCCESS )
 802ca24:	4a27      	ldr	r2, [pc, #156]	; (802cac4 <PrepareFrame+0x1c8>)
 802ca26:	a902      	add	r1, sp, #8
 802ca28:	200f      	movs	r0, #15
 802ca2a:	f001 fbf7 	bl	802e21c <LoRaMacCommandsSerializeCmds>
 802ca2e:	2800      	cmp	r0, #0
 802ca30:	d12c      	bne.n	802ca8c <PrepareFrame+0x190>
                    fCtrl->Bits.FOptsLen = macCmdsSize;
 802ca32:	220f      	movs	r2, #15
 802ca34:	9b02      	ldr	r3, [sp, #8]
 802ca36:	401a      	ands	r2, r3
 802ca38:	9c00      	ldr	r4, [sp, #0]
 802ca3a:	7823      	ldrb	r3, [r4, #0]
 802ca3c:	210f      	movs	r1, #15
 802ca3e:	438b      	bics	r3, r1
 802ca40:	4313      	orrs	r3, r2
 802ca42:	7023      	strb	r3, [r4, #0]
                    MacCtx.TxMsg.Message.Data.FHDR.FCtrl.Value = fCtrl->Value;
 802ca44:	b2d9      	uxtb	r1, r3
 802ca46:	4a15      	ldr	r2, [pc, #84]	; (802ca9c <PrepareFrame+0x1a0>)
 802ca48:	238a      	movs	r3, #138	; 0x8a
 802ca4a:	005b      	lsls	r3, r3, #1
 802ca4c:	54d1      	strb	r1, [r2, r3]
 802ca4e:	e77f      	b.n	802c950 <PrepareFrame+0x54>
                    if( LoRaMacCommandsSerializeCmds( availableSize, &macCmdsSize, MacCtx.MacCommandsBuffer ) != LORAMAC_COMMANDS_SUCCESS )
 802ca50:	4a1a      	ldr	r2, [pc, #104]	; (802cabc <PrepareFrame+0x1c0>)
 802ca52:	a902      	add	r1, sp, #8
 802ca54:	f001 fbe2 	bl	802e21c <LoRaMacCommandsSerializeCmds>
 802ca58:	2800      	cmp	r0, #0
 802ca5a:	d019      	beq.n	802ca90 <PrepareFrame+0x194>
                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802ca5c:	2013      	movs	r0, #19
 802ca5e:	e777      	b.n	802c950 <PrepareFrame+0x54>
            if( ( fBuffer != NULL ) && ( MacCtx.AppDataSize > 0 ) )
 802ca60:	2e00      	cmp	r6, #0
 802ca62:	d019      	beq.n	802ca98 <PrepareFrame+0x19c>
 802ca64:	2800      	cmp	r0, #0
 802ca66:	d100      	bne.n	802ca6a <PrepareFrame+0x16e>
 802ca68:	e772      	b.n	802c950 <PrepareFrame+0x54>
                memcpy1( MacCtx.PktBuffer + LORAMAC_MHDR_FIELD_SIZE, ( uint8_t* ) fBuffer, MacCtx.AppDataSize );
 802ca6a:	b282      	uxth	r2, r0
 802ca6c:	4c16      	ldr	r4, [pc, #88]	; (802cac8 <PrepareFrame+0x1cc>)
 802ca6e:	0031      	movs	r1, r6
 802ca70:	0020      	movs	r0, r4
 802ca72:	f005 fb46 	bl	8032102 <memcpy1>
                MacCtx.PktBufferLen = LORAMAC_MHDR_FIELD_SIZE + MacCtx.AppDataSize;
 802ca76:	3c03      	subs	r4, #3
 802ca78:	4b0b      	ldr	r3, [pc, #44]	; (802caa8 <PrepareFrame+0x1ac>)
 802ca7a:	5ce3      	ldrb	r3, [r4, r3]
 802ca7c:	3301      	adds	r3, #1
 802ca7e:	8023      	strh	r3, [r4, #0]
    return LORAMAC_STATUS_OK;
 802ca80:	2000      	movs	r0, #0
 802ca82:	e765      	b.n	802c950 <PrepareFrame+0x54>
                return LORAMAC_STATUS_FCNT_HANDLER_ERROR;
 802ca84:	2012      	movs	r0, #18
 802ca86:	e763      	b.n	802c950 <PrepareFrame+0x54>
                return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802ca88:	2013      	movs	r0, #19
 802ca8a:	e761      	b.n	802c950 <PrepareFrame+0x54>
                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802ca8c:	2013      	movs	r0, #19
 802ca8e:	e75f      	b.n	802c950 <PrepareFrame+0x54>
                    return LORAMAC_STATUS_SKIPPED_APP_DATA;
 802ca90:	200a      	movs	r0, #10
 802ca92:	e75d      	b.n	802c950 <PrepareFrame+0x54>
                        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802ca94:	2013      	movs	r0, #19
 802ca96:	e75b      	b.n	802c950 <PrepareFrame+0x54>
    return LORAMAC_STATUS_OK;
 802ca98:	2000      	movs	r0, #0
 802ca9a:	e759      	b.n	802c950 <PrepareFrame+0x54>
 802ca9c:	2000bb1c 	.word	0x2000bb1c
 802caa0:	0000041a 	.word	0x0000041a
 802caa4:	2000bc54 	.word	0x2000bc54
 802caa8:	00000237 	.word	0x00000237
 802caac:	2000a000 	.word	0x2000a000
 802cab0:	00000445 	.word	0x00000445
 802cab4:	00000444 	.word	0x00000444
 802cab8:	0000044c 	.word	0x0000044c
 802cabc:	2000bfb8 	.word	0x2000bfb8
 802cac0:	0000049c 	.word	0x0000049c
 802cac4:	2000bc34 	.word	0x2000bc34
 802cac8:	2000bb1f 	.word	0x2000bb1f

0802cacc <Send>:
{
 802cacc:	b5f0      	push	{r4, r5, r6, r7, lr}
 802cace:	46de      	mov	lr, fp
 802cad0:	4657      	mov	r7, sl
 802cad2:	464e      	mov	r6, r9
 802cad4:	4645      	mov	r5, r8
 802cad6:	b5e0      	push	{r5, r6, r7, lr}
 802cad8:	b08b      	sub	sp, #44	; 0x2c
 802cada:	4683      	mov	fp, r0
 802cadc:	4688      	mov	r8, r1
 802cade:	4691      	mov	r9, r2
 802cae0:	001f      	movs	r7, r3
 802cae2:	ab14      	add	r3, sp, #80	; 0x50
 802cae4:	781b      	ldrb	r3, [r3, #0]
 802cae6:	469a      	mov	sl, r3
    int8_t datarate = Nvm.MacGroup1.ChannelsDatarate;
 802cae8:	4b45      	ldr	r3, [pc, #276]	; (802cc00 <Send+0x134>)
 802caea:	2239      	movs	r2, #57	; 0x39
 802caec:	569e      	ldrsb	r6, [r3, r2]
    int8_t txPower = Nvm.MacGroup1.ChannelsTxPower;
 802caee:	3a01      	subs	r2, #1
 802caf0:	569d      	ldrsb	r5, [r3, r2]
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 802caf2:	6a99      	ldr	r1, [r3, #40]	; 0x28
 802caf4:	9108      	str	r1, [sp, #32]
    if( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_NONE )
 802caf6:	32f8      	adds	r2, #248	; 0xf8
 802caf8:	5c9b      	ldrb	r3, [r3, r2]
 802cafa:	2b00      	cmp	r3, #0
 802cafc:	d100      	bne.n	802cb00 <Send+0x34>
 802cafe:	e07d      	b.n	802cbfc <Send+0x130>
    if( Nvm.MacGroup2.MaxDCycle == 0 )
 802cb00:	4a3f      	ldr	r2, [pc, #252]	; (802cc00 <Send+0x134>)
 802cb02:	231c      	movs	r3, #28
 802cb04:	33ff      	adds	r3, #255	; 0xff
 802cb06:	5cd3      	ldrb	r3, [r2, r3]
 802cb08:	2b00      	cmp	r3, #0
 802cb0a:	d102      	bne.n	802cb12 <Send+0x46>
        Nvm.MacGroup1.AggregatedTimeOff = 0;
 802cb0c:	0013      	movs	r3, r2
 802cb0e:	2200      	movs	r2, #0
 802cb10:	631a      	str	r2, [r3, #48]	; 0x30
    fCtrl.Value = 0;
 802cb12:	a809      	add	r0, sp, #36	; 0x24
 802cb14:	2300      	movs	r3, #0
 802cb16:	7003      	strb	r3, [r0, #0]
    fCtrl.Bits.Adr           = Nvm.MacGroup2.AdrCtrlOn;
 802cb18:	4a39      	ldr	r2, [pc, #228]	; (802cc00 <Send+0x134>)
 802cb1a:	331b      	adds	r3, #27
 802cb1c:	33ff      	adds	r3, #255	; 0xff
 802cb1e:	5cd3      	ldrb	r3, [r2, r3]
 802cb20:	01dc      	lsls	r4, r3, #7
 802cb22:	7004      	strb	r4, [r0, #0]
    if( Nvm.MacGroup2.DeviceClass == CLASS_B )
 802cb24:	208c      	movs	r0, #140	; 0x8c
 802cb26:	0040      	lsls	r0, r0, #1
 802cb28:	5c12      	ldrb	r2, [r2, r0]
 802cb2a:	2a01      	cmp	r2, #1
 802cb2c:	d054      	beq.n	802cbd8 <Send+0x10c>
    if( Nvm.MacGroup1.SrvAckRequested == true )
 802cb2e:	4834      	ldr	r0, [pc, #208]	; (802cc00 <Send+0x134>)
 802cb30:	223a      	movs	r2, #58	; 0x3a
 802cb32:	5c82      	ldrb	r2, [r0, r2]
 802cb34:	2a00      	cmp	r2, #0
 802cb36:	d004      	beq.n	802cb42 <Send+0x76>
        fCtrl.Bits.Ack = 1;
 802cb38:	a809      	add	r0, sp, #36	; 0x24
 802cb3a:	7802      	ldrb	r2, [r0, #0]
 802cb3c:	2420      	movs	r4, #32
 802cb3e:	4322      	orrs	r2, r4
 802cb40:	7002      	strb	r2, [r0, #0]
    adrNext.UpdateChanMask = true;
 802cb42:	a803      	add	r0, sp, #12
 802cb44:	2201      	movs	r2, #1
 802cb46:	7002      	strb	r2, [r0, #0]
    adrNext.AdrEnabled = fCtrl.Bits.Adr;
 802cb48:	7043      	strb	r3, [r0, #1]
    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 802cb4a:	6041      	str	r1, [r0, #4]
    adrNext.AdrAckLimit = Nvm.MacGroup2.MacParams.AdrAckLimit;
 802cb4c:	492c      	ldr	r1, [pc, #176]	; (802cc00 <Send+0x134>)
 802cb4e:	2388      	movs	r3, #136	; 0x88
 802cb50:	5acb      	ldrh	r3, [r1, r3]
 802cb52:	8103      	strh	r3, [r0, #8]
    adrNext.AdrAckDelay = Nvm.MacGroup2.MacParams.AdrAckDelay;
 802cb54:	238a      	movs	r3, #138	; 0x8a
 802cb56:	5acb      	ldrh	r3, [r1, r3]
 802cb58:	8143      	strh	r3, [r0, #10]
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 802cb5a:	7306      	strb	r6, [r0, #12]
    adrNext.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 802cb5c:	7345      	strb	r5, [r0, #13]
    adrNext.UplinkDwellTime =  Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802cb5e:	237c      	movs	r3, #124	; 0x7c
 802cb60:	5ccb      	ldrb	r3, [r1, r3]
 802cb62:	73c3      	strb	r3, [r0, #15]
    adrNext.Region = Nvm.MacGroup2.Region;
 802cb64:	2348      	movs	r3, #72	; 0x48
 802cb66:	5ccb      	ldrb	r3, [r1, r3]
 802cb68:	7403      	strb	r3, [r0, #16]
    adrNext.NbTrans = Nvm.MacGroup2.MacParams.ChannelsNbTrans;
 802cb6a:	2368      	movs	r3, #104	; 0x68
 802cb6c:	5ccb      	ldrb	r3, [r1, r3]
 802cb6e:	7383      	strb	r3, [r0, #14]
    fCtrl.Bits.AdrAckReq = LoRaMacAdrCalcNext( &adrNext, &Nvm.MacGroup1.ChannelsDatarate,
 802cb70:	000b      	movs	r3, r1
 802cb72:	3368      	adds	r3, #104	; 0x68
 802cb74:	000a      	movs	r2, r1
 802cb76:	3238      	adds	r2, #56	; 0x38
 802cb78:	3139      	adds	r1, #57	; 0x39
 802cb7a:	ac08      	add	r4, sp, #32
 802cb7c:	9400      	str	r4, [sp, #0]
 802cb7e:	f001 f96d 	bl	802de5c <LoRaMacAdrCalcNext>
 802cb82:	2301      	movs	r3, #1
 802cb84:	4003      	ands	r3, r0
 802cb86:	019b      	lsls	r3, r3, #6
 802cb88:	466a      	mov	r2, sp
 802cb8a:	2124      	movs	r1, #36	; 0x24
 802cb8c:	1852      	adds	r2, r2, r1
 802cb8e:	7810      	ldrb	r0, [r2, #0]
 802cb90:	2240      	movs	r2, #64	; 0x40
 802cb92:	4390      	bics	r0, r2
 802cb94:	4318      	orrs	r0, r3
 802cb96:	466b      	mov	r3, sp
 802cb98:	185b      	adds	r3, r3, r1
 802cb9a:	7018      	strb	r0, [r3, #0]
    status = PrepareFrame( macHdr, &fCtrl, fPort, fBuffer, fBufferSize );
 802cb9c:	9700      	str	r7, [sp, #0]
 802cb9e:	464b      	mov	r3, r9
 802cba0:	4642      	mov	r2, r8
 802cba2:	a909      	add	r1, sp, #36	; 0x24
 802cba4:	4658      	mov	r0, fp
 802cba6:	f7ff fea9 	bl	802c8fc <PrepareFrame>
 802cbaa:	1e04      	subs	r4, r0, #0
    if( ( status == LORAMAC_STATUS_OK ) || ( status == LORAMAC_STATUS_SKIPPED_APP_DATA ) )
 802cbac:	d001      	beq.n	802cbb2 <Send+0xe6>
 802cbae:	280a      	cmp	r0, #10
 802cbb0:	d103      	bne.n	802cbba <Send+0xee>
        status = ScheduleTx( allowDelayedTx );
 802cbb2:	4650      	mov	r0, sl
 802cbb4:	f7ff f8fc 	bl	802bdb0 <ScheduleTx>
 802cbb8:	0004      	movs	r4, r0
    if( status != LORAMAC_STATUS_OK )
 802cbba:	2c00      	cmp	r4, #0
 802cbbc:	d012      	beq.n	802cbe4 <Send+0x118>
        Nvm.MacGroup1.ChannelsDatarate = datarate;
 802cbbe:	4b10      	ldr	r3, [pc, #64]	; (802cc00 <Send+0x134>)
 802cbc0:	2239      	movs	r2, #57	; 0x39
 802cbc2:	549e      	strb	r6, [r3, r2]
        Nvm.MacGroup1.ChannelsTxPower = txPower;
 802cbc4:	3a01      	subs	r2, #1
 802cbc6:	549d      	strb	r5, [r3, r2]
}
 802cbc8:	0020      	movs	r0, r4
 802cbca:	b00b      	add	sp, #44	; 0x2c
 802cbcc:	bcf0      	pop	{r4, r5, r6, r7}
 802cbce:	46bb      	mov	fp, r7
 802cbd0:	46b2      	mov	sl, r6
 802cbd2:	46a9      	mov	r9, r5
 802cbd4:	46a0      	mov	r8, r4
 802cbd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        fCtrl.Bits.FPending      = 1;
 802cbd8:	a809      	add	r0, sp, #36	; 0x24
 802cbda:	b2e2      	uxtb	r2, r4
 802cbdc:	2410      	movs	r4, #16
 802cbde:	4322      	orrs	r2, r4
 802cbe0:	7002      	strb	r2, [r0, #0]
 802cbe2:	e7a4      	b.n	802cb2e <Send+0x62>
        Nvm.MacGroup1.SrvAckRequested = false;
 802cbe4:	4b06      	ldr	r3, [pc, #24]	; (802cc00 <Send+0x134>)
 802cbe6:	223a      	movs	r2, #58	; 0x3a
 802cbe8:	2100      	movs	r1, #0
 802cbea:	5499      	strb	r1, [r3, r2]
        Nvm.MacGroup1.AdrAckCounter = adrAckCounter;
 802cbec:	9a08      	ldr	r2, [sp, #32]
 802cbee:	629a      	str	r2, [r3, #40]	; 0x28
        if( LoRaMacCommandsRemoveNoneStickyCmds( ) != LORAMAC_COMMANDS_SUCCESS )
 802cbf0:	f001 fad8 	bl	802e1a4 <LoRaMacCommandsRemoveNoneStickyCmds>
 802cbf4:	2800      	cmp	r0, #0
 802cbf6:	d0e7      	beq.n	802cbc8 <Send+0xfc>
            return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802cbf8:	2413      	movs	r4, #19
 802cbfa:	e7e5      	b.n	802cbc8 <Send+0xfc>
        return LORAMAC_STATUS_NO_NETWORK_JOINED;
 802cbfc:	2407      	movs	r4, #7
 802cbfe:	e7e3      	b.n	802cbc8 <Send+0xfc>
 802cc00:	2000a000 	.word	0x2000a000

0802cc04 <LoRaMacIsBusy>:
    if( MacCtx.MacState == LORAMAC_STOPPED )
 802cc04:	4a0d      	ldr	r2, [pc, #52]	; (802cc3c <LoRaMacIsBusy+0x38>)
 802cc06:	23d0      	movs	r3, #208	; 0xd0
 802cc08:	009b      	lsls	r3, r3, #2
 802cc0a:	58d3      	ldr	r3, [r2, r3]
 802cc0c:	2b01      	cmp	r3, #1
 802cc0e:	d00c      	beq.n	802cc2a <LoRaMacIsBusy+0x26>
    if( LoRaMacRadioEvents.Events.RxProcessPending == 1 )
 802cc10:	4a0b      	ldr	r2, [pc, #44]	; (802cc40 <LoRaMacIsBusy+0x3c>)
 802cc12:	7812      	ldrb	r2, [r2, #0]
 802cc14:	07d2      	lsls	r2, r2, #31
 802cc16:	d40a      	bmi.n	802cc2e <LoRaMacIsBusy+0x2a>
    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&
 802cc18:	2b00      	cmp	r3, #0
 802cc1a:	d10a      	bne.n	802cc32 <LoRaMacIsBusy+0x2e>
        ( MacCtx.AllowRequests == LORAMAC_REQUEST_HANDLING_ON ) )
 802cc1c:	4a07      	ldr	r2, [pc, #28]	; (802cc3c <LoRaMacIsBusy+0x38>)
 802cc1e:	4b09      	ldr	r3, [pc, #36]	; (802cc44 <LoRaMacIsBusy+0x40>)
 802cc20:	5cd3      	ldrb	r3, [r2, r3]
    if( ( MacCtx.MacState == LORAMAC_IDLE ) &&
 802cc22:	2b01      	cmp	r3, #1
 802cc24:	d007      	beq.n	802cc36 <LoRaMacIsBusy+0x32>
    return true;
 802cc26:	2001      	movs	r0, #1
 802cc28:	e002      	b.n	802cc30 <LoRaMacIsBusy+0x2c>
        return false;
 802cc2a:	2000      	movs	r0, #0
 802cc2c:	e000      	b.n	802cc30 <LoRaMacIsBusy+0x2c>
        return true;
 802cc2e:	2001      	movs	r0, #1
}
 802cc30:	4770      	bx	lr
    return true;
 802cc32:	2001      	movs	r0, #1
 802cc34:	e7fc      	b.n	802cc30 <LoRaMacIsBusy+0x2c>
        return false;
 802cc36:	2000      	movs	r0, #0
 802cc38:	e7fa      	b.n	802cc30 <LoRaMacIsBusy+0x2c>
 802cc3a:	46c0      	nop			; (mov r8, r8)
 802cc3c:	2000bb1c 	.word	0x2000bb1c
 802cc40:	2000bb18 	.word	0x2000bb18
 802cc44:	00000492 	.word	0x00000492

0802cc48 <LoRaMacIsStopped>:
    if( MacCtx.MacState == LORAMAC_STOPPED )
 802cc48:	4a04      	ldr	r2, [pc, #16]	; (802cc5c <LoRaMacIsStopped+0x14>)
 802cc4a:	23d0      	movs	r3, #208	; 0xd0
 802cc4c:	009b      	lsls	r3, r3, #2
 802cc4e:	58d3      	ldr	r3, [r2, r3]
 802cc50:	2b01      	cmp	r3, #1
 802cc52:	d001      	beq.n	802cc58 <LoRaMacIsStopped+0x10>
    return false;
 802cc54:	2000      	movs	r0, #0
}
 802cc56:	4770      	bx	lr
        return true;
 802cc58:	2001      	movs	r0, #1
 802cc5a:	e7fc      	b.n	802cc56 <LoRaMacIsStopped+0xe>
 802cc5c:	2000bb1c 	.word	0x2000bb1c

0802cc60 <LoRaMacProcess>:
{
 802cc60:	b510      	push	{r4, lr}
    LoRaMacHandleIrqEvents( );
 802cc62:	f7fe fec9 	bl	802b9f8 <LoRaMacHandleIrqEvents>
    LoRaMacClassBProcess( );
 802cc66:	f001 f999 	bl	802df9c <LoRaMacClassBProcess>
    if( MacCtx.MacFlags.Bits.MacDone == 1 )
 802cc6a:	4a1e      	ldr	r2, [pc, #120]	; (802cce4 <LoRaMacProcess+0x84>)
 802cc6c:	4b1e      	ldr	r3, [pc, #120]	; (802cce8 <LoRaMacProcess+0x88>)
 802cc6e:	5cd3      	ldrb	r3, [r2, r3]
 802cc70:	06db      	lsls	r3, r3, #27
 802cc72:	d40d      	bmi.n	802cc90 <LoRaMacProcess+0x30>
    LoRaMacHandleIndicationEvents( );
 802cc74:	f7fd fc06 	bl	802a484 <LoRaMacHandleIndicationEvents>
    if( MacCtx.RxSlot == RX_SLOT_WIN_CLASS_C )
 802cc78:	4a1a      	ldr	r2, [pc, #104]	; (802cce4 <LoRaMacProcess+0x84>)
 802cc7a:	2392      	movs	r3, #146	; 0x92
 802cc7c:	00db      	lsls	r3, r3, #3
 802cc7e:	5cd3      	ldrb	r3, [r2, r3]
 802cc80:	2b02      	cmp	r3, #2
 802cc82:	d022      	beq.n	802ccca <LoRaMacProcess+0x6a>
    if( MacCtx.MacFlags.Bits.NvmHandle == 1 )
 802cc84:	4a17      	ldr	r2, [pc, #92]	; (802cce4 <LoRaMacProcess+0x84>)
 802cc86:	4b18      	ldr	r3, [pc, #96]	; (802cce8 <LoRaMacProcess+0x88>)
 802cc88:	5cd3      	ldrb	r3, [r2, r3]
 802cc8a:	069b      	lsls	r3, r3, #26
 802cc8c:	d420      	bmi.n	802ccd0 <LoRaMacProcess+0x70>
}
 802cc8e:	bd10      	pop	{r4, pc}
        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_OFF );
 802cc90:	2000      	movs	r0, #0
 802cc92:	f7fd fbef 	bl	802a474 <LoRaMacEnableRequests>
        LoRaMacCheckForRxAbort( );
 802cc96:	f7fd fc31 	bl	802a4fc <LoRaMacCheckForRxAbort>
        if( IsRequestPending( ) > 0 )
 802cc9a:	f7fd fd43 	bl	802a724 <IsRequestPending>
 802cc9e:	2800      	cmp	r0, #0
 802cca0:	d003      	beq.n	802ccaa <LoRaMacProcess+0x4a>
            noTx |= LoRaMacCheckForBeaconAcquisition( );
 802cca2:	f7fd fe51 	bl	802a948 <LoRaMacCheckForBeaconAcquisition>
        if( noTx == 0x00 )
 802cca6:	2800      	cmp	r0, #0
 802cca8:	d103      	bne.n	802ccb2 <LoRaMacProcess+0x52>
            LoRaMacHandleMlmeRequest( );
 802ccaa:	f7fe fee3 	bl	802ba74 <LoRaMacHandleMlmeRequest>
            LoRaMacHandleMcpsRequest( );
 802ccae:	f7ff f947 	bl	802bf40 <LoRaMacHandleMcpsRequest>
        LoRaMacHandleRequestEvents( );
 802ccb2:	f7ff f98f 	bl	802bfd4 <LoRaMacHandleRequestEvents>
        LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );
 802ccb6:	2001      	movs	r0, #1
 802ccb8:	f7fd fbdc 	bl	802a474 <LoRaMacEnableRequests>
        MacCtx.MacFlags.Bits.NvmHandle = 1;
 802ccbc:	4909      	ldr	r1, [pc, #36]	; (802cce4 <LoRaMacProcess+0x84>)
 802ccbe:	4a0a      	ldr	r2, [pc, #40]	; (802cce8 <LoRaMacProcess+0x88>)
 802ccc0:	5c8b      	ldrb	r3, [r1, r2]
 802ccc2:	2020      	movs	r0, #32
 802ccc4:	4303      	orrs	r3, r0
 802ccc6:	548b      	strb	r3, [r1, r2]
 802ccc8:	e7d4      	b.n	802cc74 <LoRaMacProcess+0x14>
        OpenContinuousRxCWindow( );
 802ccca:	f7ff f9d1 	bl	802c070 <OpenContinuousRxCWindow>
 802ccce:	e7d9      	b.n	802cc84 <LoRaMacProcess+0x24>
        MacCtx.MacFlags.Bits.NvmHandle = 0;
 802ccd0:	0011      	movs	r1, r2
 802ccd2:	4a05      	ldr	r2, [pc, #20]	; (802cce8 <LoRaMacProcess+0x88>)
 802ccd4:	5c8b      	ldrb	r3, [r1, r2]
 802ccd6:	2020      	movs	r0, #32
 802ccd8:	4383      	bics	r3, r0
 802ccda:	548b      	strb	r3, [r1, r2]
        LoRaMacHandleNvm( &Nvm );
 802ccdc:	4803      	ldr	r0, [pc, #12]	; (802ccec <LoRaMacProcess+0x8c>)
 802ccde:	f7ff faab 	bl	802c238 <LoRaMacHandleNvm>
}
 802cce2:	e7d4      	b.n	802cc8e <LoRaMacProcess+0x2e>
 802cce4:	2000bb1c 	.word	0x2000bb1c
 802cce8:	00000491 	.word	0x00000491
 802ccec:	2000a000 	.word	0x2000a000

0802ccf0 <LoRaMacInitialization>:

LoRaMacStatus_t LoRaMacInitialization( LoRaMacPrimitives_t* primitives, LoRaMacCallback_t* callbacks, LoRaMacRegion_t region )
{
 802ccf0:	b5f0      	push	{r4, r5, r6, r7, lr}
 802ccf2:	46de      	mov	lr, fp
 802ccf4:	4657      	mov	r7, sl
 802ccf6:	464e      	mov	r6, r9
 802ccf8:	4645      	mov	r5, r8
 802ccfa:	b5e0      	push	{r5, r6, r7, lr}
 802ccfc:	b08f      	sub	sp, #60	; 0x3c
 802ccfe:	0006      	movs	r6, r0
 802cd00:	0015      	movs	r5, r2
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    if( ( primitives == NULL ) ||
 802cd02:	2800      	cmp	r0, #0
 802cd04:	d100      	bne.n	802cd08 <LoRaMacInitialization+0x18>
 802cd06:	e193      	b.n	802d030 <LoRaMacInitialization+0x340>
 802cd08:	9103      	str	r1, [sp, #12]
 802cd0a:	2900      	cmp	r1, #0
 802cd0c:	d100      	bne.n	802cd10 <LoRaMacInitialization+0x20>
 802cd0e:	e191      	b.n	802d034 <LoRaMacInitialization+0x344>
        ( callbacks == NULL ) )
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    if( ( primitives->MacMcpsConfirm == NULL ) ||
 802cd10:	6801      	ldr	r1, [r0, #0]
 802cd12:	2900      	cmp	r1, #0
 802cd14:	d100      	bne.n	802cd18 <LoRaMacInitialization+0x28>
 802cd16:	e18f      	b.n	802d038 <LoRaMacInitialization+0x348>
 802cd18:	6841      	ldr	r1, [r0, #4]
 802cd1a:	2900      	cmp	r1, #0
 802cd1c:	d100      	bne.n	802cd20 <LoRaMacInitialization+0x30>
 802cd1e:	e18d      	b.n	802d03c <LoRaMacInitialization+0x34c>
        ( primitives->MacMcpsIndication == NULL ) ||
 802cd20:	6881      	ldr	r1, [r0, #8]
 802cd22:	2900      	cmp	r1, #0
 802cd24:	d100      	bne.n	802cd28 <LoRaMacInitialization+0x38>
 802cd26:	e18b      	b.n	802d040 <LoRaMacInitialization+0x350>
        ( primitives->MacMlmeConfirm == NULL ) ||
 802cd28:	68c1      	ldr	r1, [r0, #12]
 802cd2a:	2900      	cmp	r1, #0
 802cd2c:	d100      	bne.n	802cd30 <LoRaMacInitialization+0x40>
 802cd2e:	e189      	b.n	802d044 <LoRaMacInitialization+0x354>
        ( primitives->MacMlmeIndication == NULL ) )
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    // Verify if the region is supported
    if( RegionIsActive( region ) == false )
 802cd30:	0010      	movs	r0, r2
 802cd32:	f002 f953 	bl	802efdc <RegionIsActive>
 802cd36:	2800      	cmp	r0, #0
 802cd38:	d100      	bne.n	802cd3c <LoRaMacInitialization+0x4c>
 802cd3a:	e185      	b.n	802d048 <LoRaMacInitialization+0x358>
    {
        return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
    }

    // Confirm queue reset
    LoRaMacConfirmQueueInit( primitives );
 802cd3c:	0030      	movs	r0, r6
 802cd3e:	f001 fb03 	bl	802e348 <LoRaMacConfirmQueueInit>

    // Initialize the module context with zeros
    memset1( ( uint8_t* ) &Nvm, 0x00, sizeof( LoRaMacNvmData_t ) );
 802cd42:	4cca      	ldr	r4, [pc, #808]	; (802d06c <LoRaMacInitialization+0x37c>)
 802cd44:	4aca      	ldr	r2, [pc, #808]	; (802d070 <LoRaMacInitialization+0x380>)
 802cd46:	2100      	movs	r1, #0
 802cd48:	0020      	movs	r0, r4
 802cd4a:	f005 f9f2 	bl	8032132 <memset1>
    memset1( ( uint8_t* ) &MacCtx, 0x00, sizeof( LoRaMacCtx_t ) );
 802cd4e:	49c9      	ldr	r1, [pc, #804]	; (802d074 <LoRaMacInitialization+0x384>)
 802cd50:	4688      	mov	r8, r1
 802cd52:	4ac9      	ldr	r2, [pc, #804]	; (802d078 <LoRaMacInitialization+0x388>)
 802cd54:	2100      	movs	r1, #0
 802cd56:	4640      	mov	r0, r8
 802cd58:	f005 f9eb 	bl	8032132 <memset1>
    // Set non zero variables to its default value
#if (defined( LORAMAC_VERSION ) && ( LORAMAC_VERSION == 0x01000300 ))
    MacCtx.AckTimeoutRetriesCounter = 1;
    MacCtx.AckTimeoutRetries = 1;
#endif /* LORAMAC_VERSION */
    Nvm.MacGroup2.Region = region;
 802cd5c:	2748      	movs	r7, #72	; 0x48
 802cd5e:	55e5      	strb	r5, [r4, r7]
    Nvm.MacGroup2.DeviceClass = CLASS_A;
 802cd60:	2100      	movs	r1, #0
 802cd62:	468a      	mov	sl, r1
 802cd64:	238c      	movs	r3, #140	; 0x8c
 802cd66:	005b      	lsls	r3, r3, #1
 802cd68:	54e1      	strb	r1, [r4, r3]
    Nvm.MacGroup2.MacParams.RepeaterSupport = false;
 802cd6a:	3b8c      	subs	r3, #140	; 0x8c
 802cd6c:	54e1      	strb	r1, [r4, r3]

    // Setup version
    Nvm.MacGroup2.Version.Value = LORAMAC_VERSION;
 802cd6e:	33a0      	adds	r3, #160	; 0xa0
 802cd70:	4ac2      	ldr	r2, [pc, #776]	; (802d07c <LoRaMacInitialization+0x38c>)
 802cd72:	50e2      	str	r2, [r4, r3]
#if (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    InitDefaultsParams_t params;
    params.Type = INIT_TYPE_DEFAULTS;
 802cd74:	a907      	add	r1, sp, #28
 802cd76:	4650      	mov	r0, sl
 802cd78:	7308      	strb	r0, [r1, #12]
    params.NvmGroup1 = &Nvm.RegionGroup1;
 802cd7a:	0020      	movs	r0, r4
 802cd7c:	3055      	adds	r0, #85	; 0x55
 802cd7e:	30ff      	adds	r0, #255	; 0xff
 802cd80:	9007      	str	r0, [sp, #28]
    params.NvmGroup2 = &Nvm.RegionGroup2;
 802cd82:	0020      	movs	r0, r4
 802cd84:	3069      	adds	r0, #105	; 0x69
 802cd86:	30ff      	adds	r0, #255	; 0xff
 802cd88:	6048      	str	r0, [r1, #4]
    params.Bands = &RegionBands;
 802cd8a:	4bbd      	ldr	r3, [pc, #756]	; (802d080 <LoRaMacInitialization+0x390>)
 802cd8c:	608b      	str	r3, [r1, #8]
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 802cd8e:	0028      	movs	r0, r5
 802cd90:	f002 f953 	bl	802f03a <RegionInitDefaults>
#endif /* LORAMAC_VERSION */

    // Reset to defaults
    getPhy.Attribute = PHY_DUTY_CYCLE;
 802cd94:	ad0c      	add	r5, sp, #48	; 0x30
 802cd96:	230f      	movs	r3, #15
 802cd98:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802cd9a:	5de0      	ldrb	r0, [r4, r7]
 802cd9c:	0029      	movs	r1, r5
 802cd9e:	f002 f927 	bl	802eff0 <RegionGetPhyParam>
 802cda2:	900b      	str	r0, [sp, #44]	; 0x2c
    Nvm.MacGroup2.DutyCycleOn = ( bool ) phyParam.Value;
 802cda4:	1e43      	subs	r3, r0, #1
 802cda6:	4198      	sbcs	r0, r3
 802cda8:	238e      	movs	r3, #142	; 0x8e
 802cdaa:	005b      	lsls	r3, r3, #1
 802cdac:	54e0      	strb	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_TX_POWER;
 802cdae:	210a      	movs	r1, #10
 802cdb0:	7029      	strb	r1, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802cdb2:	5de0      	ldrb	r0, [r4, r7]
 802cdb4:	0029      	movs	r1, r5
 802cdb6:	f002 f91b 	bl	802eff0 <RegionGetPhyParam>
 802cdba:	900b      	str	r0, [sp, #44]	; 0x2c
    Nvm.MacGroup2.ChannelsTxPowerDefault = phyParam.Value;
 802cdbc:	23dc      	movs	r3, #220	; 0xdc
 802cdbe:	54e0      	strb	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_TX_DR;
 802cdc0:	2006      	movs	r0, #6
 802cdc2:	7028      	strb	r0, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802cdc4:	5de0      	ldrb	r0, [r4, r7]
 802cdc6:	0029      	movs	r1, r5
 802cdc8:	f002 f912 	bl	802eff0 <RegionGetPhyParam>
 802cdcc:	900b      	str	r0, [sp, #44]	; 0x2c
    Nvm.MacGroup2.ChannelsDatarateDefault = phyParam.Value;
 802cdce:	23dd      	movs	r3, #221	; 0xdd
 802cdd0:	54e0      	strb	r0, [r4, r3]

    getPhy.Attribute = PHY_MAX_RX_WINDOW;
 802cdd2:	3bcd      	subs	r3, #205	; 0xcd
 802cdd4:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802cdd6:	5de0      	ldrb	r0, [r4, r7]
 802cdd8:	0029      	movs	r1, r5
 802cdda:	f002 f909 	bl	802eff0 <RegionGetPhyParam>
 802cdde:	900b      	str	r0, [sp, #44]	; 0x2c
    Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow = phyParam.Value;
 802cde0:	229c      	movs	r2, #156	; 0x9c
 802cde2:	50a0      	str	r0, [r4, r2]

    getPhy.Attribute = PHY_RECEIVE_DELAY1;
 802cde4:	2311      	movs	r3, #17
 802cde6:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802cde8:	5de0      	ldrb	r0, [r4, r7]
 802cdea:	0029      	movs	r1, r5
 802cdec:	f002 f900 	bl	802eff0 <RegionGetPhyParam>
 802cdf0:	900b      	str	r0, [sp, #44]	; 0x2c
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1 = phyParam.Value;
 802cdf2:	22a0      	movs	r2, #160	; 0xa0
 802cdf4:	50a0      	str	r0, [r4, r2]

    getPhy.Attribute = PHY_RECEIVE_DELAY2;
 802cdf6:	2312      	movs	r3, #18
 802cdf8:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802cdfa:	5de0      	ldrb	r0, [r4, r7]
 802cdfc:	0029      	movs	r1, r5
 802cdfe:	f002 f8f7 	bl	802eff0 <RegionGetPhyParam>
 802ce02:	900b      	str	r0, [sp, #44]	; 0x2c
    Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2 = phyParam.Value;
 802ce04:	22a4      	movs	r2, #164	; 0xa4
 802ce06:	50a0      	str	r0, [r4, r2]

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY1;
 802ce08:	2313      	movs	r3, #19
 802ce0a:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802ce0c:	5de0      	ldrb	r0, [r4, r7]
 802ce0e:	0029      	movs	r1, r5
 802ce10:	f002 f8ee 	bl	802eff0 <RegionGetPhyParam>
 802ce14:	900b      	str	r0, [sp, #44]	; 0x2c
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1 = phyParam.Value;
 802ce16:	23a8      	movs	r3, #168	; 0xa8
 802ce18:	4699      	mov	r9, r3
 802ce1a:	50e0      	str	r0, [r4, r3]

    getPhy.Attribute = PHY_JOIN_ACCEPT_DELAY2;
 802ce1c:	3b94      	subs	r3, #148	; 0x94
 802ce1e:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802ce20:	5de0      	ldrb	r0, [r4, r7]
 802ce22:	0029      	movs	r1, r5
 802ce24:	f002 f8e4 	bl	802eff0 <RegionGetPhyParam>
 802ce28:	900b      	str	r0, [sp, #44]	; 0x2c
    Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2 = phyParam.Value;
 802ce2a:	23ac      	movs	r3, #172	; 0xac
 802ce2c:	469b      	mov	fp, r3
 802ce2e:	50e0      	str	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_DR1_OFFSET;
 802ce30:	3b96      	subs	r3, #150	; 0x96
 802ce32:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802ce34:	5de0      	ldrb	r0, [r4, r7]
 802ce36:	0029      	movs	r1, r5
 802ce38:	f002 f8da 	bl	802eff0 <RegionGetPhyParam>
 802ce3c:	900b      	str	r0, [sp, #44]	; 0x2c
    Nvm.MacGroup2.MacParamsDefaults.Rx1DrOffset = phyParam.Value;
 802ce3e:	23b1      	movs	r3, #177	; 0xb1
 802ce40:	54e0      	strb	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_RX2_FREQUENCY;
 802ce42:	3b9a      	subs	r3, #154	; 0x9a
 802ce44:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802ce46:	5de0      	ldrb	r0, [r4, r7]
 802ce48:	0029      	movs	r1, r5
 802ce4a:	f002 f8d1 	bl	802eff0 <RegionGetPhyParam>
 802ce4e:	900b      	str	r0, [sp, #44]	; 0x2c
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Frequency = phyParam.Value;
 802ce50:	23b4      	movs	r3, #180	; 0xb4
 802ce52:	50e0      	str	r0, [r4, r3]
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Frequency = phyParam.Value;
 802ce54:	3308      	adds	r3, #8
 802ce56:	50e0      	str	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_RX2_DR;
 802ce58:	3ba4      	subs	r3, #164	; 0xa4
 802ce5a:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802ce5c:	5de0      	ldrb	r0, [r4, r7]
 802ce5e:	0029      	movs	r1, r5
 802ce60:	f002 f8c6 	bl	802eff0 <RegionGetPhyParam>
 802ce64:	900b      	str	r0, [sp, #44]	; 0x2c
    Nvm.MacGroup2.MacParamsDefaults.Rx2Channel.Datarate = phyParam.Value;
 802ce66:	b2c0      	uxtb	r0, r0
 802ce68:	23b8      	movs	r3, #184	; 0xb8
 802ce6a:	54e0      	strb	r0, [r4, r3]
    Nvm.MacGroup2.MacParamsDefaults.RxCChannel.Datarate = phyParam.Value;
 802ce6c:	3308      	adds	r3, #8
 802ce6e:	54e0      	strb	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_UPLINK_DWELL_TIME;
 802ce70:	3ba3      	subs	r3, #163	; 0xa3
 802ce72:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802ce74:	5de0      	ldrb	r0, [r4, r7]
 802ce76:	0029      	movs	r1, r5
 802ce78:	f002 f8ba 	bl	802eff0 <RegionGetPhyParam>
 802ce7c:	900b      	str	r0, [sp, #44]	; 0x2c
    Nvm.MacGroup2.MacParamsDefaults.UplinkDwellTime = phyParam.Value;
 802ce7e:	23c4      	movs	r3, #196	; 0xc4
 802ce80:	54e0      	strb	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_DOWNLINK_DWELL_TIME;
 802ce82:	3ba6      	subs	r3, #166	; 0xa6
 802ce84:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802ce86:	5de0      	ldrb	r0, [r4, r7]
 802ce88:	0029      	movs	r1, r5
 802ce8a:	f002 f8b1 	bl	802eff0 <RegionGetPhyParam>
 802ce8e:	900b      	str	r0, [sp, #44]	; 0x2c
    Nvm.MacGroup2.MacParamsDefaults.DownlinkDwellTime = phyParam.Value;
 802ce90:	23c5      	movs	r3, #197	; 0xc5
 802ce92:	54e0      	strb	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_MAX_EIRP;
 802ce94:	3ba6      	subs	r3, #166	; 0xa6
 802ce96:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802ce98:	5de0      	ldrb	r0, [r4, r7]
 802ce9a:	0029      	movs	r1, r5
 802ce9c:	f002 f8a8 	bl	802eff0 <RegionGetPhyParam>
 802cea0:	900b      	str	r0, [sp, #44]	; 0x2c
    Nvm.MacGroup2.MacParamsDefaults.MaxEirp = phyParam.fValue;
 802cea2:	23c8      	movs	r3, #200	; 0xc8
 802cea4:	980b      	ldr	r0, [sp, #44]	; 0x2c
 802cea6:	50e0      	str	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_ANTENNA_GAIN;
 802cea8:	3ba8      	subs	r3, #168	; 0xa8
 802ceaa:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802ceac:	5de0      	ldrb	r0, [r4, r7]
 802ceae:	0029      	movs	r1, r5
 802ceb0:	f002 f89e 	bl	802eff0 <RegionGetPhyParam>
 802ceb4:	900b      	str	r0, [sp, #44]	; 0x2c
    Nvm.MacGroup2.MacParamsDefaults.AntennaGain = phyParam.fValue;
 802ceb6:	23cc      	movs	r3, #204	; 0xcc
 802ceb8:	980b      	ldr	r0, [sp, #44]	; 0x2c
 802ceba:	50e0      	str	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_ADR_ACK_LIMIT;
 802cebc:	3bc1      	subs	r3, #193	; 0xc1
 802cebe:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802cec0:	5de0      	ldrb	r0, [r4, r7]
 802cec2:	0029      	movs	r1, r5
 802cec4:	f002 f894 	bl	802eff0 <RegionGetPhyParam>
 802cec8:	900b      	str	r0, [sp, #44]	; 0x2c
    Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit = phyParam.Value;
 802ceca:	23d0      	movs	r3, #208	; 0xd0
 802cecc:	52e0      	strh	r0, [r4, r3]

    getPhy.Attribute = PHY_DEF_ADR_ACK_DELAY;
 802cece:	3bc4      	subs	r3, #196	; 0xc4
 802ced0:	702b      	strb	r3, [r5, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802ced2:	5de0      	ldrb	r0, [r4, r7]
 802ced4:	0029      	movs	r1, r5
 802ced6:	f002 f88b 	bl	802eff0 <RegionGetPhyParam>
 802ceda:	900b      	str	r0, [sp, #44]	; 0x2c
    Nvm.MacGroup2.MacParamsDefaults.AdrAckDelay = phyParam.Value;
 802cedc:	23d2      	movs	r3, #210	; 0xd2
 802cede:	52e0      	strh	r0, [r4, r3]

    // Init parameters which are not set in function ResetMacParameters
    Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans = 1;
 802cee0:	2501      	movs	r5, #1
 802cee2:	3b22      	subs	r3, #34	; 0x22
 802cee4:	54e5      	strb	r5, [r4, r3]
    Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = 10;
 802cee6:	3b1c      	subs	r3, #28
 802cee8:	210a      	movs	r1, #10
 802ceea:	50e1      	str	r1, [r4, r3]
    Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = 6;
 802ceec:	3304      	adds	r3, #4
 802ceee:	2006      	movs	r0, #6
 802cef0:	54e0      	strb	r0, [r4, r3]

    Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError;
 802cef2:	64e1      	str	r1, [r4, #76]	; 0x4c
    Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols;
 802cef4:	3b48      	subs	r3, #72	; 0x48
 802cef6:	54e0      	strb	r0, [r4, r3]
    Nvm.MacGroup2.MacParams.MaxRxWindow = Nvm.MacGroup2.MacParamsDefaults.MaxRxWindow;
 802cef8:	3192      	adds	r1, #146	; 0x92
 802cefa:	5860      	ldr	r0, [r4, r1]
 802cefc:	6560      	str	r0, [r4, #84]	; 0x54
    Nvm.MacGroup2.MacParams.ReceiveDelay1 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay1;
 802cefe:	3104      	adds	r1, #4
 802cf00:	5860      	ldr	r0, [r4, r1]
 802cf02:	65a0      	str	r0, [r4, #88]	; 0x58
    Nvm.MacGroup2.MacParams.ReceiveDelay2 = Nvm.MacGroup2.MacParamsDefaults.ReceiveDelay2;
 802cf04:	3104      	adds	r1, #4
 802cf06:	5861      	ldr	r1, [r4, r1]
 802cf08:	65e1      	str	r1, [r4, #92]	; 0x5c
    Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay1;
 802cf0a:	4649      	mov	r1, r9
 802cf0c:	5861      	ldr	r1, [r4, r1]
 802cf0e:	6621      	str	r1, [r4, #96]	; 0x60
    Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = Nvm.MacGroup2.MacParamsDefaults.JoinAcceptDelay2;
 802cf10:	4659      	mov	r1, fp
 802cf12:	5861      	ldr	r1, [r4, r1]
 802cf14:	6661      	str	r1, [r4, #100]	; 0x64
    Nvm.MacGroup2.MacParams.ChannelsNbTrans = Nvm.MacGroup2.MacParamsDefaults.ChannelsNbTrans;
 802cf16:	3318      	adds	r3, #24
 802cf18:	54e5      	strb	r5, [r4, r3]
    params.NvmGroup1 = &Nvm.RegionGroup1;
    params.NvmGroup2 = &Nvm.RegionGroup2;
    RegionInitDefaults( Nvm.MacGroup2.Region, &params );
#elif (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    // FPort 224 is enabled by default.
    Nvm.MacGroup2.IsCertPortOn = true;
 802cf1a:	2320      	movs	r3, #32
 802cf1c:	33ff      	adds	r3, #255	; 0xff
 802cf1e:	54e5      	strb	r5, [r4, r3]
#endif /* LORAMAC_VERSION */

    MacCtx.MacCallbacks = callbacks;
 802cf20:	23d2      	movs	r3, #210	; 0xd2
 802cf22:	009b      	lsls	r3, r3, #2
 802cf24:	4641      	mov	r1, r8
 802cf26:	9a03      	ldr	r2, [sp, #12]
 802cf28:	50ca      	str	r2, [r1, r3]
    ResetMacParameters( false );
 802cf2a:	2000      	movs	r0, #0
 802cf2c:	f7ff fb26 	bl	802c57c <ResetMacParameters>

    Nvm.MacGroup2.PublicNetwork = true;
 802cf30:	231a      	movs	r3, #26
 802cf32:	33ff      	adds	r3, #255	; 0xff
 802cf34:	54e5      	strb	r5, [r4, r3]

    MacCtx.MacPrimitives = primitives;
 802cf36:	23d1      	movs	r3, #209	; 0xd1
 802cf38:	009b      	lsls	r3, r3, #2
 802cf3a:	4642      	mov	r2, r8
 802cf3c:	50d6      	str	r6, [r2, r3]
    MacCtx.MacFlags.Value = 0;
 802cf3e:	4b51      	ldr	r3, [pc, #324]	; (802d084 <LoRaMacInitialization+0x394>)
 802cf40:	4651      	mov	r1, sl
 802cf42:	54d1      	strb	r1, [r2, r3]
    MacCtx.MacState = LORAMAC_STOPPED;
 802cf44:	3b52      	subs	r3, #82	; 0x52
 802cf46:	3bff      	subs	r3, #255	; 0xff
 802cf48:	50d5      	str	r5, [r2, r3]

    // Reset duty cycle times
    Nvm.MacGroup1.LastTxDoneTime = 0;
 802cf4a:	62e1      	str	r1, [r4, #44]	; 0x2c
    Nvm.MacGroup1.AggregatedTimeOff = 0;
 802cf4c:	6321      	str	r1, [r4, #48]	; 0x30

    // Initialize timers
    TimerInit( &MacCtx.TxDelayedTimer, OnTxDelayedTimerEvent );
 802cf4e:	3d02      	subs	r5, #2
 802cf50:	20da      	movs	r0, #218	; 0xda
 802cf52:	0080      	lsls	r0, r0, #2
 802cf54:	4440      	add	r0, r8
 802cf56:	9100      	str	r1, [sp, #0]
 802cf58:	4b4b      	ldr	r3, [pc, #300]	; (802d088 <LoRaMacInitialization+0x398>)
 802cf5a:	2200      	movs	r2, #0
 802cf5c:	0029      	movs	r1, r5
 802cf5e:	f007 fab9 	bl	80344d4 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.RxWindowTimer1, OnRxWindow1TimerEvent );
 802cf62:	20e0      	movs	r0, #224	; 0xe0
 802cf64:	0080      	lsls	r0, r0, #2
 802cf66:	4440      	add	r0, r8
 802cf68:	4653      	mov	r3, sl
 802cf6a:	9300      	str	r3, [sp, #0]
 802cf6c:	4b47      	ldr	r3, [pc, #284]	; (802d08c <LoRaMacInitialization+0x39c>)
 802cf6e:	2200      	movs	r2, #0
 802cf70:	0029      	movs	r1, r5
 802cf72:	f007 faaf 	bl	80344d4 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.RxWindowTimer2, OnRxWindow2TimerEvent );
 802cf76:	20e6      	movs	r0, #230	; 0xe6
 802cf78:	0080      	lsls	r0, r0, #2
 802cf7a:	4440      	add	r0, r8
 802cf7c:	4653      	mov	r3, sl
 802cf7e:	9300      	str	r3, [sp, #0]
 802cf80:	4b43      	ldr	r3, [pc, #268]	; (802d090 <LoRaMacInitialization+0x3a0>)
 802cf82:	2200      	movs	r2, #0
 802cf84:	0029      	movs	r1, r5
 802cf86:	f007 faa5 	bl	80344d4 <UTIL_TIMER_Create>
#if (defined( LORAMAC_VERSION ) && ( LORAMAC_VERSION == 0x01000300 ))
    TimerInit( &MacCtx.AckTimeoutTimer, OnAckTimeoutTimerEvent );
#elif (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    TimerInit( &MacCtx.RetransmitTimeoutTimer, OnRetransmitTimeoutTimerEvent );
 802cf8a:	2080      	movs	r0, #128	; 0x80
 802cf8c:	00c0      	lsls	r0, r0, #3
 802cf8e:	4440      	add	r0, r8
 802cf90:	4653      	mov	r3, sl
 802cf92:	9300      	str	r3, [sp, #0]
 802cf94:	4b3f      	ldr	r3, [pc, #252]	; (802d094 <LoRaMacInitialization+0x3a4>)
 802cf96:	2200      	movs	r2, #0
 802cf98:	0029      	movs	r1, r5
 802cf9a:	f007 fa9b 	bl	80344d4 <UTIL_TIMER_Create>
    TimerInit( &MacCtx.Rejoin1CycleTimer, OnRejoin1CycleTimerEvent );
    TimerInit( &MacCtx.ForceRejoinReqCycleTimer, OnForceRejoinReqCycleTimerEvent );
#endif /* LORAMAC_VERSION */

    // Store the current initialization time
    Nvm.MacGroup2.InitializationTime = SysTimeGetMcuTime( );
 802cf9e:	ad04      	add	r5, sp, #16
 802cfa0:	0028      	movs	r0, r5
 802cfa2:	f007 fa2b 	bl	80343fc <SysTimeGetMcuTime>
 802cfa6:	0023      	movs	r3, r4
 802cfa8:	3325      	adds	r3, #37	; 0x25
 802cfaa:	33ff      	adds	r3, #255	; 0xff
 802cfac:	cd06      	ldmia	r5!, {r1, r2}
 802cfae:	c306      	stmia	r3!, {r1, r2}

#if (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    // Initialize MAC radio events
    LoRaMacRadioEvents.Value = 0;
 802cfb0:	4b39      	ldr	r3, [pc, #228]	; (802d098 <LoRaMacInitialization+0x3a8>)
 802cfb2:	4652      	mov	r2, sl
 802cfb4:	601a      	str	r2, [r3, #0]
#endif /* LORAMAC_VERSION */

    // Initialize Radio driver
    MacCtx.RadioEvents.TxDone = OnRadioTxDone;
 802cfb6:	23d3      	movs	r3, #211	; 0xd3
 802cfb8:	009b      	lsls	r3, r3, #2
 802cfba:	4a38      	ldr	r2, [pc, #224]	; (802d09c <LoRaMacInitialization+0x3ac>)
 802cfbc:	4641      	mov	r1, r8
 802cfbe:	50ca      	str	r2, [r1, r3]
    MacCtx.RadioEvents.RxDone = OnRadioRxDone;
 802cfc0:	3308      	adds	r3, #8
 802cfc2:	4a37      	ldr	r2, [pc, #220]	; (802d0a0 <LoRaMacInitialization+0x3b0>)
 802cfc4:	50ca      	str	r2, [r1, r3]
    MacCtx.RadioEvents.RxError = OnRadioRxError;
 802cfc6:	3308      	adds	r3, #8
 802cfc8:	4a36      	ldr	r2, [pc, #216]	; (802d0a4 <LoRaMacInitialization+0x3b4>)
 802cfca:	50ca      	str	r2, [r1, r3]
    MacCtx.RadioEvents.TxTimeout = OnRadioTxTimeout;
 802cfcc:	3b0c      	subs	r3, #12
 802cfce:	4a36      	ldr	r2, [pc, #216]	; (802d0a8 <LoRaMacInitialization+0x3b8>)
 802cfd0:	50ca      	str	r2, [r1, r3]
    MacCtx.RadioEvents.RxTimeout = OnRadioRxTimeout;
 802cfd2:	3308      	adds	r3, #8
 802cfd4:	4a35      	ldr	r2, [pc, #212]	; (802d0ac <LoRaMacInitialization+0x3bc>)
 802cfd6:	50ca      	str	r2, [r1, r3]
    Radio.Init( &MacCtx.RadioEvents );
 802cfd8:	4b35      	ldr	r3, [pc, #212]	; (802d0b0 <LoRaMacInitialization+0x3c0>)
 802cfda:	681b      	ldr	r3, [r3, #0]
 802cfdc:	20d3      	movs	r0, #211	; 0xd3
 802cfde:	0080      	lsls	r0, r0, #2
 802cfe0:	4440      	add	r0, r8
 802cfe2:	4798      	blx	r3

    // Initialize the Secure Element driver
    if( SecureElementInit( &Nvm.SecureElement ) != SECURE_ELEMENT_SUCCESS )
 802cfe4:	0020      	movs	r0, r4
 802cfe6:	304d      	adds	r0, #77	; 0x4d
 802cfe8:	30ff      	adds	r0, #255	; 0xff
 802cfea:	f004 faad 	bl	8031548 <SecureElementInit>
 802cfee:	2800      	cmp	r0, #0
 802cff0:	d133      	bne.n	802d05a <LoRaMacInitialization+0x36a>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
    }

    // Initialize Crypto module
    if( LoRaMacCryptoInit( &Nvm.Crypto ) != LORAMAC_CRYPTO_SUCCESS )
 802cff2:	481e      	ldr	r0, [pc, #120]	; (802d06c <LoRaMacInitialization+0x37c>)
 802cff4:	f001 fc5e 	bl	802e8b4 <LoRaMacCryptoInit>
 802cff8:	2800      	cmp	r0, #0
 802cffa:	d130      	bne.n	802d05e <LoRaMacInitialization+0x36e>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
    }

    // Initialize MAC commands module
    if( LoRaMacCommandsInit( ) != LORAMAC_COMMANDS_SUCCESS )
 802cffc:	f001 f860 	bl	802e0c0 <LoRaMacCommandsInit>
 802d000:	2800      	cmp	r0, #0
 802d002:	d12e      	bne.n	802d062 <LoRaMacInitialization+0x372>
    {
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
    }

    // Set multicast downlink counter reference
    if( LoRaMacCryptoSetMulticastReference( Nvm.MacGroup2.MulticastChannelList ) != LORAMAC_CRYPTO_SUCCESS )
 802d004:	482b      	ldr	r0, [pc, #172]	; (802d0b4 <LoRaMacInitialization+0x3c4>)
 802d006:	f001 fcaf 	bl	802e968 <LoRaMacCryptoSetMulticastReference>
 802d00a:	1e04      	subs	r4, r0, #0
 802d00c:	d12b      	bne.n	802d066 <LoRaMacInitialization+0x376>
    {
        return LORAMAC_STATUS_CRYPTO_ERROR;
    }

    // Random seed initialization
    srand1( Radio.Random( ) );
 802d00e:	4d28      	ldr	r5, [pc, #160]	; (802d0b0 <LoRaMacInitialization+0x3c0>)
 802d010:	696b      	ldr	r3, [r5, #20]
 802d012:	4798      	blx	r3
 802d014:	f005 f864 	bl	80320e0 <srand1>

    Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 802d018:	4a14      	ldr	r2, [pc, #80]	; (802d06c <LoRaMacInitialization+0x37c>)
 802d01a:	231a      	movs	r3, #26
 802d01c:	33ff      	adds	r3, #255	; 0xff
 802d01e:	5cd0      	ldrb	r0, [r2, r3]
 802d020:	6dab      	ldr	r3, [r5, #88]	; 0x58
 802d022:	4798      	blx	r3
    Radio.Sleep( );
 802d024:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 802d026:	4798      	blx	r3

    LoRaMacEnableRequests( LORAMAC_REQUEST_HANDLING_ON );
 802d028:	2001      	movs	r0, #1
 802d02a:	f7fd fa23 	bl	802a474 <LoRaMacEnableRequests>

    return LORAMAC_STATUS_OK;
 802d02e:	e00c      	b.n	802d04a <LoRaMacInitialization+0x35a>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802d030:	2403      	movs	r4, #3
 802d032:	e00a      	b.n	802d04a <LoRaMacInitialization+0x35a>
 802d034:	2403      	movs	r4, #3
 802d036:	e008      	b.n	802d04a <LoRaMacInitialization+0x35a>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802d038:	2403      	movs	r4, #3
 802d03a:	e006      	b.n	802d04a <LoRaMacInitialization+0x35a>
 802d03c:	2403      	movs	r4, #3
 802d03e:	e004      	b.n	802d04a <LoRaMacInitialization+0x35a>
 802d040:	2403      	movs	r4, #3
 802d042:	e002      	b.n	802d04a <LoRaMacInitialization+0x35a>
 802d044:	2403      	movs	r4, #3
 802d046:	e000      	b.n	802d04a <LoRaMacInitialization+0x35a>
        return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
 802d048:	2409      	movs	r4, #9
}
 802d04a:	0020      	movs	r0, r4
 802d04c:	b00f      	add	sp, #60	; 0x3c
 802d04e:	bcf0      	pop	{r4, r5, r6, r7}
 802d050:	46bb      	mov	fp, r7
 802d052:	46b2      	mov	sl, r6
 802d054:	46a9      	mov	r9, r5
 802d056:	46a0      	mov	r8, r4
 802d058:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_STATUS_CRYPTO_ERROR;
 802d05a:	2411      	movs	r4, #17
 802d05c:	e7f5      	b.n	802d04a <LoRaMacInitialization+0x35a>
        return LORAMAC_STATUS_CRYPTO_ERROR;
 802d05e:	2411      	movs	r4, #17
 802d060:	e7f3      	b.n	802d04a <LoRaMacInitialization+0x35a>
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802d062:	2413      	movs	r4, #19
 802d064:	e7f1      	b.n	802d04a <LoRaMacInitialization+0x35a>
        return LORAMAC_STATUS_CRYPTO_ERROR;
 802d066:	2411      	movs	r4, #17
 802d068:	e7ef      	b.n	802d04a <LoRaMacInitialization+0x35a>
 802d06a:	46c0      	nop			; (mov r8, r8)
 802d06c:	2000a000 	.word	0x2000a000
 802d070:	000004fc 	.word	0x000004fc
 802d074:	2000bb1c 	.word	0x2000bb1c
 802d078:	0000051c 	.word	0x0000051c
 802d07c:	01000400 	.word	0x01000400
 802d080:	2000c038 	.word	0x2000c038
 802d084:	00000491 	.word	0x00000491
 802d088:	0802bebd 	.word	0x0802bebd
 802d08c:	0802c1cd 	.word	0x0802c1cd
 802d090:	0802c155 	.word	0x0802c155
 802d094:	0802a8c5 	.word	0x0802a8c5
 802d098:	2000bb18 	.word	0x2000bb18
 802d09c:	0802c52d 	.word	0x0802c52d
 802d0a0:	0802c4d9 	.word	0x0802c4d9
 802d0a4:	0802a6f1 	.word	0x0802a6f1
 802d0a8:	0802c4b1 	.word	0x0802c4b1
 802d0ac:	0802c489 	.word	0x0802c489
 802d0b0:	08035d8c 	.word	0x08035d8c
 802d0b4:	2000a0e8 	.word	0x2000a0e8

0802d0b8 <LoRaMacStart>:

LoRaMacStatus_t LoRaMacStart( void )
{
 802d0b8:	b510      	push	{r4, lr}
    MacCtx.MacState = LORAMAC_IDLE;
 802d0ba:	4a04      	ldr	r2, [pc, #16]	; (802d0cc <LoRaMacStart+0x14>)
 802d0bc:	23d0      	movs	r3, #208	; 0xd0
 802d0be:	009b      	lsls	r3, r3, #2
 802d0c0:	2100      	movs	r1, #0
 802d0c2:	50d1      	str	r1, [r2, r3]
    UpdateRxSlotIdleState();
 802d0c4:	f7fd f9c0 	bl	802a448 <UpdateRxSlotIdleState>
    return LORAMAC_STATUS_OK;
}
 802d0c8:	2000      	movs	r0, #0
 802d0ca:	bd10      	pop	{r4, pc}
 802d0cc:	2000bb1c 	.word	0x2000bb1c

0802d0d0 <LoRaMacStop>:

LoRaMacStatus_t LoRaMacStop( void )
{
 802d0d0:	b510      	push	{r4, lr}
    if( LoRaMacIsBusy( ) == false )
 802d0d2:	f7ff fd97 	bl	802cc04 <LoRaMacIsBusy>
 802d0d6:	2800      	cmp	r0, #0
 802d0d8:	d007      	beq.n	802d0ea <LoRaMacStop+0x1a>
            Radio.Sleep( );
        }
        MacCtx.MacState = LORAMAC_STOPPED;
        return LORAMAC_STATUS_OK;
    }
    else if(  MacCtx.MacState == LORAMAC_STOPPED )
 802d0da:	4a0d      	ldr	r2, [pc, #52]	; (802d110 <LoRaMacStop+0x40>)
 802d0dc:	23d0      	movs	r3, #208	; 0xd0
 802d0de:	009b      	lsls	r3, r3, #2
 802d0e0:	58d3      	ldr	r3, [r2, r3]
 802d0e2:	2b01      	cmp	r3, #1
 802d0e4:	d012      	beq.n	802d10c <LoRaMacStop+0x3c>
    {
        return LORAMAC_STATUS_OK;
    }
    return LORAMAC_STATUS_BUSY;
 802d0e6:	2001      	movs	r0, #1
}
 802d0e8:	bd10      	pop	{r4, pc}
        if( Nvm.MacGroup2.DeviceClass == CLASS_C )
 802d0ea:	4a0a      	ldr	r2, [pc, #40]	; (802d114 <LoRaMacStop+0x44>)
 802d0ec:	238c      	movs	r3, #140	; 0x8c
 802d0ee:	005b      	lsls	r3, r3, #1
 802d0f0:	5cd3      	ldrb	r3, [r2, r3]
 802d0f2:	2b02      	cmp	r3, #2
 802d0f4:	d006      	beq.n	802d104 <LoRaMacStop+0x34>
        MacCtx.MacState = LORAMAC_STOPPED;
 802d0f6:	4a06      	ldr	r2, [pc, #24]	; (802d110 <LoRaMacStop+0x40>)
 802d0f8:	23d0      	movs	r3, #208	; 0xd0
 802d0fa:	009b      	lsls	r3, r3, #2
 802d0fc:	2101      	movs	r1, #1
 802d0fe:	50d1      	str	r1, [r2, r3]
        return LORAMAC_STATUS_OK;
 802d100:	2000      	movs	r0, #0
 802d102:	e7f1      	b.n	802d0e8 <LoRaMacStop+0x18>
            Radio.Sleep( );
 802d104:	4b04      	ldr	r3, [pc, #16]	; (802d118 <LoRaMacStop+0x48>)
 802d106:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802d108:	4798      	blx	r3
 802d10a:	e7f4      	b.n	802d0f6 <LoRaMacStop+0x26>
        return LORAMAC_STATUS_OK;
 802d10c:	2000      	movs	r0, #0
 802d10e:	e7eb      	b.n	802d0e8 <LoRaMacStop+0x18>
 802d110:	2000bb1c 	.word	0x2000bb1c
 802d114:	2000a000 	.word	0x2000a000
 802d118:	08035d8c 	.word	0x08035d8c

0802d11c <LoRaMacHalt>:

LoRaMacStatus_t LoRaMacHalt( void )
{
 802d11c:	b570      	push	{r4, r5, r6, lr}
    // Stop Timers
    TimerStop( &MacCtx.TxDelayedTimer );
 802d11e:	4c14      	ldr	r4, [pc, #80]	; (802d170 <LoRaMacHalt+0x54>)
 802d120:	0020      	movs	r0, r4
 802d122:	f007 fa37 	bl	8034594 <UTIL_TIMER_Stop>
    TimerStop( &MacCtx.RxWindowTimer1 );
 802d126:	0020      	movs	r0, r4
 802d128:	3018      	adds	r0, #24
 802d12a:	f007 fa33 	bl	8034594 <UTIL_TIMER_Stop>
    TimerStop( &MacCtx.RxWindowTimer2 );
 802d12e:	0020      	movs	r0, r4
 802d130:	3030      	adds	r0, #48	; 0x30
 802d132:	f007 fa2f 	bl	8034594 <UTIL_TIMER_Stop>
#if (defined( LORAMAC_VERSION ) && ( LORAMAC_VERSION == 0x01000300 ))
    TimerStop( &MacCtx.AckTimeoutTimer );
#elif (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    TimerStop( &MacCtx.RetransmitTimeoutTimer );
 802d136:	0020      	movs	r0, r4
 802d138:	3098      	adds	r0, #152	; 0x98
 802d13a:	f007 fa2b 	bl	8034594 <UTIL_TIMER_Stop>
#endif /* LORAMAC_VERSION */

    // Take care about class B
    LoRaMacClassBHaltBeaconing( );
 802d13e:	f000 ff1a 	bl	802df76 <LoRaMacClassBHaltBeaconing>

    // Switch off Radio
    Radio.Sleep( );
 802d142:	4b0c      	ldr	r3, [pc, #48]	; (802d174 <LoRaMacHalt+0x58>)
 802d144:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802d146:	4798      	blx	r3

    MacCtx.MacState = LORAMAC_IDLE;
 802d148:	4b0b      	ldr	r3, [pc, #44]	; (802d178 <LoRaMacHalt+0x5c>)
 802d14a:	469c      	mov	ip, r3
 802d14c:	4464      	add	r4, ip
 802d14e:	25d0      	movs	r5, #208	; 0xd0
 802d150:	00ad      	lsls	r5, r5, #2
 802d152:	2300      	movs	r3, #0
 802d154:	5163      	str	r3, [r4, r5]

#if (defined( CONTEXT_MANAGEMENT_ENABLED ) && ( CONTEXT_MANAGEMENT_ENABLED == 1 ))
    LoRaMacHandleNvm( &Nvm );
 802d156:	4e09      	ldr	r6, [pc, #36]	; (802d17c <LoRaMacHalt+0x60>)
 802d158:	0030      	movs	r0, r6
 802d15a:	f7ff f86d 	bl	802c238 <LoRaMacHandleNvm>

    // Preserve the Nvm context if data retention
    memcpy1( ( uint8_t* ) &NvmBackup, ( uint8_t* ) &Nvm, sizeof( LoRaMacNvmData_t ) );
 802d15e:	4a08      	ldr	r2, [pc, #32]	; (802d180 <LoRaMacHalt+0x64>)
 802d160:	0031      	movs	r1, r6
 802d162:	4808      	ldr	r0, [pc, #32]	; (802d184 <LoRaMacHalt+0x68>)
 802d164:	f004 ffcd 	bl	8032102 <memcpy1>
#endif /* CONTEXT_MANAGEMENT_ENABLED */

    MacCtx.MacState = LORAMAC_STOPPED;
 802d168:	2301      	movs	r3, #1
 802d16a:	5163      	str	r3, [r4, r5]

    return LORAMAC_STATUS_OK;
}
 802d16c:	2000      	movs	r0, #0
 802d16e:	bd70      	pop	{r4, r5, r6, pc}
 802d170:	2000be84 	.word	0x2000be84
 802d174:	08035d8c 	.word	0x08035d8c
 802d178:	fffffc98 	.word	0xfffffc98
 802d17c:	2000a000 	.word	0x2000a000
 802d180:	000004fc 	.word	0x000004fc
 802d184:	2000a4fc 	.word	0x2000a4fc

0802d188 <LoRaMacQueryTxPossible>:

LoRaMacStatus_t LoRaMacQueryTxPossible( uint8_t size, LoRaMacTxInfo_t* txInfo )
{
 802d188:	b570      	push	{r4, r5, r6, lr}
 802d18a:	b08a      	sub	sp, #40	; 0x28
 802d18c:	0005      	movs	r5, r0
 802d18e:	000c      	movs	r4, r1
    CalcNextAdrParams_t adrNext;
    uint32_t adrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 802d190:	4b30      	ldr	r3, [pc, #192]	; (802d254 <LoRaMacQueryTxPossible+0xcc>)
 802d192:	6a99      	ldr	r1, [r3, #40]	; 0x28
 802d194:	9104      	str	r1, [sp, #16]
    int8_t datarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 802d196:	22dd      	movs	r2, #221	; 0xdd
 802d198:	5698      	ldrsb	r0, [r3, r2]
 802d19a:	3ace      	subs	r2, #206	; 0xce
 802d19c:	446a      	add	r2, sp
 802d19e:	7010      	strb	r0, [r2, #0]
    int8_t txPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 802d1a0:	22dc      	movs	r2, #220	; 0xdc
 802d1a2:	569a      	ldrsb	r2, [r3, r2]
 802d1a4:	230e      	movs	r3, #14
 802d1a6:	446b      	add	r3, sp
 802d1a8:	701a      	strb	r2, [r3, #0]
#if (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    uint8_t nbTrans = MacCtx.ChannelsNbTransCounter;
 802d1aa:	4a2b      	ldr	r2, [pc, #172]	; (802d258 <LoRaMacQueryTxPossible+0xd0>)
 802d1ac:	2383      	movs	r3, #131	; 0x83
 802d1ae:	00db      	lsls	r3, r3, #3
 802d1b0:	5cd2      	ldrb	r2, [r2, r3]
 802d1b2:	230d      	movs	r3, #13
 802d1b4:	446b      	add	r3, sp
 802d1b6:	701a      	strb	r2, [r3, #0]
#endif /* LORAMAC_VERSION */
    size_t macCmdsSize = 0;
 802d1b8:	2300      	movs	r3, #0
 802d1ba:	9302      	str	r3, [sp, #8]

    if( txInfo == NULL )
 802d1bc:	2c00      	cmp	r4, #0
 802d1be:	d042      	beq.n	802d246 <LoRaMacQueryTxPossible+0xbe>

    // Setup ADR request
#if (defined( LORAMAC_VERSION ) && ( LORAMAC_VERSION == 0x01000300 ))
    adrNext.Version = Nvm.MacGroup2.Version;
#endif /* LORAMAC_VERSION */
    adrNext.UpdateChanMask = false;
 802d1c0:	a805      	add	r0, sp, #20
 802d1c2:	7003      	strb	r3, [r0, #0]
    adrNext.AdrEnabled = Nvm.MacGroup2.AdrCtrlOn;
 802d1c4:	4b23      	ldr	r3, [pc, #140]	; (802d254 <LoRaMacQueryTxPossible+0xcc>)
 802d1c6:	268d      	movs	r6, #141	; 0x8d
 802d1c8:	0076      	lsls	r6, r6, #1
 802d1ca:	5d9e      	ldrb	r6, [r3, r6]
 802d1cc:	7046      	strb	r6, [r0, #1]
    adrNext.AdrAckCounter = Nvm.MacGroup1.AdrAckCounter;
 802d1ce:	6041      	str	r1, [r0, #4]
    adrNext.AdrAckLimit = Nvm.MacGroup2.MacParams.AdrAckLimit;
 802d1d0:	2188      	movs	r1, #136	; 0x88
 802d1d2:	5a59      	ldrh	r1, [r3, r1]
 802d1d4:	8101      	strh	r1, [r0, #8]
    adrNext.AdrAckDelay = Nvm.MacGroup2.MacParams.AdrAckDelay;
 802d1d6:	218a      	movs	r1, #138	; 0x8a
 802d1d8:	5a59      	ldrh	r1, [r3, r1]
 802d1da:	8141      	strh	r1, [r0, #10]
    adrNext.Datarate = Nvm.MacGroup1.ChannelsDatarate;
 802d1dc:	2139      	movs	r1, #57	; 0x39
 802d1de:	5659      	ldrsb	r1, [r3, r1]
 802d1e0:	7301      	strb	r1, [r0, #12]
    adrNext.TxPower = Nvm.MacGroup1.ChannelsTxPower;
 802d1e2:	2138      	movs	r1, #56	; 0x38
 802d1e4:	5659      	ldrsb	r1, [r3, r1]
 802d1e6:	7341      	strb	r1, [r0, #13]
#if (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    adrNext.NbTrans = MacCtx.ChannelsNbTransCounter;
 802d1e8:	7382      	strb	r2, [r0, #14]
#endif /* LORAMAC_VERSION */
    adrNext.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802d1ea:	227c      	movs	r2, #124	; 0x7c
 802d1ec:	5c9a      	ldrb	r2, [r3, r2]
 802d1ee:	73c2      	strb	r2, [r0, #15]
    adrNext.Region = Nvm.MacGroup2.Region;
 802d1f0:	2248      	movs	r2, #72	; 0x48
 802d1f2:	5c9b      	ldrb	r3, [r3, r2]
 802d1f4:	7403      	strb	r3, [r0, #16]
    // We call the function for information purposes only. We don't want to
    // apply the datarate, the tx power and the ADR ack counter.
#if (defined( LORAMAC_VERSION ) && ( LORAMAC_VERSION == 0x01000300 ))
    LoRaMacAdrCalcNext( &adrNext, &datarate, &txPower, &adrAckCounter );
#elif (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    LoRaMacAdrCalcNext( &adrNext, &datarate, &txPower, &nbTrans, &adrAckCounter );
 802d1f6:	260f      	movs	r6, #15
 802d1f8:	446e      	add	r6, sp
 802d1fa:	ab04      	add	r3, sp, #16
 802d1fc:	9300      	str	r3, [sp, #0]
 802d1fe:	230d      	movs	r3, #13
 802d200:	446b      	add	r3, sp
 802d202:	3a3a      	subs	r2, #58	; 0x3a
 802d204:	446a      	add	r2, sp
 802d206:	0031      	movs	r1, r6
 802d208:	f000 fe28 	bl	802de5c <LoRaMacAdrCalcNext>
#endif /* LORAMAC_VERSION */

    txInfo->CurrentPossiblePayloadSize = GetMaxAppPayloadWithoutFOptsLength( datarate );
 802d20c:	2000      	movs	r0, #0
 802d20e:	5630      	ldrsb	r0, [r6, r0]
 802d210:	f7fd fa98 	bl	802a744 <GetMaxAppPayloadWithoutFOptsLength>
 802d214:	7060      	strb	r0, [r4, #1]

    if( LoRaMacCommandsGetSizeSerializedCmds( &macCmdsSize ) != LORAMAC_COMMANDS_SUCCESS )
 802d216:	a802      	add	r0, sp, #8
 802d218:	f000 fff2 	bl	802e200 <LoRaMacCommandsGetSizeSerializedCmds>
 802d21c:	2800      	cmp	r0, #0
 802d21e:	d114      	bne.n	802d24a <LoRaMacQueryTxPossible+0xc2>
    {
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
    }

    // Verify if the MAC commands fit into the FOpts and into the maximum payload.
    if( ( LORA_MAC_COMMAND_MAX_FOPTS_LENGTH >= macCmdsSize ) && ( txInfo->CurrentPossiblePayloadSize >= macCmdsSize ) )
 802d220:	9a02      	ldr	r2, [sp, #8]
 802d222:	2a0f      	cmp	r2, #15
 802d224:	d80b      	bhi.n	802d23e <LoRaMacQueryTxPossible+0xb6>
 802d226:	7863      	ldrb	r3, [r4, #1]
 802d228:	0019      	movs	r1, r3
 802d22a:	429a      	cmp	r2, r3
 802d22c:	d807      	bhi.n	802d23e <LoRaMacQueryTxPossible+0xb6>
    {
        txInfo->MaxPossibleApplicationDataSize = txInfo->CurrentPossiblePayloadSize - macCmdsSize;
 802d22e:	1a9b      	subs	r3, r3, r2
 802d230:	7023      	strb	r3, [r4, #0]

        // Verify if the application data together with MAC command fit into the maximum payload.
        if( txInfo->CurrentPossiblePayloadSize >= ( macCmdsSize + size ) )
 802d232:	4694      	mov	ip, r2
 802d234:	4465      	add	r5, ip
 802d236:	42a9      	cmp	r1, r5
 802d238:	d309      	bcc.n	802d24e <LoRaMacQueryTxPossible+0xc6>
    else
    {
        txInfo->MaxPossibleApplicationDataSize = 0;
        return LORAMAC_STATUS_LENGTH_ERROR;
    }
}
 802d23a:	b00a      	add	sp, #40	; 0x28
 802d23c:	bd70      	pop	{r4, r5, r6, pc}
        txInfo->MaxPossibleApplicationDataSize = 0;
 802d23e:	2300      	movs	r3, #0
 802d240:	7023      	strb	r3, [r4, #0]
        return LORAMAC_STATUS_LENGTH_ERROR;
 802d242:	2008      	movs	r0, #8
 802d244:	e7f9      	b.n	802d23a <LoRaMacQueryTxPossible+0xb2>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802d246:	2003      	movs	r0, #3
 802d248:	e7f7      	b.n	802d23a <LoRaMacQueryTxPossible+0xb2>
        return LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802d24a:	2013      	movs	r0, #19
 802d24c:	e7f5      	b.n	802d23a <LoRaMacQueryTxPossible+0xb2>
           return LORAMAC_STATUS_LENGTH_ERROR;
 802d24e:	2008      	movs	r0, #8
 802d250:	e7f3      	b.n	802d23a <LoRaMacQueryTxPossible+0xb2>
 802d252:	46c0      	nop			; (mov r8, r8)
 802d254:	2000a000 	.word	0x2000a000
 802d258:	2000bb1c 	.word	0x2000bb1c

0802d25c <LoRaMacMibGetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibGetRequestConfirm( MibRequestConfirm_t* mibGet )
{
 802d25c:	b510      	push	{r4, lr}
 802d25e:	b084      	sub	sp, #16
 802d260:	1e04      	subs	r4, r0, #0
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    if( mibGet == NULL )
 802d262:	d100      	bne.n	802d266 <LoRaMacMibGetRequestConfirm+0xa>
 802d264:	e11b      	b.n	802d49e <LoRaMacMibGetRequestConfirm+0x242>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    switch( mibGet->Type )
 802d266:	7800      	ldrb	r0, [r0, #0]
 802d268:	2841      	cmp	r0, #65	; 0x41
 802d26a:	d900      	bls.n	802d26e <LoRaMacMibGetRequestConfirm+0x12>
 802d26c:	e113      	b.n	802d496 <LoRaMacMibGetRequestConfirm+0x23a>
 802d26e:	0083      	lsls	r3, r0, #2
 802d270:	4a8d      	ldr	r2, [pc, #564]	; (802d4a8 <LoRaMacMibGetRequestConfirm+0x24c>)
 802d272:	58d3      	ldr	r3, [r2, r3]
 802d274:	469f      	mov	pc, r3
    {
        case MIB_DEVICE_CLASS:
        {
            mibGet->Param.Class = Nvm.MacGroup2.DeviceClass;
 802d276:	4a8d      	ldr	r2, [pc, #564]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d278:	238c      	movs	r3, #140	; 0x8c
 802d27a:	005b      	lsls	r3, r3, #1
 802d27c:	5cd3      	ldrb	r3, [r2, r3]
 802d27e:	7123      	strb	r3, [r4, #4]
            break;
 802d280:	e10e      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_NETWORK_ACTIVATION:
        {
            mibGet->Param.NetworkActivation = Nvm.MacGroup2.NetworkActivation;
 802d282:	4a8a      	ldr	r2, [pc, #552]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d284:	2398      	movs	r3, #152	; 0x98
 802d286:	005b      	lsls	r3, r3, #1
 802d288:	5cd3      	ldrb	r3, [r2, r3]
 802d28a:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d28c:	2000      	movs	r0, #0
            break;
 802d28e:	e107      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_DEV_EUI:
        {
            SecureElementGetDevEui( mibGet->Param.DevEui );
 802d290:	6860      	ldr	r0, [r4, #4]
 802d292:	f004 fde0 	bl	8031e56 <SecureElementGetDevEui>
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d296:	2000      	movs	r0, #0
            break;
 802d298:	e102      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_JOIN_EUI:
        {
             SecureElementGetJoinEui( mibGet->Param.JoinEui );
 802d29a:	6860      	ldr	r0, [r4, #4]
 802d29c:	f004 fe10 	bl	8031ec0 <SecureElementGetJoinEui>
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d2a0:	2000      	movs	r0, #0
            break;
 802d2a2:	e0fd      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_ADR:
        {
            mibGet->Param.AdrEnable = Nvm.MacGroup2.AdrCtrlOn;
 802d2a4:	4a81      	ldr	r2, [pc, #516]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d2a6:	238d      	movs	r3, #141	; 0x8d
 802d2a8:	005b      	lsls	r3, r3, #1
 802d2aa:	5cd3      	ldrb	r3, [r2, r3]
 802d2ac:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d2ae:	2000      	movs	r0, #0
            break;
 802d2b0:	e0f6      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_NET_ID:
        {
            mibGet->Param.NetID = Nvm.MacGroup2.NetID;
 802d2b2:	4a7e      	ldr	r2, [pc, #504]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d2b4:	23e0      	movs	r3, #224	; 0xe0
 802d2b6:	58d3      	ldr	r3, [r2, r3]
 802d2b8:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d2ba:	2000      	movs	r0, #0
            break;
 802d2bc:	e0f0      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_DEV_ADDR:
        {
            SecureElementGetDevAddr( Nvm.MacGroup2.NetworkActivation, &mibGet->Param.DevAddr );
 802d2be:	1d21      	adds	r1, r4, #4
 802d2c0:	4a7a      	ldr	r2, [pc, #488]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d2c2:	2398      	movs	r3, #152	; 0x98
 802d2c4:	005b      	lsls	r3, r3, #1
 802d2c6:	5cd0      	ldrb	r0, [r2, r3]
 802d2c8:	f004 fe2d 	bl	8031f26 <SecureElementGetDevAddr>
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d2cc:	2000      	movs	r0, #0
            break;
 802d2ce:	e0e7      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_PUBLIC_NETWORK:
        {
            mibGet->Param.EnablePublicNetwork = Nvm.MacGroup2.PublicNetwork;
 802d2d0:	4a76      	ldr	r2, [pc, #472]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d2d2:	231a      	movs	r3, #26
 802d2d4:	33ff      	adds	r3, #255	; 0xff
 802d2d6:	5cd3      	ldrb	r3, [r2, r3]
 802d2d8:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d2da:	2000      	movs	r0, #0
            break;
 802d2dc:	e0e0      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_REPEATER_SUPPORT:
        {
            mibGet->Param.EnableRepeaterSupport = Nvm.MacGroup2.MacParams.RepeaterSupport;
 802d2de:	4a73      	ldr	r2, [pc, #460]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d2e0:	238c      	movs	r3, #140	; 0x8c
 802d2e2:	5cd3      	ldrb	r3, [r2, r3]
 802d2e4:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d2e6:	2000      	movs	r0, #0
            break;
 802d2e8:	e0da      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_CHANNELS:
        {
            getPhy.Attribute = PHY_CHANNELS;
 802d2ea:	a902      	add	r1, sp, #8
 802d2ec:	231c      	movs	r3, #28
 802d2ee:	700b      	strb	r3, [r1, #0]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802d2f0:	4a6e      	ldr	r2, [pc, #440]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d2f2:	332c      	adds	r3, #44	; 0x2c
 802d2f4:	5cd0      	ldrb	r0, [r2, r3]
 802d2f6:	f001 fe7b 	bl	802eff0 <RegionGetPhyParam>
 802d2fa:	9001      	str	r0, [sp, #4]

            mibGet->Param.ChannelList = phyParam.Channels;
 802d2fc:	6060      	str	r0, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d2fe:	2000      	movs	r0, #0
            break;
 802d300:	e0ce      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_RX2_CHANNEL:
        {
            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParams.Rx2Channel;
 802d302:	3404      	adds	r4, #4
 802d304:	4b69      	ldr	r3, [pc, #420]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d306:	336c      	adds	r3, #108	; 0x6c
 802d308:	cb06      	ldmia	r3!, {r1, r2}
 802d30a:	c406      	stmia	r4!, {r1, r2}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d30c:	2000      	movs	r0, #0
            break;
 802d30e:	e0c7      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_RX2_DEFAULT_CHANNEL:
        {
            mibGet->Param.Rx2Channel = Nvm.MacGroup2.MacParamsDefaults.Rx2Channel;
 802d310:	3404      	adds	r4, #4
 802d312:	4b66      	ldr	r3, [pc, #408]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d314:	33b4      	adds	r3, #180	; 0xb4
 802d316:	cb06      	ldmia	r3!, {r1, r2}
 802d318:	c406      	stmia	r4!, {r1, r2}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d31a:	2000      	movs	r0, #0
            break;
 802d31c:	e0c0      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_RXC_CHANNEL:
        {
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParams.RxCChannel;
 802d31e:	3404      	adds	r4, #4
 802d320:	4b62      	ldr	r3, [pc, #392]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d322:	3374      	adds	r3, #116	; 0x74
 802d324:	cb06      	ldmia	r3!, {r1, r2}
 802d326:	c406      	stmia	r4!, {r1, r2}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d328:	2000      	movs	r0, #0
            break;
 802d32a:	e0b9      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_RXC_DEFAULT_CHANNEL:
        {
            mibGet->Param.RxCChannel = Nvm.MacGroup2.MacParamsDefaults.RxCChannel;
 802d32c:	3404      	adds	r4, #4
 802d32e:	4b5f      	ldr	r3, [pc, #380]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d330:	33bc      	adds	r3, #188	; 0xbc
 802d332:	cb06      	ldmia	r3!, {r1, r2}
 802d334:	c406      	stmia	r4!, {r1, r2}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d336:	2000      	movs	r0, #0
            break;
 802d338:	e0b2      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_CHANNELS_DEFAULT_MASK:
        {
            getPhy.Attribute = PHY_CHANNELS_DEFAULT_MASK;
 802d33a:	a902      	add	r1, sp, #8
 802d33c:	231a      	movs	r3, #26
 802d33e:	700b      	strb	r3, [r1, #0]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802d340:	4a5a      	ldr	r2, [pc, #360]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d342:	332e      	adds	r3, #46	; 0x2e
 802d344:	5cd0      	ldrb	r0, [r2, r3]
 802d346:	f001 fe53 	bl	802eff0 <RegionGetPhyParam>
 802d34a:	9001      	str	r0, [sp, #4]

            mibGet->Param.ChannelsDefaultMask = phyParam.ChannelsMask;
 802d34c:	6060      	str	r0, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d34e:	2000      	movs	r0, #0
            break;
 802d350:	e0a6      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_CHANNELS_MASK:
        {
            getPhy.Attribute = PHY_CHANNELS_MASK;
 802d352:	a902      	add	r1, sp, #8
 802d354:	2319      	movs	r3, #25
 802d356:	700b      	strb	r3, [r1, #0]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802d358:	4a54      	ldr	r2, [pc, #336]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d35a:	332f      	adds	r3, #47	; 0x2f
 802d35c:	5cd0      	ldrb	r0, [r2, r3]
 802d35e:	f001 fe47 	bl	802eff0 <RegionGetPhyParam>
 802d362:	9001      	str	r0, [sp, #4]

            mibGet->Param.ChannelsMask = phyParam.ChannelsMask;
 802d364:	6060      	str	r0, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d366:	2000      	movs	r0, #0
            break;
 802d368:	e09a      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_CHANNELS_NB_TRANS:
        {
            mibGet->Param.ChannelsNbTrans = Nvm.MacGroup2.MacParams.ChannelsNbTrans;
 802d36a:	4a50      	ldr	r2, [pc, #320]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d36c:	2368      	movs	r3, #104	; 0x68
 802d36e:	5cd3      	ldrb	r3, [r2, r3]
 802d370:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d372:	2000      	movs	r0, #0
            break;
 802d374:	e094      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_MAX_RX_WINDOW_DURATION:
        {
            mibGet->Param.MaxRxWindow = Nvm.MacGroup2.MacParams.MaxRxWindow;
 802d376:	4b4d      	ldr	r3, [pc, #308]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d378:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 802d37a:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d37c:	2000      	movs	r0, #0
            break;
 802d37e:	e08f      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_RECEIVE_DELAY_1:
        {
            mibGet->Param.ReceiveDelay1 = Nvm.MacGroup2.MacParams.ReceiveDelay1;
 802d380:	4b4a      	ldr	r3, [pc, #296]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d382:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 802d384:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d386:	2000      	movs	r0, #0
            break;
 802d388:	e08a      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_RECEIVE_DELAY_2:
        {
            mibGet->Param.ReceiveDelay2 = Nvm.MacGroup2.MacParams.ReceiveDelay2;
 802d38a:	4b48      	ldr	r3, [pc, #288]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d38c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802d38e:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d390:	2000      	movs	r0, #0
            break;
 802d392:	e085      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_JOIN_ACCEPT_DELAY_1:
        {
            mibGet->Param.JoinAcceptDelay1 = Nvm.MacGroup2.MacParams.JoinAcceptDelay1;
 802d394:	4b45      	ldr	r3, [pc, #276]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d396:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 802d398:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d39a:	2000      	movs	r0, #0
            break;
 802d39c:	e080      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_JOIN_ACCEPT_DELAY_2:
        {
            mibGet->Param.JoinAcceptDelay2 = Nvm.MacGroup2.MacParams.JoinAcceptDelay2;
 802d39e:	4b43      	ldr	r3, [pc, #268]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d3a0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 802d3a2:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d3a4:	2000      	movs	r0, #0
            break;
 802d3a6:	e07b      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
#if (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
        case MIB_CHANNELS_MIN_TX_DATARATE:
        {
            getPhy.Attribute = PHY_MIN_TX_DR;
 802d3a8:	2302      	movs	r3, #2
 802d3aa:	466a      	mov	r2, sp
 802d3ac:	7213      	strb	r3, [r2, #8]
            getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802d3ae:	4b3f      	ldr	r3, [pc, #252]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d3b0:	227c      	movs	r2, #124	; 0x7c
 802d3b2:	5c9a      	ldrb	r2, [r3, r2]
 802d3b4:	4669      	mov	r1, sp
 802d3b6:	728a      	strb	r2, [r1, #10]
            phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802d3b8:	2248      	movs	r2, #72	; 0x48
 802d3ba:	5c98      	ldrb	r0, [r3, r2]
 802d3bc:	a902      	add	r1, sp, #8
 802d3be:	f001 fe17 	bl	802eff0 <RegionGetPhyParam>
 802d3c2:	9001      	str	r0, [sp, #4]

            mibGet->Param.ChannelsMinTxDatarate = phyParam.Value;
 802d3c4:	7120      	strb	r0, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d3c6:	2000      	movs	r0, #0
            break;
 802d3c8:	e06a      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
#endif /* LORAMAC_VERSION */
        case MIB_CHANNELS_DEFAULT_DATARATE:
        {
            mibGet->Param.ChannelsDefaultDatarate = Nvm.MacGroup2.ChannelsDatarateDefault;
 802d3ca:	4a38      	ldr	r2, [pc, #224]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d3cc:	23dd      	movs	r3, #221	; 0xdd
 802d3ce:	56d3      	ldrsb	r3, [r2, r3]
 802d3d0:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d3d2:	2000      	movs	r0, #0
            break;
 802d3d4:	e064      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_CHANNELS_DATARATE:
        {
            mibGet->Param.ChannelsDatarate = Nvm.MacGroup1.ChannelsDatarate;
 802d3d6:	4a35      	ldr	r2, [pc, #212]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d3d8:	2339      	movs	r3, #57	; 0x39
 802d3da:	56d3      	ldrsb	r3, [r2, r3]
 802d3dc:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d3de:	2000      	movs	r0, #0
            break;
 802d3e0:	e05e      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_CHANNELS_DEFAULT_TX_POWER:
        {
            mibGet->Param.ChannelsDefaultTxPower = Nvm.MacGroup2.ChannelsTxPowerDefault;
 802d3e2:	4a32      	ldr	r2, [pc, #200]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d3e4:	23dc      	movs	r3, #220	; 0xdc
 802d3e6:	56d3      	ldrsb	r3, [r2, r3]
 802d3e8:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d3ea:	2000      	movs	r0, #0
            break;
 802d3ec:	e058      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_CHANNELS_TX_POWER:
        {
            mibGet->Param.ChannelsTxPower = Nvm.MacGroup1.ChannelsTxPower;
 802d3ee:	4a2f      	ldr	r2, [pc, #188]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d3f0:	2338      	movs	r3, #56	; 0x38
 802d3f2:	56d3      	ldrsb	r3, [r2, r3]
 802d3f4:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d3f6:	2000      	movs	r0, #0
            break;
 802d3f8:	e052      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_SYSTEM_MAX_RX_ERROR:
        {
            mibGet->Param.SystemMaxRxError = Nvm.MacGroup2.MacParams.SystemMaxRxError;
 802d3fa:	4b2c      	ldr	r3, [pc, #176]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d3fc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 802d3fe:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d400:	2000      	movs	r0, #0
            break;
 802d402:	e04d      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_MIN_RX_SYMBOLS:
        {
            mibGet->Param.MinRxSymbols = Nvm.MacGroup2.MacParams.MinRxSymbols;
 802d404:	4a29      	ldr	r2, [pc, #164]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d406:	2350      	movs	r3, #80	; 0x50
 802d408:	5cd3      	ldrb	r3, [r2, r3]
 802d40a:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d40c:	2000      	movs	r0, #0
            break;
 802d40e:	e047      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_ANTENNA_GAIN:
        {
            mibGet->Param.AntennaGain = Nvm.MacGroup2.MacParams.AntennaGain;
 802d410:	4a26      	ldr	r2, [pc, #152]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d412:	2384      	movs	r3, #132	; 0x84
 802d414:	58d3      	ldr	r3, [r2, r3]
 802d416:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d418:	2000      	movs	r0, #0
            break;
 802d41a:	e041      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_NVM_CTXS:
        {
            mibGet->Param.Contexts = &Nvm;
 802d41c:	4b23      	ldr	r3, [pc, #140]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d41e:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d420:	2000      	movs	r0, #0
            break;
 802d422:	e03d      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_NVM_BKP_CTXS:
        {
#if (defined( CONTEXT_MANAGEMENT_ENABLED ) && ( CONTEXT_MANAGEMENT_ENABLED == 1 ))
            mibGet->Param.BackupContexts = &NvmBackup;
 802d424:	4b22      	ldr	r3, [pc, #136]	; (802d4b0 <LoRaMacMibGetRequestConfirm+0x254>)
 802d426:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d428:	2000      	movs	r0, #0
#else
            mibGet->Param.BackupContexts = NULL;
#endif /* CONTEXT_MANAGEMENT_ENABLED */
            break;
 802d42a:	e039      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_DEFAULT_ANTENNA_GAIN:
        {
            mibGet->Param.DefaultAntennaGain = Nvm.MacGroup2.MacParamsDefaults.AntennaGain;
 802d42c:	4a1f      	ldr	r2, [pc, #124]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d42e:	23cc      	movs	r3, #204	; 0xcc
 802d430:	58d3      	ldr	r3, [r2, r3]
 802d432:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d434:	2000      	movs	r0, #0
            break;
 802d436:	e033      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_LORAWAN_VERSION:
        {
            mibGet->Param.LrWanVersion.LoRaWan = Nvm.MacGroup2.Version;
 802d438:	4a1c      	ldr	r2, [pc, #112]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d43a:	2396      	movs	r3, #150	; 0x96
 802d43c:	005b      	lsls	r3, r3, #1
 802d43e:	58d3      	ldr	r3, [r2, r3]
 802d440:	6063      	str	r3, [r4, #4]
            mibGet->Param.LrWanVersion.LoRaWanRegion = RegionGetVersion( );
 802d442:	f001 fef1 	bl	802f228 <RegionGetVersion>
 802d446:	60a0      	str	r0, [r4, #8]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d448:	2000      	movs	r0, #0
            break;
 802d44a:	e029      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
    case MIB_RXB_C_TIMEOUT:
        {
            mibGet->Param.RxBCTimeout = Nvm.MacGroup2.MacParams.RxBCTimeout;
 802d44c:	4a17      	ldr	r2, [pc, #92]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d44e:	2390      	movs	r3, #144	; 0x90
 802d450:	58d3      	ldr	r3, [r2, r3]
 802d452:	6063      	str	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d454:	2000      	movs	r0, #0
            break;
 802d456:	e023      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
#if (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
        case MIB_IS_CERT_FPORT_ON:
        {
            mibGet->Param.IsCertPortOn = Nvm.MacGroup2.IsCertPortOn;
 802d458:	4a14      	ldr	r2, [pc, #80]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d45a:	2320      	movs	r3, #32
 802d45c:	33ff      	adds	r3, #255	; 0xff
 802d45e:	5cd3      	ldrb	r3, [r2, r3]
 802d460:	7123      	strb	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d462:	2000      	movs	r0, #0
            break;
 802d464:	e01c      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
            break;
        }
#endif /* LORAMAC_VERSION */
        case MIB_ADR_ACK_LIMIT:
        {
            mibGet->Param.AdrAckLimit = Nvm.MacGroup2.MacParams.AdrAckLimit;
 802d466:	4a11      	ldr	r2, [pc, #68]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d468:	2388      	movs	r3, #136	; 0x88
 802d46a:	5ad3      	ldrh	r3, [r2, r3]
 802d46c:	80a3      	strh	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d46e:	2000      	movs	r0, #0
            break;
 802d470:	e016      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_ADR_ACK_DELAY:
        {
            mibGet->Param.AdrAckDelay = Nvm.MacGroup2.MacParams.AdrAckDelay;
 802d472:	4a0e      	ldr	r2, [pc, #56]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d474:	238a      	movs	r3, #138	; 0x8a
 802d476:	5ad3      	ldrh	r3, [r2, r3]
 802d478:	80a3      	strh	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d47a:	2000      	movs	r0, #0
            break;
 802d47c:	e010      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_ADR_ACK_DEFAULT_LIMIT:
        {
            mibGet->Param.AdrAckLimit = Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit;
 802d47e:	4a0b      	ldr	r2, [pc, #44]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d480:	23d0      	movs	r3, #208	; 0xd0
 802d482:	5ad3      	ldrh	r3, [r2, r3]
 802d484:	80a3      	strh	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d486:	2000      	movs	r0, #0
            break;
 802d488:	e00a      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        }
        case MIB_ADR_ACK_DEFAULT_DELAY:
        {
            mibGet->Param.AdrAckDelay = Nvm.MacGroup2.MacParamsDefaults.AdrAckDelay;
 802d48a:	4a08      	ldr	r2, [pc, #32]	; (802d4ac <LoRaMacMibGetRequestConfirm+0x250>)
 802d48c:	23d2      	movs	r3, #210	; 0xd2
 802d48e:	5ad3      	ldrh	r3, [r2, r3]
 802d490:	80a3      	strh	r3, [r4, #4]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d492:	2000      	movs	r0, #0
            break;
 802d494:	e004      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
#endif
            break;
        }
        default:
        {
            status = LoRaMacClassBMibGetRequestConfirm( mibGet );
 802d496:	0020      	movs	r0, r4
 802d498:	f000 fd71 	bl	802df7e <LoRaMacClassBMibGetRequestConfirm>
            break;
 802d49c:	e000      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802d49e:	2003      	movs	r0, #3
        }
    }
    return status;
}
 802d4a0:	b004      	add	sp, #16
 802d4a2:	bd10      	pop	{r4, pc}
    switch( mibGet->Type )
 802d4a4:	2018      	movs	r0, #24
 802d4a6:	e7fb      	b.n	802d4a0 <LoRaMacMibGetRequestConfirm+0x244>
 802d4a8:	08035448 	.word	0x08035448
 802d4ac:	2000a000 	.word	0x2000a000
 802d4b0:	2000a4fc 	.word	0x2000a4fc

0802d4b4 <LoRaMacMibSetRequestConfirm>:

LoRaMacStatus_t LoRaMacMibSetRequestConfirm( MibRequestConfirm_t* mibSet )
{
 802d4b4:	b530      	push	{r4, r5, lr}
 802d4b6:	b085      	sub	sp, #20
 802d4b8:	1e04      	subs	r4, r0, #0
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
    ChanMaskSetParams_t chanMaskSet;
    VerifyParams_t verify;

    if( mibSet == NULL )
 802d4ba:	d100      	bne.n	802d4be <LoRaMacMibSetRequestConfirm+0xa>
 802d4bc:	e242      	b.n	802d944 <LoRaMacMibSetRequestConfirm+0x490>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
    if( ( MacCtx.MacState & LORAMAC_TX_RUNNING ) == LORAMAC_TX_RUNNING )
 802d4be:	4ac3      	ldr	r2, [pc, #780]	; (802d7cc <LoRaMacMibSetRequestConfirm+0x318>)
 802d4c0:	23d0      	movs	r3, #208	; 0xd0
 802d4c2:	009b      	lsls	r3, r3, #2
 802d4c4:	58d3      	ldr	r3, [r2, r3]
 802d4c6:	079b      	lsls	r3, r3, #30
 802d4c8:	d500      	bpl.n	802d4cc <LoRaMacMibSetRequestConfirm+0x18>
 802d4ca:	e23d      	b.n	802d948 <LoRaMacMibSetRequestConfirm+0x494>
    {
        return LORAMAC_STATUS_BUSY;
    }

    switch( mibSet->Type )
 802d4cc:	7805      	ldrb	r5, [r0, #0]
 802d4ce:	2d41      	cmp	r5, #65	; 0x41
 802d4d0:	d900      	bls.n	802d4d4 <LoRaMacMibSetRequestConfirm+0x20>
 802d4d2:	e233      	b.n	802d93c <LoRaMacMibSetRequestConfirm+0x488>
 802d4d4:	00ab      	lsls	r3, r5, #2
 802d4d6:	4abe      	ldr	r2, [pc, #760]	; (802d7d0 <LoRaMacMibSetRequestConfirm+0x31c>)
 802d4d8:	58d3      	ldr	r3, [r2, r3]
 802d4da:	469f      	mov	pc, r3
    {
        case MIB_DEVICE_CLASS:
        {
            status = SwitchClass( mibSet->Param.Class );
 802d4dc:	7900      	ldrb	r0, [r0, #4]
 802d4de:	f7ff f937 	bl	802c750 <SwitchClass>
            break;
        }
    }

#if (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    if( status == LORAMAC_STATUS_OK )
 802d4e2:	2800      	cmp	r0, #0
 802d4e4:	d105      	bne.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
    {
        // Handle NVM potential changes
        MacCtx.MacFlags.Bits.NvmHandle = 1;
 802d4e6:	49b9      	ldr	r1, [pc, #740]	; (802d7cc <LoRaMacMibSetRequestConfirm+0x318>)
 802d4e8:	4aba      	ldr	r2, [pc, #744]	; (802d7d4 <LoRaMacMibSetRequestConfirm+0x320>)
 802d4ea:	5c8b      	ldrb	r3, [r1, r2]
 802d4ec:	2420      	movs	r4, #32
 802d4ee:	4323      	orrs	r3, r4
 802d4f0:	548b      	strb	r3, [r1, r2]
    }
#endif /* LORAMAC_VERSION */
    return status;
}
 802d4f2:	b005      	add	sp, #20
 802d4f4:	bd30      	pop	{r4, r5, pc}
            if( mibSet->Param.NetworkActivation != ACTIVATION_TYPE_OTAA  )
 802d4f6:	7903      	ldrb	r3, [r0, #4]
 802d4f8:	2b02      	cmp	r3, #2
 802d4fa:	d100      	bne.n	802d4fe <LoRaMacMibSetRequestConfirm+0x4a>
 802d4fc:	e228      	b.n	802d950 <LoRaMacMibSetRequestConfirm+0x49c>
                Nvm.MacGroup2.NetworkActivation = mibSet->Param.NetworkActivation;
 802d4fe:	49b6      	ldr	r1, [pc, #728]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d500:	2298      	movs	r2, #152	; 0x98
 802d502:	0052      	lsls	r2, r2, #1
 802d504:	548b      	strb	r3, [r1, r2]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d506:	2000      	movs	r0, #0
 802d508:	e7ed      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            if( SecureElementSetDevEui( mibSet->Param.DevEui ) != SECURE_ELEMENT_SUCCESS )
 802d50a:	6840      	ldr	r0, [r0, #4]
 802d50c:	f004 fc83 	bl	8031e16 <SecureElementSetDevEui>
 802d510:	2800      	cmp	r0, #0
 802d512:	d0e8      	beq.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d514:	2003      	movs	r0, #3
 802d516:	e7ec      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
            if( SecureElementSetJoinEui( mibSet->Param.JoinEui ) != SECURE_ELEMENT_SUCCESS )
 802d518:	6840      	ldr	r0, [r0, #4]
 802d51a:	f004 fcb1 	bl	8031e80 <SecureElementSetJoinEui>
 802d51e:	2800      	cmp	r0, #0
 802d520:	d0e1      	beq.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d522:	0028      	movs	r0, r5
 802d524:	e7e5      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
            Nvm.MacGroup2.AdrCtrlOn = mibSet->Param.AdrEnable;
 802d526:	7901      	ldrb	r1, [r0, #4]
 802d528:	4aab      	ldr	r2, [pc, #684]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d52a:	238d      	movs	r3, #141	; 0x8d
 802d52c:	005b      	lsls	r3, r3, #1
 802d52e:	54d1      	strb	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d530:	2000      	movs	r0, #0
 802d532:	e7d8      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            Nvm.MacGroup2.NetID = mibSet->Param.NetID;
 802d534:	6841      	ldr	r1, [r0, #4]
 802d536:	4aa8      	ldr	r2, [pc, #672]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d538:	23e0      	movs	r3, #224	; 0xe0
 802d53a:	50d1      	str	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d53c:	2000      	movs	r0, #0
 802d53e:	e7d2      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            if(SecureElementSetDevAddr( Nvm.MacGroup2.NetworkActivation, mibSet->Param.DevAddr ) != SECURE_ELEMENT_SUCCESS )
 802d540:	4aa5      	ldr	r2, [pc, #660]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d542:	2398      	movs	r3, #152	; 0x98
 802d544:	005b      	lsls	r3, r3, #1
 802d546:	5cd0      	ldrb	r0, [r2, r3]
 802d548:	6861      	ldr	r1, [r4, #4]
 802d54a:	f004 fcce 	bl	8031eea <SecureElementSetDevAddr>
 802d54e:	2800      	cmp	r0, #0
 802d550:	d000      	beq.n	802d554 <LoRaMacMibSetRequestConfirm+0xa0>
 802d552:	e1ff      	b.n	802d954 <LoRaMacMibSetRequestConfirm+0x4a0>
                Nvm.MacGroup2.DevAddr = mibSet->Param.DevAddr;
 802d554:	6861      	ldr	r1, [r4, #4]
 802d556:	4aa0      	ldr	r2, [pc, #640]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d558:	23e4      	movs	r3, #228	; 0xe4
 802d55a:	50d1      	str	r1, [r2, r3]
    if( status == LORAMAC_STATUS_OK )
 802d55c:	e7c3      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            if( mibSet->Param.AppKey != NULL )
 802d55e:	6841      	ldr	r1, [r0, #4]
 802d560:	2900      	cmp	r1, #0
 802d562:	d100      	bne.n	802d566 <LoRaMacMibSetRequestConfirm+0xb2>
 802d564:	e1f8      	b.n	802d958 <LoRaMacMibSetRequestConfirm+0x4a4>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_KEY, mibSet->Param.AppKey ) )
 802d566:	2000      	movs	r0, #0
 802d568:	f001 fb18 	bl	802eb9c <LoRaMacCryptoSetKey>
 802d56c:	2800      	cmp	r0, #0
 802d56e:	d0ba      	beq.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802d570:	2011      	movs	r0, #17
 802d572:	e7be      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
            if( mibSet->Param.NwkKey != NULL )
 802d574:	6841      	ldr	r1, [r0, #4]
 802d576:	2900      	cmp	r1, #0
 802d578:	d100      	bne.n	802d57c <LoRaMacMibSetRequestConfirm+0xc8>
 802d57a:	e1ef      	b.n	802d95c <LoRaMacMibSetRequestConfirm+0x4a8>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_KEY, mibSet->Param.NwkKey ) )
 802d57c:	2001      	movs	r0, #1
 802d57e:	f001 fb0d 	bl	802eb9c <LoRaMacCryptoSetKey>
 802d582:	2800      	cmp	r0, #0
 802d584:	d0ad      	beq.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802d586:	2011      	movs	r0, #17
 802d588:	e7b3      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
            if( mibSet->Param.NwkSKey != NULL )
 802d58a:	6841      	ldr	r1, [r0, #4]
 802d58c:	2900      	cmp	r1, #0
 802d58e:	d100      	bne.n	802d592 <LoRaMacMibSetRequestConfirm+0xde>
 802d590:	e1e6      	b.n	802d960 <LoRaMacMibSetRequestConfirm+0x4ac>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( NWK_S_KEY, mibSet->Param.NwkSKey ) )
 802d592:	2008      	movs	r0, #8
 802d594:	f001 fb02 	bl	802eb9c <LoRaMacCryptoSetKey>
 802d598:	2800      	cmp	r0, #0
 802d59a:	d0a2      	beq.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802d59c:	2011      	movs	r0, #17
 802d59e:	e7a8      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
            if( mibSet->Param.AppSKey != NULL )
 802d5a0:	6841      	ldr	r1, [r0, #4]
 802d5a2:	2900      	cmp	r1, #0
 802d5a4:	d100      	bne.n	802d5a8 <LoRaMacMibSetRequestConfirm+0xf4>
 802d5a6:	e1dd      	b.n	802d964 <LoRaMacMibSetRequestConfirm+0x4b0>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( APP_S_KEY, mibSet->Param.AppSKey ) )
 802d5a8:	2009      	movs	r0, #9
 802d5aa:	f001 faf7 	bl	802eb9c <LoRaMacCryptoSetKey>
 802d5ae:	2800      	cmp	r0, #0
 802d5b0:	d097      	beq.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802d5b2:	2011      	movs	r0, #17
 802d5b4:	e79d      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
            if( mibSet->Param.McKEKey != NULL )
 802d5b6:	6841      	ldr	r1, [r0, #4]
 802d5b8:	2900      	cmp	r1, #0
 802d5ba:	d100      	bne.n	802d5be <LoRaMacMibSetRequestConfirm+0x10a>
 802d5bc:	e1d4      	b.n	802d968 <LoRaMacMibSetRequestConfirm+0x4b4>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KE_KEY, mibSet->Param.McKEKey ) )
 802d5be:	200c      	movs	r0, #12
 802d5c0:	f001 faec 	bl	802eb9c <LoRaMacCryptoSetKey>
 802d5c4:	2800      	cmp	r0, #0
 802d5c6:	d100      	bne.n	802d5ca <LoRaMacMibSetRequestConfirm+0x116>
 802d5c8:	e78b      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802d5ca:	2011      	movs	r0, #17
 802d5cc:	e791      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
            if( mibSet->Param.McKey0 != NULL )
 802d5ce:	6841      	ldr	r1, [r0, #4]
 802d5d0:	2900      	cmp	r1, #0
 802d5d2:	d100      	bne.n	802d5d6 <LoRaMacMibSetRequestConfirm+0x122>
 802d5d4:	e1ca      	b.n	802d96c <LoRaMacMibSetRequestConfirm+0x4b8>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_KEY_0, mibSet->Param.McKey0 ) )
 802d5d6:	200d      	movs	r0, #13
 802d5d8:	f001 fae0 	bl	802eb9c <LoRaMacCryptoSetKey>
 802d5dc:	2800      	cmp	r0, #0
 802d5de:	d100      	bne.n	802d5e2 <LoRaMacMibSetRequestConfirm+0x12e>
 802d5e0:	e77f      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802d5e2:	2011      	movs	r0, #17
 802d5e4:	e785      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
            if( mibSet->Param.McAppSKey0 != NULL )
 802d5e6:	6841      	ldr	r1, [r0, #4]
 802d5e8:	2900      	cmp	r1, #0
 802d5ea:	d100      	bne.n	802d5ee <LoRaMacMibSetRequestConfirm+0x13a>
 802d5ec:	e1c0      	b.n	802d970 <LoRaMacMibSetRequestConfirm+0x4bc>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_APP_S_KEY_0, mibSet->Param.McAppSKey0 ) )
 802d5ee:	200e      	movs	r0, #14
 802d5f0:	f001 fad4 	bl	802eb9c <LoRaMacCryptoSetKey>
 802d5f4:	2800      	cmp	r0, #0
 802d5f6:	d100      	bne.n	802d5fa <LoRaMacMibSetRequestConfirm+0x146>
 802d5f8:	e773      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802d5fa:	2011      	movs	r0, #17
 802d5fc:	e779      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
            if( mibSet->Param.McNwkSKey0 != NULL )
 802d5fe:	6841      	ldr	r1, [r0, #4]
 802d600:	2900      	cmp	r1, #0
 802d602:	d100      	bne.n	802d606 <LoRaMacMibSetRequestConfirm+0x152>
 802d604:	e1b6      	b.n	802d974 <LoRaMacMibSetRequestConfirm+0x4c0>
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetKey( MC_NWK_S_KEY_0, mibSet->Param.McNwkSKey0 ) )
 802d606:	200f      	movs	r0, #15
 802d608:	f001 fac8 	bl	802eb9c <LoRaMacCryptoSetKey>
 802d60c:	2800      	cmp	r0, #0
 802d60e:	d100      	bne.n	802d612 <LoRaMacMibSetRequestConfirm+0x15e>
 802d610:	e767      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802d612:	2011      	movs	r0, #17
 802d614:	e76d      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
            Nvm.MacGroup2.PublicNetwork = mibSet->Param.EnablePublicNetwork;
 802d616:	7900      	ldrb	r0, [r0, #4]
 802d618:	4a6f      	ldr	r2, [pc, #444]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d61a:	231a      	movs	r3, #26
 802d61c:	33ff      	adds	r3, #255	; 0xff
 802d61e:	54d0      	strb	r0, [r2, r3]
            Radio.SetPublicNetwork( Nvm.MacGroup2.PublicNetwork );
 802d620:	4c6e      	ldr	r4, [pc, #440]	; (802d7dc <LoRaMacMibSetRequestConfirm+0x328>)
 802d622:	6da3      	ldr	r3, [r4, #88]	; 0x58
 802d624:	4798      	blx	r3
            Radio.Sleep( );
 802d626:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 802d628:	4798      	blx	r3
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d62a:	2000      	movs	r0, #0
 802d62c:	e75b      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            Nvm.MacGroup2.MacParams.RepeaterSupport = mibSet->Param.EnableRepeaterSupport;
 802d62e:	7901      	ldrb	r1, [r0, #4]
 802d630:	4a69      	ldr	r2, [pc, #420]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d632:	238c      	movs	r3, #140	; 0x8c
 802d634:	54d1      	strb	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d636:	2000      	movs	r0, #0
 802d638:	e755      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 802d63a:	2308      	movs	r3, #8
 802d63c:	56c3      	ldrsb	r3, [r0, r3]
 802d63e:	466a      	mov	r2, sp
 802d640:	7113      	strb	r3, [r2, #4]
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802d642:	4b65      	ldr	r3, [pc, #404]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d644:	227d      	movs	r2, #125	; 0x7d
 802d646:	5c9a      	ldrb	r2, [r3, r2]
 802d648:	4669      	mov	r1, sp
 802d64a:	714a      	strb	r2, [r1, #5]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) != true )
 802d64c:	2248      	movs	r2, #72	; 0x48
 802d64e:	5c98      	ldrb	r0, [r3, r2]
 802d650:	3a41      	subs	r2, #65	; 0x41
 802d652:	a901      	add	r1, sp, #4
 802d654:	f001 fcff 	bl	802f056 <RegionVerify>
 802d658:	2800      	cmp	r0, #0
 802d65a:	d101      	bne.n	802d660 <LoRaMacMibSetRequestConfirm+0x1ac>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d65c:	2003      	movs	r0, #3
 802d65e:	e740      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
                verify.Frequency = mibSet->Param.Rx2Channel.Frequency;
 802d660:	6863      	ldr	r3, [r4, #4]
 802d662:	9301      	str	r3, [sp, #4]
                if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_FREQUENCY ) != true )
 802d664:	4a5c      	ldr	r2, [pc, #368]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d666:	2348      	movs	r3, #72	; 0x48
 802d668:	5cd0      	ldrb	r0, [r2, r3]
 802d66a:	2200      	movs	r2, #0
 802d66c:	a901      	add	r1, sp, #4
 802d66e:	f001 fcf2 	bl	802f056 <RegionVerify>
 802d672:	2800      	cmp	r0, #0
 802d674:	d100      	bne.n	802d678 <LoRaMacMibSetRequestConfirm+0x1c4>
 802d676:	e17f      	b.n	802d978 <LoRaMacMibSetRequestConfirm+0x4c4>
                    Nvm.MacGroup2.MacParams.Rx2Channel = mibSet->Param.Rx2Channel;
 802d678:	4b57      	ldr	r3, [pc, #348]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d67a:	336c      	adds	r3, #108	; 0x6c
 802d67c:	3404      	adds	r4, #4
 802d67e:	cc06      	ldmia	r4!, {r1, r2}
 802d680:	c306      	stmia	r3!, {r1, r2}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d682:	2000      	movs	r0, #0
 802d684:	e72d      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
            verify.DatarateParams.Datarate = mibSet->Param.Rx2Channel.Datarate;
 802d686:	2308      	movs	r3, #8
 802d688:	56c3      	ldrsb	r3, [r0, r3]
 802d68a:	466a      	mov	r2, sp
 802d68c:	7113      	strb	r3, [r2, #4]
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802d68e:	4b52      	ldr	r3, [pc, #328]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d690:	227d      	movs	r2, #125	; 0x7d
 802d692:	5c9a      	ldrb	r2, [r3, r2]
 802d694:	4669      	mov	r1, sp
 802d696:	714a      	strb	r2, [r1, #5]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 802d698:	2248      	movs	r2, #72	; 0x48
 802d69a:	5c98      	ldrb	r0, [r3, r2]
 802d69c:	3a41      	subs	r2, #65	; 0x41
 802d69e:	a901      	add	r1, sp, #4
 802d6a0:	f001 fcd9 	bl	802f056 <RegionVerify>
 802d6a4:	2800      	cmp	r0, #0
 802d6a6:	d100      	bne.n	802d6aa <LoRaMacMibSetRequestConfirm+0x1f6>
 802d6a8:	e168      	b.n	802d97c <LoRaMacMibSetRequestConfirm+0x4c8>
                Nvm.MacGroup2.MacParamsDefaults.Rx2Channel = mibSet->Param.Rx2DefaultChannel;
 802d6aa:	4b4b      	ldr	r3, [pc, #300]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d6ac:	33b4      	adds	r3, #180	; 0xb4
 802d6ae:	3404      	adds	r4, #4
 802d6b0:	cc06      	ldmia	r4!, {r1, r2}
 802d6b2:	c306      	stmia	r3!, {r1, r2}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d6b4:	2000      	movs	r0, #0
 802d6b6:	e714      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 802d6b8:	2308      	movs	r3, #8
 802d6ba:	56c3      	ldrsb	r3, [r0, r3]
 802d6bc:	466a      	mov	r2, sp
 802d6be:	7113      	strb	r3, [r2, #4]
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802d6c0:	4b45      	ldr	r3, [pc, #276]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d6c2:	227d      	movs	r2, #125	; 0x7d
 802d6c4:	5c9a      	ldrb	r2, [r3, r2]
 802d6c6:	4669      	mov	r1, sp
 802d6c8:	714a      	strb	r2, [r1, #5]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 802d6ca:	2248      	movs	r2, #72	; 0x48
 802d6cc:	5c98      	ldrb	r0, [r3, r2]
 802d6ce:	3a41      	subs	r2, #65	; 0x41
 802d6d0:	a901      	add	r1, sp, #4
 802d6d2:	f001 fcc0 	bl	802f056 <RegionVerify>
 802d6d6:	2800      	cmp	r0, #0
 802d6d8:	d100      	bne.n	802d6dc <LoRaMacMibSetRequestConfirm+0x228>
 802d6da:	e151      	b.n	802d980 <LoRaMacMibSetRequestConfirm+0x4cc>
                Nvm.MacGroup2.MacParams.RxCChannel = mibSet->Param.RxCChannel;
 802d6dc:	4a3e      	ldr	r2, [pc, #248]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d6de:	0013      	movs	r3, r2
 802d6e0:	3374      	adds	r3, #116	; 0x74
 802d6e2:	3404      	adds	r4, #4
 802d6e4:	cc03      	ldmia	r4!, {r0, r1}
 802d6e6:	c303      	stmia	r3!, {r0, r1}
                if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) && ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) )
 802d6e8:	238c      	movs	r3, #140	; 0x8c
 802d6ea:	005b      	lsls	r3, r3, #1
 802d6ec:	5cd3      	ldrb	r3, [r2, r3]
 802d6ee:	2b02      	cmp	r3, #2
 802d6f0:	d001      	beq.n	802d6f6 <LoRaMacMibSetRequestConfirm+0x242>
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d6f2:	2000      	movs	r0, #0
 802d6f4:	e6f5      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
                if( ( Nvm.MacGroup2.DeviceClass == CLASS_C ) && ( Nvm.MacGroup2.NetworkActivation != ACTIVATION_TYPE_NONE ) )
 802d6f6:	332f      	adds	r3, #47	; 0x2f
 802d6f8:	33ff      	adds	r3, #255	; 0xff
 802d6fa:	5cd0      	ldrb	r0, [r2, r3]
 802d6fc:	2800      	cmp	r0, #0
 802d6fe:	d100      	bne.n	802d702 <LoRaMacMibSetRequestConfirm+0x24e>
 802d700:	e6ef      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
                    Radio.Sleep( );
 802d702:	4b36      	ldr	r3, [pc, #216]	; (802d7dc <LoRaMacMibSetRequestConfirm+0x328>)
 802d704:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802d706:	4798      	blx	r3
                    OpenContinuousRxCWindow( );
 802d708:	f7fe fcb2 	bl	802c070 <OpenContinuousRxCWindow>
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d70c:	2000      	movs	r0, #0
 802d70e:	e6e8      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
            verify.DatarateParams.Datarate = mibSet->Param.RxCChannel.Datarate;
 802d710:	2308      	movs	r3, #8
 802d712:	56c3      	ldrsb	r3, [r0, r3]
 802d714:	466a      	mov	r2, sp
 802d716:	7113      	strb	r3, [r2, #4]
            verify.DatarateParams.DownlinkDwellTime = Nvm.MacGroup2.MacParams.DownlinkDwellTime;
 802d718:	4b2f      	ldr	r3, [pc, #188]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d71a:	227d      	movs	r2, #125	; 0x7d
 802d71c:	5c9a      	ldrb	r2, [r3, r2]
 802d71e:	4669      	mov	r1, sp
 802d720:	714a      	strb	r2, [r1, #5]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_RX_DR ) == true )
 802d722:	2248      	movs	r2, #72	; 0x48
 802d724:	5c98      	ldrb	r0, [r3, r2]
 802d726:	3a41      	subs	r2, #65	; 0x41
 802d728:	a901      	add	r1, sp, #4
 802d72a:	f001 fc94 	bl	802f056 <RegionVerify>
 802d72e:	2800      	cmp	r0, #0
 802d730:	d100      	bne.n	802d734 <LoRaMacMibSetRequestConfirm+0x280>
 802d732:	e127      	b.n	802d984 <LoRaMacMibSetRequestConfirm+0x4d0>
                Nvm.MacGroup2.MacParamsDefaults.RxCChannel = mibSet->Param.RxCDefaultChannel;
 802d734:	4b28      	ldr	r3, [pc, #160]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d736:	33bc      	adds	r3, #188	; 0xbc
 802d738:	3404      	adds	r4, #4
 802d73a:	cc06      	ldmia	r4!, {r1, r2}
 802d73c:	c306      	stmia	r3!, {r1, r2}
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d73e:	2000      	movs	r0, #0
 802d740:	e6cf      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsDefaultMask;
 802d742:	6843      	ldr	r3, [r0, #4]
 802d744:	9302      	str	r3, [sp, #8]
 802d746:	a902      	add	r1, sp, #8
            chanMaskSet.ChannelsMaskType = CHANNELS_DEFAULT_MASK;
 802d748:	2301      	movs	r3, #1
 802d74a:	710b      	strb	r3, [r1, #4]
            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 802d74c:	4a22      	ldr	r2, [pc, #136]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d74e:	3347      	adds	r3, #71	; 0x47
 802d750:	5cd0      	ldrb	r0, [r2, r3]
 802d752:	f001 fc9e 	bl	802f092 <RegionChanMaskSet>
 802d756:	2800      	cmp	r0, #0
 802d758:	d001      	beq.n	802d75e <LoRaMacMibSetRequestConfirm+0x2aa>
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d75a:	2000      	movs	r0, #0
 802d75c:	e6c1      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d75e:	3003      	adds	r0, #3
 802d760:	e6c7      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
            chanMaskSet.ChannelsMaskIn = mibSet->Param.ChannelsMask;
 802d762:	6843      	ldr	r3, [r0, #4]
 802d764:	9302      	str	r3, [sp, #8]
 802d766:	a902      	add	r1, sp, #8
            chanMaskSet.ChannelsMaskType = CHANNELS_MASK;
 802d768:	2300      	movs	r3, #0
 802d76a:	710b      	strb	r3, [r1, #4]
            if( RegionChanMaskSet( Nvm.MacGroup2.Region, &chanMaskSet ) == false )
 802d76c:	4a1a      	ldr	r2, [pc, #104]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d76e:	3348      	adds	r3, #72	; 0x48
 802d770:	5cd0      	ldrb	r0, [r2, r3]
 802d772:	f001 fc8e 	bl	802f092 <RegionChanMaskSet>
 802d776:	2800      	cmp	r0, #0
 802d778:	d001      	beq.n	802d77e <LoRaMacMibSetRequestConfirm+0x2ca>
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d77a:	2000      	movs	r0, #0
 802d77c:	e6b1      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d77e:	3003      	adds	r0, #3
 802d780:	e6b7      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
            if( ( mibSet->Param.ChannelsNbTrans >= 1 ) &&
 802d782:	7902      	ldrb	r2, [r0, #4]
 802d784:	1e53      	subs	r3, r2, #1
 802d786:	b2db      	uxtb	r3, r3
 802d788:	2b0e      	cmp	r3, #14
 802d78a:	d900      	bls.n	802d78e <LoRaMacMibSetRequestConfirm+0x2da>
 802d78c:	e0fc      	b.n	802d988 <LoRaMacMibSetRequestConfirm+0x4d4>
                Nvm.MacGroup2.MacParams.ChannelsNbTrans = mibSet->Param.ChannelsNbTrans;
 802d78e:	4912      	ldr	r1, [pc, #72]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d790:	2368      	movs	r3, #104	; 0x68
 802d792:	54ca      	strb	r2, [r1, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d794:	2000      	movs	r0, #0
 802d796:	e6a4      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
            Nvm.MacGroup2.MacParams.MaxRxWindow = mibSet->Param.MaxRxWindow;
 802d798:	6842      	ldr	r2, [r0, #4]
 802d79a:	4b0f      	ldr	r3, [pc, #60]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d79c:	655a      	str	r2, [r3, #84]	; 0x54
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d79e:	2000      	movs	r0, #0
 802d7a0:	e6a1      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            Nvm.MacGroup2.MacParams.ReceiveDelay1 = mibSet->Param.ReceiveDelay1;
 802d7a2:	6842      	ldr	r2, [r0, #4]
 802d7a4:	4b0c      	ldr	r3, [pc, #48]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d7a6:	659a      	str	r2, [r3, #88]	; 0x58
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d7a8:	2000      	movs	r0, #0
 802d7aa:	e69c      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            Nvm.MacGroup2.MacParams.ReceiveDelay2 = mibSet->Param.ReceiveDelay2;
 802d7ac:	6842      	ldr	r2, [r0, #4]
 802d7ae:	4b0a      	ldr	r3, [pc, #40]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d7b0:	65da      	str	r2, [r3, #92]	; 0x5c
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d7b2:	2000      	movs	r0, #0
 802d7b4:	e697      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            Nvm.MacGroup2.MacParams.JoinAcceptDelay1 = mibSet->Param.JoinAcceptDelay1;
 802d7b6:	6842      	ldr	r2, [r0, #4]
 802d7b8:	4b07      	ldr	r3, [pc, #28]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d7ba:	661a      	str	r2, [r3, #96]	; 0x60
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d7bc:	2000      	movs	r0, #0
 802d7be:	e692      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            Nvm.MacGroup2.MacParams.JoinAcceptDelay2 = mibSet->Param.JoinAcceptDelay2;
 802d7c0:	6842      	ldr	r2, [r0, #4]
 802d7c2:	4b05      	ldr	r3, [pc, #20]	; (802d7d8 <LoRaMacMibSetRequestConfirm+0x324>)
 802d7c4:	665a      	str	r2, [r3, #100]	; 0x64
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d7c6:	2000      	movs	r0, #0
 802d7c8:	e68d      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
 802d7ca:	46c0      	nop			; (mov r8, r8)
 802d7cc:	2000bb1c 	.word	0x2000bb1c
 802d7d0:	08035550 	.word	0x08035550
 802d7d4:	00000491 	.word	0x00000491
 802d7d8:	2000a000 	.word	0x2000a000
 802d7dc:	08035d8c 	.word	0x08035d8c
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDefaultDatarate;
 802d7e0:	2304      	movs	r3, #4
 802d7e2:	56c3      	ldrsb	r3, [r0, r3]
 802d7e4:	a901      	add	r1, sp, #4
 802d7e6:	700b      	strb	r3, [r1, #0]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_DR ) == true )
 802d7e8:	4a6c      	ldr	r2, [pc, #432]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d7ea:	2348      	movs	r3, #72	; 0x48
 802d7ec:	5cd0      	ldrb	r0, [r2, r3]
 802d7ee:	2206      	movs	r2, #6
 802d7f0:	f001 fc31 	bl	802f056 <RegionVerify>
 802d7f4:	2800      	cmp	r0, #0
 802d7f6:	d100      	bne.n	802d7fa <LoRaMacMibSetRequestConfirm+0x346>
 802d7f8:	e0c8      	b.n	802d98c <LoRaMacMibSetRequestConfirm+0x4d8>
                Nvm.MacGroup2.ChannelsDatarateDefault = verify.DatarateParams.Datarate;
 802d7fa:	ab01      	add	r3, sp, #4
 802d7fc:	2100      	movs	r1, #0
 802d7fe:	5659      	ldrsb	r1, [r3, r1]
 802d800:	4a66      	ldr	r2, [pc, #408]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d802:	23dd      	movs	r3, #221	; 0xdd
 802d804:	54d1      	strb	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d806:	2000      	movs	r0, #0
 802d808:	e66b      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
            verify.DatarateParams.Datarate = mibSet->Param.ChannelsDatarate;
 802d80a:	2304      	movs	r3, #4
 802d80c:	56c3      	ldrsb	r3, [r0, r3]
 802d80e:	466a      	mov	r2, sp
 802d810:	7113      	strb	r3, [r2, #4]
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802d812:	4b62      	ldr	r3, [pc, #392]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d814:	227c      	movs	r2, #124	; 0x7c
 802d816:	5c9a      	ldrb	r2, [r3, r2]
 802d818:	4669      	mov	r1, sp
 802d81a:	718a      	strb	r2, [r1, #6]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 802d81c:	2248      	movs	r2, #72	; 0x48
 802d81e:	5c98      	ldrb	r0, [r3, r2]
 802d820:	3a43      	subs	r2, #67	; 0x43
 802d822:	a901      	add	r1, sp, #4
 802d824:	f001 fc17 	bl	802f056 <RegionVerify>
 802d828:	2800      	cmp	r0, #0
 802d82a:	d100      	bne.n	802d82e <LoRaMacMibSetRequestConfirm+0x37a>
 802d82c:	e0b0      	b.n	802d990 <LoRaMacMibSetRequestConfirm+0x4dc>
                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;
 802d82e:	ab01      	add	r3, sp, #4
 802d830:	2100      	movs	r1, #0
 802d832:	5659      	ldrsb	r1, [r3, r1]
 802d834:	4a59      	ldr	r2, [pc, #356]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d836:	2339      	movs	r3, #57	; 0x39
 802d838:	54d1      	strb	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d83a:	2000      	movs	r0, #0
 802d83c:	e651      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
            verify.TxPower = mibSet->Param.ChannelsDefaultTxPower;
 802d83e:	2304      	movs	r3, #4
 802d840:	56c3      	ldrsb	r3, [r0, r3]
 802d842:	a901      	add	r1, sp, #4
 802d844:	700b      	strb	r3, [r1, #0]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DEF_TX_POWER ) == true )
 802d846:	4a55      	ldr	r2, [pc, #340]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d848:	2348      	movs	r3, #72	; 0x48
 802d84a:	5cd0      	ldrb	r0, [r2, r3]
 802d84c:	220a      	movs	r2, #10
 802d84e:	f001 fc02 	bl	802f056 <RegionVerify>
 802d852:	2800      	cmp	r0, #0
 802d854:	d100      	bne.n	802d858 <LoRaMacMibSetRequestConfirm+0x3a4>
 802d856:	e09d      	b.n	802d994 <LoRaMacMibSetRequestConfirm+0x4e0>
                Nvm.MacGroup2.ChannelsTxPowerDefault = verify.TxPower;
 802d858:	ab01      	add	r3, sp, #4
 802d85a:	2100      	movs	r1, #0
 802d85c:	5659      	ldrsb	r1, [r3, r1]
 802d85e:	4a4f      	ldr	r2, [pc, #316]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d860:	23dc      	movs	r3, #220	; 0xdc
 802d862:	54d1      	strb	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d864:	2000      	movs	r0, #0
 802d866:	e63c      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
            verify.TxPower = mibSet->Param.ChannelsTxPower;
 802d868:	2304      	movs	r3, #4
 802d86a:	56c3      	ldrsb	r3, [r0, r3]
 802d86c:	a901      	add	r1, sp, #4
 802d86e:	700b      	strb	r3, [r1, #0]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_POWER ) == true )
 802d870:	4a4a      	ldr	r2, [pc, #296]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d872:	2348      	movs	r3, #72	; 0x48
 802d874:	5cd0      	ldrb	r0, [r2, r3]
 802d876:	2209      	movs	r2, #9
 802d878:	f001 fbed 	bl	802f056 <RegionVerify>
 802d87c:	2800      	cmp	r0, #0
 802d87e:	d100      	bne.n	802d882 <LoRaMacMibSetRequestConfirm+0x3ce>
 802d880:	e08a      	b.n	802d998 <LoRaMacMibSetRequestConfirm+0x4e4>
                Nvm.MacGroup1.ChannelsTxPower = verify.TxPower;
 802d882:	ab01      	add	r3, sp, #4
 802d884:	2100      	movs	r1, #0
 802d886:	5659      	ldrsb	r1, [r3, r1]
 802d888:	4a44      	ldr	r2, [pc, #272]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d88a:	2338      	movs	r3, #56	; 0x38
 802d88c:	54d1      	strb	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d88e:	2000      	movs	r0, #0
 802d890:	e627      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
            Nvm.MacGroup2.MacParams.SystemMaxRxError = Nvm.MacGroup2.MacParamsDefaults.SystemMaxRxError = mibSet->Param.SystemMaxRxError;
 802d892:	6842      	ldr	r2, [r0, #4]
 802d894:	4b41      	ldr	r3, [pc, #260]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d896:	2194      	movs	r1, #148	; 0x94
 802d898:	505a      	str	r2, [r3, r1]
 802d89a:	64da      	str	r2, [r3, #76]	; 0x4c
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d89c:	2000      	movs	r0, #0
 802d89e:	e622      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            Nvm.MacGroup2.MacParams.MinRxSymbols = Nvm.MacGroup2.MacParamsDefaults.MinRxSymbols = mibSet->Param.MinRxSymbols;
 802d8a0:	7902      	ldrb	r2, [r0, #4]
 802d8a2:	4b3e      	ldr	r3, [pc, #248]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d8a4:	2198      	movs	r1, #152	; 0x98
 802d8a6:	545a      	strb	r2, [r3, r1]
 802d8a8:	3948      	subs	r1, #72	; 0x48
 802d8aa:	545a      	strb	r2, [r3, r1]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d8ac:	2000      	movs	r0, #0
 802d8ae:	e61a      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            Nvm.MacGroup2.MacParams.AntennaGain = mibSet->Param.AntennaGain;
 802d8b0:	6841      	ldr	r1, [r0, #4]
 802d8b2:	4a3a      	ldr	r2, [pc, #232]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d8b4:	2384      	movs	r3, #132	; 0x84
 802d8b6:	50d1      	str	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d8b8:	2000      	movs	r0, #0
 802d8ba:	e614      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            Nvm.MacGroup2.MacParamsDefaults.AntennaGain = mibSet->Param.DefaultAntennaGain;
 802d8bc:	6841      	ldr	r1, [r0, #4]
 802d8be:	4a37      	ldr	r2, [pc, #220]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d8c0:	23cc      	movs	r3, #204	; 0xcc
 802d8c2:	50d1      	str	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d8c4:	2000      	movs	r0, #0
 802d8c6:	e60e      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            status = RestoreNvmData( );
 802d8c8:	f7fe fd32 	bl	802c330 <RestoreNvmData>
            break;
 802d8cc:	e609      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
            if( mibSet->Param.AbpLrWanVersion.Fields.Minor <= 1 )
 802d8ce:	7983      	ldrb	r3, [r0, #6]
 802d8d0:	2b01      	cmp	r3, #1
 802d8d2:	d901      	bls.n	802d8d8 <LoRaMacMibSetRequestConfirm+0x424>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d8d4:	2003      	movs	r0, #3
 802d8d6:	e60c      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                Nvm.MacGroup2.Version = mibSet->Param.AbpLrWanVersion;
 802d8d8:	4a30      	ldr	r2, [pc, #192]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d8da:	2396      	movs	r3, #150	; 0x96
 802d8dc:	005b      	lsls	r3, r3, #1
 802d8de:	6841      	ldr	r1, [r0, #4]
 802d8e0:	50d1      	str	r1, [r2, r3]
                if( LORAMAC_CRYPTO_SUCCESS != LoRaMacCryptoSetLrWanVersion( mibSet->Param.AbpLrWanVersion ) )
 802d8e2:	6840      	ldr	r0, [r0, #4]
 802d8e4:	f000 fffe 	bl	802e8e4 <LoRaMacCryptoSetLrWanVersion>
 802d8e8:	2800      	cmp	r0, #0
 802d8ea:	d100      	bne.n	802d8ee <LoRaMacMibSetRequestConfirm+0x43a>
 802d8ec:	e5fb      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
                    return LORAMAC_STATUS_CRYPTO_ERROR;
 802d8ee:	2011      	movs	r0, #17
 802d8f0:	e5ff      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
            Nvm.MacGroup2.MacParams.RxBCTimeout = mibSet->Param.RxBCTimeout;
 802d8f2:	6841      	ldr	r1, [r0, #4]
 802d8f4:	4a29      	ldr	r2, [pc, #164]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d8f6:	2390      	movs	r3, #144	; 0x90
 802d8f8:	50d1      	str	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d8fa:	2000      	movs	r0, #0
 802d8fc:	e5f3      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            Nvm.MacGroup2.IsCertPortOn = mibSet->Param.IsCertPortOn;
 802d8fe:	7901      	ldrb	r1, [r0, #4]
 802d900:	4a26      	ldr	r2, [pc, #152]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d902:	2320      	movs	r3, #32
 802d904:	33ff      	adds	r3, #255	; 0xff
 802d906:	54d1      	strb	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d908:	2000      	movs	r0, #0
 802d90a:	e5ec      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            Nvm.MacGroup2.MacParams.AdrAckLimit = mibSet->Param.AdrAckLimit;
 802d90c:	8881      	ldrh	r1, [r0, #4]
 802d90e:	4a23      	ldr	r2, [pc, #140]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d910:	2388      	movs	r3, #136	; 0x88
 802d912:	52d1      	strh	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d914:	2000      	movs	r0, #0
 802d916:	e5e6      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            Nvm.MacGroup2.MacParams.AdrAckDelay = mibSet->Param.AdrAckDelay;
 802d918:	8881      	ldrh	r1, [r0, #4]
 802d91a:	4a20      	ldr	r2, [pc, #128]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d91c:	238a      	movs	r3, #138	; 0x8a
 802d91e:	52d1      	strh	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d920:	2000      	movs	r0, #0
 802d922:	e5e0      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            Nvm.MacGroup2.MacParamsDefaults.AdrAckLimit = mibSet->Param.AdrAckLimit;
 802d924:	8881      	ldrh	r1, [r0, #4]
 802d926:	4a1d      	ldr	r2, [pc, #116]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d928:	23d0      	movs	r3, #208	; 0xd0
 802d92a:	52d1      	strh	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d92c:	2000      	movs	r0, #0
 802d92e:	e5da      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            Nvm.MacGroup2.MacParamsDefaults.AdrAckDelay = mibSet->Param.AdrAckDelay;
 802d930:	8881      	ldrh	r1, [r0, #4]
 802d932:	4a1a      	ldr	r2, [pc, #104]	; (802d99c <LoRaMacMibSetRequestConfirm+0x4e8>)
 802d934:	23d2      	movs	r3, #210	; 0xd2
 802d936:	52d1      	strh	r1, [r2, r3]
    LoRaMacStatus_t status = LORAMAC_STATUS_OK;
 802d938:	2000      	movs	r0, #0
 802d93a:	e5d4      	b.n	802d4e6 <LoRaMacMibSetRequestConfirm+0x32>
            status = LoRaMacMibClassBSetRequestConfirm( mibSet );
 802d93c:	0020      	movs	r0, r4
 802d93e:	f000 fb20 	bl	802df82 <LoRaMacMibClassBSetRequestConfirm>
            break;
 802d942:	e5ce      	b.n	802d4e2 <LoRaMacMibSetRequestConfirm+0x2e>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802d944:	2003      	movs	r0, #3
 802d946:	e5d4      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
        return LORAMAC_STATUS_BUSY;
 802d948:	2001      	movs	r0, #1
 802d94a:	e5d2      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
    switch( mibSet->Type )
 802d94c:	2018      	movs	r0, #24
 802d94e:	e5d0      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d950:	2003      	movs	r0, #3
 802d952:	e5ce      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d954:	2003      	movs	r0, #3
 802d956:	e5cc      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d958:	2003      	movs	r0, #3
 802d95a:	e5ca      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d95c:	2003      	movs	r0, #3
 802d95e:	e5c8      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d960:	2003      	movs	r0, #3
 802d962:	e5c6      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d964:	2003      	movs	r0, #3
 802d966:	e5c4      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d968:	2003      	movs	r0, #3
 802d96a:	e5c2      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d96c:	2003      	movs	r0, #3
 802d96e:	e5c0      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d970:	2003      	movs	r0, #3
 802d972:	e5be      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d974:	2003      	movs	r0, #3
 802d976:	e5bc      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                    status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d978:	2003      	movs	r0, #3
 802d97a:	e5ba      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d97c:	2003      	movs	r0, #3
 802d97e:	e5b8      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d980:	2003      	movs	r0, #3
 802d982:	e5b6      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d984:	2003      	movs	r0, #3
 802d986:	e5b4      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d988:	2003      	movs	r0, #3
 802d98a:	e5b2      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d98c:	2003      	movs	r0, #3
 802d98e:	e5b0      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d990:	2003      	movs	r0, #3
 802d992:	e5ae      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d994:	2003      	movs	r0, #3
 802d996:	e5ac      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
                status = LORAMAC_STATUS_PARAMETER_INVALID;
 802d998:	2003      	movs	r0, #3
 802d99a:	e5aa      	b.n	802d4f2 <LoRaMacMibSetRequestConfirm+0x3e>
 802d99c:	2000a000 	.word	0x2000a000

0802d9a0 <LoRaMacMlmeRequest>:

    return LORAMAC_STATUS_OK;
}

LoRaMacStatus_t LoRaMacMlmeRequest( MlmeReq_t* mlmeRequest )
{
 802d9a0:	b570      	push	{r4, r5, r6, lr}
 802d9a2:	b086      	sub	sp, #24
 802d9a4:	0004      	movs	r4, r0
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
    MlmeConfirmQueue_t queueElement;
    uint8_t macCmdPayload[2] = { 0x00, 0x00 };
 802d9a6:	ab04      	add	r3, sp, #16
 802d9a8:	2200      	movs	r2, #0
 802d9aa:	801a      	strh	r2, [r3, #0]

    if( mlmeRequest == NULL )
 802d9ac:	2800      	cmp	r0, #0
 802d9ae:	d100      	bne.n	802d9b2 <LoRaMacMlmeRequest+0x12>
 802d9b0:	e0ec      	b.n	802db8c <LoRaMacMlmeRequest+0x1ec>
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }
#if (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    // Initialize mlmeRequest->ReqReturn.DutyCycleWaitTime to 0 in order to
    // return a valid value in case the MAC is busy.
    mlmeRequest->ReqReturn.DutyCycleWaitTime = 0;
 802d9b2:	2300      	movs	r3, #0
 802d9b4:	6103      	str	r3, [r0, #16]
#endif /* LORAMAC_VERSION */

    if( LoRaMacIsBusy( ) == true )
 802d9b6:	f7ff f925 	bl	802cc04 <LoRaMacIsBusy>
 802d9ba:	2800      	cmp	r0, #0
 802d9bc:	d003      	beq.n	802d9c6 <LoRaMacMlmeRequest+0x26>
    {
        return LORAMAC_STATUS_BUSY;
 802d9be:	2501      	movs	r5, #1
    else
    {
        LoRaMacConfirmQueueAdd( &queueElement );
    }
    return status;
}
 802d9c0:	0028      	movs	r0, r5
 802d9c2:	b006      	add	sp, #24
 802d9c4:	bd70      	pop	{r4, r5, r6, pc}
    if( LoRaMacConfirmQueueIsFull( ) == true )
 802d9c6:	f000 fda7 	bl	802e518 <LoRaMacConfirmQueueIsFull>
 802d9ca:	2800      	cmp	r0, #0
 802d9cc:	d001      	beq.n	802d9d2 <LoRaMacMlmeRequest+0x32>
        return LORAMAC_STATUS_BUSY;
 802d9ce:	2501      	movs	r5, #1
 802d9d0:	e7f6      	b.n	802d9c0 <LoRaMacMlmeRequest+0x20>
    if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 802d9d2:	f000 fd9b 	bl	802e50c <LoRaMacConfirmQueueGetCnt>
 802d9d6:	2800      	cmp	r0, #0
 802d9d8:	d017      	beq.n	802da0a <LoRaMacMlmeRequest+0x6a>
    MacCtx.MlmeConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802d9da:	4b6d      	ldr	r3, [pc, #436]	; (802db90 <LoRaMacMlmeRequest+0x1f0>)
 802d9dc:	2101      	movs	r1, #1
 802d9de:	4a6d      	ldr	r2, [pc, #436]	; (802db94 <LoRaMacMlmeRequest+0x1f4>)
 802d9e0:	5499      	strb	r1, [r3, r2]
    MacCtx.MacFlags.Bits.MlmeReq = 1;
 802d9e2:	486d      	ldr	r0, [pc, #436]	; (802db98 <LoRaMacMlmeRequest+0x1f8>)
 802d9e4:	5c1a      	ldrb	r2, [r3, r0]
 802d9e6:	2504      	movs	r5, #4
 802d9e8:	432a      	orrs	r2, r5
 802d9ea:	541a      	strb	r2, [r3, r0]
    queueElement.Request = mlmeRequest->Type;
 802d9ec:	7823      	ldrb	r3, [r4, #0]
 802d9ee:	aa05      	add	r2, sp, #20
 802d9f0:	7013      	strb	r3, [r2, #0]
    queueElement.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802d9f2:	7051      	strb	r1, [r2, #1]
    queueElement.RestrictCommonReadyToHandle = false;
 802d9f4:	2100      	movs	r1, #0
 802d9f6:	70d1      	strb	r1, [r2, #3]
    queueElement.ReadyToHandle = false;
 802d9f8:	7091      	strb	r1, [r2, #2]
    switch( mlmeRequest->Type )
 802d9fa:	001d      	movs	r5, r3
 802d9fc:	2b0d      	cmp	r3, #13
 802d9fe:	d900      	bls.n	802da02 <LoRaMacMlmeRequest+0x62>
 802da00:	e0aa      	b.n	802db58 <LoRaMacMlmeRequest+0x1b8>
 802da02:	009b      	lsls	r3, r3, #2
 802da04:	4a65      	ldr	r2, [pc, #404]	; (802db9c <LoRaMacMlmeRequest+0x1fc>)
 802da06:	58d3      	ldr	r3, [r2, r3]
 802da08:	469f      	mov	pc, r3
        memset1( ( uint8_t* ) &MacCtx.MlmeConfirm, 0, sizeof( MacCtx.MlmeConfirm ) );
 802da0a:	2214      	movs	r2, #20
 802da0c:	2100      	movs	r1, #0
 802da0e:	4864      	ldr	r0, [pc, #400]	; (802dba0 <LoRaMacMlmeRequest+0x200>)
 802da10:	f004 fb8f 	bl	8032132 <memset1>
 802da14:	e7e1      	b.n	802d9da <LoRaMacMlmeRequest+0x3a>
            if( ( MacCtx.MacState & LORAMAC_TX_DELAYED ) == LORAMAC_TX_DELAYED )
 802da16:	4a5e      	ldr	r2, [pc, #376]	; (802db90 <LoRaMacMlmeRequest+0x1f0>)
 802da18:	23d0      	movs	r3, #208	; 0xd0
 802da1a:	009b      	lsls	r3, r3, #2
 802da1c:	58d3      	ldr	r3, [r2, r3]
 802da1e:	069b      	lsls	r3, r3, #26
 802da20:	d4ce      	bmi.n	802d9c0 <LoRaMacMlmeRequest+0x20>
            if( mlmeRequest->Req.Join.NetworkActivation == ACTIVATION_TYPE_OTAA )
 802da22:	7923      	ldrb	r3, [r4, #4]
 802da24:	2b02      	cmp	r3, #2
 802da26:	d003      	beq.n	802da30 <LoRaMacMlmeRequest+0x90>
            else if( mlmeRequest->Req.Join.NetworkActivation == ACTIVATION_TYPE_ABP )
 802da28:	2b01      	cmp	r3, #1
 802da2a:	d026      	beq.n	802da7a <LoRaMacMlmeRequest+0xda>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 802da2c:	2502      	movs	r5, #2
 802da2e:	e094      	b.n	802db5a <LoRaMacMlmeRequest+0x1ba>
                ResetMacParameters( false );
 802da30:	2000      	movs	r0, #0
 802da32:	f7fe fda3 	bl	802c57c <ResetMacParameters>
                Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR );
 802da36:	2105      	movs	r1, #5
 802da38:	5661      	ldrsb	r1, [r4, r1]
 802da3a:	4d5a      	ldr	r5, [pc, #360]	; (802dba4 <LoRaMacMlmeRequest+0x204>)
 802da3c:	2348      	movs	r3, #72	; 0x48
 802da3e:	5ce8      	ldrb	r0, [r5, r3]
 802da40:	2200      	movs	r2, #0
 802da42:	f001 fbbd 	bl	802f1c0 <RegionAlternateDr>
 802da46:	2339      	movs	r3, #57	; 0x39
 802da48:	54e8      	strb	r0, [r5, r3]
                Nvm.MacGroup1.ChannelsTxPower = mlmeRequest->Req.Join.TxPower;
 802da4a:	2206      	movs	r2, #6
 802da4c:	56a2      	ldrsb	r2, [r4, r2]
 802da4e:	3b01      	subs	r3, #1
 802da50:	54ea      	strb	r2, [r5, r3]
                queueElement.Status = LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL;
 802da52:	ab05      	add	r3, sp, #20
 802da54:	2207      	movs	r2, #7
 802da56:	705a      	strb	r2, [r3, #1]
                status = SendReJoinReq( JOIN_REQ );
 802da58:	20ff      	movs	r0, #255	; 0xff
 802da5a:	f7fe ff29 	bl	802c8b0 <SendReJoinReq>
 802da5e:	1e05      	subs	r5, r0, #0
                if( status != LORAMAC_STATUS_OK )
 802da60:	d100      	bne.n	802da64 <LoRaMacMlmeRequest+0xc4>
 802da62:	e07a      	b.n	802db5a <LoRaMacMlmeRequest+0x1ba>
                    Nvm.MacGroup1.ChannelsDatarate = RegionAlternateDr( Nvm.MacGroup2.Region, mlmeRequest->Req.Join.Datarate, ALTERNATE_DR_RESTORE );
 802da64:	2105      	movs	r1, #5
 802da66:	5661      	ldrsb	r1, [r4, r1]
 802da68:	4e4e      	ldr	r6, [pc, #312]	; (802dba4 <LoRaMacMlmeRequest+0x204>)
 802da6a:	2348      	movs	r3, #72	; 0x48
 802da6c:	5cf0      	ldrb	r0, [r6, r3]
 802da6e:	2201      	movs	r2, #1
 802da70:	f001 fba6 	bl	802f1c0 <RegionAlternateDr>
 802da74:	2339      	movs	r3, #57	; 0x39
 802da76:	54f0      	strb	r0, [r6, r3]
 802da78:	e06f      	b.n	802db5a <LoRaMacMlmeRequest+0x1ba>
                Nvm.MacGroup2.ChannelsDatarateChangedLinkAdrReq = false;
 802da7a:	4d4a      	ldr	r5, [pc, #296]	; (802dba4 <LoRaMacMlmeRequest+0x204>)
 802da7c:	2600      	movs	r6, #0
 802da7e:	231e      	movs	r3, #30
 802da80:	33ff      	adds	r3, #255	; 0xff
 802da82:	54ee      	strb	r6, [r5, r3]
                params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;
 802da84:	3b1c      	subs	r3, #28
 802da86:	3bff      	subs	r3, #255	; 0xff
 802da88:	466a      	mov	r2, sp
 802da8a:	7313      	strb	r3, [r2, #12]
                RegionInitDefaults( Nvm.MacGroup2.Region, &params );
 802da8c:	3346      	adds	r3, #70	; 0x46
 802da8e:	5ce8      	ldrb	r0, [r5, r3]
 802da90:	4669      	mov	r1, sp
 802da92:	f001 fad2 	bl	802f03a <RegionInitDefaults>
                Nvm.MacGroup2.NetworkActivation = mlmeRequest->Req.Join.NetworkActivation;
 802da96:	7922      	ldrb	r2, [r4, #4]
 802da98:	2398      	movs	r3, #152	; 0x98
 802da9a:	005b      	lsls	r3, r3, #1
 802da9c:	54ea      	strb	r2, [r5, r3]
                queueElement.Status = LORAMAC_EVENT_INFO_STATUS_OK;
 802da9e:	ab05      	add	r3, sp, #20
 802daa0:	705e      	strb	r6, [r3, #1]
                queueElement.ReadyToHandle = true;
 802daa2:	2201      	movs	r2, #1
 802daa4:	709a      	strb	r2, [r3, #2]
                OnMacProcessNotify( );
 802daa6:	f7fc fe15 	bl	802a6d4 <OnMacProcessNotify>
                MacCtx.MacFlags.Bits.MacDone = 1;
 802daaa:	4939      	ldr	r1, [pc, #228]	; (802db90 <LoRaMacMlmeRequest+0x1f0>)
 802daac:	4a3a      	ldr	r2, [pc, #232]	; (802db98 <LoRaMacMlmeRequest+0x1f8>)
 802daae:	5c8b      	ldrb	r3, [r1, r2]
 802dab0:	2010      	movs	r0, #16
 802dab2:	4303      	orrs	r3, r0
 802dab4:	548b      	strb	r3, [r1, r2]
                status = LORAMAC_STATUS_OK;
 802dab6:	2500      	movs	r5, #0
 802dab8:	e04f      	b.n	802db5a <LoRaMacMlmeRequest+0x1ba>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_LINK_CHECK_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 802daba:	2200      	movs	r2, #0
 802dabc:	a904      	add	r1, sp, #16
 802dabe:	2002      	movs	r0, #2
 802dac0:	f000 fb0e 	bl	802e0e0 <LoRaMacCommandsAddCmd>
 802dac4:	1e05      	subs	r5, r0, #0
 802dac6:	d048      	beq.n	802db5a <LoRaMacMlmeRequest+0x1ba>
                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802dac8:	2513      	movs	r5, #19
 802daca:	e046      	b.n	802db5a <LoRaMacMlmeRequest+0x1ba>
            status = SetTxContinuousWave( mlmeRequest->Req.TxCw.Timeout, mlmeRequest->Req.TxCw.Frequency, mlmeRequest->Req.TxCw.Power );
 802dacc:	7b22      	ldrb	r2, [r4, #12]
 802dace:	88a0      	ldrh	r0, [r4, #4]
 802dad0:	68a1      	ldr	r1, [r4, #8]
 802dad2:	f7fc fd3b 	bl	802a54c <SetTxContinuousWave>
 802dad6:	0005      	movs	r5, r0
            break;
 802dad8:	e03f      	b.n	802db5a <LoRaMacMlmeRequest+0x1ba>
            if (LoRaMacCommandsGetCmd( MOTE_MAC_DEVICE_TIME_REQ, &newCmd ) == LORAMAC_COMMANDS_SUCCESS)
 802dada:	4669      	mov	r1, sp
 802dadc:	200d      	movs	r0, #13
 802dade:	f000 fb4f 	bl	802e180 <LoRaMacCommandsGetCmd>
 802dae2:	1e05      	subs	r5, r0, #0
 802dae4:	d039      	beq.n	802db5a <LoRaMacMlmeRequest+0x1ba>
            else if( LoRaMacCommandsAddCmd( MOTE_MAC_DEVICE_TIME_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 802dae6:	2200      	movs	r2, #0
 802dae8:	a904      	add	r1, sp, #16
 802daea:	200d      	movs	r0, #13
 802daec:	f000 faf8 	bl	802e0e0 <LoRaMacCommandsAddCmd>
 802daf0:	1e05      	subs	r5, r0, #0
 802daf2:	d032      	beq.n	802db5a <LoRaMacMlmeRequest+0x1ba>
                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802daf4:	2513      	movs	r5, #19
            break;
 802daf6:	e030      	b.n	802db5a <LoRaMacMlmeRequest+0x1ba>
            if( Nvm.MacGroup2.DeviceClass == CLASS_A )
 802daf8:	4a2a      	ldr	r2, [pc, #168]	; (802dba4 <LoRaMacMlmeRequest+0x204>)
 802dafa:	238c      	movs	r3, #140	; 0x8c
 802dafc:	005b      	lsls	r3, r3, #1
 802dafe:	5cd3      	ldrb	r3, [r2, r3]
 802db00:	2b00      	cmp	r3, #0
 802db02:	d001      	beq.n	802db08 <LoRaMacMlmeRequest+0x168>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 802db04:	2502      	movs	r5, #2
 802db06:	e028      	b.n	802db5a <LoRaMacMlmeRequest+0x1ba>
                uint8_t value = mlmeRequest->Req.PingSlotInfo.PingSlot.Value;
 802db08:	7925      	ldrb	r5, [r4, #4]
                LoRaMacClassBSetPingSlotInfo( mlmeRequest->Req.PingSlotInfo.PingSlot.Fields.Periodicity );
 802db0a:	0768      	lsls	r0, r5, #29
 802db0c:	0f40      	lsrs	r0, r0, #29
 802db0e:	f000 fa31 	bl	802df74 <LoRaMacClassBSetPingSlotInfo>
                macCmdPayload[0] = value;
 802db12:	a904      	add	r1, sp, #16
 802db14:	700d      	strb	r5, [r1, #0]
                if( LoRaMacCommandsAddCmd( MOTE_MAC_PING_SLOT_INFO_REQ, macCmdPayload, 1 ) != LORAMAC_COMMANDS_SUCCESS )
 802db16:	2201      	movs	r2, #1
 802db18:	2010      	movs	r0, #16
 802db1a:	f000 fae1 	bl	802e0e0 <LoRaMacCommandsAddCmd>
 802db1e:	1e05      	subs	r5, r0, #0
 802db20:	d01b      	beq.n	802db5a <LoRaMacMlmeRequest+0x1ba>
                    status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802db22:	2513      	movs	r5, #19
 802db24:	e019      	b.n	802db5a <LoRaMacMlmeRequest+0x1ba>
            if( LoRaMacCommandsAddCmd( MOTE_MAC_BEACON_TIMING_REQ, macCmdPayload, 0 ) != LORAMAC_COMMANDS_SUCCESS )
 802db26:	2200      	movs	r2, #0
 802db28:	a904      	add	r1, sp, #16
 802db2a:	2012      	movs	r0, #18
 802db2c:	f000 fad8 	bl	802e0e0 <LoRaMacCommandsAddCmd>
 802db30:	1e05      	subs	r5, r0, #0
 802db32:	d012      	beq.n	802db5a <LoRaMacMlmeRequest+0x1ba>
                status = LORAMAC_STATUS_MAC_COMMAD_ERROR;
 802db34:	2513      	movs	r5, #19
 802db36:	e010      	b.n	802db5a <LoRaMacMlmeRequest+0x1ba>
            queueElement.RestrictCommonReadyToHandle = true;
 802db38:	ab05      	add	r3, sp, #20
 802db3a:	2201      	movs	r2, #1
 802db3c:	70da      	strb	r2, [r3, #3]
            if( LoRaMacClassBIsAcquisitionInProgress( ) == false )
 802db3e:	f000 fa0a 	bl	802df56 <LoRaMacClassBIsAcquisitionInProgress>
 802db42:	2800      	cmp	r0, #0
 802db44:	d001      	beq.n	802db4a <LoRaMacMlmeRequest+0x1aa>
                status = LORAMAC_STATUS_BUSY;
 802db46:	2501      	movs	r5, #1
 802db48:	e007      	b.n	802db5a <LoRaMacMlmeRequest+0x1ba>
                LoRaMacClassBSetBeaconState( BEACON_STATE_ACQUISITION );
 802db4a:	f000 fa01 	bl	802df50 <LoRaMacClassBSetBeaconState>
                LoRaMacClassBBeaconTimerEvent( NULL );
 802db4e:	2000      	movs	r0, #0
 802db50:	f000 fa03 	bl	802df5a <LoRaMacClassBBeaconTimerEvent>
                status = LORAMAC_STATUS_OK;
 802db54:	2500      	movs	r5, #0
 802db56:	e000      	b.n	802db5a <LoRaMacMlmeRequest+0x1ba>
    switch( mlmeRequest->Type )
 802db58:	2502      	movs	r5, #2
    mlmeRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 802db5a:	4a0d      	ldr	r2, [pc, #52]	; (802db90 <LoRaMacMlmeRequest+0x1f0>)
 802db5c:	4b12      	ldr	r3, [pc, #72]	; (802dba8 <LoRaMacMlmeRequest+0x208>)
 802db5e:	58d3      	ldr	r3, [r2, r3]
 802db60:	6123      	str	r3, [r4, #16]
    if( status != LORAMAC_STATUS_OK )
 802db62:	2d00      	cmp	r5, #0
 802db64:	d00e      	beq.n	802db84 <LoRaMacMlmeRequest+0x1e4>
        if( LoRaMacConfirmQueueGetCnt( ) == 0 )
 802db66:	f000 fcd1 	bl	802e50c <LoRaMacConfirmQueueGetCnt>
 802db6a:	2800      	cmp	r0, #0
 802db6c:	d000      	beq.n	802db70 <LoRaMacMlmeRequest+0x1d0>
 802db6e:	e727      	b.n	802d9c0 <LoRaMacMlmeRequest+0x20>
            MacCtx.NodeAckRequested = false;
 802db70:	4b07      	ldr	r3, [pc, #28]	; (802db90 <LoRaMacMlmeRequest+0x1f0>)
 802db72:	4a0e      	ldr	r2, [pc, #56]	; (802dbac <LoRaMacMlmeRequest+0x20c>)
 802db74:	2100      	movs	r1, #0
 802db76:	5499      	strb	r1, [r3, r2]
            MacCtx.MacFlags.Bits.MlmeReq = 0;
 802db78:	4907      	ldr	r1, [pc, #28]	; (802db98 <LoRaMacMlmeRequest+0x1f8>)
 802db7a:	5c5a      	ldrb	r2, [r3, r1]
 802db7c:	3004      	adds	r0, #4
 802db7e:	4382      	bics	r2, r0
 802db80:	545a      	strb	r2, [r3, r1]
 802db82:	e71d      	b.n	802d9c0 <LoRaMacMlmeRequest+0x20>
        LoRaMacConfirmQueueAdd( &queueElement );
 802db84:	a805      	add	r0, sp, #20
 802db86:	f000 fbf3 	bl	802e370 <LoRaMacConfirmQueueAdd>
 802db8a:	e719      	b.n	802d9c0 <LoRaMacMlmeRequest+0x20>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802db8c:	2503      	movs	r5, #3
 802db8e:	e717      	b.n	802d9c0 <LoRaMacMlmeRequest+0x20>
 802db90:	2000bb1c 	.word	0x2000bb1c
 802db94:	00000455 	.word	0x00000455
 802db98:	00000491 	.word	0x00000491
 802db9c:	08035658 	.word	0x08035658
 802dba0:	2000bf70 	.word	0x2000bf70
 802dba4:	2000a000 	.word	0x2000a000
 802dba8:	00000494 	.word	0x00000494
 802dbac:	0000041a 	.word	0x0000041a

0802dbb0 <LoRaMacMcpsRequest>:

LoRaMacStatus_t LoRaMacMcpsRequest( McpsReq_t* mcpsRequest, bool allowDelayedTx )
{
 802dbb0:	b5f0      	push	{r4, r5, r6, r7, lr}
 802dbb2:	46de      	mov	lr, fp
 802dbb4:	4657      	mov	r7, sl
 802dbb6:	464e      	mov	r6, r9
 802dbb8:	4645      	mov	r5, r8
 802dbba:	b5e0      	push	{r5, r6, r7, lr}
 802dbbc:	b08f      	sub	sp, #60	; 0x3c
 802dbbe:	0004      	movs	r4, r0
 802dbc0:	9102      	str	r1, [sp, #8]
 802dbc2:	2300      	movs	r3, #0
 802dbc4:	4698      	mov	r8, r3
    void* fBuffer = NULL;
    uint16_t fBufferSize;
    int8_t datarate = DR_0;
    bool readyToSend = false;

    if( mcpsRequest == NULL )
 802dbc6:	2800      	cmp	r0, #0
 802dbc8:	d100      	bne.n	802dbcc <LoRaMacMcpsRequest+0x1c>
 802dbca:	e0f0      	b.n	802ddae <LoRaMacMcpsRequest+0x1fe>
        }
    }
#elif (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    // Initialize mcpsRequest->ReqReturn.DutyCycleWaitTime to 0 in order to
    // return a valid value in case the MAC is busy.
    mcpsRequest->ReqReturn.DutyCycleWaitTime = 0;
 802dbcc:	6103      	str	r3, [r0, #16]

    if( LoRaMacIsBusy( ) == true )
 802dbce:	f7ff f819 	bl	802cc04 <LoRaMacIsBusy>
 802dbd2:	1e05      	subs	r5, r0, #0
 802dbd4:	d007      	beq.n	802dbe6 <LoRaMacMcpsRequest+0x36>
    {
        return LORAMAC_STATUS_BUSY;
 802dbd6:	2001      	movs	r0, #1

    // Fill return structure
    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;

    return status;
}
 802dbd8:	b00f      	add	sp, #60	; 0x3c
 802dbda:	bcf0      	pop	{r4, r5, r6, r7}
 802dbdc:	46bb      	mov	fp, r7
 802dbde:	46b2      	mov	sl, r6
 802dbe0:	46a9      	mov	r9, r5
 802dbe2:	46a0      	mov	r8, r4
 802dbe4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    McpsReq_t request = *mcpsRequest;
 802dbe6:	a904      	add	r1, sp, #16
 802dbe8:	000b      	movs	r3, r1
 802dbea:	0022      	movs	r2, r4
 802dbec:	ca43      	ldmia	r2!, {r0, r1, r6}
 802dbee:	c343      	stmia	r3!, {r0, r1, r6}
 802dbf0:	ca03      	ldmia	r2!, {r0, r1}
 802dbf2:	c303      	stmia	r3!, {r0, r1}
    macHdr.Value = 0;
 802dbf4:	ab0a      	add	r3, sp, #40	; 0x28
 802dbf6:	2200      	movs	r2, #0
 802dbf8:	701a      	strb	r2, [r3, #0]
    memset1( ( uint8_t* ) &MacCtx.McpsConfirm, 0, sizeof( MacCtx.McpsConfirm ) );
 802dbfa:	4e6f      	ldr	r6, [pc, #444]	; (802ddb8 <LoRaMacMcpsRequest+0x208>)
 802dbfc:	3214      	adds	r2, #20
 802dbfe:	2100      	movs	r1, #0
 802dc00:	0030      	movs	r0, r6
 802dc02:	f004 fa96 	bl	8032132 <memset1>
    MacCtx.McpsConfirm.Status = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802dc06:	4b6d      	ldr	r3, [pc, #436]	; (802ddbc <LoRaMacMcpsRequest+0x20c>)
 802dc08:	469c      	mov	ip, r3
 802dc0a:	4466      	add	r6, ip
 802dc0c:	4b6c      	ldr	r3, [pc, #432]	; (802ddc0 <LoRaMacMcpsRequest+0x210>)
 802dc0e:	2201      	movs	r2, #1
 802dc10:	54f2      	strb	r2, [r6, r3]
    if( ( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_OTAA ) &&
 802dc12:	4a6c      	ldr	r2, [pc, #432]	; (802ddc4 <LoRaMacMcpsRequest+0x214>)
 802dc14:	2398      	movs	r3, #152	; 0x98
 802dc16:	005b      	lsls	r3, r3, #1
 802dc18:	5cd3      	ldrb	r3, [r2, r3]
 802dc1a:	2b02      	cmp	r3, #2
 802dc1c:	d071      	beq.n	802dd02 <LoRaMacMcpsRequest+0x152>
    switch( request.Type )
 802dc1e:	ab04      	add	r3, sp, #16
 802dc20:	781f      	ldrb	r7, [r3, #0]
 802dc22:	2f01      	cmp	r7, #1
 802dc24:	d100      	bne.n	802dc28 <LoRaMacMcpsRequest+0x78>
 802dc26:	e092      	b.n	802dd4e <LoRaMacMcpsRequest+0x19e>
 802dc28:	2f03      	cmp	r7, #3
 802dc2a:	d100      	bne.n	802dc2e <LoRaMacMcpsRequest+0x7e>
 802dc2c:	e0a2      	b.n	802dd74 <LoRaMacMcpsRequest+0x1c4>
 802dc2e:	2f00      	cmp	r7, #0
 802dc30:	d07a      	beq.n	802dd28 <LoRaMacMcpsRequest+0x178>
 802dc32:	2300      	movs	r3, #0
 802dc34:	4699      	mov	r9, r3
 802dc36:	469b      	mov	fp, r3
 802dc38:	469a      	mov	sl, r3
    getPhy.Attribute = PHY_MIN_TX_DR;
 802dc3a:	2302      	movs	r3, #2
 802dc3c:	aa02      	add	r2, sp, #8
 802dc3e:	2128      	movs	r1, #40	; 0x28
 802dc40:	1852      	adds	r2, r2, r1
 802dc42:	7013      	strb	r3, [r2, #0]
    getPhy.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802dc44:	4b5f      	ldr	r3, [pc, #380]	; (802ddc4 <LoRaMacMcpsRequest+0x214>)
 802dc46:	227c      	movs	r2, #124	; 0x7c
 802dc48:	5c9a      	ldrb	r2, [r3, r2]
 802dc4a:	a902      	add	r1, sp, #8
 802dc4c:	202a      	movs	r0, #42	; 0x2a
 802dc4e:	1809      	adds	r1, r1, r0
 802dc50:	700a      	strb	r2, [r1, #0]
    phyParam = RegionGetPhyParam( Nvm.MacGroup2.Region, &getPhy );
 802dc52:	2248      	movs	r2, #72	; 0x48
 802dc54:	5c98      	ldrb	r0, [r3, r2]
 802dc56:	a90c      	add	r1, sp, #48	; 0x30
 802dc58:	f001 f9ca 	bl	802eff0 <RegionGetPhyParam>
 802dc5c:	900b      	str	r0, [sp, #44]	; 0x2c
    datarate = MAX( datarate, ( int8_t )phyParam.Value );
 802dc5e:	b246      	sxtb	r6, r0
 802dc60:	1c33      	adds	r3, r6, #0
 802dc62:	454e      	cmp	r6, r9
 802dc64:	da00      	bge.n	802dc68 <LoRaMacMcpsRequest+0xb8>
 802dc66:	464b      	mov	r3, r9
 802dc68:	b25b      	sxtb	r3, r3
 802dc6a:	9303      	str	r3, [sp, #12]
    if( CheckForMinimumAbpDatarate( Nvm.MacGroup2.AdrCtrlOn, Nvm.MacGroup2.NetworkActivation,
 802dc6c:	4b55      	ldr	r3, [pc, #340]	; (802ddc4 <LoRaMacMcpsRequest+0x214>)
 802dc6e:	228d      	movs	r2, #141	; 0x8d
 802dc70:	0052      	lsls	r2, r2, #1
 802dc72:	5c9a      	ldrb	r2, [r3, r2]
 802dc74:	4691      	mov	r9, r2
 802dc76:	221e      	movs	r2, #30
 802dc78:	32ff      	adds	r2, #255	; 0xff
 802dc7a:	5c9a      	ldrb	r2, [r3, r2]
 802dc7c:	2198      	movs	r1, #152	; 0x98
 802dc7e:	0049      	lsls	r1, r1, #1
 802dc80:	5c59      	ldrb	r1, [r3, r1]
 802dc82:	4648      	mov	r0, r9
 802dc84:	f7fc fc30 	bl	802a4e8 <CheckForMinimumAbpDatarate>
 802dc88:	2800      	cmp	r0, #0
 802dc8a:	d100      	bne.n	802dc8e <LoRaMacMcpsRequest+0xde>
    datarate = MAX( datarate, ( int8_t )phyParam.Value );
 802dc8c:	9e03      	ldr	r6, [sp, #12]
    if( readyToSend == true )
 802dc8e:	2d00      	cmp	r5, #0
 802dc90:	d100      	bne.n	802dc94 <LoRaMacMcpsRequest+0xe4>
 802dc92:	e086      	b.n	802dda2 <LoRaMacMcpsRequest+0x1f2>
        if( ( Nvm.MacGroup2.AdrCtrlOn == false ) ||
 802dc94:	464b      	mov	r3, r9
 802dc96:	2b00      	cmp	r3, #0
 802dc98:	d001      	beq.n	802dc9e <LoRaMacMcpsRequest+0xee>
 802dc9a:	2800      	cmp	r0, #0
 802dc9c:	d014      	beq.n	802dcc8 <LoRaMacMcpsRequest+0x118>
            verify.DatarateParams.Datarate = datarate;
 802dc9e:	ab02      	add	r3, sp, #8
 802dca0:	771e      	strb	r6, [r3, #28]
            verify.DatarateParams.UplinkDwellTime = Nvm.MacGroup2.MacParams.UplinkDwellTime;
 802dca2:	4b48      	ldr	r3, [pc, #288]	; (802ddc4 <LoRaMacMcpsRequest+0x214>)
 802dca4:	227c      	movs	r2, #124	; 0x7c
 802dca6:	5c9a      	ldrb	r2, [r3, r2]
 802dca8:	a902      	add	r1, sp, #8
 802dcaa:	778a      	strb	r2, [r1, #30]
            if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_TX_DR ) == true )
 802dcac:	2248      	movs	r2, #72	; 0x48
 802dcae:	5c98      	ldrb	r0, [r3, r2]
 802dcb0:	3a43      	subs	r2, #67	; 0x43
 802dcb2:	a909      	add	r1, sp, #36	; 0x24
 802dcb4:	f001 f9cf 	bl	802f056 <RegionVerify>
 802dcb8:	2800      	cmp	r0, #0
 802dcba:	d07a      	beq.n	802ddb2 <LoRaMacMcpsRequest+0x202>
                Nvm.MacGroup1.ChannelsDatarate = verify.DatarateParams.Datarate;
 802dcbc:	ab09      	add	r3, sp, #36	; 0x24
 802dcbe:	2100      	movs	r1, #0
 802dcc0:	5659      	ldrsb	r1, [r3, r1]
 802dcc2:	4a40      	ldr	r2, [pc, #256]	; (802ddc4 <LoRaMacMcpsRequest+0x214>)
 802dcc4:	2339      	movs	r3, #57	; 0x39
 802dcc6:	54d1      	strb	r1, [r2, r3]
        LoRaMacHandleResponseTimeout( Nvm.MacGroup2.MacParams.RxBCTimeout,
 802dcc8:	4a3f      	ldr	r2, [pc, #252]	; (802ddc8 <LoRaMacMcpsRequest+0x218>)
 802dcca:	2393      	movs	r3, #147	; 0x93
 802dccc:	00db      	lsls	r3, r3, #3
 802dcce:	58d1      	ldr	r1, [r2, r3]
 802dcd0:	4a3c      	ldr	r2, [pc, #240]	; (802ddc4 <LoRaMacMcpsRequest+0x214>)
 802dcd2:	2390      	movs	r3, #144	; 0x90
 802dcd4:	58d0      	ldr	r0, [r2, r3]
 802dcd6:	f7fd feb9 	bl	802ba4c <LoRaMacHandleResponseTimeout>
        status = Send( &macHdr, fPort, fBuffer, fBufferSize, allowDelayedTx );
 802dcda:	9b02      	ldr	r3, [sp, #8]
 802dcdc:	9300      	str	r3, [sp, #0]
 802dcde:	4643      	mov	r3, r8
 802dce0:	465a      	mov	r2, fp
 802dce2:	4651      	mov	r1, sl
 802dce4:	a80a      	add	r0, sp, #40	; 0x28
 802dce6:	f7fe fef1 	bl	802cacc <Send>
        if( status == LORAMAC_STATUS_OK )
 802dcea:	2800      	cmp	r0, #0
 802dcec:	d154      	bne.n	802dd98 <LoRaMacMcpsRequest+0x1e8>
            MacCtx.McpsConfirm.McpsRequest = request.Type;
 802dcee:	4b36      	ldr	r3, [pc, #216]	; (802ddc8 <LoRaMacMcpsRequest+0x218>)
 802dcf0:	2288      	movs	r2, #136	; 0x88
 802dcf2:	00d2      	lsls	r2, r2, #3
 802dcf4:	549f      	strb	r7, [r3, r2]
            MacCtx.MacFlags.Bits.McpsReq = 1;
 802dcf6:	4935      	ldr	r1, [pc, #212]	; (802ddcc <LoRaMacMcpsRequest+0x21c>)
 802dcf8:	5c5a      	ldrb	r2, [r3, r1]
 802dcfa:	2501      	movs	r5, #1
 802dcfc:	432a      	orrs	r2, r5
 802dcfe:	545a      	strb	r2, [r3, r1]
 802dd00:	e050      	b.n	802dda4 <LoRaMacMcpsRequest+0x1f4>
        ( Nvm.MacGroup2.DeviceClass == CLASS_C ) &&
 802dd02:	3317      	adds	r3, #23
 802dd04:	33ff      	adds	r3, #255	; 0xff
 802dd06:	5cd3      	ldrb	r3, [r2, r3]
    if( ( Nvm.MacGroup2.NetworkActivation == ACTIVATION_TYPE_OTAA ) &&
 802dd08:	2b02      	cmp	r3, #2
 802dd0a:	d188      	bne.n	802dc1e <LoRaMacMcpsRequest+0x6e>
        ( Nvm.MacGroup2.DownlinkReceived == false ) &&
 802dd0c:	331d      	adds	r3, #29
 802dd0e:	33ff      	adds	r3, #255	; 0xff
 802dd10:	5cd3      	ldrb	r3, [r2, r3]
        ( Nvm.MacGroup2.DeviceClass == CLASS_C ) &&
 802dd12:	2b00      	cmp	r3, #0
 802dd14:	d183      	bne.n	802dc1e <LoRaMacMcpsRequest+0x6e>
        ( request.Type == MCPS_UNCONFIRMED ) )
 802dd16:	ab04      	add	r3, sp, #16
 802dd18:	781b      	ldrb	r3, [r3, #0]
        ( Nvm.MacGroup2.DownlinkReceived == false ) &&
 802dd1a:	2b00      	cmp	r3, #0
 802dd1c:	d000      	beq.n	802dd20 <LoRaMacMcpsRequest+0x170>
 802dd1e:	e77e      	b.n	802dc1e <LoRaMacMcpsRequest+0x6e>
        request.Type = MCPS_CONFIRMED;
 802dd20:	ab04      	add	r3, sp, #16
 802dd22:	2201      	movs	r2, #1
 802dd24:	701a      	strb	r2, [r3, #0]
 802dd26:	e77a      	b.n	802dc1e <LoRaMacMcpsRequest+0x6e>
            macHdr.Bits.MType = FRAME_TYPE_DATA_UNCONFIRMED_UP;
 802dd28:	aa0a      	add	r2, sp, #40	; 0x28
 802dd2a:	7811      	ldrb	r1, [r2, #0]
 802dd2c:	231f      	movs	r3, #31
 802dd2e:	400b      	ands	r3, r1
 802dd30:	2140      	movs	r1, #64	; 0x40
 802dd32:	430b      	orrs	r3, r1
 802dd34:	7013      	strb	r3, [r2, #0]
            fPort = request.Req.Unconfirmed.fPort;
 802dd36:	ab04      	add	r3, sp, #16
 802dd38:	791a      	ldrb	r2, [r3, #4]
 802dd3a:	4692      	mov	sl, r2
            fBuffer = request.Req.Unconfirmed.fBuffer;
 802dd3c:	9a06      	ldr	r2, [sp, #24]
 802dd3e:	4693      	mov	fp, r2
            fBufferSize = request.Req.Unconfirmed.fBufferSize;
 802dd40:	899a      	ldrh	r2, [r3, #12]
 802dd42:	4690      	mov	r8, r2
            datarate = request.Req.Unconfirmed.Datarate;
 802dd44:	7b9b      	ldrb	r3, [r3, #14]
 802dd46:	b25b      	sxtb	r3, r3
 802dd48:	4699      	mov	r9, r3
            readyToSend = true;
 802dd4a:	2501      	movs	r5, #1
            break;
 802dd4c:	e775      	b.n	802dc3a <LoRaMacMcpsRequest+0x8a>
            macHdr.Bits.MType = FRAME_TYPE_DATA_CONFIRMED_UP;
 802dd4e:	a90a      	add	r1, sp, #40	; 0x28
 802dd50:	780a      	ldrb	r2, [r1, #0]
 802dd52:	231f      	movs	r3, #31
 802dd54:	401a      	ands	r2, r3
 802dd56:	3b9f      	subs	r3, #159	; 0x9f
 802dd58:	4313      	orrs	r3, r2
 802dd5a:	700b      	strb	r3, [r1, #0]
            fPort = request.Req.Confirmed.fPort;
 802dd5c:	ab04      	add	r3, sp, #16
 802dd5e:	791a      	ldrb	r2, [r3, #4]
 802dd60:	4692      	mov	sl, r2
            fBuffer = request.Req.Confirmed.fBuffer;
 802dd62:	9a06      	ldr	r2, [sp, #24]
 802dd64:	4693      	mov	fp, r2
            fBufferSize = request.Req.Confirmed.fBufferSize;
 802dd66:	899a      	ldrh	r2, [r3, #12]
 802dd68:	4690      	mov	r8, r2
            datarate = request.Req.Confirmed.Datarate;
 802dd6a:	7b9b      	ldrb	r3, [r3, #14]
 802dd6c:	b25b      	sxtb	r3, r3
 802dd6e:	4699      	mov	r9, r3
            readyToSend = true;
 802dd70:	2501      	movs	r5, #1
            break;
 802dd72:	e762      	b.n	802dc3a <LoRaMacMcpsRequest+0x8a>
            macHdr.Bits.MType = FRAME_TYPE_PROPRIETARY;
 802dd74:	aa0a      	add	r2, sp, #40	; 0x28
 802dd76:	7811      	ldrb	r1, [r2, #0]
 802dd78:	2320      	movs	r3, #32
 802dd7a:	425b      	negs	r3, r3
 802dd7c:	430b      	orrs	r3, r1
 802dd7e:	7013      	strb	r3, [r2, #0]
            fBuffer = request.Req.Proprietary.fBuffer;
 802dd80:	ab04      	add	r3, sp, #16
 802dd82:	9a05      	ldr	r2, [sp, #20]
 802dd84:	4693      	mov	fp, r2
            fBufferSize = request.Req.Proprietary.fBufferSize;
 802dd86:	891a      	ldrh	r2, [r3, #8]
 802dd88:	4690      	mov	r8, r2
            datarate = request.Req.Proprietary.Datarate;
 802dd8a:	7a9b      	ldrb	r3, [r3, #10]
 802dd8c:	b25b      	sxtb	r3, r3
 802dd8e:	4699      	mov	r9, r3
            readyToSend = true;
 802dd90:	2501      	movs	r5, #1
    uint8_t fPort = 0;
 802dd92:	2300      	movs	r3, #0
 802dd94:	469a      	mov	sl, r3
            break;
 802dd96:	e750      	b.n	802dc3a <LoRaMacMcpsRequest+0x8a>
            MacCtx.NodeAckRequested = false;
 802dd98:	4a0b      	ldr	r2, [pc, #44]	; (802ddc8 <LoRaMacMcpsRequest+0x218>)
 802dd9a:	4b0d      	ldr	r3, [pc, #52]	; (802ddd0 <LoRaMacMcpsRequest+0x220>)
 802dd9c:	2100      	movs	r1, #0
 802dd9e:	54d1      	strb	r1, [r2, r3]
 802dda0:	e000      	b.n	802dda4 <LoRaMacMcpsRequest+0x1f4>
    LoRaMacStatus_t status = LORAMAC_STATUS_SERVICE_UNKNOWN;
 802dda2:	2002      	movs	r0, #2
    mcpsRequest->ReqReturn.DutyCycleWaitTime = MacCtx.DutyCycleWaitTime;
 802dda4:	4a08      	ldr	r2, [pc, #32]	; (802ddc8 <LoRaMacMcpsRequest+0x218>)
 802dda6:	4b0b      	ldr	r3, [pc, #44]	; (802ddd4 <LoRaMacMcpsRequest+0x224>)
 802dda8:	58d3      	ldr	r3, [r2, r3]
 802ddaa:	6123      	str	r3, [r4, #16]
    return status;
 802ddac:	e714      	b.n	802dbd8 <LoRaMacMcpsRequest+0x28>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802ddae:	2003      	movs	r0, #3
 802ddb0:	e712      	b.n	802dbd8 <LoRaMacMcpsRequest+0x28>
                return LORAMAC_STATUS_PARAMETER_INVALID;
 802ddb2:	2003      	movs	r0, #3
 802ddb4:	e710      	b.n	802dbd8 <LoRaMacMcpsRequest+0x28>
 802ddb6:	46c0      	nop			; (mov r8, r8)
 802ddb8:	2000bf5c 	.word	0x2000bf5c
 802ddbc:	fffffbc0 	.word	0xfffffbc0
 802ddc0:	00000441 	.word	0x00000441
 802ddc4:	2000a000 	.word	0x2000a000
 802ddc8:	2000bb1c 	.word	0x2000bb1c
 802ddcc:	00000491 	.word	0x00000491
 802ddd0:	0000041a 	.word	0x0000041a
 802ddd4:	00000494 	.word	0x00000494

0802ddd8 <LoRaMacTestSetDutyCycleOn>:
    OnMacProcessNotify( );
}
#endif /* LORAMAC_VERSION */

void LoRaMacTestSetDutyCycleOn( bool enable )
{
 802ddd8:	b510      	push	{r4, lr}
 802ddda:	b082      	sub	sp, #8
 802dddc:	0004      	movs	r4, r0
    VerifyParams_t verify;

    verify.DutyCycle = enable;
 802ddde:	a901      	add	r1, sp, #4
 802dde0:	7008      	strb	r0, [r1, #0]

    if( RegionVerify( Nvm.MacGroup2.Region, &verify, PHY_DUTY_CYCLE ) == true )
 802dde2:	4a0a      	ldr	r2, [pc, #40]	; (802de0c <LoRaMacTestSetDutyCycleOn+0x34>)
 802dde4:	2348      	movs	r3, #72	; 0x48
 802dde6:	5cd0      	ldrb	r0, [r2, r3]
 802dde8:	220f      	movs	r2, #15
 802ddea:	f001 f934 	bl	802f056 <RegionVerify>
 802ddee:	2800      	cmp	r0, #0
 802ddf0:	d009      	beq.n	802de06 <LoRaMacTestSetDutyCycleOn+0x2e>
    {
        Nvm.MacGroup2.DutyCycleOn = enable;
 802ddf2:	4a06      	ldr	r2, [pc, #24]	; (802de0c <LoRaMacTestSetDutyCycleOn+0x34>)
 802ddf4:	238e      	movs	r3, #142	; 0x8e
 802ddf6:	005b      	lsls	r3, r3, #1
 802ddf8:	54d4      	strb	r4, [r2, r3]
        // Handle NVM potential changes
        MacCtx.MacFlags.Bits.NvmHandle = 1;
 802ddfa:	4905      	ldr	r1, [pc, #20]	; (802de10 <LoRaMacTestSetDutyCycleOn+0x38>)
 802ddfc:	4a05      	ldr	r2, [pc, #20]	; (802de14 <LoRaMacTestSetDutyCycleOn+0x3c>)
 802ddfe:	5c8b      	ldrb	r3, [r1, r2]
 802de00:	2020      	movs	r0, #32
 802de02:	4303      	orrs	r3, r0
 802de04:	548b      	strb	r3, [r1, r2]
    }
}
 802de06:	b002      	add	sp, #8
 802de08:	bd10      	pop	{r4, pc}
 802de0a:	46c0      	nop			; (mov r8, r8)
 802de0c:	2000a000 	.word	0x2000a000
 802de10:	2000bb1c 	.word	0x2000bb1c
 802de14:	00000491 	.word	0x00000491

0802de18 <LoRaMacDeInitialization>:

LoRaMacStatus_t LoRaMacDeInitialization( void )
{
 802de18:	b570      	push	{r4, r5, r6, lr}
    // Check the current state of the LoRaMac
    if ( LoRaMacStop( ) == LORAMAC_STATUS_OK )
 802de1a:	f7ff f959 	bl	802d0d0 <LoRaMacStop>
 802de1e:	1e04      	subs	r4, r0, #0
 802de20:	d002      	beq.n	802de28 <LoRaMacDeInitialization+0x10>
        // Return success
        return LORAMAC_STATUS_OK;
    }
    else
    {
        return LORAMAC_STATUS_BUSY;
 802de22:	2401      	movs	r4, #1
    }
}
 802de24:	0020      	movs	r0, r4
 802de26:	bd70      	pop	{r4, r5, r6, pc}
        TimerStop( &MacCtx.TxDelayedTimer );
 802de28:	4d0a      	ldr	r5, [pc, #40]	; (802de54 <LoRaMacDeInitialization+0x3c>)
 802de2a:	0028      	movs	r0, r5
 802de2c:	f006 fbb2 	bl	8034594 <UTIL_TIMER_Stop>
        TimerStop( &MacCtx.RxWindowTimer1 );
 802de30:	0028      	movs	r0, r5
 802de32:	3018      	adds	r0, #24
 802de34:	f006 fbae 	bl	8034594 <UTIL_TIMER_Stop>
        TimerStop( &MacCtx.RxWindowTimer2 );
 802de38:	0028      	movs	r0, r5
 802de3a:	3030      	adds	r0, #48	; 0x30
 802de3c:	f006 fbaa 	bl	8034594 <UTIL_TIMER_Stop>
        LoRaMacClassBHaltBeaconing( );
 802de40:	f000 f899 	bl	802df76 <LoRaMacClassBHaltBeaconing>
        ResetMacParameters( false );
 802de44:	2000      	movs	r0, #0
 802de46:	f7fe fb99 	bl	802c57c <ResetMacParameters>
        Radio.Sleep( );
 802de4a:	4b03      	ldr	r3, [pc, #12]	; (802de58 <LoRaMacDeInitialization+0x40>)
 802de4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802de4e:	4798      	blx	r3
        return LORAMAC_STATUS_OK;
 802de50:	e7e8      	b.n	802de24 <LoRaMacDeInitialization+0xc>
 802de52:	46c0      	nop			; (mov r8, r8)
 802de54:	2000be84 	.word	0x2000be84
 802de58:	08035d8c 	.word	0x08035d8c

0802de5c <LoRaMacAdrCalcNext>:
    return false;
}
#elif (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
bool LoRaMacAdrCalcNext( CalcNextAdrParams_t* adrNext, int8_t* drOut, int8_t* txPowOut,
                         uint8_t* nbTransOut, uint32_t* adrAckCounter )
{
 802de5c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802de5e:	46de      	mov	lr, fp
 802de60:	4657      	mov	r7, sl
 802de62:	464e      	mov	r6, r9
 802de64:	4645      	mov	r5, r8
 802de66:	b5e0      	push	{r5, r6, r7, lr}
 802de68:	b08b      	sub	sp, #44	; 0x2c
 802de6a:	0004      	movs	r4, r0
 802de6c:	000f      	movs	r7, r1
 802de6e:	9200      	str	r2, [sp, #0]
 802de70:	4699      	mov	r9, r3
    bool adrAckReq = false;
    int8_t datarate = adrNext->Datarate;
 802de72:	260c      	movs	r6, #12
 802de74:	5786      	ldrsb	r6, [r0, r6]
    int8_t txPower = adrNext->TxPower;
 802de76:	230d      	movs	r3, #13
 802de78:	56c3      	ldrsb	r3, [r0, r3]
 802de7a:	469a      	mov	sl, r3
    uint8_t nbTrans = adrNext->NbTrans;
 802de7c:	7b83      	ldrb	r3, [r0, #14]
 802de7e:	469b      	mov	fp, r3
    int8_t minTxDatarate;
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;

    // Report back the adr ack counter
    *adrAckCounter = adrNext->AdrAckCounter;
 802de80:	9b14      	ldr	r3, [sp, #80]	; 0x50
 802de82:	6842      	ldr	r2, [r0, #4]
 802de84:	601a      	str	r2, [r3, #0]

    if( adrNext->AdrEnabled == true )
 802de86:	7845      	ldrb	r5, [r0, #1]
 802de88:	2d00      	cmp	r5, #0
 802de8a:	d10e      	bne.n	802deaa <LoRaMacAdrCalcNext+0x4e>
                datarate = phyParam.Value;
            }
        }
    }

    *drOut = datarate;
 802de8c:	703e      	strb	r6, [r7, #0]
    *txPowOut = txPower;
 802de8e:	9b00      	ldr	r3, [sp, #0]
 802de90:	4652      	mov	r2, sl
 802de92:	701a      	strb	r2, [r3, #0]
    *nbTransOut = nbTrans;
 802de94:	464b      	mov	r3, r9
 802de96:	465a      	mov	r2, fp
 802de98:	701a      	strb	r2, [r3, #0]
    return adrAckReq;
}
 802de9a:	0028      	movs	r0, r5
 802de9c:	b00b      	add	sp, #44	; 0x2c
 802de9e:	bcf0      	pop	{r4, r5, r6, r7}
 802dea0:	46bb      	mov	fp, r7
 802dea2:	46b2      	mov	sl, r6
 802dea4:	46a9      	mov	r9, r5
 802dea6:	46a0      	mov	r8, r4
 802dea8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        getPhy.Attribute = PHY_MIN_TX_DR;
 802deaa:	2302      	movs	r3, #2
 802deac:	aa02      	add	r2, sp, #8
 802deae:	7613      	strb	r3, [r2, #24]
        getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 802deb0:	7bc3      	ldrb	r3, [r0, #15]
 802deb2:	7693      	strb	r3, [r2, #26]
        phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 802deb4:	7c00      	ldrb	r0, [r0, #16]
 802deb6:	a908      	add	r1, sp, #32
 802deb8:	f001 f89a 	bl	802eff0 <RegionGetPhyParam>
 802debc:	9007      	str	r0, [sp, #28]
        minTxDatarate = phyParam.Value;
 802debe:	b243      	sxtb	r3, r0
 802dec0:	4698      	mov	r8, r3
        datarate = MAX( datarate, minTxDatarate );
 802dec2:	1c33      	adds	r3, r6, #0
 802dec4:	4546      	cmp	r6, r8
 802dec6:	da00      	bge.n	802deca <LoRaMacAdrCalcNext+0x6e>
 802dec8:	4643      	mov	r3, r8
 802deca:	b25b      	sxtb	r3, r3
 802decc:	9301      	str	r3, [sp, #4]
        if( adrNext->AdrAckCounter >= adrNext->AdrAckLimit )
 802dece:	6862      	ldr	r2, [r4, #4]
 802ded0:	8923      	ldrh	r3, [r4, #8]
 802ded2:	429a      	cmp	r2, r3
 802ded4:	d200      	bcs.n	802ded8 <LoRaMacAdrCalcNext+0x7c>
    bool adrAckReq = false;
 802ded6:	2500      	movs	r5, #0
        if( adrNext->AdrAckCounter >= ( adrNext->AdrAckLimit + adrNext->AdrAckDelay ) )
 802ded8:	8961      	ldrh	r1, [r4, #10]
 802deda:	185b      	adds	r3, r3, r1
 802dedc:	429a      	cmp	r2, r3
 802dede:	d21f      	bcs.n	802df20 <LoRaMacAdrCalcNext+0xc4>
        if( adrNext->AdrAckCounter >= ( uint32_t )( adrNext->AdrAckLimit + ( adrNext->AdrAckDelay << 1 ) ) )
 802dee0:	6860      	ldr	r0, [r4, #4]
 802dee2:	8922      	ldrh	r2, [r4, #8]
 802dee4:	8961      	ldrh	r1, [r4, #10]
 802dee6:	004b      	lsls	r3, r1, #1
 802dee8:	18d3      	adds	r3, r2, r3
 802deea:	4298      	cmp	r0, r3
 802deec:	d32b      	bcc.n	802df46 <LoRaMacAdrCalcNext+0xea>
            if( ( ( adrNext->AdrAckCounter - adrNext->AdrAckLimit ) % adrNext->AdrAckDelay ) == 0 )
 802deee:	1a80      	subs	r0, r0, r2
 802def0:	f7f2 f998 	bl	8020224 <__aeabi_uidivmod>
 802def4:	2900      	cmp	r1, #0
 802def6:	d128      	bne.n	802df4a <LoRaMacAdrCalcNext+0xee>
                if( datarate == minTxDatarate )
 802def8:	4546      	cmp	r6, r8
 802defa:	dc04      	bgt.n	802df06 <LoRaMacAdrCalcNext+0xaa>
                    if( adrNext->UpdateChanMask == true )
 802defc:	7823      	ldrb	r3, [r4, #0]
 802defe:	2b00      	cmp	r3, #0
 802df00:	d118      	bne.n	802df34 <LoRaMacAdrCalcNext+0xd8>
                    nbTrans = 1;
 802df02:	2301      	movs	r3, #1
 802df04:	469b      	mov	fp, r3
                getPhy.Attribute = PHY_NEXT_LOWER_TX_DR;
 802df06:	a908      	add	r1, sp, #32
 802df08:	2321      	movs	r3, #33	; 0x21
 802df0a:	700b      	strb	r3, [r1, #0]
                getPhy.Datarate = datarate;
 802df0c:	9b01      	ldr	r3, [sp, #4]
 802df0e:	704b      	strb	r3, [r1, #1]
                getPhy.UplinkDwellTime = adrNext->UplinkDwellTime;
 802df10:	7be3      	ldrb	r3, [r4, #15]
 802df12:	708b      	strb	r3, [r1, #2]
                phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 802df14:	7c20      	ldrb	r0, [r4, #16]
 802df16:	f001 f86b 	bl	802eff0 <RegionGetPhyParam>
 802df1a:	9007      	str	r0, [sp, #28]
                datarate = phyParam.Value;
 802df1c:	b246      	sxtb	r6, r0
 802df1e:	e7b5      	b.n	802de8c <LoRaMacAdrCalcNext+0x30>
            getPhy.Attribute = PHY_DEF_TX_POWER;
 802df20:	a908      	add	r1, sp, #32
 802df22:	230a      	movs	r3, #10
 802df24:	700b      	strb	r3, [r1, #0]
            phyParam = RegionGetPhyParam( adrNext->Region, &getPhy );
 802df26:	7c20      	ldrb	r0, [r4, #16]
 802df28:	f001 f862 	bl	802eff0 <RegionGetPhyParam>
 802df2c:	9007      	str	r0, [sp, #28]
            txPower = phyParam.Value;
 802df2e:	b243      	sxtb	r3, r0
 802df30:	469a      	mov	sl, r3
 802df32:	e7d5      	b.n	802dee0 <LoRaMacAdrCalcNext+0x84>
                        params.Type = INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS;
 802df34:	a903      	add	r1, sp, #12
 802df36:	2302      	movs	r3, #2
 802df38:	730b      	strb	r3, [r1, #12]
                        RegionInitDefaults( adrNext->Region, &params );
 802df3a:	7c20      	ldrb	r0, [r4, #16]
 802df3c:	f001 f87d 	bl	802f03a <RegionInitDefaults>
                    nbTrans = 1;
 802df40:	2301      	movs	r3, #1
 802df42:	469b      	mov	fp, r3
 802df44:	e7df      	b.n	802df06 <LoRaMacAdrCalcNext+0xaa>
        datarate = MAX( datarate, minTxDatarate );
 802df46:	9e01      	ldr	r6, [sp, #4]
 802df48:	e7a0      	b.n	802de8c <LoRaMacAdrCalcNext+0x30>
 802df4a:	9e01      	ldr	r6, [sp, #4]
 802df4c:	e79e      	b.n	802de8c <LoRaMacAdrCalcNext+0x30>

0802df4e <LoRaMacClassBInit>:
    TimerInit( &Ctx.PingSlotTimer, LoRaMacClassBPingSlotTimerEvent );
    TimerInit( &Ctx.MulticastSlotTimer, LoRaMacClassBMulticastSlotTimerEvent );

    InitClassB( );
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df4e:	4770      	bx	lr

0802df50 <LoRaMacClassBSetBeaconState>:
        {
            Ctx.BeaconState = beaconState;
        }
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df50:	4770      	bx	lr

0802df52 <LoRaMacClassBSetPingSlotState>:
void LoRaMacClassBSetPingSlotState( PingSlotState_t pingSlotState )
{
#if ( LORAMAC_CLASSB_ENABLED == 1 )
    Ctx.PingSlotState = pingSlotState;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df52:	4770      	bx	lr

0802df54 <LoRaMacClassBSetMulticastSlotState>:
void LoRaMacClassBSetMulticastSlotState( PingSlotState_t multicastSlotState )
{
#if ( LORAMAC_CLASSB_ENABLED == 1 )
    Ctx.MulticastSlotState = multicastSlotState;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df54:	4770      	bx	lr

0802df56 <LoRaMacClassBIsAcquisitionInProgress>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df56:	2000      	movs	r0, #0
 802df58:	4770      	bx	lr

0802df5a <LoRaMacClassBBeaconTimerEvent>:
    Ctx.BeaconCtx.TimeStamp = TimerGetCurrentTime( );
    TimerStop( &Ctx.BeaconTimer );
    LoRaMacClassBEvents.Events.Beacon = 1;
    OnClassBMacProcessNotify( );
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df5a:	4770      	bx	lr

0802df5c <LoRaMacClassBPingSlotTimerEvent>:
#if ( LORAMAC_CLASSB_ENABLED == 1 )
    LoRaMacClassBEvents.Events.PingSlot = 1;

    OnClassBMacProcessNotify( );
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df5c:	4770      	bx	lr

0802df5e <LoRaMacClassBMulticastSlotTimerEvent>:
#if ( LORAMAC_CLASSB_ENABLED == 1 )
    LoRaMacClassBEvents.Events.MulticastSlot = 1;

    OnClassBMacProcessNotify( );
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df5e:	4770      	bx	lr

0802df60 <LoRaMacClassBRxBeacon>:
    }
    return beaconProcessed;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df60:	2000      	movs	r0, #0
 802df62:	4770      	bx	lr

0802df64 <LoRaMacClassBIsBeaconExpected>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df64:	2000      	movs	r0, #0
 802df66:	4770      	bx	lr

0802df68 <LoRaMacClassBIsPingExpected>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df68:	2000      	movs	r0, #0
 802df6a:	4770      	bx	lr

0802df6c <LoRaMacClassBIsMulticastExpected>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df6c:	2000      	movs	r0, #0
 802df6e:	4770      	bx	lr

0802df70 <LoRaMacClassBIsBeaconModeActive>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df70:	2000      	movs	r0, #0
 802df72:	4770      	bx	lr

0802df74 <LoRaMacClassBSetPingSlotInfo>:
{
#if ( LORAMAC_CLASSB_ENABLED == 1 )
    ClassBNvm->PingSlotCtx.PingNb = CalcPingNb( periodicity );
    ClassBNvm->PingSlotCtx.PingPeriod = CalcPingPeriod( ClassBNvm->PingSlotCtx.PingNb );
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df74:	4770      	bx	lr

0802df76 <LoRaMacClassBHaltBeaconing>:

        // Halt ping and multicast slot state machines
        LoRaMacClassBStopRxSlots( );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df76:	4770      	bx	lr

0802df78 <LoRaMacClassBResumeBeaconing>:
        }

        LoRaMacClassBBeaconTimerEvent( NULL );
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df78:	4770      	bx	lr

0802df7a <LoRaMacClassBSwitchClass>:
    }
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df7a:	2002      	movs	r0, #2
 802df7c:	4770      	bx	lr

0802df7e <LoRaMacClassBMibGetRequestConfirm>:
    }
    return status;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df7e:	2002      	movs	r0, #2
 802df80:	4770      	bx	lr

0802df82 <LoRaMacMibClassBSetRequestConfirm>:
    }
    return status;
#else
    return LORAMAC_STATUS_SERVICE_UNKNOWN;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df82:	2002      	movs	r0, #2
 802df84:	4770      	bx	lr

0802df86 <LoRaMacClassBPingSlotInfoAns>:
    {
        LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_PING_SLOT_INFO );
        ClassBNvm->PingSlotCtx.Ctrl.Assigned = 1;
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df86:	4770      	bx	lr

0802df88 <LoRaMacClassBPingSlotChannelReq>:

    return status;
#else
    return 0;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df88:	2000      	movs	r0, #0
 802df8a:	4770      	bx	lr

0802df8c <LoRaMacClassBBeaconTimingAns>:

        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingDelay = Ctx.BeaconCtx.BeaconTimingDelay;
        Ctx.LoRaMacClassBParams.MlmeConfirm->BeaconTimingChannel = Ctx.BeaconCtx.BeaconTimingChannel;
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df8c:	4770      	bx	lr

0802df8e <LoRaMacClassBDeviceTimeAns>:
            Ctx.BeaconCtx.BeaconTime.SubSeconds = 0;
            LoRaMacConfirmQueueSetStatus( LORAMAC_EVENT_INFO_STATUS_OK, MLME_DEVICE_TIME );
        }
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df8e:	4770      	bx	lr

0802df90 <LoRaMacClassBBeaconFreqReq>:
    }
    return false;
#else
    return false;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df90:	2000      	movs	r0, #0
 802df92:	4770      	bx	lr

0802df94 <LoRaMacClassBIsUplinkCollision>:
    }
    return 0;
#else
    return 0;
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df94:	2000      	movs	r0, #0
 802df96:	4770      	bx	lr

0802df98 <LoRaMacClassBStopRxSlots>:
    CRITICAL_SECTION_BEGIN( );
    LoRaMacClassBEvents.Events.PingSlot = 0;
    LoRaMacClassBEvents.Events.MulticastSlot = 0;
    CRITICAL_SECTION_END( );
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df98:	4770      	bx	lr

0802df9a <LoRaMacClassBSetFPendingBit>:
            }
            cur++;
        }
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df9a:	4770      	bx	lr

0802df9c <LoRaMacClassBProcess>:
        {
            LoRaMacClassBProcessMulticastSlot( );
        }
    }
#endif /* LORAMAC_CLASSB_ENABLED */
}
 802df9c:	4770      	bx	lr

0802df9e <IsSlotFree>:
 */
static bool IsSlotFree( const MacCommand_t* slot )
{
    uint8_t* mem = ( uint8_t* )slot;

    for( uint16_t size = 0; size < sizeof( MacCommand_t ); size++ )
 802df9e:	2300      	movs	r3, #0
 802dfa0:	2b0f      	cmp	r3, #15
 802dfa2:	d805      	bhi.n	802dfb0 <IsSlotFree+0x12>
    {
        if( mem[size] != 0x00 )
 802dfa4:	5cc2      	ldrb	r2, [r0, r3]
 802dfa6:	2a00      	cmp	r2, #0
 802dfa8:	d104      	bne.n	802dfb4 <IsSlotFree+0x16>
    for( uint16_t size = 0; size < sizeof( MacCommand_t ); size++ )
 802dfaa:	3301      	adds	r3, #1
 802dfac:	b29b      	uxth	r3, r3
 802dfae:	e7f7      	b.n	802dfa0 <IsSlotFree+0x2>
        {
            return false;
        }
    }
    return true;
 802dfb0:	2001      	movs	r0, #1
}
 802dfb2:	4770      	bx	lr
            return false;
 802dfb4:	2000      	movs	r0, #0
 802dfb6:	e7fc      	b.n	802dfb2 <IsSlotFree+0x14>

0802dfb8 <MallocNewMacCommandSlot>:
 * \brief Allocates a new MAC command memory slot
 *
 * \retval                       - Pointer to slot
 */
static MacCommand_t* MallocNewMacCommandSlot( void )
{
 802dfb8:	b570      	push	{r4, r5, r6, lr}
    uint8_t itr = 0;
 802dfba:	2500      	movs	r5, #0

    while( IsSlotFree( ( const MacCommand_t* )&CommandsCtx.MacCommandSlots[itr] ) == false )
 802dfbc:	012c      	lsls	r4, r5, #4
 802dfbe:	3408      	adds	r4, #8
 802dfc0:	4b06      	ldr	r3, [pc, #24]	; (802dfdc <MallocNewMacCommandSlot+0x24>)
 802dfc2:	18e4      	adds	r4, r4, r3
 802dfc4:	0020      	movs	r0, r4
 802dfc6:	f7ff ffea 	bl	802df9e <IsSlotFree>
 802dfca:	2800      	cmp	r0, #0
 802dfcc:	d104      	bne.n	802dfd8 <MallocNewMacCommandSlot+0x20>
    {
        itr++;
 802dfce:	3501      	adds	r5, #1
 802dfd0:	b2ed      	uxtb	r5, r5
        if( itr == NUM_OF_MAC_COMMANDS )
 802dfd2:	2d20      	cmp	r5, #32
 802dfd4:	d1f2      	bne.n	802dfbc <MallocNewMacCommandSlot+0x4>
        {
            return NULL;
 802dfd6:	2400      	movs	r4, #0
        }
    }

    return &CommandsCtx.MacCommandSlots[itr];
}
 802dfd8:	0020      	movs	r0, r4
 802dfda:	bd70      	pop	{r4, r5, r6, pc}
 802dfdc:	2000c0dc 	.word	0x2000c0dc

0802dfe0 <LinkedListInit>:
 * \param [in]    list           - List that shall be initialized
 * \retval                       - Status of the operation
 */
static bool LinkedListInit( MacCommandsList_t* list )
{
    if( list == NULL )
 802dfe0:	2800      	cmp	r0, #0
 802dfe2:	d004      	beq.n	802dfee <LinkedListInit+0xe>
    {
        return false;
    }

    list->First = NULL;
 802dfe4:	2300      	movs	r3, #0
 802dfe6:	6003      	str	r3, [r0, #0]
    list->Last = NULL;
 802dfe8:	6043      	str	r3, [r0, #4]

    return true;
 802dfea:	2001      	movs	r0, #1
}
 802dfec:	4770      	bx	lr
        return false;
 802dfee:	2000      	movs	r0, #0
 802dff0:	e7fc      	b.n	802dfec <LinkedListInit+0xc>

0802dff2 <LinkedListAdd>:
 * \param [in]    element        - Element to add
 * \retval                       - Status of the operation
 */
static bool LinkedListAdd( MacCommandsList_t* list, MacCommand_t* element )
{
    if( ( list == NULL ) || ( element == NULL ) )
 802dff2:	2800      	cmp	r0, #0
 802dff4:	d00f      	beq.n	802e016 <LinkedListAdd+0x24>
 802dff6:	2900      	cmp	r1, #0
 802dff8:	d00f      	beq.n	802e01a <LinkedListAdd+0x28>
    {
        return false;
    }

    // Check if this is the first entry to enter the list.
    if( list->First == NULL )
 802dffa:	6803      	ldr	r3, [r0, #0]
 802dffc:	2b00      	cmp	r3, #0
 802dffe:	d008      	beq.n	802e012 <LinkedListAdd+0x20>
    {
        list->First = element;
    }

    // Check if the last entry exists and update its next point.
    if( list->Last )
 802e000:	6843      	ldr	r3, [r0, #4]
 802e002:	2b00      	cmp	r3, #0
 802e004:	d000      	beq.n	802e008 <LinkedListAdd+0x16>
    {
        list->Last->Next = element;
 802e006:	6019      	str	r1, [r3, #0]
    }

    // Update the next point of this entry.
    element->Next = NULL;
 802e008:	2300      	movs	r3, #0
 802e00a:	600b      	str	r3, [r1, #0]

    // Update the last entry of the list.
    list->Last = element;
 802e00c:	6041      	str	r1, [r0, #4]

    return true;
 802e00e:	2001      	movs	r0, #1
}
 802e010:	4770      	bx	lr
        list->First = element;
 802e012:	6001      	str	r1, [r0, #0]
 802e014:	e7f4      	b.n	802e000 <LinkedListAdd+0xe>
        return false;
 802e016:	2000      	movs	r0, #0
 802e018:	e7fa      	b.n	802e010 <LinkedListAdd+0x1e>
 802e01a:	2000      	movs	r0, #0
 802e01c:	e7f8      	b.n	802e010 <LinkedListAdd+0x1e>

0802e01e <LinkedListGetPrevious>:
 * \param [in]    element        - Element where the previous element shall be searched
 * \retval                       - Status of the operation
 */
static MacCommand_t* LinkedListGetPrevious( MacCommandsList_t* list, MacCommand_t* element )
{
    if( ( list == NULL ) || ( element == NULL ) )
 802e01e:	2800      	cmp	r0, #0
 802e020:	d00c      	beq.n	802e03c <LinkedListGetPrevious+0x1e>
 802e022:	2900      	cmp	r1, #0
 802e024:	d00b      	beq.n	802e03e <LinkedListGetPrevious+0x20>
    }

    MacCommand_t* curElement;

    // Start at the head of the list
    curElement = list->First;
 802e026:	6800      	ldr	r0, [r0, #0]

    // When current element is the first of the list, there's no previous element so we can return NULL immediately.
    if( element != curElement )
 802e028:	4281      	cmp	r1, r0
 802e02a:	d102      	bne.n	802e032 <LinkedListGetPrevious+0x14>
            curElement = curElement->Next;
        }
    }
    else
    {
        curElement = NULL;
 802e02c:	2000      	movs	r0, #0
 802e02e:	e005      	b.n	802e03c <LinkedListGetPrevious+0x1e>
            curElement = curElement->Next;
 802e030:	0018      	movs	r0, r3
        while( ( curElement != NULL ) && ( curElement->Next != element ) )
 802e032:	2800      	cmp	r0, #0
 802e034:	d002      	beq.n	802e03c <LinkedListGetPrevious+0x1e>
 802e036:	6803      	ldr	r3, [r0, #0]
 802e038:	428b      	cmp	r3, r1
 802e03a:	d1f9      	bne.n	802e030 <LinkedListGetPrevious+0x12>
    }

    return curElement;
}
 802e03c:	4770      	bx	lr
        return NULL;
 802e03e:	0008      	movs	r0, r1
 802e040:	e7fc      	b.n	802e03c <LinkedListGetPrevious+0x1e>

0802e042 <LinkedListRemove>:
 * \param [in]    list           - List where the element shall be removed from.
 * \param [in]    element        - Element to remove
 * \retval                       - Status of the operation
 */
static bool LinkedListRemove( MacCommandsList_t* list, MacCommand_t* element )
{
 802e042:	b570      	push	{r4, r5, r6, lr}
 802e044:	0005      	movs	r5, r0
 802e046:	000c      	movs	r4, r1
    if( ( list == NULL ) || ( element == NULL ) )
 802e048:	2800      	cmp	r0, #0
 802e04a:	d016      	beq.n	802e07a <LinkedListRemove+0x38>
 802e04c:	2900      	cmp	r1, #0
 802e04e:	d016      	beq.n	802e07e <LinkedListRemove+0x3c>
    {
        return false;
    }

    MacCommand_t* PrevElement = LinkedListGetPrevious( list, element );
 802e050:	f7ff ffe5 	bl	802e01e <LinkedListGetPrevious>

    if( list->First == element )
 802e054:	682b      	ldr	r3, [r5, #0]
 802e056:	42a3      	cmp	r3, r4
 802e058:	d00a      	beq.n	802e070 <LinkedListRemove+0x2e>
    {
        list->First = element->Next;
    }

    if( list->Last == element )
 802e05a:	686b      	ldr	r3, [r5, #4]
 802e05c:	42a3      	cmp	r3, r4
 802e05e:	d00a      	beq.n	802e076 <LinkedListRemove+0x34>
    {
        list->Last = PrevElement;
    }

    if( PrevElement != NULL )
 802e060:	2800      	cmp	r0, #0
 802e062:	d001      	beq.n	802e068 <LinkedListRemove+0x26>
    {
        PrevElement->Next = element->Next;
 802e064:	6823      	ldr	r3, [r4, #0]
 802e066:	6003      	str	r3, [r0, #0]
    }

    element->Next = NULL;
 802e068:	2300      	movs	r3, #0
 802e06a:	6023      	str	r3, [r4, #0]

    return true;
 802e06c:	2001      	movs	r0, #1
}
 802e06e:	bd70      	pop	{r4, r5, r6, pc}
        list->First = element->Next;
 802e070:	6823      	ldr	r3, [r4, #0]
 802e072:	602b      	str	r3, [r5, #0]
 802e074:	e7f1      	b.n	802e05a <LinkedListRemove+0x18>
        list->Last = PrevElement;
 802e076:	6068      	str	r0, [r5, #4]
 802e078:	e7f2      	b.n	802e060 <LinkedListRemove+0x1e>
        return false;
 802e07a:	2000      	movs	r0, #0
 802e07c:	e7f7      	b.n	802e06e <LinkedListRemove+0x2c>
 802e07e:	2000      	movs	r0, #0
 802e080:	e7f5      	b.n	802e06e <LinkedListRemove+0x2c>
	...

0802e084 <IsSticky>:
 * \param[IN]   cid            - MAC command identifier
 *
 * \retval                     - Status of the operation
 */
static bool IsSticky( uint8_t cid )
{
 802e084:	0003      	movs	r3, r0
    switch( cid )
 802e086:	2811      	cmp	r0, #17
 802e088:	d807      	bhi.n	802e09a <IsSticky+0x16>
 802e08a:	2001      	movs	r0, #1
 802e08c:	4098      	lsls	r0, r3
 802e08e:	4b04      	ldr	r3, [pc, #16]	; (802e0a0 <IsSticky+0x1c>)
 802e090:	4018      	ands	r0, r3
 802e092:	1e43      	subs	r3, r0, #1
 802e094:	4198      	sbcs	r0, r3
 802e096:	b2c0      	uxtb	r0, r0
#endif /* LORAMAC_VERSION */
            return true;
        default:
            return false;
    }
}
 802e098:	4770      	bx	lr
            return false;
 802e09a:	2000      	movs	r0, #0
 802e09c:	e7fc      	b.n	802e098 <IsSticky+0x14>
 802e09e:	46c0      	nop			; (mov r8, r8)
 802e0a0:	00020720 	.word	0x00020720

0802e0a4 <IsConfirmationRequired>:
            return true;
#endif /* LORAMAC_VERSION */
        default:
            return false;
    }
}
 802e0a4:	2000      	movs	r0, #0
 802e0a6:	4770      	bx	lr

0802e0a8 <FreeMacCommandSlot>:
{
 802e0a8:	b510      	push	{r4, lr}
    if( slot == NULL )
 802e0aa:	2800      	cmp	r0, #0
 802e0ac:	d005      	beq.n	802e0ba <FreeMacCommandSlot+0x12>
    memset1( ( uint8_t* )slot, 0x00, sizeof( MacCommand_t ) );
 802e0ae:	2210      	movs	r2, #16
 802e0b0:	2100      	movs	r1, #0
 802e0b2:	f004 f83e 	bl	8032132 <memset1>
    return true;
 802e0b6:	2001      	movs	r0, #1
}
 802e0b8:	bd10      	pop	{r4, pc}
        return false;
 802e0ba:	2000      	movs	r0, #0
 802e0bc:	e7fc      	b.n	802e0b8 <FreeMacCommandSlot+0x10>
	...

0802e0c0 <LoRaMacCommandsInit>:

LoRaMacCommandStatus_t LoRaMacCommandsInit( void )
{
 802e0c0:	b510      	push	{r4, lr}
    // Initialize with default
    memset1( ( uint8_t* )&CommandsCtx, 0, sizeof( CommandsCtx ) );
 802e0c2:	2283      	movs	r2, #131	; 0x83
 802e0c4:	4c05      	ldr	r4, [pc, #20]	; (802e0dc <LoRaMacCommandsInit+0x1c>)
 802e0c6:	0092      	lsls	r2, r2, #2
 802e0c8:	2100      	movs	r1, #0
 802e0ca:	0020      	movs	r0, r4
 802e0cc:	f004 f831 	bl	8032132 <memset1>

    LinkedListInit( &CommandsCtx.MacCommandList );
 802e0d0:	0020      	movs	r0, r4
 802e0d2:	f7ff ff85 	bl	802dfe0 <LinkedListInit>

    return LORAMAC_COMMANDS_SUCCESS;
}
 802e0d6:	2000      	movs	r0, #0
 802e0d8:	bd10      	pop	{r4, pc}
 802e0da:	46c0      	nop			; (mov r8, r8)
 802e0dc:	2000c0dc 	.word	0x2000c0dc

0802e0e0 <LoRaMacCommandsAddCmd>:

LoRaMacCommandStatus_t LoRaMacCommandsAddCmd( uint8_t cid, uint8_t* payload, size_t payloadSize )
{
 802e0e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802e0e2:	0007      	movs	r7, r0
 802e0e4:	000e      	movs	r6, r1
 802e0e6:	0015      	movs	r5, r2
    if( payload == NULL )
 802e0e8:	2900      	cmp	r1, #0
 802e0ea:	d021      	beq.n	802e130 <LoRaMacCommandsAddCmd+0x50>
        return LORAMAC_COMMANDS_ERROR_NPE;
    }
    MacCommand_t* newCmd;

    // Allocate a memory slot
    newCmd = MallocNewMacCommandSlot( );
 802e0ec:	f7ff ff64 	bl	802dfb8 <MallocNewMacCommandSlot>
 802e0f0:	1e04      	subs	r4, r0, #0

    if( newCmd == NULL )
 802e0f2:	d01f      	beq.n	802e134 <LoRaMacCommandsAddCmd+0x54>
    {
        return LORAMAC_COMMANDS_ERROR_MEMORY;
    }

    // Add it to the list of Mac commands
    if( LinkedListAdd( &CommandsCtx.MacCommandList, newCmd ) == false )
 802e0f4:	0001      	movs	r1, r0
 802e0f6:	4811      	ldr	r0, [pc, #68]	; (802e13c <LoRaMacCommandsAddCmd+0x5c>)
 802e0f8:	f7ff ff7b 	bl	802dff2 <LinkedListAdd>
 802e0fc:	2800      	cmp	r0, #0
 802e0fe:	d01b      	beq.n	802e138 <LoRaMacCommandsAddCmd+0x58>
    {
        return LORAMAC_COMMANDS_ERROR;
    }

    // Set Values
    newCmd->CID = cid;
 802e100:	7127      	strb	r7, [r4, #4]
    newCmd->PayloadSize = payloadSize;
 802e102:	60a5      	str	r5, [r4, #8]
    memcpy1( ( uint8_t* )newCmd->Payload, payload, payloadSize );
 802e104:	1d60      	adds	r0, r4, #5
 802e106:	b2aa      	uxth	r2, r5
 802e108:	0031      	movs	r1, r6
 802e10a:	f003 fffa 	bl	8032102 <memcpy1>
    newCmd->IsSticky = IsSticky( cid );
 802e10e:	0038      	movs	r0, r7
 802e110:	f7ff ffb8 	bl	802e084 <IsSticky>
 802e114:	7320      	strb	r0, [r4, #12]
    newCmd->IsConfirmationRequired = IsConfirmationRequired( cid );
 802e116:	0038      	movs	r0, r7
 802e118:	f7ff ffc4 	bl	802e0a4 <IsConfirmationRequired>
 802e11c:	7360      	strb	r0, [r4, #13]

    CommandsCtx.SerializedCmdsSize += ( CID_FIELD_SIZE + payloadSize );
 802e11e:	4907      	ldr	r1, [pc, #28]	; (802e13c <LoRaMacCommandsAddCmd+0x5c>)
 802e120:	2382      	movs	r3, #130	; 0x82
 802e122:	009b      	lsls	r3, r3, #2
 802e124:	58ca      	ldr	r2, [r1, r3]
 802e126:	18aa      	adds	r2, r5, r2
 802e128:	3201      	adds	r2, #1
 802e12a:	50ca      	str	r2, [r1, r3]

    return LORAMAC_COMMANDS_SUCCESS;
 802e12c:	2000      	movs	r0, #0
}
 802e12e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return LORAMAC_COMMANDS_ERROR_NPE;
 802e130:	2001      	movs	r0, #1
 802e132:	e7fc      	b.n	802e12e <LoRaMacCommandsAddCmd+0x4e>
        return LORAMAC_COMMANDS_ERROR_MEMORY;
 802e134:	2002      	movs	r0, #2
 802e136:	e7fa      	b.n	802e12e <LoRaMacCommandsAddCmd+0x4e>
        return LORAMAC_COMMANDS_ERROR;
 802e138:	2005      	movs	r0, #5
 802e13a:	e7f8      	b.n	802e12e <LoRaMacCommandsAddCmd+0x4e>
 802e13c:	2000c0dc 	.word	0x2000c0dc

0802e140 <LoRaMacCommandsRemoveCmd>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveCmd( MacCommand_t* macCmd )
{
 802e140:	b510      	push	{r4, lr}
 802e142:	1e04      	subs	r4, r0, #0
    if( macCmd == NULL )
 802e144:	d014      	beq.n	802e170 <LoRaMacCommandsRemoveCmd+0x30>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }

    // Remove the Mac command element from MacCommandList
    if( LinkedListRemove( &CommandsCtx.MacCommandList, macCmd ) == false )
 802e146:	0001      	movs	r1, r0
 802e148:	480c      	ldr	r0, [pc, #48]	; (802e17c <LoRaMacCommandsRemoveCmd+0x3c>)
 802e14a:	f7ff ff7a 	bl	802e042 <LinkedListRemove>
 802e14e:	2800      	cmp	r0, #0
 802e150:	d010      	beq.n	802e174 <LoRaMacCommandsRemoveCmd+0x34>
    {
        return LORAMAC_COMMANDS_ERROR_CMD_NOT_FOUND;
    }

    CommandsCtx.SerializedCmdsSize -= ( CID_FIELD_SIZE + macCmd->PayloadSize );
 802e152:	490a      	ldr	r1, [pc, #40]	; (802e17c <LoRaMacCommandsRemoveCmd+0x3c>)
 802e154:	2282      	movs	r2, #130	; 0x82
 802e156:	0092      	lsls	r2, r2, #2
 802e158:	588b      	ldr	r3, [r1, r2]
 802e15a:	68a0      	ldr	r0, [r4, #8]
 802e15c:	1a1b      	subs	r3, r3, r0
 802e15e:	3b01      	subs	r3, #1
 802e160:	508b      	str	r3, [r1, r2]

    // Free the MacCommand Slot
    if( FreeMacCommandSlot( macCmd ) == false )
 802e162:	0020      	movs	r0, r4
 802e164:	f7ff ffa0 	bl	802e0a8 <FreeMacCommandSlot>
 802e168:	2800      	cmp	r0, #0
 802e16a:	d005      	beq.n	802e178 <LoRaMacCommandsRemoveCmd+0x38>
    {
        return LORAMAC_COMMANDS_ERROR;
    }

    return LORAMAC_COMMANDS_SUCCESS;
 802e16c:	2000      	movs	r0, #0
}
 802e16e:	bd10      	pop	{r4, pc}
        return LORAMAC_COMMANDS_ERROR_NPE;
 802e170:	2001      	movs	r0, #1
 802e172:	e7fc      	b.n	802e16e <LoRaMacCommandsRemoveCmd+0x2e>
        return LORAMAC_COMMANDS_ERROR_CMD_NOT_FOUND;
 802e174:	2003      	movs	r0, #3
 802e176:	e7fa      	b.n	802e16e <LoRaMacCommandsRemoveCmd+0x2e>
        return LORAMAC_COMMANDS_ERROR;
 802e178:	2005      	movs	r0, #5
 802e17a:	e7f8      	b.n	802e16e <LoRaMacCommandsRemoveCmd+0x2e>
 802e17c:	2000c0dc 	.word	0x2000c0dc

0802e180 <LoRaMacCommandsGetCmd>:
LoRaMacCommandStatus_t LoRaMacCommandsGetCmd( uint8_t cid, MacCommand_t** macCmd )
{
    MacCommand_t* curElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 802e180:	4b07      	ldr	r3, [pc, #28]	; (802e1a0 <LoRaMacCommandsGetCmd+0x20>)
 802e182:	681b      	ldr	r3, [r3, #0]

    // Loop through all elements until we find the element with the given CID
    while( ( curElement != NULL ) && ( curElement->CID != cid ) )
 802e184:	e000      	b.n	802e188 <LoRaMacCommandsGetCmd+0x8>
    {
        curElement = curElement->Next;
 802e186:	681b      	ldr	r3, [r3, #0]
    while( ( curElement != NULL ) && ( curElement->CID != cid ) )
 802e188:	2b00      	cmp	r3, #0
 802e18a:	d002      	beq.n	802e192 <LoRaMacCommandsGetCmd+0x12>
 802e18c:	791a      	ldrb	r2, [r3, #4]
 802e18e:	4282      	cmp	r2, r0
 802e190:	d1f9      	bne.n	802e186 <LoRaMacCommandsGetCmd+0x6>
    }

    // Update the pointer anyway
    *macCmd = curElement;
 802e192:	600b      	str	r3, [r1, #0]

    // Handle error in case if we reached the end without finding it.
    if( curElement == NULL )
 802e194:	2b00      	cmp	r3, #0
 802e196:	d001      	beq.n	802e19c <LoRaMacCommandsGetCmd+0x1c>
    {
        return LORAMAC_COMMANDS_ERROR_CMD_NOT_FOUND;
    }
    return LORAMAC_COMMANDS_SUCCESS;
 802e198:	2000      	movs	r0, #0
}
 802e19a:	4770      	bx	lr
        return LORAMAC_COMMANDS_ERROR_CMD_NOT_FOUND;
 802e19c:	2003      	movs	r0, #3
 802e19e:	e7fc      	b.n	802e19a <LoRaMacCommandsGetCmd+0x1a>
 802e1a0:	2000c0dc 	.word	0x2000c0dc

0802e1a4 <LoRaMacCommandsRemoveNoneStickyCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveNoneStickyCmds( void )
{
 802e1a4:	b510      	push	{r4, lr}
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 802e1a6:	4b07      	ldr	r3, [pc, #28]	; (802e1c4 <LoRaMacCommandsRemoveNoneStickyCmds+0x20>)
 802e1a8:	6818      	ldr	r0, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 802e1aa:	e000      	b.n	802e1ae <LoRaMacCommandsRemoveNoneStickyCmds+0xa>
            LoRaMacCommandsRemoveCmd( curElement );
            curElement = nexElement;
        }
        else
        {
            curElement = curElement->Next;
 802e1ac:	6800      	ldr	r0, [r0, #0]
    while( curElement != NULL )
 802e1ae:	2800      	cmp	r0, #0
 802e1b0:	d007      	beq.n	802e1c2 <LoRaMacCommandsRemoveNoneStickyCmds+0x1e>
        if( curElement->IsSticky == false )
 802e1b2:	7b03      	ldrb	r3, [r0, #12]
 802e1b4:	2b00      	cmp	r3, #0
 802e1b6:	d1f9      	bne.n	802e1ac <LoRaMacCommandsRemoveNoneStickyCmds+0x8>
            nexElement = curElement->Next;
 802e1b8:	6804      	ldr	r4, [r0, #0]
            LoRaMacCommandsRemoveCmd( curElement );
 802e1ba:	f7ff ffc1 	bl	802e140 <LoRaMacCommandsRemoveCmd>
            curElement = nexElement;
 802e1be:	0020      	movs	r0, r4
 802e1c0:	e7f5      	b.n	802e1ae <LoRaMacCommandsRemoveNoneStickyCmds+0xa>
        }
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 802e1c2:	bd10      	pop	{r4, pc}
 802e1c4:	2000c0dc 	.word	0x2000c0dc

0802e1c8 <LoRaMacCommandsRemoveStickyAnsCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsRemoveStickyAnsCmds( void )
{
 802e1c8:	b570      	push	{r4, r5, r6, lr}
    MacCommand_t* curElement;
    MacCommand_t* nexElement;

    // Start at the head of the list
    curElement = CommandsCtx.MacCommandList.First;
 802e1ca:	4b0c      	ldr	r3, [pc, #48]	; (802e1fc <LoRaMacCommandsRemoveStickyAnsCmds+0x34>)
 802e1cc:	681c      	ldr	r4, [r3, #0]

    // Loop through all elements
    while( curElement != NULL )
 802e1ce:	e000      	b.n	802e1d2 <LoRaMacCommandsRemoveStickyAnsCmds+0xa>
{
 802e1d0:	0034      	movs	r4, r6
    while( curElement != NULL )
 802e1d2:	2c00      	cmp	r4, #0
 802e1d4:	d00f      	beq.n	802e1f6 <LoRaMacCommandsRemoveStickyAnsCmds+0x2e>
    {
        nexElement = curElement->Next;
 802e1d6:	6826      	ldr	r6, [r4, #0]
        if( ( IsSticky( curElement->CID ) == true ) &&
 802e1d8:	7925      	ldrb	r5, [r4, #4]
 802e1da:	0028      	movs	r0, r5
 802e1dc:	f7ff ff52 	bl	802e084 <IsSticky>
 802e1e0:	2800      	cmp	r0, #0
 802e1e2:	d0f5      	beq.n	802e1d0 <LoRaMacCommandsRemoveStickyAnsCmds+0x8>
            ( IsConfirmationRequired( curElement->CID ) == false ) )
 802e1e4:	0028      	movs	r0, r5
 802e1e6:	f7ff ff5d 	bl	802e0a4 <IsConfirmationRequired>
        if( ( IsSticky( curElement->CID ) == true ) &&
 802e1ea:	2800      	cmp	r0, #0
 802e1ec:	d1f0      	bne.n	802e1d0 <LoRaMacCommandsRemoveStickyAnsCmds+0x8>
        {
            LoRaMacCommandsRemoveCmd( curElement );
 802e1ee:	0020      	movs	r0, r4
 802e1f0:	f7ff ffa6 	bl	802e140 <LoRaMacCommandsRemoveCmd>
 802e1f4:	e7ec      	b.n	802e1d0 <LoRaMacCommandsRemoveStickyAnsCmds+0x8>
        }
        curElement = nexElement;
    }

    return LORAMAC_COMMANDS_SUCCESS;
}
 802e1f6:	2000      	movs	r0, #0
 802e1f8:	bd70      	pop	{r4, r5, r6, pc}
 802e1fa:	46c0      	nop			; (mov r8, r8)
 802e1fc:	2000c0dc 	.word	0x2000c0dc

0802e200 <LoRaMacCommandsGetSizeSerializedCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsGetSizeSerializedCmds( size_t* size )
{
    if( size == NULL )
 802e200:	2800      	cmp	r0, #0
 802e202:	d006      	beq.n	802e212 <LoRaMacCommandsGetSizeSerializedCmds+0x12>
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }
    *size = CommandsCtx.SerializedCmdsSize;
 802e204:	4a04      	ldr	r2, [pc, #16]	; (802e218 <LoRaMacCommandsGetSizeSerializedCmds+0x18>)
 802e206:	2382      	movs	r3, #130	; 0x82
 802e208:	009b      	lsls	r3, r3, #2
 802e20a:	58d3      	ldr	r3, [r2, r3]
 802e20c:	6003      	str	r3, [r0, #0]
    return LORAMAC_COMMANDS_SUCCESS;
 802e20e:	2000      	movs	r0, #0
}
 802e210:	4770      	bx	lr
        return LORAMAC_COMMANDS_ERROR_NPE;
 802e212:	2001      	movs	r0, #1
 802e214:	e7fc      	b.n	802e210 <LoRaMacCommandsGetSizeSerializedCmds+0x10>
 802e216:	46c0      	nop			; (mov r8, r8)
 802e218:	2000c0dc 	.word	0x2000c0dc

0802e21c <LoRaMacCommandsSerializeCmds>:

LoRaMacCommandStatus_t LoRaMacCommandsSerializeCmds( size_t availableSize, size_t* effectiveSize, uint8_t* buffer )
{
 802e21c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802e21e:	46ce      	mov	lr, r9
 802e220:	4647      	mov	r7, r8
 802e222:	b580      	push	{r7, lr}
 802e224:	4680      	mov	r8, r0
 802e226:	4689      	mov	r9, r1
 802e228:	1e17      	subs	r7, r2, #0
    MacCommand_t* curElement = CommandsCtx.MacCommandList.First;
 802e22a:	4b18      	ldr	r3, [pc, #96]	; (802e28c <LoRaMacCommandsSerializeCmds+0x70>)
 802e22c:	681c      	ldr	r4, [r3, #0]
    MacCommand_t* nextElement;
    uint8_t itr = 0;

    if( ( buffer == NULL ) || ( effectiveSize == NULL ) )
 802e22e:	d029      	beq.n	802e284 <LoRaMacCommandsSerializeCmds+0x68>
 802e230:	2900      	cmp	r1, #0
 802e232:	d029      	beq.n	802e288 <LoRaMacCommandsSerializeCmds+0x6c>
    uint8_t itr = 0;
 802e234:	2200      	movs	r2, #0
    {
        return LORAMAC_COMMANDS_ERROR_NPE;
    }

    // Loop through all elements which fits into the buffer
    while( curElement != NULL )
 802e236:	2c00      	cmp	r4, #0
 802e238:	d014      	beq.n	802e264 <LoRaMacCommandsSerializeCmds+0x48>
    {
        // If the next MAC command still fits into the buffer, add it.
        if( ( availableSize - itr ) >= ( CID_FIELD_SIZE + curElement->PayloadSize ) )
 802e23a:	4643      	mov	r3, r8
 802e23c:	1a9e      	subs	r6, r3, r2
 802e23e:	68a3      	ldr	r3, [r4, #8]
 802e240:	3301      	adds	r3, #1
 802e242:	429e      	cmp	r6, r3
 802e244:	d30e      	bcc.n	802e264 <LoRaMacCommandsSerializeCmds+0x48>
        {
            buffer[itr++] = curElement->CID;
 802e246:	1c55      	adds	r5, r2, #1
 802e248:	b2ed      	uxtb	r5, r5
 802e24a:	7923      	ldrb	r3, [r4, #4]
 802e24c:	54bb      	strb	r3, [r7, r2]
            memcpy1( &buffer[itr], curElement->Payload, curElement->PayloadSize );
 802e24e:	1d61      	adds	r1, r4, #5
 802e250:	8922      	ldrh	r2, [r4, #8]
 802e252:	1978      	adds	r0, r7, r5
 802e254:	f003 ff55 	bl	8032102 <memcpy1>
            itr += curElement->PayloadSize;
 802e258:	68a3      	ldr	r3, [r4, #8]
 802e25a:	469c      	mov	ip, r3
 802e25c:	4465      	add	r5, ip
 802e25e:	b2ea      	uxtb	r2, r5
        }
        else
        {
            break;
        }
        curElement = curElement->Next;
 802e260:	6824      	ldr	r4, [r4, #0]
 802e262:	e7e8      	b.n	802e236 <LoRaMacCommandsSerializeCmds+0x1a>
    }

    // Remove all commands which do not fit into the buffer
    while( curElement != NULL )
 802e264:	2c00      	cmp	r4, #0
 802e266:	d005      	beq.n	802e274 <LoRaMacCommandsSerializeCmds+0x58>
    {
        // Store the next element before removing the current one
        nextElement = curElement->Next;
 802e268:	6825      	ldr	r5, [r4, #0]
        LoRaMacCommandsRemoveCmd( curElement );
 802e26a:	0020      	movs	r0, r4
 802e26c:	f7ff ff68 	bl	802e140 <LoRaMacCommandsRemoveCmd>
        curElement = nextElement;
 802e270:	002c      	movs	r4, r5
 802e272:	e7f7      	b.n	802e264 <LoRaMacCommandsSerializeCmds+0x48>
    }

    // Fetch the effective size of the mac commands
    LoRaMacCommandsGetSizeSerializedCmds( effectiveSize );
 802e274:	4648      	mov	r0, r9
 802e276:	f7ff ffc3 	bl	802e200 <LoRaMacCommandsGetSizeSerializedCmds>

    return LORAMAC_COMMANDS_SUCCESS;
 802e27a:	2000      	movs	r0, #0
}
 802e27c:	bcc0      	pop	{r6, r7}
 802e27e:	46b9      	mov	r9, r7
 802e280:	46b0      	mov	r8, r6
 802e282:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return LORAMAC_COMMANDS_ERROR_NPE;
 802e284:	2001      	movs	r0, #1
 802e286:	e7f9      	b.n	802e27c <LoRaMacCommandsSerializeCmds+0x60>
 802e288:	2001      	movs	r0, #1
 802e28a:	e7f7      	b.n	802e27c <LoRaMacCommandsSerializeCmds+0x60>
 802e28c:	2000c0dc 	.word	0x2000c0dc

0802e290 <LoRaMacCommandsGetCmdSize>:
uint8_t LoRaMacCommandsGetCmdSize( uint8_t cid )
{
    uint8_t cidSize = 0;

    // Decode Frame MAC commands
    switch( cid )
 802e290:	2813      	cmp	r0, #19
 802e292:	d803      	bhi.n	802e29c <LoRaMacCommandsGetCmdSize+0xc>
 802e294:	0083      	lsls	r3, r0, #2
 802e296:	4a0f      	ldr	r2, [pc, #60]	; (802e2d4 <LoRaMacCommandsGetCmdSize+0x44>)
 802e298:	58d3      	ldr	r3, [r2, r3]
 802e29a:	469f      	mov	pc, r3
 802e29c:	2000      	movs	r0, #0
            // Unknown command. ABORT MAC commands processing
            break;
        }
    }
    return cidSize;
}
 802e29e:	4770      	bx	lr
            cidSize = 5;
 802e2a0:	2005      	movs	r0, #5
            break;
 802e2a2:	e7fc      	b.n	802e29e <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 2;
 802e2a4:	2002      	movs	r0, #2
            break;
 802e2a6:	e7fa      	b.n	802e29e <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 1;
 802e2a8:	2001      	movs	r0, #1
            break;
 802e2aa:	e7f8      	b.n	802e29e <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 6;
 802e2ac:	2006      	movs	r0, #6
            break;
 802e2ae:	e7f6      	b.n	802e29e <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 2;
 802e2b0:	2002      	movs	r0, #2
            break;
 802e2b2:	e7f4      	b.n	802e29e <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 2;
 802e2b4:	2002      	movs	r0, #2
            break;
 802e2b6:	e7f2      	b.n	802e29e <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 5;
 802e2b8:	2005      	movs	r0, #5
            break;
 802e2ba:	e7f0      	b.n	802e29e <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 6;
 802e2bc:	2006      	movs	r0, #6
            break;
 802e2be:	e7ee      	b.n	802e29e <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 1;
 802e2c0:	2001      	movs	r0, #1
            break;
 802e2c2:	e7ec      	b.n	802e29e <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 5;
 802e2c4:	2005      	movs	r0, #5
            break;
 802e2c6:	e7ea      	b.n	802e29e <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 4;
 802e2c8:	2004      	movs	r0, #4
            break;
 802e2ca:	e7e8      	b.n	802e29e <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 4;
 802e2cc:	2004      	movs	r0, #4
            break;
 802e2ce:	e7e6      	b.n	802e29e <LoRaMacCommandsGetCmdSize+0xe>
            cidSize = 3;
 802e2d0:	2003      	movs	r0, #3
 802e2d2:	e7e4      	b.n	802e29e <LoRaMacCommandsGetCmdSize+0xe>
 802e2d4:	080356a0 	.word	0x080356a0

0802e2d8 <IncreaseBufferPointer>:
 */
static LoRaMacConfirmQueueCtx_t ConfirmQueueCtx;

static MlmeConfirmQueue_t* IncreaseBufferPointer( MlmeConfirmQueue_t* bufferPointer )
{
    if( bufferPointer == &ConfirmQueueCtx.Nvm.MlmeConfirmQueue[LORA_MAC_MLME_CONFIRM_QUEUE_LEN - 1] )
 802e2d8:	4b04      	ldr	r3, [pc, #16]	; (802e2ec <IncreaseBufferPointer+0x14>)
 802e2da:	331c      	adds	r3, #28
 802e2dc:	4298      	cmp	r0, r3
 802e2de:	d001      	beq.n	802e2e4 <IncreaseBufferPointer+0xc>
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
    }
    else
    {
        // Increase
        bufferPointer++;
 802e2e0:	3004      	adds	r0, #4
    }
    return bufferPointer;
}
 802e2e2:	4770      	bx	lr
        bufferPointer = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 802e2e4:	4801      	ldr	r0, [pc, #4]	; (802e2ec <IncreaseBufferPointer+0x14>)
 802e2e6:	300c      	adds	r0, #12
    return bufferPointer;
 802e2e8:	e7fb      	b.n	802e2e2 <IncreaseBufferPointer+0xa>
 802e2ea:	46c0      	nop			; (mov r8, r8)
 802e2ec:	2000c2e8 	.word	0x2000c2e8

0802e2f0 <IsListEmpty>:
    return bufferPointer;
}

static bool IsListEmpty( uint8_t count )
{
    if( count == 0 )
 802e2f0:	2800      	cmp	r0, #0
 802e2f2:	d001      	beq.n	802e2f8 <IsListEmpty+0x8>
    {
        return true;
    }
    return false;
 802e2f4:	2000      	movs	r0, #0
}
 802e2f6:	4770      	bx	lr
        return true;
 802e2f8:	2001      	movs	r0, #1
 802e2fa:	e7fc      	b.n	802e2f6 <IsListEmpty+0x6>

0802e2fc <IsListFull>:

static bool IsListFull( uint8_t count )
{
    if( count >= LORA_MAC_MLME_CONFIRM_QUEUE_LEN )
 802e2fc:	2804      	cmp	r0, #4
 802e2fe:	d801      	bhi.n	802e304 <IsListFull+0x8>
    {
        return true;
    }
    return false;
 802e300:	2000      	movs	r0, #0
}
 802e302:	4770      	bx	lr
        return true;
 802e304:	2001      	movs	r0, #1
 802e306:	e7fc      	b.n	802e302 <IsListFull+0x6>

0802e308 <GetElement>:

static MlmeConfirmQueue_t* GetElement( Mlme_t request, MlmeConfirmQueue_t* bufferStart, MlmeConfirmQueue_t* bufferEnd )
{
 802e308:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802e30a:	0006      	movs	r6, r0
 802e30c:	000c      	movs	r4, r1
    MlmeConfirmQueue_t* element = bufferStart;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 802e30e:	4a0d      	ldr	r2, [pc, #52]	; (802e344 <GetElement+0x3c>)
 802e310:	2320      	movs	r3, #32
 802e312:	5cd7      	ldrb	r7, [r2, r3]
 802e314:	0038      	movs	r0, r7
 802e316:	f7ff ffeb 	bl	802e2f0 <IsListEmpty>
 802e31a:	2800      	cmp	r0, #0
 802e31c:	d10e      	bne.n	802e33c <GetElement+0x34>
    {
        return NULL;
    }

    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 802e31e:	2500      	movs	r5, #0
 802e320:	42af      	cmp	r7, r5
 802e322:	d909      	bls.n	802e338 <GetElement+0x30>
    {
        if( element->Request == request )
 802e324:	7823      	ldrb	r3, [r4, #0]
 802e326:	42b3      	cmp	r3, r6
 802e328:	d00a      	beq.n	802e340 <GetElement+0x38>
        {
            // We have found the element
            return element;
        }
        element = IncreaseBufferPointer( element );
 802e32a:	0020      	movs	r0, r4
 802e32c:	f7ff ffd4 	bl	802e2d8 <IncreaseBufferPointer>
 802e330:	0004      	movs	r4, r0
    for( uint8_t elementCnt = 0; elementCnt < ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt; elementCnt++ )
 802e332:	3501      	adds	r5, #1
 802e334:	b2ed      	uxtb	r5, r5
 802e336:	e7f3      	b.n	802e320 <GetElement+0x18>
    }

    return NULL;
 802e338:	2000      	movs	r0, #0
}
 802e33a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return NULL;
 802e33c:	2000      	movs	r0, #0
 802e33e:	e7fc      	b.n	802e33a <GetElement+0x32>
            return element;
 802e340:	0020      	movs	r0, r4
 802e342:	e7fa      	b.n	802e33a <GetElement+0x32>
 802e344:	2000c2e8 	.word	0x2000c2e8

0802e348 <LoRaMacConfirmQueueInit>:

void LoRaMacConfirmQueueInit( LoRaMacPrimitives_t* primitives )
{
 802e348:	b510      	push	{r4, lr}
    ConfirmQueueCtx.Primitives = primitives;
 802e34a:	4c08      	ldr	r4, [pc, #32]	; (802e36c <LoRaMacConfirmQueueInit+0x24>)
 802e34c:	6020      	str	r0, [r4, #0]

    // Init counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt = 0;
 802e34e:	2320      	movs	r3, #32
 802e350:	2200      	movs	r2, #0
 802e352:	54e2      	strb	r2, [r4, r3]

    // Init buffer
    ConfirmQueueCtx.BufferStart = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 802e354:	0020      	movs	r0, r4
 802e356:	300c      	adds	r0, #12
 802e358:	6060      	str	r0, [r4, #4]
    ConfirmQueueCtx.BufferEnd = ConfirmQueueCtx.Nvm.MlmeConfirmQueue;
 802e35a:	60a0      	str	r0, [r4, #8]

    memset1( ( uint8_t* )ConfirmQueueCtx.Nvm.MlmeConfirmQueue, 0xFF, sizeof( ConfirmQueueCtx.Nvm.MlmeConfirmQueue ) );
 802e35c:	3214      	adds	r2, #20
 802e35e:	21ff      	movs	r1, #255	; 0xff
 802e360:	f003 fee7 	bl	8032132 <memset1>

    // Common status
    ConfirmQueueCtx.Nvm.CommonStatus = LORAMAC_EVENT_INFO_STATUS_ERROR;
 802e364:	2321      	movs	r3, #33	; 0x21
 802e366:	2201      	movs	r2, #1
 802e368:	54e2      	strb	r2, [r4, r3]
}
 802e36a:	bd10      	pop	{r4, pc}
 802e36c:	2000c2e8 	.word	0x2000c2e8

0802e370 <LoRaMacConfirmQueueAdd>:

bool LoRaMacConfirmQueueAdd( MlmeConfirmQueue_t* mlmeConfirm )
{
 802e370:	b570      	push	{r4, r5, r6, lr}
 802e372:	0005      	movs	r5, r0
    if( IsListFull( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 802e374:	4a0f      	ldr	r2, [pc, #60]	; (802e3b4 <LoRaMacConfirmQueueAdd+0x44>)
 802e376:	2320      	movs	r3, #32
 802e378:	5cd0      	ldrb	r0, [r2, r3]
 802e37a:	f7ff ffbf 	bl	802e2fc <IsListFull>
 802e37e:	2800      	cmp	r0, #0
 802e380:	d116      	bne.n	802e3b0 <LoRaMacConfirmQueueAdd+0x40>
        // Protect the buffer against overwrites
        return false;
    }

    // Add the element to the ring buffer
    ConfirmQueueCtx.BufferEnd->Request = mlmeConfirm->Request;
 802e382:	4c0c      	ldr	r4, [pc, #48]	; (802e3b4 <LoRaMacConfirmQueueAdd+0x44>)
 802e384:	782b      	ldrb	r3, [r5, #0]
 802e386:	68a2      	ldr	r2, [r4, #8]
 802e388:	7013      	strb	r3, [r2, #0]
    ConfirmQueueCtx.BufferEnd->Status = mlmeConfirm->Status;
 802e38a:	786b      	ldrb	r3, [r5, #1]
 802e38c:	68a2      	ldr	r2, [r4, #8]
 802e38e:	7053      	strb	r3, [r2, #1]
    ConfirmQueueCtx.BufferEnd->RestrictCommonReadyToHandle = mlmeConfirm->RestrictCommonReadyToHandle;
 802e390:	78eb      	ldrb	r3, [r5, #3]
 802e392:	68a2      	ldr	r2, [r4, #8]
 802e394:	70d3      	strb	r3, [r2, #3]
#if (defined( LORAMAC_VERSION ) && ( LORAMAC_VERSION == 0x01000300 ))
    ConfirmQueueCtx.BufferEnd->ReadyToHandle = false;
#elif (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
    ConfirmQueueCtx.BufferEnd->ReadyToHandle = mlmeConfirm->ReadyToHandle;
 802e396:	78ab      	ldrb	r3, [r5, #2]
 802e398:	68a2      	ldr	r2, [r4, #8]
 802e39a:	7093      	strb	r3, [r2, #2]
#endif /* LORAMAC_VERSION */
    // Increase counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt++;
 802e39c:	2220      	movs	r2, #32
 802e39e:	5ca3      	ldrb	r3, [r4, r2]
 802e3a0:	3301      	adds	r3, #1
 802e3a2:	54a3      	strb	r3, [r4, r2]
    // Update end pointer
    ConfirmQueueCtx.BufferEnd = IncreaseBufferPointer( ConfirmQueueCtx.BufferEnd );
 802e3a4:	68a0      	ldr	r0, [r4, #8]
 802e3a6:	f7ff ff97 	bl	802e2d8 <IncreaseBufferPointer>
 802e3aa:	60a0      	str	r0, [r4, #8]

    return true;
 802e3ac:	2001      	movs	r0, #1
}
 802e3ae:	bd70      	pop	{r4, r5, r6, pc}
        return false;
 802e3b0:	2000      	movs	r0, #0
 802e3b2:	e7fc      	b.n	802e3ae <LoRaMacConfirmQueueAdd+0x3e>
 802e3b4:	2000c2e8 	.word	0x2000c2e8

0802e3b8 <LoRaMacConfirmQueueRemoveFirst>:

    return true;
}

bool LoRaMacConfirmQueueRemoveFirst( void )
{
 802e3b8:	b570      	push	{r4, r5, r6, lr}
    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 802e3ba:	4a0a      	ldr	r2, [pc, #40]	; (802e3e4 <LoRaMacConfirmQueueRemoveFirst+0x2c>)
 802e3bc:	2320      	movs	r3, #32
 802e3be:	5cd4      	ldrb	r4, [r2, r3]
 802e3c0:	0020      	movs	r0, r4
 802e3c2:	f7ff ff95 	bl	802e2f0 <IsListEmpty>
 802e3c6:	2800      	cmp	r0, #0
 802e3c8:	d109      	bne.n	802e3de <LoRaMacConfirmQueueRemoveFirst+0x26>
    {
        return false;
    }

    // Increase counter
    ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt--;
 802e3ca:	4d06      	ldr	r5, [pc, #24]	; (802e3e4 <LoRaMacConfirmQueueRemoveFirst+0x2c>)
 802e3cc:	3c01      	subs	r4, #1
 802e3ce:	2320      	movs	r3, #32
 802e3d0:	54ec      	strb	r4, [r5, r3]
    // Update start pointer
    ConfirmQueueCtx.BufferStart = IncreaseBufferPointer( ConfirmQueueCtx.BufferStart );
 802e3d2:	6868      	ldr	r0, [r5, #4]
 802e3d4:	f7ff ff80 	bl	802e2d8 <IncreaseBufferPointer>
 802e3d8:	6068      	str	r0, [r5, #4]

    return true;
 802e3da:	2001      	movs	r0, #1
}
 802e3dc:	bd70      	pop	{r4, r5, r6, pc}
        return false;
 802e3de:	2000      	movs	r0, #0
 802e3e0:	e7fc      	b.n	802e3dc <LoRaMacConfirmQueueRemoveFirst+0x24>
 802e3e2:	46c0      	nop			; (mov r8, r8)
 802e3e4:	2000c2e8 	.word	0x2000c2e8

0802e3e8 <LoRaMacConfirmQueueSetStatus>:

void LoRaMacConfirmQueueSetStatus( LoRaMacEventInfoStatus_t status, Mlme_t request )
{
 802e3e8:	b570      	push	{r4, r5, r6, lr}
 802e3ea:	0005      	movs	r5, r0
 802e3ec:	000c      	movs	r4, r1
    MlmeConfirmQueue_t* element = NULL;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 802e3ee:	4a09      	ldr	r2, [pc, #36]	; (802e414 <LoRaMacConfirmQueueSetStatus+0x2c>)
 802e3f0:	2320      	movs	r3, #32
 802e3f2:	5cd0      	ldrb	r0, [r2, r3]
 802e3f4:	f7ff ff7c 	bl	802e2f0 <IsListEmpty>
 802e3f8:	2800      	cmp	r0, #0
 802e3fa:	d10a      	bne.n	802e412 <LoRaMacConfirmQueueSetStatus+0x2a>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 802e3fc:	4b05      	ldr	r3, [pc, #20]	; (802e414 <LoRaMacConfirmQueueSetStatus+0x2c>)
 802e3fe:	689a      	ldr	r2, [r3, #8]
 802e400:	6859      	ldr	r1, [r3, #4]
 802e402:	0020      	movs	r0, r4
 802e404:	f7ff ff80 	bl	802e308 <GetElement>
        if( element != NULL )
 802e408:	2800      	cmp	r0, #0
 802e40a:	d002      	beq.n	802e412 <LoRaMacConfirmQueueSetStatus+0x2a>
        {
            element->Status = status;
 802e40c:	7045      	strb	r5, [r0, #1]
            element->ReadyToHandle = true;
 802e40e:	2301      	movs	r3, #1
 802e410:	7083      	strb	r3, [r0, #2]
        }
    }
}
 802e412:	bd70      	pop	{r4, r5, r6, pc}
 802e414:	2000c2e8 	.word	0x2000c2e8

0802e418 <LoRaMacConfirmQueueGetStatus>:

LoRaMacEventInfoStatus_t LoRaMacConfirmQueueGetStatus( Mlme_t request )
{
 802e418:	b510      	push	{r4, lr}
 802e41a:	0004      	movs	r4, r0
    MlmeConfirmQueue_t* element = NULL;

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 802e41c:	4a0a      	ldr	r2, [pc, #40]	; (802e448 <LoRaMacConfirmQueueGetStatus+0x30>)
 802e41e:	2320      	movs	r3, #32
 802e420:	5cd0      	ldrb	r0, [r2, r3]
 802e422:	f7ff ff65 	bl	802e2f0 <IsListEmpty>
 802e426:	2800      	cmp	r0, #0
 802e428:	d109      	bne.n	802e43e <LoRaMacConfirmQueueGetStatus+0x26>
    {
        element = GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd );
 802e42a:	4b07      	ldr	r3, [pc, #28]	; (802e448 <LoRaMacConfirmQueueGetStatus+0x30>)
 802e42c:	689a      	ldr	r2, [r3, #8]
 802e42e:	6859      	ldr	r1, [r3, #4]
 802e430:	0020      	movs	r0, r4
 802e432:	f7ff ff69 	bl	802e308 <GetElement>
        if( element != NULL )
 802e436:	2800      	cmp	r0, #0
 802e438:	d003      	beq.n	802e442 <LoRaMacConfirmQueueGetStatus+0x2a>
        {
            return element->Status;
 802e43a:	7840      	ldrb	r0, [r0, #1]
 802e43c:	e000      	b.n	802e440 <LoRaMacConfirmQueueGetStatus+0x28>
        }
    }
    return LORAMAC_EVENT_INFO_STATUS_ERROR;
 802e43e:	2001      	movs	r0, #1
}
 802e440:	bd10      	pop	{r4, pc}
    return LORAMAC_EVENT_INFO_STATUS_ERROR;
 802e442:	2001      	movs	r0, #1
 802e444:	e7fc      	b.n	802e440 <LoRaMacConfirmQueueGetStatus+0x28>
 802e446:	46c0      	nop			; (mov r8, r8)
 802e448:	2000c2e8 	.word	0x2000c2e8

0802e44c <LoRaMacConfirmQueueSetStatusCmn>:

void LoRaMacConfirmQueueSetStatusCmn( LoRaMacEventInfoStatus_t status )
{
 802e44c:	b570      	push	{r4, r5, r6, lr}
 802e44e:	0005      	movs	r5, r0
    MlmeConfirmQueue_t* element = ConfirmQueueCtx.BufferStart;
 802e450:	4b0c      	ldr	r3, [pc, #48]	; (802e484 <LoRaMacConfirmQueueSetStatusCmn+0x38>)
 802e452:	685c      	ldr	r4, [r3, #4]

    ConfirmQueueCtx.Nvm.CommonStatus = status;
 802e454:	2221      	movs	r2, #33	; 0x21
 802e456:	5498      	strb	r0, [r3, r2]

    if( IsListEmpty( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == false )
 802e458:	3a01      	subs	r2, #1
 802e45a:	5c98      	ldrb	r0, [r3, r2]
 802e45c:	f7ff ff48 	bl	802e2f0 <IsListEmpty>
 802e460:	2800      	cmp	r0, #0
 802e462:	d00a      	beq.n	802e47a <LoRaMacConfirmQueueSetStatusCmn+0x2e>
                element->ReadyToHandle = true;
            }
            element = IncreaseBufferPointer( element );
        }while( element != ConfirmQueueCtx.BufferEnd );
    }
}
 802e464:	bd70      	pop	{r4, r5, r6, pc}
                element->ReadyToHandle = true;
 802e466:	3301      	adds	r3, #1
 802e468:	70a3      	strb	r3, [r4, #2]
            element = IncreaseBufferPointer( element );
 802e46a:	0020      	movs	r0, r4
 802e46c:	f7ff ff34 	bl	802e2d8 <IncreaseBufferPointer>
 802e470:	0004      	movs	r4, r0
        }while( element != ConfirmQueueCtx.BufferEnd );
 802e472:	4b04      	ldr	r3, [pc, #16]	; (802e484 <LoRaMacConfirmQueueSetStatusCmn+0x38>)
 802e474:	689b      	ldr	r3, [r3, #8]
 802e476:	4283      	cmp	r3, r0
 802e478:	d0f4      	beq.n	802e464 <LoRaMacConfirmQueueSetStatusCmn+0x18>
            element->Status = status;
 802e47a:	7065      	strb	r5, [r4, #1]
            if( element->RestrictCommonReadyToHandle == false )
 802e47c:	78e3      	ldrb	r3, [r4, #3]
 802e47e:	2b00      	cmp	r3, #0
 802e480:	d1f3      	bne.n	802e46a <LoRaMacConfirmQueueSetStatusCmn+0x1e>
 802e482:	e7f0      	b.n	802e466 <LoRaMacConfirmQueueSetStatusCmn+0x1a>
 802e484:	2000c2e8 	.word	0x2000c2e8

0802e488 <LoRaMacConfirmQueueIsCmdActive>:
{
    return ConfirmQueueCtx.Nvm.CommonStatus;
}

bool LoRaMacConfirmQueueIsCmdActive( Mlme_t request )
{
 802e488:	b510      	push	{r4, lr}
    if( GetElement( request, ConfirmQueueCtx.BufferStart, ConfirmQueueCtx.BufferEnd ) != NULL )
 802e48a:	4b04      	ldr	r3, [pc, #16]	; (802e49c <LoRaMacConfirmQueueIsCmdActive+0x14>)
 802e48c:	689a      	ldr	r2, [r3, #8]
 802e48e:	6859      	ldr	r1, [r3, #4]
 802e490:	f7ff ff3a 	bl	802e308 <GetElement>
 802e494:	2800      	cmp	r0, #0
 802e496:	d000      	beq.n	802e49a <LoRaMacConfirmQueueIsCmdActive+0x12>
    {
        return true;
 802e498:	2001      	movs	r0, #1
    }
    return false;
}
 802e49a:	bd10      	pop	{r4, pc}
 802e49c:	2000c2e8 	.word	0x2000c2e8

0802e4a0 <LoRaMacConfirmQueueHandleCb>:

void LoRaMacConfirmQueueHandleCb( MlmeConfirm_t* mlmeConfirm )
{
 802e4a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 802e4a2:	b083      	sub	sp, #12
 802e4a4:	0006      	movs	r6, r0
    uint8_t nbElements = ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt;
 802e4a6:	4a18      	ldr	r2, [pc, #96]	; (802e508 <LoRaMacConfirmQueueHandleCb+0x68>)
 802e4a8:	2320      	movs	r3, #32
 802e4aa:	5cd7      	ldrb	r7, [r2, r3]
    bool readyToHandle = false;
    MlmeConfirmQueue_t mlmeConfirmToStore;

    memset1( ( uint8_t* ) &mlmeConfirmToStore, 0, sizeof( MlmeConfirmQueue_t ) );
 802e4ac:	2204      	movs	r2, #4
 802e4ae:	2100      	movs	r1, #0
 802e4b0:	a801      	add	r0, sp, #4
 802e4b2:	f003 fe3e 	bl	8032132 <memset1>

    for( uint8_t i = 0; i < nbElements; i++ )
 802e4b6:	2400      	movs	r4, #0
 802e4b8:	e00c      	b.n	802e4d4 <LoRaMacConfirmQueueHandleCb+0x34>
            ConfirmQueueCtx.Primitives->MacMlmeConfirm( mlmeConfirm );
        }
        else
        {
            // The request is not processed yet. Store the state.
            mlmeConfirmToStore.Request = ConfirmQueueCtx.BufferStart->Request;
 802e4ba:	7819      	ldrb	r1, [r3, #0]
 802e4bc:	aa01      	add	r2, sp, #4
 802e4be:	7011      	strb	r1, [r2, #0]
            mlmeConfirmToStore.Status = ConfirmQueueCtx.BufferStart->Status;
 802e4c0:	7859      	ldrb	r1, [r3, #1]
 802e4c2:	7051      	strb	r1, [r2, #1]
            mlmeConfirmToStore.RestrictCommonReadyToHandle = ConfirmQueueCtx.BufferStart->RestrictCommonReadyToHandle;
 802e4c4:	78db      	ldrb	r3, [r3, #3]
 802e4c6:	70d3      	strb	r3, [r2, #3]
        }

        // Increase the pointer afterwards to prevent overwrites
        LoRaMacConfirmQueueRemoveFirst( );
 802e4c8:	f7ff ff76 	bl	802e3b8 <LoRaMacConfirmQueueRemoveFirst>

        if( readyToHandle == false )
 802e4cc:	2d00      	cmp	r5, #0
 802e4ce:	d014      	beq.n	802e4fa <LoRaMacConfirmQueueHandleCb+0x5a>
    for( uint8_t i = 0; i < nbElements; i++ )
 802e4d0:	3401      	adds	r4, #1
 802e4d2:	b2e4      	uxtb	r4, r4
 802e4d4:	42bc      	cmp	r4, r7
 802e4d6:	d214      	bcs.n	802e502 <LoRaMacConfirmQueueHandleCb+0x62>
        mlmeConfirm->MlmeRequest = ConfirmQueueCtx.BufferStart->Request;
 802e4d8:	4b0b      	ldr	r3, [pc, #44]	; (802e508 <LoRaMacConfirmQueueHandleCb+0x68>)
 802e4da:	685a      	ldr	r2, [r3, #4]
 802e4dc:	7812      	ldrb	r2, [r2, #0]
 802e4de:	7032      	strb	r2, [r6, #0]
        mlmeConfirm->Status = ConfirmQueueCtx.BufferStart->Status;
 802e4e0:	685a      	ldr	r2, [r3, #4]
 802e4e2:	7852      	ldrb	r2, [r2, #1]
 802e4e4:	7072      	strb	r2, [r6, #1]
        readyToHandle = ConfirmQueueCtx.BufferStart->ReadyToHandle;
 802e4e6:	685b      	ldr	r3, [r3, #4]
 802e4e8:	789d      	ldrb	r5, [r3, #2]
        if( readyToHandle == true )
 802e4ea:	2d00      	cmp	r5, #0
 802e4ec:	d0e5      	beq.n	802e4ba <LoRaMacConfirmQueueHandleCb+0x1a>
            ConfirmQueueCtx.Primitives->MacMlmeConfirm( mlmeConfirm );
 802e4ee:	4b06      	ldr	r3, [pc, #24]	; (802e508 <LoRaMacConfirmQueueHandleCb+0x68>)
 802e4f0:	681b      	ldr	r3, [r3, #0]
 802e4f2:	689b      	ldr	r3, [r3, #8]
 802e4f4:	0030      	movs	r0, r6
 802e4f6:	4798      	blx	r3
 802e4f8:	e7e6      	b.n	802e4c8 <LoRaMacConfirmQueueHandleCb+0x28>
        {
            // Add a request which has not been finished again to the queue
            LoRaMacConfirmQueueAdd( &mlmeConfirmToStore );
 802e4fa:	a801      	add	r0, sp, #4
 802e4fc:	f7ff ff38 	bl	802e370 <LoRaMacConfirmQueueAdd>
 802e500:	e7e6      	b.n	802e4d0 <LoRaMacConfirmQueueHandleCb+0x30>
        }
    }
}
 802e502:	b003      	add	sp, #12
 802e504:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802e506:	46c0      	nop			; (mov r8, r8)
 802e508:	2000c2e8 	.word	0x2000c2e8

0802e50c <LoRaMacConfirmQueueGetCnt>:

uint8_t LoRaMacConfirmQueueGetCnt( void )
{
    return ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt;
 802e50c:	4a01      	ldr	r2, [pc, #4]	; (802e514 <LoRaMacConfirmQueueGetCnt+0x8>)
 802e50e:	2320      	movs	r3, #32
 802e510:	5cd0      	ldrb	r0, [r2, r3]
}
 802e512:	4770      	bx	lr
 802e514:	2000c2e8 	.word	0x2000c2e8

0802e518 <LoRaMacConfirmQueueIsFull>:

bool LoRaMacConfirmQueueIsFull( void )
{
 802e518:	b510      	push	{r4, lr}
    if( IsListFull( ConfirmQueueCtx.Nvm.MlmeConfirmQueueCnt ) == true )
 802e51a:	4a03      	ldr	r2, [pc, #12]	; (802e528 <LoRaMacConfirmQueueIsFull+0x10>)
 802e51c:	2320      	movs	r3, #32
 802e51e:	5cd0      	ldrb	r0, [r2, r3]
 802e520:	f7ff feec 	bl	802e2fc <IsListFull>
    }
    else
    {
        return false;
    }
}
 802e524:	bd10      	pop	{r4, pc}
 802e526:	46c0      	nop			; (mov r8, r8)
 802e528:	2000c2e8 	.word	0x2000c2e8

0802e52c <PrepareB0>:
 * \param [in] fCnt           - Frame counter
 * \param [in,out] b0         - B0 block
 * \retval                    - Status of the operation
 */
static LoRaMacCryptoStatus_t PrepareB0( uint16_t msgLen, KeyIdentifier_t keyID, bool isAck, uint8_t dir, uint32_t devAddr, uint32_t fCnt, uint8_t* b0 )
{
 802e52c:	b530      	push	{r4, r5, lr}
 802e52e:	9c03      	ldr	r4, [sp, #12]
 802e530:	9904      	ldr	r1, [sp, #16]
 802e532:	9a05      	ldr	r2, [sp, #20]
    if( b0 == 0 )
 802e534:	2a00      	cmp	r2, #0
 802e536:	d019      	beq.n	802e56c <PrepareB0+0x40>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }

    b0[0] = 0x49;
 802e538:	2549      	movs	r5, #73	; 0x49
 802e53a:	7015      	strb	r5, [r2, #0]
        b0[2] = ( confFCnt >> 8 ) & 0xFF;
    }
    else
#endif /* LORAMAC_VERSION */
    {
        b0[1] = 0x00;
 802e53c:	2500      	movs	r5, #0
 802e53e:	7055      	strb	r5, [r2, #1]
        b0[2] = 0x00;
 802e540:	7095      	strb	r5, [r2, #2]
    }

    b0[3] = 0x00;
 802e542:	70d5      	strb	r5, [r2, #3]
    b0[4] = 0x00;
 802e544:	7115      	strb	r5, [r2, #4]

    b0[5] = dir;
 802e546:	7153      	strb	r3, [r2, #5]

    b0[6] = devAddr & 0xFF;
 802e548:	7194      	strb	r4, [r2, #6]
    b0[7] = ( devAddr >> 8 ) & 0xFF;
 802e54a:	0a23      	lsrs	r3, r4, #8
 802e54c:	71d3      	strb	r3, [r2, #7]
    b0[8] = ( devAddr >> 16 ) & 0xFF;
 802e54e:	0c23      	lsrs	r3, r4, #16
 802e550:	7213      	strb	r3, [r2, #8]
    b0[9] = ( devAddr >> 24 ) & 0xFF;
 802e552:	0e24      	lsrs	r4, r4, #24
 802e554:	7254      	strb	r4, [r2, #9]

    b0[10] = fCnt & 0xFF;
 802e556:	7291      	strb	r1, [r2, #10]
    b0[11] = ( fCnt >> 8 ) & 0xFF;
 802e558:	0a0b      	lsrs	r3, r1, #8
 802e55a:	72d3      	strb	r3, [r2, #11]
    b0[12] = ( fCnt >> 16 ) & 0xFF;
 802e55c:	0c0b      	lsrs	r3, r1, #16
 802e55e:	7313      	strb	r3, [r2, #12]
    b0[13] = ( fCnt >> 24 ) & 0xFF;
 802e560:	0e09      	lsrs	r1, r1, #24
 802e562:	7351      	strb	r1, [r2, #13]

    b0[14] = 0x00;
 802e564:	7395      	strb	r5, [r2, #14]

    b0[15] = msgLen & 0xFF;
 802e566:	73d0      	strb	r0, [r2, #15]

    return LORAMAC_CRYPTO_SUCCESS;
 802e568:	2000      	movs	r0, #0
}
 802e56a:	bd30      	pop	{r4, r5, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 802e56c:	2009      	movs	r0, #9
 802e56e:	e7fc      	b.n	802e56a <PrepareB0+0x3e>

0802e570 <GetKeyAddrItem>:
 * \param [in] addrID         - Address identifier
 * \param [out] keyItem       - Key item reference
 * \retval                    - Status of the operation
 */
static LoRaMacCryptoStatus_t GetKeyAddrItem( AddressIdentifier_t addrID, KeyAddr_t** item )
{
 802e570:	b530      	push	{r4, r5, lr}
    for( uint8_t i = 0; i < NUM_OF_SEC_CTX; i++ )
 802e572:	2300      	movs	r3, #0
 802e574:	2b01      	cmp	r3, #1
 802e576:	d80c      	bhi.n	802e592 <GetKeyAddrItem+0x22>
    {
        if( KeyAddrList[i].AddrID == addrID )
 802e578:	009a      	lsls	r2, r3, #2
 802e57a:	4c07      	ldr	r4, [pc, #28]	; (802e598 <GetKeyAddrItem+0x28>)
 802e57c:	5d12      	ldrb	r2, [r2, r4]
 802e57e:	4282      	cmp	r2, r0
 802e580:	d002      	beq.n	802e588 <GetKeyAddrItem+0x18>
    for( uint8_t i = 0; i < NUM_OF_SEC_CTX; i++ )
 802e582:	3301      	adds	r3, #1
 802e584:	b2db      	uxtb	r3, r3
 802e586:	e7f5      	b.n	802e574 <GetKeyAddrItem+0x4>
        {
            *item = &( KeyAddrList[i] );
 802e588:	009d      	lsls	r5, r3, #2
 802e58a:	1965      	adds	r5, r4, r5
 802e58c:	600d      	str	r5, [r1, #0]
            return LORAMAC_CRYPTO_SUCCESS;
 802e58e:	2000      	movs	r0, #0
 802e590:	e000      	b.n	802e594 <GetKeyAddrItem+0x24>
        }
    }
    return LORAMAC_CRYPTO_ERROR_INVALID_ADDR_ID;
 802e592:	200b      	movs	r0, #11
}
 802e594:	bd30      	pop	{r4, r5, pc}
 802e596:	46c0      	nop			; (mov r8, r8)
 802e598:	2000b0cc 	.word	0x2000b0cc

0802e59c <GetLastFcntDown>:
 *
 * \retval                     - Status of the operation
 */
static LoRaMacCryptoStatus_t GetLastFcntDown( FCntIdentifier_t fCntID, uint32_t* lastDown )
{
    if( lastDown == NULL )
 802e59c:	2900      	cmp	r1, #0
 802e59e:	d024      	beq.n	802e5ea <GetLastFcntDown+0x4e>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }
    switch( fCntID )
 802e5a0:	2803      	cmp	r0, #3
 802e5a2:	d01c      	beq.n	802e5de <GetLastFcntDown+0x42>
 802e5a4:	d80b      	bhi.n	802e5be <GetLastFcntDown+0x22>
 802e5a6:	2801      	cmp	r0, #1
 802e5a8:	d013      	beq.n	802e5d2 <GetLastFcntDown+0x36>
 802e5aa:	2802      	cmp	r0, #2
 802e5ac:	d105      	bne.n	802e5ba <GetLastFcntDown+0x1e>
    {
        case N_FCNT_DOWN:
            *lastDown = CryptoNvm->FCntList.NFCntDown;
            break;
        case A_FCNT_DOWN:
            *lastDown = CryptoNvm->FCntList.AFCntDown;
 802e5ae:	4b10      	ldr	r3, [pc, #64]	; (802e5f0 <GetLastFcntDown+0x54>)
 802e5b0:	681b      	ldr	r3, [r3, #0]
 802e5b2:	695b      	ldr	r3, [r3, #20]
 802e5b4:	600b      	str	r3, [r1, #0]
            break;
#endif /* LORAMAC_MAX_MC_CTX > 3 */
        default:
            return LORAMAC_CRYPTO_FAIL_FCNT_ID;
    }
    return LORAMAC_CRYPTO_SUCCESS;
 802e5b6:	2000      	movs	r0, #0
            break;
 802e5b8:	e00a      	b.n	802e5d0 <GetLastFcntDown+0x34>
    switch( fCntID )
 802e5ba:	2005      	movs	r0, #5
 802e5bc:	e008      	b.n	802e5d0 <GetLastFcntDown+0x34>
 802e5be:	2804      	cmp	r0, #4
 802e5c0:	d105      	bne.n	802e5ce <GetLastFcntDown+0x32>
            *lastDown = CryptoNvm->FCntList.McFCntDown[0];
 802e5c2:	4b0b      	ldr	r3, [pc, #44]	; (802e5f0 <GetLastFcntDown+0x54>)
 802e5c4:	681b      	ldr	r3, [r3, #0]
 802e5c6:	69db      	ldr	r3, [r3, #28]
 802e5c8:	600b      	str	r3, [r1, #0]
    return LORAMAC_CRYPTO_SUCCESS;
 802e5ca:	2000      	movs	r0, #0
            break;
 802e5cc:	e000      	b.n	802e5d0 <GetLastFcntDown+0x34>
    switch( fCntID )
 802e5ce:	2005      	movs	r0, #5
}
 802e5d0:	4770      	bx	lr
            *lastDown = CryptoNvm->FCntList.NFCntDown;
 802e5d2:	4b07      	ldr	r3, [pc, #28]	; (802e5f0 <GetLastFcntDown+0x54>)
 802e5d4:	681b      	ldr	r3, [r3, #0]
 802e5d6:	691b      	ldr	r3, [r3, #16]
 802e5d8:	600b      	str	r3, [r1, #0]
    return LORAMAC_CRYPTO_SUCCESS;
 802e5da:	2000      	movs	r0, #0
            break;
 802e5dc:	e7f8      	b.n	802e5d0 <GetLastFcntDown+0x34>
            *lastDown = CryptoNvm->FCntList.FCntDown;
 802e5de:	4b04      	ldr	r3, [pc, #16]	; (802e5f0 <GetLastFcntDown+0x54>)
 802e5e0:	681b      	ldr	r3, [r3, #0]
 802e5e2:	699b      	ldr	r3, [r3, #24]
 802e5e4:	600b      	str	r3, [r1, #0]
    return LORAMAC_CRYPTO_SUCCESS;
 802e5e6:	2000      	movs	r0, #0
            break;
 802e5e8:	e7f2      	b.n	802e5d0 <GetLastFcntDown+0x34>
        return LORAMAC_CRYPTO_ERROR_NPE;
 802e5ea:	2009      	movs	r0, #9
 802e5ec:	e7f0      	b.n	802e5d0 <GetLastFcntDown+0x34>
 802e5ee:	46c0      	nop			; (mov r8, r8)
 802e5f0:	2000c30c 	.word	0x2000c30c

0802e5f4 <CheckFCntDown>:
 * \param [in]    currentDown  - Current downlink counter value
 *
 * \retval                     - Status of the operation
 */
static bool CheckFCntDown( FCntIdentifier_t fCntID, uint32_t currentDown )
{
 802e5f4:	b510      	push	{r4, lr}
 802e5f6:	b082      	sub	sp, #8
 802e5f8:	000c      	movs	r4, r1
    uint32_t lastDown = 0;
 802e5fa:	2300      	movs	r3, #0
 802e5fc:	9301      	str	r3, [sp, #4]
    if( GetLastFcntDown( fCntID, &lastDown ) != LORAMAC_CRYPTO_SUCCESS )
 802e5fe:	a901      	add	r1, sp, #4
 802e600:	f7ff ffcc 	bl	802e59c <GetLastFcntDown>
 802e604:	2800      	cmp	r0, #0
 802e606:	d108      	bne.n	802e61a <CheckFCntDown+0x26>
    {
        return false;
    }
    if( ( currentDown > lastDown ) ||
 802e608:	9b01      	ldr	r3, [sp, #4]
 802e60a:	42a3      	cmp	r3, r4
 802e60c:	d308      	bcc.n	802e620 <CheckFCntDown+0x2c>
 802e60e:	3301      	adds	r3, #1
 802e610:	d001      	beq.n	802e616 <CheckFCntDown+0x22>
    {
        return true;
    }
    else
    {
        return false;
 802e612:	2000      	movs	r0, #0
 802e614:	e002      	b.n	802e61c <CheckFCntDown+0x28>
        return true;
 802e616:	3001      	adds	r0, #1
 802e618:	e000      	b.n	802e61c <CheckFCntDown+0x28>
        return false;
 802e61a:	2000      	movs	r0, #0
    }
}
 802e61c:	b002      	add	sp, #8
 802e61e:	bd10      	pop	{r4, pc}
        return true;
 802e620:	2001      	movs	r0, #1
 802e622:	e7fb      	b.n	802e61c <CheckFCntDown+0x28>

0802e624 <UpdateFCntDown>:
 *
 * \retval                     - Status of the operation
 */
static void UpdateFCntDown( FCntIdentifier_t fCntID, uint32_t currentDown )
{
    switch( fCntID )
 802e624:	2803      	cmp	r0, #3
 802e626:	d014      	beq.n	802e652 <UpdateFCntDown+0x2e>
 802e628:	d808      	bhi.n	802e63c <UpdateFCntDown+0x18>
 802e62a:	2801      	cmp	r0, #1
 802e62c:	d00c      	beq.n	802e648 <UpdateFCntDown+0x24>
 802e62e:	2802      	cmp	r0, #2
 802e630:	d10e      	bne.n	802e650 <UpdateFCntDown+0x2c>
        case N_FCNT_DOWN:
            CryptoNvm->FCntList.NFCntDown = currentDown;
            CryptoNvm->LastDownFCnt = currentDown;
            break;
        case A_FCNT_DOWN:
            CryptoNvm->FCntList.AFCntDown = currentDown;
 802e632:	4b0a      	ldr	r3, [pc, #40]	; (802e65c <UpdateFCntDown+0x38>)
 802e634:	681b      	ldr	r3, [r3, #0]
 802e636:	6159      	str	r1, [r3, #20]
            CryptoNvm->LastDownFCnt = currentDown;
 802e638:	6219      	str	r1, [r3, #32]
            break;
 802e63a:	e009      	b.n	802e650 <UpdateFCntDown+0x2c>
    switch( fCntID )
 802e63c:	2804      	cmp	r0, #4
 802e63e:	d107      	bne.n	802e650 <UpdateFCntDown+0x2c>
            CryptoNvm->FCntList.FCntDown = currentDown;
            CryptoNvm->LastDownFCnt = currentDown;
            break;
#if ( LORAMAC_MAX_MC_CTX > 0 )
        case MC_FCNT_DOWN_0:
            CryptoNvm->FCntList.McFCntDown[0] = currentDown;
 802e640:	4b06      	ldr	r3, [pc, #24]	; (802e65c <UpdateFCntDown+0x38>)
 802e642:	681b      	ldr	r3, [r3, #0]
 802e644:	61d9      	str	r1, [r3, #28]
            break;
#endif /* LORAMAC_MAX_MC_CTX > 3 */
        default:
            break;
    }
}
 802e646:	e003      	b.n	802e650 <UpdateFCntDown+0x2c>
            CryptoNvm->FCntList.NFCntDown = currentDown;
 802e648:	4b04      	ldr	r3, [pc, #16]	; (802e65c <UpdateFCntDown+0x38>)
 802e64a:	681b      	ldr	r3, [r3, #0]
 802e64c:	6119      	str	r1, [r3, #16]
            CryptoNvm->LastDownFCnt = currentDown;
 802e64e:	6219      	str	r1, [r3, #32]
}
 802e650:	4770      	bx	lr
            CryptoNvm->FCntList.FCntDown = currentDown;
 802e652:	4b02      	ldr	r3, [pc, #8]	; (802e65c <UpdateFCntDown+0x38>)
 802e654:	681b      	ldr	r3, [r3, #0]
 802e656:	6199      	str	r1, [r3, #24]
            CryptoNvm->LastDownFCnt = currentDown;
 802e658:	6219      	str	r1, [r3, #32]
            break;
 802e65a:	e7f9      	b.n	802e650 <UpdateFCntDown+0x2c>
 802e65c:	2000c30c 	.word	0x2000c30c

0802e660 <ResetFCnts>:
/*!
 * Resets the frame counters
 */
static void ResetFCnts( void )
{
    CryptoNvm->FCntList.FCntUp = 0;
 802e660:	4b0a      	ldr	r3, [pc, #40]	; (802e68c <ResetFCnts+0x2c>)
 802e662:	681b      	ldr	r3, [r3, #0]
 802e664:	2200      	movs	r2, #0
 802e666:	60da      	str	r2, [r3, #12]
    CryptoNvm->FCntList.NFCntDown = FCNT_DOWN_INITIAL_VALUE;
 802e668:	3a01      	subs	r2, #1
 802e66a:	611a      	str	r2, [r3, #16]
    CryptoNvm->FCntList.AFCntDown = FCNT_DOWN_INITIAL_VALUE;
 802e66c:	615a      	str	r2, [r3, #20]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITIAL_VALUE;
 802e66e:	619a      	str	r2, [r3, #24]
    CryptoNvm->LastDownFCnt = CryptoNvm->FCntList.FCntDown;
 802e670:	621a      	str	r2, [r3, #32]

    for( int32_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 802e672:	2200      	movs	r2, #0
 802e674:	2a00      	cmp	r2, #0
 802e676:	dd00      	ble.n	802e67a <ResetFCnts+0x1a>
    {
        CryptoNvm->FCntList.McFCntDown[i] = FCNT_DOWN_INITIAL_VALUE;
    }
}
 802e678:	4770      	bx	lr
        CryptoNvm->FCntList.McFCntDown[i] = FCNT_DOWN_INITIAL_VALUE;
 802e67a:	1d91      	adds	r1, r2, #6
 802e67c:	0089      	lsls	r1, r1, #2
 802e67e:	1859      	adds	r1, r3, r1
 802e680:	2001      	movs	r0, #1
 802e682:	4240      	negs	r0, r0
 802e684:	6048      	str	r0, [r1, #4]
    for( int32_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 802e686:	3201      	adds	r2, #1
 802e688:	e7f4      	b.n	802e674 <ResetFCnts+0x14>
 802e68a:	46c0      	nop			; (mov r8, r8)
 802e68c:	2000c30c 	.word	0x2000c30c

0802e690 <IsJoinNonce10xOk>:

static bool IsJoinNonce10xOk( uint32_t joinNonce )
{
#if( USE_10X_JOIN_NONCE_COUNTER_CHECK == 1 )
    // Check if the JoinNonce is greater as the previous one
    return ( joinNonce > CryptoNvm->JoinNonce ) ? true : false;
 802e690:	4b03      	ldr	r3, [pc, #12]	; (802e6a0 <IsJoinNonce10xOk+0x10>)
 802e692:	681b      	ldr	r3, [r3, #0]
 802e694:	689b      	ldr	r3, [r3, #8]
 802e696:	4283      	cmp	r3, r0
 802e698:	4180      	sbcs	r0, r0
 802e69a:	4240      	negs	r0, r0
#else
    // Check if the JoinNonce is different from the previous one
    return( joinNonce != CryptoNvm->JoinNonce ) ? true : false;
#endif
}
 802e69c:	4770      	bx	lr
 802e69e:	46c0      	nop			; (mov r8, r8)
 802e6a0:	2000c30c 	.word	0x2000c30c

0802e6a4 <ComputeCmacB0>:
{
 802e6a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 802e6a6:	b089      	sub	sp, #36	; 0x24
 802e6a8:	0007      	movs	r7, r0
 802e6aa:	000c      	movs	r4, r1
 802e6ac:	0015      	movs	r5, r2
 802e6ae:	001a      	movs	r2, r3
 802e6b0:	ae0e      	add	r6, sp, #56	; 0x38
 802e6b2:	7833      	ldrb	r3, [r6, #0]
    if( ( msg == 0 ) || ( cmac == 0 ) )
 802e6b4:	2800      	cmp	r0, #0
 802e6b6:	d01c      	beq.n	802e6f2 <ComputeCmacB0+0x4e>
 802e6b8:	9911      	ldr	r1, [sp, #68]	; 0x44
 802e6ba:	2900      	cmp	r1, #0
 802e6bc:	d01b      	beq.n	802e6f6 <ComputeCmacB0+0x52>
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 802e6be:	2180      	movs	r1, #128	; 0x80
 802e6c0:	0049      	lsls	r1, r1, #1
 802e6c2:	428c      	cmp	r4, r1
 802e6c4:	d819      	bhi.n	802e6fa <ComputeCmacB0+0x56>
    PrepareB0( len, keyID, isAck, dir, devAddr, fCnt, micBuff );
 802e6c6:	ae04      	add	r6, sp, #16
 802e6c8:	9602      	str	r6, [sp, #8]
 802e6ca:	9910      	ldr	r1, [sp, #64]	; 0x40
 802e6cc:	9101      	str	r1, [sp, #4]
 802e6ce:	990f      	ldr	r1, [sp, #60]	; 0x3c
 802e6d0:	9100      	str	r1, [sp, #0]
 802e6d2:	0029      	movs	r1, r5
 802e6d4:	0020      	movs	r0, r4
 802e6d6:	f7ff ff29 	bl	802e52c <PrepareB0>
    if( SecureElementComputeAesCmac( micBuff, msg, len, keyID, cmac ) != SECURE_ELEMENT_SUCCESS )
 802e6da:	9b11      	ldr	r3, [sp, #68]	; 0x44
 802e6dc:	9300      	str	r3, [sp, #0]
 802e6de:	002b      	movs	r3, r5
 802e6e0:	0022      	movs	r2, r4
 802e6e2:	0039      	movs	r1, r7
 802e6e4:	0030      	movs	r0, r6
 802e6e6:	f003 f957 	bl	8031998 <SecureElementComputeAesCmac>
 802e6ea:	2800      	cmp	r0, #0
 802e6ec:	d107      	bne.n	802e6fe <ComputeCmacB0+0x5a>
}
 802e6ee:	b009      	add	sp, #36	; 0x24
 802e6f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 802e6f2:	2009      	movs	r0, #9
 802e6f4:	e7fb      	b.n	802e6ee <ComputeCmacB0+0x4a>
 802e6f6:	2009      	movs	r0, #9
 802e6f8:	e7f9      	b.n	802e6ee <ComputeCmacB0+0x4a>
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 802e6fa:	200d      	movs	r0, #13
 802e6fc:	e7f7      	b.n	802e6ee <ComputeCmacB0+0x4a>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802e6fe:	200e      	movs	r0, #14
 802e700:	e7f5      	b.n	802e6ee <ComputeCmacB0+0x4a>

0802e702 <DeriveSessionKey10x>:
{
 802e702:	b5f0      	push	{r4, r5, r6, r7, lr}
 802e704:	b085      	sub	sp, #20
 802e706:	0006      	movs	r6, r0
 802e708:	000d      	movs	r5, r1
 802e70a:	0014      	movs	r4, r2
 802e70c:	001f      	movs	r7, r3
    uint8_t compBase[16] = { 0 };
 802e70e:	2200      	movs	r2, #0
 802e710:	9200      	str	r2, [sp, #0]
 802e712:	320c      	adds	r2, #12
 802e714:	2100      	movs	r1, #0
 802e716:	a801      	add	r0, sp, #4
 802e718:	f006 fa0d 	bl	8034b36 <memset>
    switch( keyID )
 802e71c:	2e08      	cmp	r6, #8
 802e71e:	d003      	beq.n	802e728 <DeriveSessionKey10x+0x26>
 802e720:	2e09      	cmp	r6, #9
 802e722:	d01c      	beq.n	802e75e <DeriveSessionKey10x+0x5c>
 802e724:	200a      	movs	r0, #10
 802e726:	e018      	b.n	802e75a <DeriveSessionKey10x+0x58>
            compBase[0] = 0x01;
 802e728:	2301      	movs	r3, #1
 802e72a:	466a      	mov	r2, sp
 802e72c:	7013      	strb	r3, [r2, #0]
    compBase[1] = ( uint8_t )( ( joinNonce >> 0 ) & 0xFF );
 802e72e:	466b      	mov	r3, sp
 802e730:	705d      	strb	r5, [r3, #1]
    compBase[2] = ( uint8_t )( ( joinNonce >> 8 ) & 0xFF );
 802e732:	0a2b      	lsrs	r3, r5, #8
 802e734:	466a      	mov	r2, sp
 802e736:	7093      	strb	r3, [r2, #2]
    compBase[3] = ( uint8_t )( ( joinNonce >> 16 ) & 0xFF );
 802e738:	0c2d      	lsrs	r5, r5, #16
 802e73a:	70d5      	strb	r5, [r2, #3]
    compBase[4] = ( uint8_t )( ( netID >> 0 ) & 0xFF );
 802e73c:	7114      	strb	r4, [r2, #4]
    compBase[5] = ( uint8_t )( ( netID >> 8 ) & 0xFF );
 802e73e:	0a23      	lsrs	r3, r4, #8
 802e740:	7153      	strb	r3, [r2, #5]
    compBase[6] = ( uint8_t )( ( netID >> 16 ) & 0xFF );
 802e742:	0c24      	lsrs	r4, r4, #16
 802e744:	7194      	strb	r4, [r2, #6]
    compBase[7] = ( uint8_t )( ( devNonce >> 0 ) & 0xFF );
 802e746:	71d7      	strb	r7, [r2, #7]
    compBase[8] = ( uint8_t )( ( devNonce >> 8 ) & 0xFF );
 802e748:	0a3f      	lsrs	r7, r7, #8
 802e74a:	7217      	strb	r7, [r2, #8]
    if( SecureElementDeriveAndStoreKey( compBase, NWK_KEY, keyID ) != SECURE_ELEMENT_SUCCESS )
 802e74c:	0032      	movs	r2, r6
 802e74e:	2101      	movs	r1, #1
 802e750:	4668      	mov	r0, sp
 802e752:	f003 fabb 	bl	8031ccc <SecureElementDeriveAndStoreKey>
 802e756:	2800      	cmp	r0, #0
 802e758:	d105      	bne.n	802e766 <DeriveSessionKey10x+0x64>
}
 802e75a:	b005      	add	sp, #20
 802e75c:	bdf0      	pop	{r4, r5, r6, r7, pc}
            compBase[0] = 0x02;
 802e75e:	2302      	movs	r3, #2
 802e760:	466a      	mov	r2, sp
 802e762:	7013      	strb	r3, [r2, #0]
            break;
 802e764:	e7e3      	b.n	802e72e <DeriveSessionKey10x+0x2c>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802e766:	200e      	movs	r0, #14
 802e768:	e7f7      	b.n	802e75a <DeriveSessionKey10x+0x58>

0802e76a <PayloadEncrypt>:
{
 802e76a:	b5f0      	push	{r4, r5, r6, r7, lr}
 802e76c:	46d6      	mov	lr, sl
 802e76e:	464f      	mov	r7, r9
 802e770:	4646      	mov	r6, r8
 802e772:	b5c0      	push	{r6, r7, lr}
 802e774:	b088      	sub	sp, #32
 802e776:	0005      	movs	r5, r0
 802e778:	000c      	movs	r4, r1
 802e77a:	4690      	mov	r8, r2
 802e77c:	001f      	movs	r7, r3
 802e77e:	ab10      	add	r3, sp, #64	; 0x40
 802e780:	781b      	ldrb	r3, [r3, #0]
 802e782:	469a      	mov	sl, r3
 802e784:	9e11      	ldr	r6, [sp, #68]	; 0x44
    if( buffer == 0 )
 802e786:	2800      	cmp	r0, #0
 802e788:	d055      	beq.n	802e836 <PayloadEncrypt+0xcc>
    uint8_t sBlock[16] = { 0 };
 802e78a:	2300      	movs	r3, #0
 802e78c:	4699      	mov	r9, r3
 802e78e:	9304      	str	r3, [sp, #16]
 802e790:	220c      	movs	r2, #12
 802e792:	2100      	movs	r1, #0
 802e794:	a805      	add	r0, sp, #20
 802e796:	f006 f9ce 	bl	8034b36 <memset>
    uint8_t aBlock[16] = { 0 };
 802e79a:	464b      	mov	r3, r9
 802e79c:	9300      	str	r3, [sp, #0]
 802e79e:	220c      	movs	r2, #12
 802e7a0:	2100      	movs	r1, #0
 802e7a2:	a801      	add	r0, sp, #4
 802e7a4:	f006 f9c7 	bl	8034b36 <memset>
    aBlock[0] = 0x01;
 802e7a8:	2301      	movs	r3, #1
 802e7aa:	466a      	mov	r2, sp
 802e7ac:	7013      	strb	r3, [r2, #0]
    aBlock[5] = dir;
 802e7ae:	466b      	mov	r3, sp
 802e7b0:	4652      	mov	r2, sl
 802e7b2:	715a      	strb	r2, [r3, #5]
    aBlock[6] = address & 0xFF;
 802e7b4:	719f      	strb	r7, [r3, #6]
    aBlock[7] = ( address >> 8 ) & 0xFF;
 802e7b6:	0a3b      	lsrs	r3, r7, #8
 802e7b8:	466a      	mov	r2, sp
 802e7ba:	71d3      	strb	r3, [r2, #7]
    aBlock[8] = ( address >> 16 ) & 0xFF;
 802e7bc:	0c3b      	lsrs	r3, r7, #16
 802e7be:	7213      	strb	r3, [r2, #8]
    aBlock[9] = ( address >> 24 ) & 0xFF;
 802e7c0:	0e3f      	lsrs	r7, r7, #24
 802e7c2:	7257      	strb	r7, [r2, #9]
    aBlock[10] = frameCounter & 0xFF;
 802e7c4:	7296      	strb	r6, [r2, #10]
    aBlock[11] = ( frameCounter >> 8 ) & 0xFF;
 802e7c6:	0a33      	lsrs	r3, r6, #8
 802e7c8:	72d3      	strb	r3, [r2, #11]
    aBlock[12] = ( frameCounter >> 16 ) & 0xFF;
 802e7ca:	0c33      	lsrs	r3, r6, #16
 802e7cc:	7313      	strb	r3, [r2, #12]
    aBlock[13] = ( frameCounter >> 24 ) & 0xFF;
 802e7ce:	0e36      	lsrs	r6, r6, #24
 802e7d0:	7356      	strb	r6, [r2, #13]
    uint16_t ctr = 1;
 802e7d2:	2301      	movs	r3, #1
 802e7d4:	4699      	mov	r9, r3
    uint8_t bufferIndex = 0;
 802e7d6:	2600      	movs	r6, #0
    while( size > 0 )
 802e7d8:	e014      	b.n	802e804 <PayloadEncrypt+0x9a>
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 802e7da:	b21b      	sxth	r3, r3
 802e7dc:	429a      	cmp	r2, r3
 802e7de:	da0d      	bge.n	802e7fc <PayloadEncrypt+0x92>
            buffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i];
 802e7e0:	18b1      	adds	r1, r6, r2
 802e7e2:	5c6b      	ldrb	r3, [r5, r1]
 802e7e4:	af04      	add	r7, sp, #16
 802e7e6:	5cba      	ldrb	r2, [r7, r2]
 802e7e8:	4053      	eors	r3, r2
 802e7ea:	546b      	strb	r3, [r5, r1]
        for( uint8_t i = 0; i < ( ( size > 16 ) ? 16 : size ); i++ )
 802e7ec:	3001      	adds	r0, #1
 802e7ee:	b2c0      	uxtb	r0, r0
 802e7f0:	0002      	movs	r2, r0
 802e7f2:	1c23      	adds	r3, r4, #0
 802e7f4:	2c10      	cmp	r4, #16
 802e7f6:	ddf0      	ble.n	802e7da <PayloadEncrypt+0x70>
 802e7f8:	2310      	movs	r3, #16
 802e7fa:	e7ee      	b.n	802e7da <PayloadEncrypt+0x70>
        size -= 16;
 802e7fc:	3c10      	subs	r4, #16
 802e7fe:	b224      	sxth	r4, r4
        bufferIndex += 16;
 802e800:	3610      	adds	r6, #16
 802e802:	b2f6      	uxtb	r6, r6
    while( size > 0 )
 802e804:	2c00      	cmp	r4, #0
 802e806:	dd0f      	ble.n	802e828 <PayloadEncrypt+0xbe>
        aBlock[15] = ctr & 0xFF;
 802e808:	466b      	mov	r3, sp
 802e80a:	464a      	mov	r2, r9
 802e80c:	73da      	strb	r2, [r3, #15]
        ctr++;
 802e80e:	1c57      	adds	r7, r2, #1
 802e810:	b2bb      	uxth	r3, r7
 802e812:	4699      	mov	r9, r3
        if( SecureElementAesEncrypt( aBlock, 16, keyID, sBlock ) != SECURE_ELEMENT_SUCCESS )
 802e814:	ab04      	add	r3, sp, #16
 802e816:	4642      	mov	r2, r8
 802e818:	2110      	movs	r1, #16
 802e81a:	4668      	mov	r0, sp
 802e81c:	f003 f90e 	bl	8031a3c <SecureElementAesEncrypt>
 802e820:	2800      	cmp	r0, #0
 802e822:	d0e5      	beq.n	802e7f0 <PayloadEncrypt+0x86>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802e824:	200e      	movs	r0, #14
 802e826:	e000      	b.n	802e82a <PayloadEncrypt+0xc0>
    return LORAMAC_CRYPTO_SUCCESS;
 802e828:	2000      	movs	r0, #0
}
 802e82a:	b008      	add	sp, #32
 802e82c:	bce0      	pop	{r5, r6, r7}
 802e82e:	46ba      	mov	sl, r7
 802e830:	46b1      	mov	r9, r6
 802e832:	46a8      	mov	r8, r5
 802e834:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_CRYPTO_ERROR_NPE;
 802e836:	2009      	movs	r0, #9
 802e838:	e7f7      	b.n	802e82a <PayloadEncrypt+0xc0>

0802e83a <VerifyCmacB0>:
{
 802e83a:	b5f0      	push	{r4, r5, r6, r7, lr}
 802e83c:	46ce      	mov	lr, r9
 802e83e:	b500      	push	{lr}
 802e840:	b0ca      	sub	sp, #296	; 0x128
 802e842:	0005      	movs	r5, r0
 802e844:	000c      	movs	r4, r1
 802e846:	0016      	movs	r6, r2
 802e848:	9305      	str	r3, [sp, #20]
 802e84a:	ab50      	add	r3, sp, #320	; 0x140
 802e84c:	7819      	ldrb	r1, [r3, #0]
 802e84e:	4689      	mov	r9, r1
    if( msg == 0 )
 802e850:	2800      	cmp	r0, #0
 802e852:	d027      	beq.n	802e8a4 <VerifyCmacB0+0x6a>
    if( len > CRYPTO_MAXMESSAGE_SIZE )
 802e854:	2380      	movs	r3, #128	; 0x80
 802e856:	005b      	lsls	r3, r3, #1
 802e858:	429c      	cmp	r4, r3
 802e85a:	d825      	bhi.n	802e8a8 <VerifyCmacB0+0x6e>
    memset1( micBuff, 0, CRYPTO_BUFFER_SIZE );
 802e85c:	2288      	movs	r2, #136	; 0x88
 802e85e:	af06      	add	r7, sp, #24
 802e860:	0052      	lsls	r2, r2, #1
 802e862:	2100      	movs	r1, #0
 802e864:	0038      	movs	r0, r7
 802e866:	f003 fc64 	bl	8032132 <memset1>
    PrepareB0( len, keyID, isAck, dir, devAddr, fCnt, micBuff );
 802e86a:	9702      	str	r7, [sp, #8]
 802e86c:	9952      	ldr	r1, [sp, #328]	; 0x148
 802e86e:	9101      	str	r1, [sp, #4]
 802e870:	9951      	ldr	r1, [sp, #324]	; 0x144
 802e872:	9100      	str	r1, [sp, #0]
 802e874:	464b      	mov	r3, r9
 802e876:	9a05      	ldr	r2, [sp, #20]
 802e878:	0031      	movs	r1, r6
 802e87a:	0020      	movs	r0, r4
 802e87c:	f7ff fe56 	bl	802e52c <PrepareB0>
    memcpy1( ( micBuff + MIC_BLOCK_BX_SIZE ), msg, len );
 802e880:	0022      	movs	r2, r4
 802e882:	0029      	movs	r1, r5
 802e884:	a80a      	add	r0, sp, #40	; 0x28
 802e886:	f003 fc3c 	bl	8032102 <memcpy1>
    retval = SecureElementVerifyAesCmac( micBuff, ( len + MIC_BLOCK_BX_SIZE ), expectedCmac, keyID );
 802e88a:	0021      	movs	r1, r4
 802e88c:	3110      	adds	r1, #16
 802e88e:	0033      	movs	r3, r6
 802e890:	9a53      	ldr	r2, [sp, #332]	; 0x14c
 802e892:	0038      	movs	r0, r7
 802e894:	f003 f88c 	bl	80319b0 <SecureElementVerifyAesCmac>
    if( retval == SECURE_ELEMENT_SUCCESS )
 802e898:	2800      	cmp	r0, #0
 802e89a:	d006      	beq.n	802e8aa <VerifyCmacB0+0x70>
    else if( retval == SECURE_ELEMENT_FAIL_CMAC )
 802e89c:	2801      	cmp	r0, #1
 802e89e:	d004      	beq.n	802e8aa <VerifyCmacB0+0x70>
    return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802e8a0:	200e      	movs	r0, #14
 802e8a2:	e002      	b.n	802e8aa <VerifyCmacB0+0x70>
        return LORAMAC_CRYPTO_ERROR_NPE;
 802e8a4:	2009      	movs	r0, #9
 802e8a6:	e000      	b.n	802e8aa <VerifyCmacB0+0x70>
        return LORAMAC_CRYPTO_ERROR_BUF_SIZE;
 802e8a8:	200d      	movs	r0, #13
}
 802e8aa:	b04a      	add	sp, #296	; 0x128
 802e8ac:	bc80      	pop	{r7}
 802e8ae:	46b9      	mov	r9, r7
 802e8b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

0802e8b4 <LoRaMacCryptoInit>:

/*
 *  API functions
 */
LoRaMacCryptoStatus_t LoRaMacCryptoInit( LoRaMacCryptoNvmData_t* nvm )
{
 802e8b4:	b510      	push	{r4, lr}
    if( nvm == NULL )
 802e8b6:	2800      	cmp	r0, #0
 802e8b8:	d010      	beq.n	802e8dc <LoRaMacCryptoInit+0x28>
    {
        return LORAMAC_CRYPTO_FAIL_PARAM;
    }

    // Assign non volatile context
    CryptoNvm = nvm;
 802e8ba:	4c09      	ldr	r4, [pc, #36]	; (802e8e0 <LoRaMacCryptoInit+0x2c>)
 802e8bc:	6020      	str	r0, [r4, #0]

    // Initialize with default
    memset1( ( uint8_t* )CryptoNvm, 0, sizeof( LoRaMacCryptoNvmData_t ) );
 802e8be:	2228      	movs	r2, #40	; 0x28
 802e8c0:	2100      	movs	r1, #0
 802e8c2:	f003 fc36 	bl	8032132 <memset1>

    // Set default LoRaWAN version
    CryptoNvm->LrWanVersion.Fields.Major = 1;
 802e8c6:	6823      	ldr	r3, [r4, #0]
 802e8c8:	2201      	movs	r2, #1
 802e8ca:	70da      	strb	r2, [r3, #3]
    CryptoNvm->LrWanVersion.Fields.Minor = 1;
 802e8cc:	709a      	strb	r2, [r3, #2]
    CryptoNvm->LrWanVersion.Fields.Patch = 1;
 802e8ce:	705a      	strb	r2, [r3, #1]
    CryptoNvm->LrWanVersion.Fields.Revision = 0;
 802e8d0:	2200      	movs	r2, #0
 802e8d2:	701a      	strb	r2, [r3, #0]

    // Reset frame counters
    ResetFCnts( );
 802e8d4:	f7ff fec4 	bl	802e660 <ResetFCnts>

    return LORAMAC_CRYPTO_SUCCESS;
 802e8d8:	2000      	movs	r0, #0
}
 802e8da:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_FAIL_PARAM;
 802e8dc:	2008      	movs	r0, #8
 802e8de:	e7fc      	b.n	802e8da <LoRaMacCryptoInit+0x26>
 802e8e0:	2000c30c 	.word	0x2000c30c

0802e8e4 <LoRaMacCryptoSetLrWanVersion>:

LoRaMacCryptoStatus_t LoRaMacCryptoSetLrWanVersion( Version_t version )
{
    CryptoNvm->LrWanVersion = version;
 802e8e4:	4b02      	ldr	r3, [pc, #8]	; (802e8f0 <LoRaMacCryptoSetLrWanVersion+0xc>)
 802e8e6:	681b      	ldr	r3, [r3, #0]
 802e8e8:	6018      	str	r0, [r3, #0]
    return LORAMAC_CRYPTO_SUCCESS;
}
 802e8ea:	2000      	movs	r0, #0
 802e8ec:	4770      	bx	lr
 802e8ee:	46c0      	nop			; (mov r8, r8)
 802e8f0:	2000c30c 	.word	0x2000c30c

0802e8f4 <LoRaMacCryptoGetFCntUp>:

LoRaMacCryptoStatus_t LoRaMacCryptoGetFCntUp( uint32_t* currentUp )
{
    if( currentUp == NULL )
 802e8f4:	2800      	cmp	r0, #0
 802e8f6:	d006      	beq.n	802e906 <LoRaMacCryptoGetFCntUp+0x12>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }

    *currentUp = CryptoNvm->FCntList.FCntUp + 1;
 802e8f8:	4b04      	ldr	r3, [pc, #16]	; (802e90c <LoRaMacCryptoGetFCntUp+0x18>)
 802e8fa:	681b      	ldr	r3, [r3, #0]
 802e8fc:	68db      	ldr	r3, [r3, #12]
 802e8fe:	3301      	adds	r3, #1
 802e900:	6003      	str	r3, [r0, #0]

    return LORAMAC_CRYPTO_SUCCESS;
 802e902:	2000      	movs	r0, #0
}
 802e904:	4770      	bx	lr
        return LORAMAC_CRYPTO_ERROR_NPE;
 802e906:	2009      	movs	r0, #9
 802e908:	e7fc      	b.n	802e904 <LoRaMacCryptoGetFCntUp+0x10>
 802e90a:	46c0      	nop			; (mov r8, r8)
 802e90c:	2000c30c 	.word	0x2000c30c

0802e910 <LoRaMacCryptoGetFCntDown>:

    return LORAMAC_CRYPTO_SUCCESS;
}
#elif (defined( LORAMAC_VERSION ) && (( LORAMAC_VERSION == 0x01000400 ) || ( LORAMAC_VERSION == 0x01010100 )))
LoRaMacCryptoStatus_t LoRaMacCryptoGetFCntDown( FCntIdentifier_t fCntID, uint32_t frameFcnt, uint32_t* currentDown )
{
 802e910:	b530      	push	{r4, r5, lr}
 802e912:	b083      	sub	sp, #12
 802e914:	000d      	movs	r5, r1
 802e916:	0014      	movs	r4, r2
    uint32_t lastDown = 0;
 802e918:	2300      	movs	r3, #0
 802e91a:	9301      	str	r3, [sp, #4]
    int32_t fCntDiff = 0;
    LoRaMacCryptoStatus_t cryptoStatus = LORAMAC_CRYPTO_ERROR;

    if( currentDown == NULL )
 802e91c:	2a00      	cmp	r2, #0
 802e91e:	d020      	beq.n	802e962 <LoRaMacCryptoGetFCntDown+0x52>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }

    cryptoStatus = GetLastFcntDown( fCntID, &lastDown );
 802e920:	a901      	add	r1, sp, #4
 802e922:	f7ff fe3b 	bl	802e59c <GetLastFcntDown>
    if( cryptoStatus != LORAMAC_CRYPTO_SUCCESS )
 802e926:	2800      	cmp	r0, #0
 802e928:	d109      	bne.n	802e93e <LoRaMacCryptoGetFCntDown+0x2e>
    {
        return cryptoStatus;
    }

    // For LoRaWAN 1.0.X only, allow downlink frames of 0
    if( lastDown == FCNT_DOWN_INITIAL_VALUE )
 802e92a:	9b01      	ldr	r3, [sp, #4]
 802e92c:	1c5a      	adds	r2, r3, #1
 802e92e:	d008      	beq.n	802e942 <LoRaMacCryptoGetFCntDown+0x32>
        *currentDown = frameFcnt;
    }
    else
    {
        // Add difference, consider roll-over
        fCntDiff = ( int32_t )( ( int64_t )frameFcnt - ( int64_t )( lastDown & 0x0000FFFF ) );
 802e930:	041a      	lsls	r2, r3, #16
 802e932:	0c12      	lsrs	r2, r2, #16
 802e934:	1aaa      	subs	r2, r5, r2

        if( fCntDiff > 0 )
 802e936:	2a00      	cmp	r2, #0
 802e938:	dd05      	ble.n	802e946 <LoRaMacCryptoGetFCntDown+0x36>
        {  // Positive difference
            *currentDown = lastDown + fCntDiff;
 802e93a:	189b      	adds	r3, r3, r2
 802e93c:	6023      	str	r3, [r4, #0]
            *currentDown = ( lastDown & 0xFFFF0000 ) + 0x10000 + frameFcnt;
        }
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 802e93e:	b003      	add	sp, #12
 802e940:	bd30      	pop	{r4, r5, pc}
        *currentDown = frameFcnt;
 802e942:	6025      	str	r5, [r4, #0]
 802e944:	e7fb      	b.n	802e93e <LoRaMacCryptoGetFCntDown+0x2e>
        else if( fCntDiff == 0 )
 802e946:	2a00      	cmp	r2, #0
 802e948:	d008      	beq.n	802e95c <LoRaMacCryptoGetFCntDown+0x4c>
            *currentDown = ( lastDown & 0xFFFF0000 ) + 0x10000 + frameFcnt;
 802e94a:	0c1b      	lsrs	r3, r3, #16
 802e94c:	041b      	lsls	r3, r3, #16
 802e94e:	195d      	adds	r5, r3, r5
 802e950:	2380      	movs	r3, #128	; 0x80
 802e952:	025b      	lsls	r3, r3, #9
 802e954:	469c      	mov	ip, r3
 802e956:	4465      	add	r5, ip
 802e958:	6025      	str	r5, [r4, #0]
 802e95a:	e7f0      	b.n	802e93e <LoRaMacCryptoGetFCntDown+0x2e>
            *currentDown = lastDown;
 802e95c:	6023      	str	r3, [r4, #0]
            return LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED;
 802e95e:	2007      	movs	r0, #7
 802e960:	e7ed      	b.n	802e93e <LoRaMacCryptoGetFCntDown+0x2e>
        return LORAMAC_CRYPTO_ERROR_NPE;
 802e962:	2009      	movs	r0, #9
 802e964:	e7eb      	b.n	802e93e <LoRaMacCryptoGetFCntDown+0x2e>
	...

0802e968 <LoRaMacCryptoSetMulticastReference>:
    return LORAMAC_CRYPTO_ERROR;
#endif /* LORAMAC_VERSION */
}

LoRaMacCryptoStatus_t LoRaMacCryptoSetMulticastReference( MulticastCtx_t* multicastList )
{
 802e968:	b510      	push	{r4, lr}
    if( multicastList == NULL )
 802e96a:	2800      	cmp	r0, #0
 802e96c:	d101      	bne.n	802e972 <LoRaMacCryptoSetMulticastReference+0xa>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
 802e96e:	2009      	movs	r0, #9
    {
        multicastList[i].DownLinkCounter = &CryptoNvm->FCntList.McFCntDown[i];
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 802e970:	bd10      	pop	{r4, pc}
    for( int32_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 802e972:	2300      	movs	r3, #0
 802e974:	2b00      	cmp	r3, #0
 802e976:	dd01      	ble.n	802e97c <LoRaMacCryptoSetMulticastReference+0x14>
    return LORAMAC_CRYPTO_SUCCESS;
 802e978:	2000      	movs	r0, #0
 802e97a:	e7f9      	b.n	802e970 <LoRaMacCryptoSetMulticastReference+0x8>
        multicastList[i].DownLinkCounter = &CryptoNvm->FCntList.McFCntDown[i];
 802e97c:	4a06      	ldr	r2, [pc, #24]	; (802e998 <LoRaMacCryptoSetMulticastReference+0x30>)
 802e97e:	6811      	ldr	r1, [r2, #0]
 802e980:	005a      	lsls	r2, r3, #1
 802e982:	18d2      	adds	r2, r2, r3
 802e984:	0112      	lsls	r2, r2, #4
 802e986:	1882      	adds	r2, r0, r2
 802e988:	1d9c      	adds	r4, r3, #6
 802e98a:	00a4      	lsls	r4, r4, #2
 802e98c:	1909      	adds	r1, r1, r4
 802e98e:	3104      	adds	r1, #4
 802e990:	6251      	str	r1, [r2, #36]	; 0x24
    for( int32_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
 802e992:	3301      	adds	r3, #1
 802e994:	e7ee      	b.n	802e974 <LoRaMacCryptoSetMulticastReference+0xc>
 802e996:	46c0      	nop			; (mov r8, r8)
 802e998:	2000c30c 	.word	0x2000c30c

0802e99c <LoRaMacCryptoPrepareJoinRequest>:
    }
    return LORAMAC_CRYPTO_SUCCESS;
}

LoRaMacCryptoStatus_t LoRaMacCryptoPrepareJoinRequest( LoRaMacMessageJoinRequest_t* macMsg )
{
 802e99c:	b510      	push	{r4, lr}
 802e99e:	b082      	sub	sp, #8
 802e9a0:	1e04      	subs	r4, r0, #0
    if( macMsg == 0 )
 802e9a2:	d01b      	beq.n	802e9dc <LoRaMacCryptoPrepareJoinRequest+0x40>
#if ( USE_RANDOM_DEV_NONCE == 1 )
    uint32_t devNonce = 0;
    SecureElementRandomNumber( &devNonce );
    CryptoNvm->DevNonce = devNonce;
#else
    CryptoNvm->DevNonce++;
 802e9a4:	4b11      	ldr	r3, [pc, #68]	; (802e9ec <LoRaMacCryptoPrepareJoinRequest+0x50>)
 802e9a6:	681a      	ldr	r2, [r3, #0]
 802e9a8:	8893      	ldrh	r3, [r2, #4]
 802e9aa:	3301      	adds	r3, #1
 802e9ac:	b29b      	uxth	r3, r3
 802e9ae:	8093      	strh	r3, [r2, #4]
#endif /* USE_RANDOM_DEV_NONCE */
    macMsg->DevNonce = CryptoNvm->DevNonce;
 802e9b0:	82c3      	strh	r3, [r0, #22]
        return LORAMAC_CRYPTO_ERROR;
    }
#endif /* LORAMAC_VERSION */

    // Serialize message
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 802e9b2:	f000 fa46 	bl	802ee42 <LoRaMacSerializerJoinRequest>
 802e9b6:	2800      	cmp	r0, #0
 802e9b8:	d112      	bne.n	802e9e0 <LoRaMacCryptoPrepareJoinRequest+0x44>
    {
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
    }

    // Compute mic
    if( SecureElementComputeAesCmac( NULL, macMsg->Buffer, ( LORAMAC_JOIN_REQ_MSG_SIZE - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, &macMsg->MIC ) != SECURE_ELEMENT_SUCCESS )
 802e9ba:	0023      	movs	r3, r4
 802e9bc:	3318      	adds	r3, #24
 802e9be:	9300      	str	r3, [sp, #0]
 802e9c0:	2301      	movs	r3, #1
 802e9c2:	2213      	movs	r2, #19
 802e9c4:	6821      	ldr	r1, [r4, #0]
 802e9c6:	f002 ffe7 	bl	8031998 <SecureElementComputeAesCmac>
 802e9ca:	2800      	cmp	r0, #0
 802e9cc:	d10b      	bne.n	802e9e6 <LoRaMacCryptoPrepareJoinRequest+0x4a>
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    // Reserialize message to add the MIC
    if( LoRaMacSerializerJoinRequest( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 802e9ce:	0020      	movs	r0, r4
 802e9d0:	f000 fa37 	bl	802ee42 <LoRaMacSerializerJoinRequest>
 802e9d4:	2800      	cmp	r0, #0
 802e9d6:	d004      	beq.n	802e9e2 <LoRaMacCryptoPrepareJoinRequest+0x46>
    {
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 802e9d8:	2010      	movs	r0, #16
 802e9da:	e002      	b.n	802e9e2 <LoRaMacCryptoPrepareJoinRequest+0x46>
        return LORAMAC_CRYPTO_ERROR_NPE;
 802e9dc:	2009      	movs	r0, #9
 802e9de:	e000      	b.n	802e9e2 <LoRaMacCryptoPrepareJoinRequest+0x46>
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 802e9e0:	2010      	movs	r0, #16
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 802e9e2:	b002      	add	sp, #8
 802e9e4:	bd10      	pop	{r4, pc}
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802e9e6:	200e      	movs	r0, #14
 802e9e8:	e7fb      	b.n	802e9e2 <LoRaMacCryptoPrepareJoinRequest+0x46>
 802e9ea:	46c0      	nop			; (mov r8, r8)
 802e9ec:	2000c30c 	.word	0x2000c30c

0802e9f0 <LoRaMacCryptoSecureMessage>:

    return LORAMAC_CRYPTO_SUCCESS;
}

LoRaMacCryptoStatus_t LoRaMacCryptoSecureMessage( uint32_t fCntUp, uint8_t txDr, uint8_t txCh, LoRaMacMessageData_t* macMsg )
{
 802e9f0:	b530      	push	{r4, r5, lr}
 802e9f2:	b085      	sub	sp, #20
 802e9f4:	0005      	movs	r5, r0
 802e9f6:	1e1c      	subs	r4, r3, #0
    LoRaMacCryptoStatus_t retval = LORAMAC_CRYPTO_ERROR;
    KeyIdentifier_t payloadDecryptionKeyID = APP_S_KEY;

    if( macMsg == NULL )
 802e9f8:	d037      	beq.n	802ea6a <LoRaMacCryptoSecureMessage+0x7a>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }

    if( fCntUp < CryptoNvm->FCntList.FCntUp )
 802e9fa:	4b20      	ldr	r3, [pc, #128]	; (802ea7c <LoRaMacCryptoSecureMessage+0x8c>)
 802e9fc:	681b      	ldr	r3, [r3, #0]
 802e9fe:	68db      	ldr	r3, [r3, #12]
 802ea00:	4283      	cmp	r3, r0
 802ea02:	d834      	bhi.n	802ea6e <LoRaMacCryptoSecureMessage+0x7e>
    {
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
    }

    // Encrypt payload
    if( macMsg->FPort == 0 )
 802ea04:	2220      	movs	r2, #32
 802ea06:	5ca2      	ldrb	r2, [r4, r2]
 802ea08:	2a00      	cmp	r2, #0
 802ea0a:	d02c      	beq.n	802ea66 <LoRaMacCryptoSecureMessage+0x76>
    KeyIdentifier_t payloadDecryptionKeyID = APP_S_KEY;
 802ea0c:	2209      	movs	r2, #9
#else
        payloadDecryptionKeyID = NWK_S_KEY;
#endif /* LORAMAC_VERSION */
    }

    if( fCntUp > CryptoNvm->FCntList.FCntUp )
 802ea0e:	42ab      	cmp	r3, r5
 802ea10:	d20a      	bcs.n	802ea28 <LoRaMacCryptoSecureMessage+0x38>
    {
        retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, macMsg->FHDR.DevAddr, UPLINK, fCntUp );
 802ea12:	2328      	movs	r3, #40	; 0x28
 802ea14:	5ce1      	ldrb	r1, [r4, r3]
 802ea16:	9501      	str	r5, [sp, #4]
 802ea18:	2300      	movs	r3, #0
 802ea1a:	9300      	str	r3, [sp, #0]
 802ea1c:	68a3      	ldr	r3, [r4, #8]
 802ea1e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802ea20:	f7ff fea3 	bl	802e76a <PayloadEncrypt>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 802ea24:	2800      	cmp	r0, #0
 802ea26:	d125      	bne.n	802ea74 <LoRaMacCryptoSecureMessage+0x84>
        }
#endif /* LORAMAC_VERSION */
    }

    // Serialize message
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 802ea28:	0020      	movs	r0, r4
 802ea2a:	f000 fa40 	bl	802eeae <LoRaMacSerializerData>
 802ea2e:	2800      	cmp	r0, #0
 802ea30:	d11f      	bne.n	802ea72 <LoRaMacCryptoSecureMessage+0x82>
#else
        payloadDecryptionKeyID = NWK_S_KEY;
#endif /* LORAMAC_VERSION */
        // MIC = cmacF[0..3]
        // The IsAck parameter is every time false since the ConfFCnt field is not used in legacy mode.
        retval = ComputeCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), payloadDecryptionKeyID, false, UPLINK, macMsg->FHDR.DevAddr, fCntUp, &macMsg->MIC );
 802ea32:	7921      	ldrb	r1, [r4, #4]
 802ea34:	3904      	subs	r1, #4
 802ea36:	b289      	uxth	r1, r1
 802ea38:	0023      	movs	r3, r4
 802ea3a:	332c      	adds	r3, #44	; 0x2c
 802ea3c:	9303      	str	r3, [sp, #12]
 802ea3e:	9502      	str	r5, [sp, #8]
 802ea40:	68a3      	ldr	r3, [r4, #8]
 802ea42:	9301      	str	r3, [sp, #4]
 802ea44:	2300      	movs	r3, #0
 802ea46:	9300      	str	r3, [sp, #0]
 802ea48:	2208      	movs	r2, #8
 802ea4a:	6820      	ldr	r0, [r4, #0]
 802ea4c:	f7ff fe2a 	bl	802e6a4 <ComputeCmacB0>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 802ea50:	2800      	cmp	r0, #0
 802ea52:	d10f      	bne.n	802ea74 <LoRaMacCryptoSecureMessage+0x84>
            return retval;
        }
    }

    // Re-serialize message to add the MIC
    if( LoRaMacSerializerData( macMsg ) != LORAMAC_SERIALIZER_SUCCESS )
 802ea54:	0020      	movs	r0, r4
 802ea56:	f000 fa2a 	bl	802eeae <LoRaMacSerializerData>
 802ea5a:	2800      	cmp	r0, #0
 802ea5c:	d10c      	bne.n	802ea78 <LoRaMacCryptoSecureMessage+0x88>
    {
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
    }

    CryptoNvm->FCntList.FCntUp = fCntUp;
 802ea5e:	4b07      	ldr	r3, [pc, #28]	; (802ea7c <LoRaMacCryptoSecureMessage+0x8c>)
 802ea60:	681b      	ldr	r3, [r3, #0]
 802ea62:	60dd      	str	r5, [r3, #12]

    return LORAMAC_CRYPTO_SUCCESS;
 802ea64:	e006      	b.n	802ea74 <LoRaMacCryptoSecureMessage+0x84>
        payloadDecryptionKeyID = NWK_S_KEY;
 802ea66:	2208      	movs	r2, #8
 802ea68:	e7d1      	b.n	802ea0e <LoRaMacCryptoSecureMessage+0x1e>
        return LORAMAC_CRYPTO_ERROR_NPE;
 802ea6a:	2009      	movs	r0, #9
 802ea6c:	e002      	b.n	802ea74 <LoRaMacCryptoSecureMessage+0x84>
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 802ea6e:	2006      	movs	r0, #6
 802ea70:	e000      	b.n	802ea74 <LoRaMacCryptoSecureMessage+0x84>
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 802ea72:	2010      	movs	r0, #16
}
 802ea74:	b005      	add	sp, #20
 802ea76:	bd30      	pop	{r4, r5, pc}
        return LORAMAC_CRYPTO_ERROR_SERIALIZER;
 802ea78:	2010      	movs	r0, #16
 802ea7a:	e7fb      	b.n	802ea74 <LoRaMacCryptoSecureMessage+0x84>
 802ea7c:	2000c30c 	.word	0x2000c30c

0802ea80 <LoRaMacCryptoUnsecureMessage>:

LoRaMacCryptoStatus_t LoRaMacCryptoUnsecureMessage( AddressIdentifier_t addrID, uint32_t address, FCntIdentifier_t fCntID, uint32_t fCntDown, LoRaMacMessageData_t* macMsg )
{
 802ea80:	b5f0      	push	{r4, r5, r6, r7, lr}
 802ea82:	46ce      	mov	lr, r9
 802ea84:	b500      	push	{lr}
 802ea86:	b088      	sub	sp, #32
 802ea88:	0005      	movs	r5, r0
 802ea8a:	9105      	str	r1, [sp, #20]
 802ea8c:	0017      	movs	r7, r2
 802ea8e:	001c      	movs	r4, r3
 802ea90:	9e0e      	ldr	r6, [sp, #56]	; 0x38
    if( macMsg == 0 )
 802ea92:	2e00      	cmp	r6, #0
 802ea94:	d047      	beq.n	802eb26 <LoRaMacCryptoUnsecureMessage+0xa6>
    {
        return LORAMAC_CRYPTO_ERROR_NPE;
    }

    if( CheckFCntDown( fCntID, fCntDown ) == false )
 802ea96:	0019      	movs	r1, r3
 802ea98:	0010      	movs	r0, r2
 802ea9a:	f7ff fdab 	bl	802e5f4 <CheckFCntDown>
 802ea9e:	2800      	cmp	r0, #0
 802eaa0:	d043      	beq.n	802eb2a <LoRaMacCryptoUnsecureMessage+0xaa>
    KeyIdentifier_t micComputationKeyID = NWK_S_KEY;
#endif /* LORAMAC_VERSION */
    KeyAddr_t* curItem;

    // Parse the message
    if( LoRaMacParserData( macMsg ) != LORAMAC_PARSER_SUCCESS )
 802eaa2:	0030      	movs	r0, r6
 802eaa4:	f000 f96d 	bl	802ed82 <LoRaMacParserData>
 802eaa8:	2800      	cmp	r0, #0
 802eaaa:	d144      	bne.n	802eb36 <LoRaMacCryptoUnsecureMessage+0xb6>
    {
        return LORAMAC_CRYPTO_ERROR_PARSER;
    }

    // Determine current security context
    retval = GetKeyAddrItem( addrID, &curItem );
 802eaac:	a907      	add	r1, sp, #28
 802eaae:	0028      	movs	r0, r5
 802eab0:	f7ff fd5e 	bl	802e570 <GetKeyAddrItem>
 802eab4:	1e05      	subs	r5, r0, #0
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 802eab6:	d139      	bne.n	802eb2c <LoRaMacCryptoUnsecureMessage+0xac>
    {
        return retval;
    }

    payloadDecryptionKeyID = curItem->AppSkey;
 802eab8:	9b07      	ldr	r3, [sp, #28]
 802eaba:	785a      	ldrb	r2, [r3, #1]
 802eabc:	4691      	mov	r9, r2
    micComputationKeyID = curItem->NwkSkey;
 802eabe:	789a      	ldrb	r2, [r3, #2]

    // Check if it is our address
    if( address != macMsg->FHDR.DevAddr )
 802eac0:	68b0      	ldr	r0, [r6, #8]
 802eac2:	9b05      	ldr	r3, [sp, #20]
 802eac4:	4298      	cmp	r0, r3
 802eac6:	d138      	bne.n	802eb3a <LoRaMacCryptoUnsecureMessage+0xba>
    {
        return LORAMAC_CRYPTO_FAIL_ADDRESS;
    }

    // Compute mic
    bool isAck = macMsg->FHDR.FCtrl.Bits.Ack;
 802eac8:	7b33      	ldrb	r3, [r6, #12]
 802eaca:	069b      	lsls	r3, r3, #26
 802eacc:	0fdb      	lsrs	r3, r3, #31
    if( CryptoNvm->LrWanVersion.Fields.Minor == 0 )
 802eace:	491c      	ldr	r1, [pc, #112]	; (802eb40 <LoRaMacCryptoUnsecureMessage+0xc0>)
 802ead0:	6809      	ldr	r1, [r1, #0]
 802ead2:	7889      	ldrb	r1, [r1, #2]
 802ead4:	2900      	cmp	r1, #0
 802ead6:	d100      	bne.n	802eada <LoRaMacCryptoUnsecureMessage+0x5a>
    {
        // In legacy mode the IsAck parameter is forced to be false since the ConfFCnt field is not used.
        isAck = false;
 802ead8:	2300      	movs	r3, #0
    }

    // Verify mic
    retval = VerifyCmacB0( macMsg->Buffer, ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ), micComputationKeyID, isAck, DOWNLINK, address, fCntDown, macMsg->MIC );
 802eada:	7931      	ldrb	r1, [r6, #4]
 802eadc:	3904      	subs	r1, #4
 802eade:	b289      	uxth	r1, r1
 802eae0:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 802eae2:	9003      	str	r0, [sp, #12]
 802eae4:	9402      	str	r4, [sp, #8]
 802eae6:	9805      	ldr	r0, [sp, #20]
 802eae8:	9001      	str	r0, [sp, #4]
 802eaea:	2001      	movs	r0, #1
 802eaec:	9000      	str	r0, [sp, #0]
 802eaee:	6830      	ldr	r0, [r6, #0]
 802eaf0:	f7ff fea3 	bl	802e83a <VerifyCmacB0>
 802eaf4:	1e05      	subs	r5, r0, #0
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 802eaf6:	d119      	bne.n	802eb2c <LoRaMacCryptoUnsecureMessage+0xac>
    {
        return retval;
    }

    // Decrypt payload
    if( macMsg->FPort == 0 )
 802eaf8:	2320      	movs	r3, #32
 802eafa:	5cf3      	ldrb	r3, [r6, r3]
 802eafc:	2b00      	cmp	r3, #0
 802eafe:	d101      	bne.n	802eb04 <LoRaMacCryptoUnsecureMessage+0x84>
    {
        // Use network session encryption key
#if (defined( LORAMAC_VERSION ) && ( LORAMAC_VERSION == 0x01010100 ))
        payloadDecryptionKeyID = NWK_S_ENC_KEY;
#else
        payloadDecryptionKeyID = NWK_S_KEY;
 802eb00:	3308      	adds	r3, #8
 802eb02:	4699      	mov	r9, r3
#endif /* LORAMAC_VERSION */
    }
    retval = PayloadEncrypt( macMsg->FRMPayload, macMsg->FRMPayloadSize, payloadDecryptionKeyID, address, DOWNLINK, fCntDown );
 802eb04:	2328      	movs	r3, #40	; 0x28
 802eb06:	5cf1      	ldrb	r1, [r6, r3]
 802eb08:	6a70      	ldr	r0, [r6, #36]	; 0x24
 802eb0a:	9401      	str	r4, [sp, #4]
 802eb0c:	3b27      	subs	r3, #39	; 0x27
 802eb0e:	9300      	str	r3, [sp, #0]
 802eb10:	9b05      	ldr	r3, [sp, #20]
 802eb12:	464a      	mov	r2, r9
 802eb14:	f7ff fe29 	bl	802e76a <PayloadEncrypt>
 802eb18:	1e05      	subs	r5, r0, #0
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 802eb1a:	d107      	bne.n	802eb2c <LoRaMacCryptoUnsecureMessage+0xac>
            }
        }
    }
#endif /* LORAMAC_VERSION */

    UpdateFCntDown( fCntID, fCntDown );
 802eb1c:	0021      	movs	r1, r4
 802eb1e:	0038      	movs	r0, r7
 802eb20:	f7ff fd80 	bl	802e624 <UpdateFCntDown>

    return LORAMAC_CRYPTO_SUCCESS;
 802eb24:	e002      	b.n	802eb2c <LoRaMacCryptoUnsecureMessage+0xac>
        return LORAMAC_CRYPTO_ERROR_NPE;
 802eb26:	2509      	movs	r5, #9
 802eb28:	e000      	b.n	802eb2c <LoRaMacCryptoUnsecureMessage+0xac>
        return LORAMAC_CRYPTO_FAIL_FCNT_SMALLER;
 802eb2a:	2506      	movs	r5, #6
}
 802eb2c:	0028      	movs	r0, r5
 802eb2e:	b008      	add	sp, #32
 802eb30:	bc80      	pop	{r7}
 802eb32:	46b9      	mov	r9, r7
 802eb34:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_CRYPTO_ERROR_PARSER;
 802eb36:	250f      	movs	r5, #15
 802eb38:	e7f8      	b.n	802eb2c <LoRaMacCryptoUnsecureMessage+0xac>
        return LORAMAC_CRYPTO_FAIL_ADDRESS;
 802eb3a:	2502      	movs	r5, #2
 802eb3c:	e7f6      	b.n	802eb2c <LoRaMacCryptoUnsecureMessage+0xac>
 802eb3e:	46c0      	nop			; (mov r8, r8)
 802eb40:	2000c30c 	.word	0x2000c30c

0802eb44 <LoRaMacCryptoDeriveLifeTimeKey>:

    return LORAMAC_CRYPTO_SUCCESS;
}

LoRaMacCryptoStatus_t LoRaMacCryptoDeriveLifeTimeKey( uint8_t versionMinor, KeyIdentifier_t keyID )
{
 802eb44:	b530      	push	{r4, r5, lr}
 802eb46:	b085      	sub	sp, #20
 802eb48:	0005      	movs	r5, r0
 802eb4a:	000c      	movs	r4, r1
    uint8_t compBase[16] = { 0 };
 802eb4c:	2300      	movs	r3, #0
 802eb4e:	9300      	str	r3, [sp, #0]
 802eb50:	220c      	movs	r2, #12
 802eb52:	2100      	movs	r1, #0
 802eb54:	a801      	add	r0, sp, #4
 802eb56:	f005 ffee 	bl	8034b36 <memset>
    KeyIdentifier_t rootKeyId = APP_KEY;
    switch( keyID )
 802eb5a:	2c0b      	cmp	r4, #11
 802eb5c:	d006      	beq.n	802eb6c <LoRaMacCryptoDeriveLifeTimeKey+0x28>
 802eb5e:	2c0c      	cmp	r4, #12
 802eb60:	d012      	beq.n	802eb88 <LoRaMacCryptoDeriveLifeTimeKey+0x44>
 802eb62:	2c0a      	cmp	r4, #10
 802eb64:	d00b      	beq.n	802eb7e <LoRaMacCryptoDeriveLifeTimeKey+0x3a>
 802eb66:	200a      	movs	r0, #10
    {
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
    }

    return LORAMAC_CRYPTO_SUCCESS;
}
 802eb68:	b005      	add	sp, #20
 802eb6a:	bd30      	pop	{r4, r5, pc}
            if( versionMinor == 1 )
 802eb6c:	2d01      	cmp	r5, #1
 802eb6e:	d001      	beq.n	802eb74 <LoRaMacCryptoDeriveLifeTimeKey+0x30>
    KeyIdentifier_t rootKeyId = APP_KEY;
 802eb70:	2100      	movs	r1, #0
 802eb72:	e00a      	b.n	802eb8a <LoRaMacCryptoDeriveLifeTimeKey+0x46>
                compBase[0] = 0x20;
 802eb74:	2320      	movs	r3, #32
 802eb76:	466a      	mov	r2, sp
 802eb78:	7013      	strb	r3, [r2, #0]
    KeyIdentifier_t rootKeyId = APP_KEY;
 802eb7a:	2100      	movs	r1, #0
 802eb7c:	e005      	b.n	802eb8a <LoRaMacCryptoDeriveLifeTimeKey+0x46>
            compBase[0] = 0x30;
 802eb7e:	2330      	movs	r3, #48	; 0x30
 802eb80:	466a      	mov	r2, sp
 802eb82:	7013      	strb	r3, [r2, #0]
    KeyIdentifier_t rootKeyId = APP_KEY;
 802eb84:	2100      	movs	r1, #0
            break;
 802eb86:	e000      	b.n	802eb8a <LoRaMacCryptoDeriveLifeTimeKey+0x46>
    switch( keyID )
 802eb88:	210b      	movs	r1, #11
    if( SecureElementDeriveAndStoreKey( compBase, rootKeyId, keyID ) != SECURE_ELEMENT_SUCCESS )
 802eb8a:	0022      	movs	r2, r4
 802eb8c:	4668      	mov	r0, sp
 802eb8e:	f003 f89d 	bl	8031ccc <SecureElementDeriveAndStoreKey>
 802eb92:	2800      	cmp	r0, #0
 802eb94:	d0e8      	beq.n	802eb68 <LoRaMacCryptoDeriveLifeTimeKey+0x24>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802eb96:	200e      	movs	r0, #14
 802eb98:	e7e6      	b.n	802eb68 <LoRaMacCryptoDeriveLifeTimeKey+0x24>
	...

0802eb9c <LoRaMacCryptoSetKey>:
{
 802eb9c:	b510      	push	{r4, lr}
 802eb9e:	0004      	movs	r4, r0
    if( SecureElementSetKey( keyID, key ) != SECURE_ELEMENT_SUCCESS )
 802eba0:	f002 ffc4 	bl	8031b2c <SecureElementSetKey>
 802eba4:	2800      	cmp	r0, #0
 802eba6:	d116      	bne.n	802ebd6 <LoRaMacCryptoSetKey+0x3a>
    if( keyID == APP_KEY )
 802eba8:	2c00      	cmp	r4, #0
 802ebaa:	d000      	beq.n	802ebae <LoRaMacCryptoSetKey+0x12>
}
 802ebac:	bd10      	pop	{r4, pc}
        if( LoRaMacCryptoDeriveLifeTimeKey( CryptoNvm->LrWanVersion.Fields.Minor, MC_ROOT_KEY ) != LORAMAC_CRYPTO_SUCCESS )
 802ebae:	4b0d      	ldr	r3, [pc, #52]	; (802ebe4 <LoRaMacCryptoSetKey+0x48>)
 802ebb0:	681b      	ldr	r3, [r3, #0]
 802ebb2:	7898      	ldrb	r0, [r3, #2]
 802ebb4:	210b      	movs	r1, #11
 802ebb6:	f7ff ffc5 	bl	802eb44 <LoRaMacCryptoDeriveLifeTimeKey>
 802ebba:	2800      	cmp	r0, #0
 802ebbc:	d10d      	bne.n	802ebda <LoRaMacCryptoSetKey+0x3e>
        if( LoRaMacCryptoDeriveLifeTimeKey( 0, MC_KE_KEY ) != LORAMAC_CRYPTO_SUCCESS )
 802ebbe:	210c      	movs	r1, #12
 802ebc0:	f7ff ffc0 	bl	802eb44 <LoRaMacCryptoDeriveLifeTimeKey>
 802ebc4:	2800      	cmp	r0, #0
 802ebc6:	d10a      	bne.n	802ebde <LoRaMacCryptoSetKey+0x42>
        if( LoRaMacCryptoDeriveLifeTimeKey( 0, DATABLOCK_INT_KEY ) != LORAMAC_CRYPTO_SUCCESS )
 802ebc8:	210a      	movs	r1, #10
 802ebca:	f7ff ffbb 	bl	802eb44 <LoRaMacCryptoDeriveLifeTimeKey>
 802ebce:	2800      	cmp	r0, #0
 802ebd0:	d0ec      	beq.n	802ebac <LoRaMacCryptoSetKey+0x10>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802ebd2:	200e      	movs	r0, #14
 802ebd4:	e7ea      	b.n	802ebac <LoRaMacCryptoSetKey+0x10>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802ebd6:	200e      	movs	r0, #14
 802ebd8:	e7e8      	b.n	802ebac <LoRaMacCryptoSetKey+0x10>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802ebda:	200e      	movs	r0, #14
 802ebdc:	e7e6      	b.n	802ebac <LoRaMacCryptoSetKey+0x10>
            return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802ebde:	200e      	movs	r0, #14
 802ebe0:	e7e4      	b.n	802ebac <LoRaMacCryptoSetKey+0x10>
 802ebe2:	46c0      	nop			; (mov r8, r8)
 802ebe4:	2000c30c 	.word	0x2000c30c

0802ebe8 <LoRaMacCryptoHandleJoinAccept>:
{
 802ebe8:	b5f0      	push	{r4, r5, r6, r7, lr}
 802ebea:	b08f      	sub	sp, #60	; 0x3c
 802ebec:	0006      	movs	r6, r0
 802ebee:	000d      	movs	r5, r1
 802ebf0:	1e14      	subs	r4, r2, #0
    if( ( macMsg == 0 ) || ( joinEUI == 0 ) )
 802ebf2:	d06a      	beq.n	802ecca <LoRaMacCryptoHandleJoinAccept+0xe2>
 802ebf4:	2900      	cmp	r1, #0
 802ebf6:	d06a      	beq.n	802ecce <LoRaMacCryptoHandleJoinAccept+0xe6>
    uint8_t decJoinAccept[LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE] = { 0 };
 802ebf8:	2700      	movs	r7, #0
 802ebfa:	9705      	str	r7, [sp, #20]
 802ebfc:	221d      	movs	r2, #29
 802ebfe:	2100      	movs	r1, #0
 802ec00:	a806      	add	r0, sp, #24
 802ec02:	f005 ff98 	bl	8034b36 <memset>
    uint8_t versionMinor         = 0;
 802ec06:	2313      	movs	r3, #19
 802ec08:	446b      	add	r3, sp
 802ec0a:	701f      	strb	r7, [r3, #0]
    uint16_t nonce               = CryptoNvm->DevNonce;
 802ec0c:	4a34      	ldr	r2, [pc, #208]	; (802ece0 <LoRaMacCryptoHandleJoinAccept+0xf8>)
 802ec0e:	6812      	ldr	r2, [r2, #0]
 802ec10:	8897      	ldrh	r7, [r2, #4]
    if( SecureElementProcessJoinAccept( joinReqType, joinEUI, nonce, macMsg->Buffer,
 802ec12:	9302      	str	r3, [sp, #8]
 802ec14:	ab05      	add	r3, sp, #20
 802ec16:	9301      	str	r3, [sp, #4]
 802ec18:	7923      	ldrb	r3, [r4, #4]
 802ec1a:	9300      	str	r3, [sp, #0]
 802ec1c:	6823      	ldr	r3, [r4, #0]
 802ec1e:	003a      	movs	r2, r7
 802ec20:	0029      	movs	r1, r5
 802ec22:	0030      	movs	r0, r6
 802ec24:	f003 f8b2 	bl	8031d8c <SecureElementProcessJoinAccept>
 802ec28:	2800      	cmp	r0, #0
 802ec2a:	d152      	bne.n	802ecd2 <LoRaMacCryptoHandleJoinAccept+0xea>
    memcpy1( macMsg->Buffer, decJoinAccept, macMsg->BufSize );
 802ec2c:	7922      	ldrb	r2, [r4, #4]
 802ec2e:	a905      	add	r1, sp, #20
 802ec30:	6820      	ldr	r0, [r4, #0]
 802ec32:	f003 fa66 	bl	8032102 <memcpy1>
    if( LoRaMacParserJoinAccept( macMsg ) != LORAMAC_PARSER_SUCCESS )
 802ec36:	0020      	movs	r0, r4
 802ec38:	f000 f854 	bl	802ece4 <LoRaMacParserJoinAccept>
 802ec3c:	2800      	cmp	r0, #0
 802ec3e:	d14b      	bne.n	802ecd8 <LoRaMacCryptoHandleJoinAccept+0xf0>
    currentJoinNonce = ( uint32_t )macMsg->JoinNonce[0];
 802ec40:	79a2      	ldrb	r2, [r4, #6]
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[1] << 8 );
 802ec42:	79e5      	ldrb	r5, [r4, #7]
 802ec44:	022d      	lsls	r5, r5, #8
 802ec46:	4315      	orrs	r5, r2
    currentJoinNonce |= ( ( uint32_t )macMsg->JoinNonce[2] << 16 );
 802ec48:	7a23      	ldrb	r3, [r4, #8]
 802ec4a:	041b      	lsls	r3, r3, #16
 802ec4c:	431d      	orrs	r5, r3
        isJoinNonceOk = IsJoinNonce10xOk( currentJoinNonce );
 802ec4e:	0028      	movs	r0, r5
 802ec50:	f7ff fd1e 	bl	802e690 <IsJoinNonce10xOk>
    if( isJoinNonceOk == true )
 802ec54:	2800      	cmp	r0, #0
 802ec56:	d041      	beq.n	802ecdc <LoRaMacCryptoHandleJoinAccept+0xf4>
        CryptoNvm->JoinNonce = currentJoinNonce;
 802ec58:	4b21      	ldr	r3, [pc, #132]	; (802ece0 <LoRaMacCryptoHandleJoinAccept+0xf8>)
 802ec5a:	681b      	ldr	r3, [r3, #0]
 802ec5c:	609d      	str	r5, [r3, #8]
    retval = LoRaMacCryptoDeriveLifeTimeKey( versionMinor, MC_ROOT_KEY );
 802ec5e:	2313      	movs	r3, #19
 802ec60:	446b      	add	r3, sp
 802ec62:	7818      	ldrb	r0, [r3, #0]
 802ec64:	210b      	movs	r1, #11
 802ec66:	f7ff ff6d 	bl	802eb44 <LoRaMacCryptoDeriveLifeTimeKey>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 802ec6a:	2800      	cmp	r0, #0
 802ec6c:	d132      	bne.n	802ecd4 <LoRaMacCryptoHandleJoinAccept+0xec>
    retval = LoRaMacCryptoDeriveLifeTimeKey( 0, MC_KE_KEY );
 802ec6e:	210c      	movs	r1, #12
 802ec70:	f7ff ff68 	bl	802eb44 <LoRaMacCryptoDeriveLifeTimeKey>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 802ec74:	2800      	cmp	r0, #0
 802ec76:	d12d      	bne.n	802ecd4 <LoRaMacCryptoHandleJoinAccept+0xec>
    retval = LoRaMacCryptoDeriveLifeTimeKey( 0, DATABLOCK_INT_KEY );
 802ec78:	210a      	movs	r1, #10
 802ec7a:	f7ff ff63 	bl	802eb44 <LoRaMacCryptoDeriveLifeTimeKey>
    if( retval != LORAMAC_CRYPTO_SUCCESS )
 802ec7e:	2800      	cmp	r0, #0
 802ec80:	d128      	bne.n	802ecd4 <LoRaMacCryptoHandleJoinAccept+0xec>
        netID = ( uint32_t )macMsg->NetID[0];
 802ec82:	7a63      	ldrb	r3, [r4, #9]
        netID |= ( ( uint32_t )macMsg->NetID[1] << 8 );
 802ec84:	7aa2      	ldrb	r2, [r4, #10]
 802ec86:	0212      	lsls	r2, r2, #8
 802ec88:	431a      	orrs	r2, r3
        netID |= ( ( uint32_t )macMsg->NetID[2] << 16 );
 802ec8a:	7ae4      	ldrb	r4, [r4, #11]
 802ec8c:	0424      	lsls	r4, r4, #16
 802ec8e:	4314      	orrs	r4, r2
        retval = DeriveSessionKey10x( APP_S_KEY, currentJoinNonce, netID, nonce );
 802ec90:	003b      	movs	r3, r7
 802ec92:	0022      	movs	r2, r4
 802ec94:	0029      	movs	r1, r5
 802ec96:	3009      	adds	r0, #9
 802ec98:	f7ff fd33 	bl	802e702 <DeriveSessionKey10x>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 802ec9c:	2800      	cmp	r0, #0
 802ec9e:	d119      	bne.n	802ecd4 <LoRaMacCryptoHandleJoinAccept+0xec>
        retval = DeriveSessionKey10x( NWK_S_KEY, currentJoinNonce, netID, nonce );
 802eca0:	003b      	movs	r3, r7
 802eca2:	0022      	movs	r2, r4
 802eca4:	0029      	movs	r1, r5
 802eca6:	3008      	adds	r0, #8
 802eca8:	f7ff fd2b 	bl	802e702 <DeriveSessionKey10x>
        if( retval != LORAMAC_CRYPTO_SUCCESS )
 802ecac:	2800      	cmp	r0, #0
 802ecae:	d111      	bne.n	802ecd4 <LoRaMacCryptoHandleJoinAccept+0xec>
    CryptoNvm->LrWanVersion.Fields.Minor = versionMinor;
 802ecb0:	4b0b      	ldr	r3, [pc, #44]	; (802ece0 <LoRaMacCryptoHandleJoinAccept+0xf8>)
 802ecb2:	681b      	ldr	r3, [r3, #0]
 802ecb4:	2213      	movs	r2, #19
 802ecb6:	446a      	add	r2, sp
 802ecb8:	7812      	ldrb	r2, [r2, #0]
 802ecba:	709a      	strb	r2, [r3, #2]
    CryptoNvm->FCntList.FCntUp = 0;
 802ecbc:	2200      	movs	r2, #0
 802ecbe:	60da      	str	r2, [r3, #12]
    CryptoNvm->FCntList.FCntDown = FCNT_DOWN_INITIAL_VALUE;
 802ecc0:	3a01      	subs	r2, #1
 802ecc2:	619a      	str	r2, [r3, #24]
    CryptoNvm->FCntList.NFCntDown = FCNT_DOWN_INITIAL_VALUE;
 802ecc4:	611a      	str	r2, [r3, #16]
    CryptoNvm->FCntList.AFCntDown = FCNT_DOWN_INITIAL_VALUE;
 802ecc6:	615a      	str	r2, [r3, #20]
    return LORAMAC_CRYPTO_SUCCESS;
 802ecc8:	e004      	b.n	802ecd4 <LoRaMacCryptoHandleJoinAccept+0xec>
        return LORAMAC_CRYPTO_ERROR_NPE;
 802ecca:	2009      	movs	r0, #9
 802eccc:	e002      	b.n	802ecd4 <LoRaMacCryptoHandleJoinAccept+0xec>
 802ecce:	2009      	movs	r0, #9
 802ecd0:	e000      	b.n	802ecd4 <LoRaMacCryptoHandleJoinAccept+0xec>
        return LORAMAC_CRYPTO_ERROR_SECURE_ELEMENT_FUNC;
 802ecd2:	200e      	movs	r0, #14
}
 802ecd4:	b00f      	add	sp, #60	; 0x3c
 802ecd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_CRYPTO_ERROR_PARSER;
 802ecd8:	200f      	movs	r0, #15
 802ecda:	e7fb      	b.n	802ecd4 <LoRaMacCryptoHandleJoinAccept+0xec>
        return LORAMAC_CRYPTO_FAIL_JOIN_NONCE;
 802ecdc:	2003      	movs	r0, #3
 802ecde:	e7f9      	b.n	802ecd4 <LoRaMacCryptoHandleJoinAccept+0xec>
 802ece0:	2000c30c 	.word	0x2000c30c

0802ece4 <LoRaMacParserJoinAccept>:
 */
#include "LoRaMacParser.h"
#include "utilities.h"

LoRaMacParserStatus_t LoRaMacParserJoinAccept( LoRaMacMessageJoinAccept_t* macMsg )
{
 802ece4:	b570      	push	{r4, r5, r6, lr}
 802ece6:	1e04      	subs	r4, r0, #0
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 802ece8:	d045      	beq.n	802ed76 <LoRaMacParserJoinAccept+0x92>
 802ecea:	6801      	ldr	r1, [r0, #0]
 802ecec:	2900      	cmp	r1, #0
 802ecee:	d044      	beq.n	802ed7a <LoRaMacParserJoinAccept+0x96>
        return LORAMAC_PARSER_ERROR_NPE;
    }

    uint16_t bufItr = 0;

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 802ecf0:	780b      	ldrb	r3, [r1, #0]
 802ecf2:	7143      	strb	r3, [r0, #5]

    memcpy1( macMsg->JoinNonce, &macMsg->Buffer[bufItr], 3 );
 802ecf4:	3006      	adds	r0, #6
 802ecf6:	3101      	adds	r1, #1
 802ecf8:	2203      	movs	r2, #3
 802ecfa:	f003 fa02 	bl	8032102 <memcpy1>
    bufItr = bufItr + 3;

    memcpy1( macMsg->NetID, &macMsg->Buffer[bufItr], 3 );
 802ecfe:	6823      	ldr	r3, [r4, #0]
 802ed00:	1d19      	adds	r1, r3, #4
 802ed02:	2203      	movs	r2, #3
 802ed04:	0020      	movs	r0, r4
 802ed06:	3009      	adds	r0, #9
 802ed08:	f003 f9fb 	bl	8032102 <memcpy1>
    bufItr = bufItr + 3;

    macMsg->DevAddr = ( uint32_t ) macMsg->Buffer[bufItr++];
 802ed0c:	6821      	ldr	r1, [r4, #0]
 802ed0e:	79cb      	ldrb	r3, [r1, #7]
 802ed10:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 802ed12:	7a0a      	ldrb	r2, [r1, #8]
 802ed14:	0212      	lsls	r2, r2, #8
 802ed16:	4313      	orrs	r3, r2
 802ed18:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 802ed1a:	7a4a      	ldrb	r2, [r1, #9]
 802ed1c:	0412      	lsls	r2, r2, #16
 802ed1e:	4313      	orrs	r3, r2
 802ed20:	60e3      	str	r3, [r4, #12]
    macMsg->DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 802ed22:	7a8a      	ldrb	r2, [r1, #10]
 802ed24:	0612      	lsls	r2, r2, #24
 802ed26:	4313      	orrs	r3, r2
 802ed28:	60e3      	str	r3, [r4, #12]

    macMsg->DLSettings.Value = macMsg->Buffer[bufItr++];
 802ed2a:	7acb      	ldrb	r3, [r1, #11]
 802ed2c:	7423      	strb	r3, [r4, #16]

    macMsg->RxDelay = macMsg->Buffer[bufItr++];
 802ed2e:	7b0b      	ldrb	r3, [r1, #12]
 802ed30:	7463      	strb	r3, [r4, #17]

    if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) == LORAMAC_CF_LIST_FIELD_SIZE )
 802ed32:	7923      	ldrb	r3, [r4, #4]
 802ed34:	2b21      	cmp	r3, #33	; 0x21
 802ed36:	d016      	beq.n	802ed66 <LoRaMacParserJoinAccept+0x82>
    {
        memcpy1( macMsg->CFList, &macMsg->Buffer[bufItr], LORAMAC_CF_LIST_FIELD_SIZE );
        bufItr = bufItr + LORAMAC_CF_LIST_FIELD_SIZE;
    }
    else if( ( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE - bufItr ) > 0 )
 802ed38:	2b11      	cmp	r3, #17
 802ed3a:	dc20      	bgt.n	802ed7e <LoRaMacParserJoinAccept+0x9a>
    macMsg->RxDelay = macMsg->Buffer[bufItr++];
 802ed3c:	220d      	movs	r2, #13
    {
        return LORAMAC_PARSER_FAIL;
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[bufItr++];
 802ed3e:	6821      	ldr	r1, [r4, #0]
 802ed40:	1c50      	adds	r0, r2, #1
 802ed42:	5c8b      	ldrb	r3, [r1, r2]
 802ed44:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 802ed46:	1c95      	adds	r5, r2, #2
 802ed48:	5c08      	ldrb	r0, [r1, r0]
 802ed4a:	0200      	lsls	r0, r0, #8
 802ed4c:	4303      	orrs	r3, r0
 802ed4e:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 802ed50:	3203      	adds	r2, #3
 802ed52:	5d48      	ldrb	r0, [r1, r5]
 802ed54:	0400      	lsls	r0, r0, #16
 802ed56:	4303      	orrs	r3, r0
 802ed58:	6263      	str	r3, [r4, #36]	; 0x24
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 802ed5a:	5c8a      	ldrb	r2, [r1, r2]
 802ed5c:	0612      	lsls	r2, r2, #24
 802ed5e:	4313      	orrs	r3, r2
 802ed60:	6263      	str	r3, [r4, #36]	; 0x24

    return LORAMAC_PARSER_SUCCESS;
 802ed62:	2000      	movs	r0, #0
}
 802ed64:	bd70      	pop	{r4, r5, r6, pc}
        memcpy1( macMsg->CFList, &macMsg->Buffer[bufItr], LORAMAC_CF_LIST_FIELD_SIZE );
 802ed66:	310d      	adds	r1, #13
 802ed68:	2210      	movs	r2, #16
 802ed6a:	0020      	movs	r0, r4
 802ed6c:	3012      	adds	r0, #18
 802ed6e:	f003 f9c8 	bl	8032102 <memcpy1>
        bufItr = bufItr + LORAMAC_CF_LIST_FIELD_SIZE;
 802ed72:	221d      	movs	r2, #29
 802ed74:	e7e3      	b.n	802ed3e <LoRaMacParserJoinAccept+0x5a>
        return LORAMAC_PARSER_ERROR_NPE;
 802ed76:	2002      	movs	r0, #2
 802ed78:	e7f4      	b.n	802ed64 <LoRaMacParserJoinAccept+0x80>
 802ed7a:	2002      	movs	r0, #2
 802ed7c:	e7f2      	b.n	802ed64 <LoRaMacParserJoinAccept+0x80>
        return LORAMAC_PARSER_FAIL;
 802ed7e:	2001      	movs	r0, #1
 802ed80:	e7f0      	b.n	802ed64 <LoRaMacParserJoinAccept+0x80>

0802ed82 <LoRaMacParserData>:

LoRaMacParserStatus_t LoRaMacParserData( LoRaMacMessageData_t* macMsg )
{
 802ed82:	b570      	push	{r4, r5, r6, lr}
 802ed84:	1e04      	subs	r4, r0, #0
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 802ed86:	d058      	beq.n	802ee3a <LoRaMacParserData+0xb8>
 802ed88:	6801      	ldr	r1, [r0, #0]
 802ed8a:	2900      	cmp	r1, #0
 802ed8c:	d057      	beq.n	802ee3e <LoRaMacParserData+0xbc>
        return LORAMAC_PARSER_ERROR_NPE;
    }

    uint16_t bufItr = 0;

    macMsg->MHDR.Value = macMsg->Buffer[bufItr++];
 802ed8e:	780b      	ldrb	r3, [r1, #0]
 802ed90:	7143      	strb	r3, [r0, #5]

    macMsg->FHDR.DevAddr = macMsg->Buffer[bufItr++];
 802ed92:	784b      	ldrb	r3, [r1, #1]
 802ed94:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 8 );
 802ed96:	788a      	ldrb	r2, [r1, #2]
 802ed98:	0212      	lsls	r2, r2, #8
 802ed9a:	4313      	orrs	r3, r2
 802ed9c:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 16 );
 802ed9e:	78ca      	ldrb	r2, [r1, #3]
 802eda0:	0412      	lsls	r2, r2, #16
 802eda2:	4313      	orrs	r3, r2
 802eda4:	6083      	str	r3, [r0, #8]
    macMsg->FHDR.DevAddr |= ( ( uint32_t ) macMsg->Buffer[bufItr++] << 24 );
 802eda6:	790a      	ldrb	r2, [r1, #4]
 802eda8:	0612      	lsls	r2, r2, #24
 802edaa:	4313      	orrs	r3, r2
 802edac:	6083      	str	r3, [r0, #8]

    macMsg->FHDR.FCtrl.Value = macMsg->Buffer[bufItr++];
 802edae:	794b      	ldrb	r3, [r1, #5]
 802edb0:	7303      	strb	r3, [r0, #12]

    macMsg->FHDR.FCnt = macMsg->Buffer[bufItr++];
 802edb2:	798b      	ldrb	r3, [r1, #6]
 802edb4:	81c3      	strh	r3, [r0, #14]
    macMsg->FHDR.FCnt |= macMsg->Buffer[bufItr++] << 8;
 802edb6:	79ca      	ldrb	r2, [r1, #7]
 802edb8:	0212      	lsls	r2, r2, #8
 802edba:	4313      	orrs	r3, r2
 802edbc:	81c3      	strh	r3, [r0, #14]

    memcpy1( macMsg->FHDR.FOpts, &macMsg->Buffer[bufItr], macMsg->FHDR.FCtrl.Bits.FOptsLen );
 802edbe:	3010      	adds	r0, #16
 802edc0:	3108      	adds	r1, #8
 802edc2:	7b22      	ldrb	r2, [r4, #12]
 802edc4:	0712      	lsls	r2, r2, #28
 802edc6:	0f12      	lsrs	r2, r2, #28
 802edc8:	f003 f99b 	bl	8032102 <memcpy1>
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 802edcc:	7b23      	ldrb	r3, [r4, #12]
 802edce:	071b      	lsls	r3, r3, #28
 802edd0:	0f1b      	lsrs	r3, r3, #28
 802edd2:	0018      	movs	r0, r3
 802edd4:	3008      	adds	r0, #8

    // Initialize anyway with zero.
    macMsg->FPort = 0;
 802edd6:	2200      	movs	r2, #0
 802edd8:	2120      	movs	r1, #32
 802edda:	5462      	strb	r2, [r4, r1]
    macMsg->FRMPayloadSize = 0;
 802eddc:	3108      	adds	r1, #8
 802edde:	5462      	strb	r2, [r4, r1]

    if( ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE ) > 0 )
 802ede0:	7922      	ldrb	r2, [r4, #4]
 802ede2:	1a11      	subs	r1, r2, r0
 802ede4:	2904      	cmp	r1, #4
 802ede6:	dc17      	bgt.n	802ee18 <LoRaMacParserData+0x96>
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
        bufItr = bufItr + macMsg->FRMPayloadSize;
    }

    macMsg->MIC = ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE )];
 802ede8:	7922      	ldrb	r2, [r4, #4]
 802edea:	6823      	ldr	r3, [r4, #0]
 802edec:	469c      	mov	ip, r3
 802edee:	4462      	add	r2, ip
 802edf0:	1f13      	subs	r3, r2, #4
 802edf2:	781b      	ldrb	r3, [r3, #0]
 802edf4:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 1] << 8 );
 802edf6:	1ed1      	subs	r1, r2, #3
 802edf8:	7809      	ldrb	r1, [r1, #0]
 802edfa:	0209      	lsls	r1, r1, #8
 802edfc:	430b      	orrs	r3, r1
 802edfe:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 2] << 16 );
 802ee00:	1e91      	subs	r1, r2, #2
 802ee02:	7809      	ldrb	r1, [r1, #0]
 802ee04:	0409      	lsls	r1, r1, #16
 802ee06:	430b      	orrs	r3, r1
 802ee08:	62e3      	str	r3, [r4, #44]	; 0x2c
    macMsg->MIC |= ( ( uint32_t ) macMsg->Buffer[( macMsg->BufSize - LORAMAC_MIC_FIELD_SIZE ) + 3] << 24 );
 802ee0a:	3a01      	subs	r2, #1
 802ee0c:	7812      	ldrb	r2, [r2, #0]
 802ee0e:	0612      	lsls	r2, r2, #24
 802ee10:	4313      	orrs	r3, r2
 802ee12:	62e3      	str	r3, [r4, #44]	; 0x2c

    return LORAMAC_PARSER_SUCCESS;
 802ee14:	2000      	movs	r0, #0
}
 802ee16:	bd70      	pop	{r4, r5, r6, pc}
        macMsg->FPort = macMsg->Buffer[bufItr++];
 802ee18:	6821      	ldr	r1, [r4, #0]
 802ee1a:	3309      	adds	r3, #9
 802ee1c:	5c0d      	ldrb	r5, [r1, r0]
 802ee1e:	2020      	movs	r0, #32
 802ee20:	5425      	strb	r5, [r4, r0]
        macMsg->FRMPayloadSize = ( macMsg->BufSize - bufItr - LORAMAC_MIC_FIELD_SIZE );
 802ee22:	1ad2      	subs	r2, r2, r3
 802ee24:	b2d2      	uxtb	r2, r2
 802ee26:	3a04      	subs	r2, #4
 802ee28:	b2d2      	uxtb	r2, r2
 802ee2a:	3008      	adds	r0, #8
 802ee2c:	5422      	strb	r2, [r4, r0]
        memcpy1( macMsg->FRMPayload, &macMsg->Buffer[bufItr], macMsg->FRMPayloadSize );
 802ee2e:	18c9      	adds	r1, r1, r3
 802ee30:	b292      	uxth	r2, r2
 802ee32:	6a60      	ldr	r0, [r4, #36]	; 0x24
 802ee34:	f003 f965 	bl	8032102 <memcpy1>
        bufItr = bufItr + macMsg->FRMPayloadSize;
 802ee38:	e7d6      	b.n	802ede8 <LoRaMacParserData+0x66>
        return LORAMAC_PARSER_ERROR_NPE;
 802ee3a:	2002      	movs	r0, #2
 802ee3c:	e7eb      	b.n	802ee16 <LoRaMacParserData+0x94>
 802ee3e:	2002      	movs	r0, #2
 802ee40:	e7e9      	b.n	802ee16 <LoRaMacParserData+0x94>

0802ee42 <LoRaMacSerializerJoinRequest>:
 */
#include "LoRaMacSerializer.h"
#include "utilities.h"

LoRaMacSerializerStatus_t LoRaMacSerializerJoinRequest( LoRaMacMessageJoinRequest_t* macMsg )
{
 802ee42:	b510      	push	{r4, lr}
 802ee44:	1e04      	subs	r4, r0, #0
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 802ee46:	d02c      	beq.n	802eea2 <LoRaMacSerializerJoinRequest+0x60>
 802ee48:	6803      	ldr	r3, [r0, #0]
 802ee4a:	2b00      	cmp	r3, #0
 802ee4c:	d02b      	beq.n	802eea6 <LoRaMacSerializerJoinRequest+0x64>
    }

    uint16_t bufItr = 0;

    // Check macMsg->BufSize
    if( macMsg->BufSize < LORAMAC_JOIN_REQ_MSG_SIZE )
 802ee4e:	7902      	ldrb	r2, [r0, #4]
 802ee50:	2a16      	cmp	r2, #22
 802ee52:	d92a      	bls.n	802eeaa <LoRaMacSerializerJoinRequest+0x68>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 802ee54:	7942      	ldrb	r2, [r0, #5]
 802ee56:	701a      	strb	r2, [r3, #0]

    memcpyr( &macMsg->Buffer[bufItr], macMsg->JoinEUI, LORAMAC_JOIN_EUI_FIELD_SIZE );
 802ee58:	1d81      	adds	r1, r0, #6
 802ee5a:	6803      	ldr	r3, [r0, #0]
 802ee5c:	1c58      	adds	r0, r3, #1
 802ee5e:	2208      	movs	r2, #8
 802ee60:	f003 f95a 	bl	8032118 <memcpyr>
    bufItr += LORAMAC_JOIN_EUI_FIELD_SIZE;

    memcpyr( &macMsg->Buffer[bufItr], macMsg->DevEUI, LORAMAC_DEV_EUI_FIELD_SIZE );
 802ee64:	0021      	movs	r1, r4
 802ee66:	310e      	adds	r1, #14
 802ee68:	6820      	ldr	r0, [r4, #0]
 802ee6a:	3009      	adds	r0, #9
 802ee6c:	2208      	movs	r2, #8
 802ee6e:	f003 f953 	bl	8032118 <memcpyr>
    bufItr += LORAMAC_DEV_EUI_FIELD_SIZE;

    macMsg->Buffer[bufItr++] = macMsg->DevNonce & 0xFF;
 802ee72:	8ae3      	ldrh	r3, [r4, #22]
 802ee74:	6822      	ldr	r2, [r4, #0]
 802ee76:	7453      	strb	r3, [r2, #17]
    macMsg->Buffer[bufItr++] = ( macMsg->DevNonce >> 8 ) & 0xFF;
 802ee78:	8ae3      	ldrh	r3, [r4, #22]
 802ee7a:	0a1b      	lsrs	r3, r3, #8
 802ee7c:	6822      	ldr	r2, [r4, #0]
 802ee7e:	7493      	strb	r3, [r2, #18]

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 802ee80:	69a3      	ldr	r3, [r4, #24]
 802ee82:	6822      	ldr	r2, [r4, #0]
 802ee84:	74d3      	strb	r3, [r2, #19]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 802ee86:	69a3      	ldr	r3, [r4, #24]
 802ee88:	0a1b      	lsrs	r3, r3, #8
 802ee8a:	6822      	ldr	r2, [r4, #0]
 802ee8c:	7513      	strb	r3, [r2, #20]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 802ee8e:	8b63      	ldrh	r3, [r4, #26]
 802ee90:	6822      	ldr	r2, [r4, #0]
 802ee92:	7553      	strb	r3, [r2, #21]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 802ee94:	7ee3      	ldrb	r3, [r4, #27]
 802ee96:	6822      	ldr	r2, [r4, #0]
 802ee98:	7593      	strb	r3, [r2, #22]

    macMsg->BufSize = bufItr;
 802ee9a:	2317      	movs	r3, #23
 802ee9c:	7123      	strb	r3, [r4, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 802ee9e:	2000      	movs	r0, #0
}
 802eea0:	bd10      	pop	{r4, pc}
        return LORAMAC_SERIALIZER_ERROR_NPE;
 802eea2:	2001      	movs	r0, #1
 802eea4:	e7fc      	b.n	802eea0 <LoRaMacSerializerJoinRequest+0x5e>
 802eea6:	2001      	movs	r0, #1
 802eea8:	e7fa      	b.n	802eea0 <LoRaMacSerializerJoinRequest+0x5e>
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 802eeaa:	2002      	movs	r0, #2
 802eeac:	e7f8      	b.n	802eea0 <LoRaMacSerializerJoinRequest+0x5e>

0802eeae <LoRaMacSerializerData>:

    return LORAMAC_SERIALIZER_SUCCESS;
}

LoRaMacSerializerStatus_t LoRaMacSerializerData( LoRaMacMessageData_t* macMsg )
{
 802eeae:	b570      	push	{r4, r5, r6, lr}
 802eeb0:	1e04      	subs	r4, r0, #0
    if( ( macMsg == 0 ) || ( macMsg->Buffer == 0 ) )
 802eeb2:	d100      	bne.n	802eeb6 <LoRaMacSerializerData+0x8>
 802eeb4:	e067      	b.n	802ef86 <LoRaMacSerializerData+0xd8>
 802eeb6:	6801      	ldr	r1, [r0, #0]
 802eeb8:	2900      	cmp	r1, #0
 802eeba:	d066      	beq.n	802ef8a <LoRaMacSerializerData+0xdc>
    uint16_t computedBufSize =   LORAMAC_MHDR_FIELD_SIZE
                               + LORAMAC_FHDR_DEV_ADDR_FIELD_SIZE
                               + LORAMAC_FHDR_F_CTRL_FIELD_SIZE
                               + LORAMAC_FHDR_F_CNT_FIELD_SIZE;

    computedBufSize += macMsg->FHDR.FCtrl.Bits.FOptsLen;
 802eebc:	7b02      	ldrb	r2, [r0, #12]
 802eebe:	0712      	lsls	r2, r2, #28
 802eec0:	0f12      	lsrs	r2, r2, #28
 802eec2:	0010      	movs	r0, r2
 802eec4:	3008      	adds	r0, #8

    if( macMsg->FRMPayloadSize > 0 )
 802eec6:	2328      	movs	r3, #40	; 0x28
 802eec8:	5ce3      	ldrb	r3, [r4, r3]
 802eeca:	2b00      	cmp	r3, #0
 802eecc:	d001      	beq.n	802eed2 <LoRaMacSerializerData+0x24>
    {
        computedBufSize += LORAMAC_F_PORT_FIELD_SIZE;
 802eece:	3209      	adds	r2, #9
 802eed0:	0010      	movs	r0, r2
    }

    computedBufSize += macMsg->FRMPayloadSize;
 802eed2:	181b      	adds	r3, r3, r0
 802eed4:	b29b      	uxth	r3, r3
    computedBufSize += LORAMAC_MIC_FIELD_SIZE;
 802eed6:	3304      	adds	r3, #4
 802eed8:	b29b      	uxth	r3, r3

    if( macMsg->BufSize < computedBufSize )
 802eeda:	7922      	ldrb	r2, [r4, #4]
 802eedc:	429a      	cmp	r2, r3
 802eede:	d356      	bcc.n	802ef8e <LoRaMacSerializerData+0xe0>
    {
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
    }

    macMsg->Buffer[bufItr++] = macMsg->MHDR.Value;
 802eee0:	7963      	ldrb	r3, [r4, #5]
 802eee2:	700b      	strb	r3, [r1, #0]

    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr ) & 0xFF;
 802eee4:	68a3      	ldr	r3, [r4, #8]
 802eee6:	6822      	ldr	r2, [r4, #0]
 802eee8:	7053      	strb	r3, [r2, #1]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 8 ) & 0xFF;
 802eeea:	68a3      	ldr	r3, [r4, #8]
 802eeec:	0a1b      	lsrs	r3, r3, #8
 802eeee:	6822      	ldr	r2, [r4, #0]
 802eef0:	7093      	strb	r3, [r2, #2]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 16 ) & 0xFF;
 802eef2:	8963      	ldrh	r3, [r4, #10]
 802eef4:	6822      	ldr	r2, [r4, #0]
 802eef6:	70d3      	strb	r3, [r2, #3]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.DevAddr >> 24 ) & 0xFF;
 802eef8:	7ae3      	ldrb	r3, [r4, #11]
 802eefa:	6822      	ldr	r2, [r4, #0]
 802eefc:	7113      	strb	r3, [r2, #4]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCtrl.Value;
 802eefe:	7b23      	ldrb	r3, [r4, #12]
 802ef00:	6822      	ldr	r2, [r4, #0]
 802ef02:	7153      	strb	r3, [r2, #5]

    macMsg->Buffer[bufItr++] = macMsg->FHDR.FCnt & 0xFF;
 802ef04:	89e3      	ldrh	r3, [r4, #14]
 802ef06:	6822      	ldr	r2, [r4, #0]
 802ef08:	7193      	strb	r3, [r2, #6]
    macMsg->Buffer[bufItr++] = ( macMsg->FHDR.FCnt >> 8 ) & 0xFF;
 802ef0a:	89e3      	ldrh	r3, [r4, #14]
 802ef0c:	0a1b      	lsrs	r3, r3, #8
 802ef0e:	6822      	ldr	r2, [r4, #0]
 802ef10:	71d3      	strb	r3, [r2, #7]

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FHDR.FOpts, macMsg->FHDR.FCtrl.Bits.FOptsLen );
 802ef12:	0021      	movs	r1, r4
 802ef14:	3110      	adds	r1, #16
 802ef16:	7b22      	ldrb	r2, [r4, #12]
 802ef18:	0712      	lsls	r2, r2, #28
 802ef1a:	0f12      	lsrs	r2, r2, #28
 802ef1c:	6820      	ldr	r0, [r4, #0]
 802ef1e:	3008      	adds	r0, #8
 802ef20:	f003 f8ef 	bl	8032102 <memcpy1>
    bufItr = bufItr + macMsg->FHDR.FCtrl.Bits.FOptsLen;
 802ef24:	7b23      	ldrb	r3, [r4, #12]
 802ef26:	071b      	lsls	r3, r3, #28
 802ef28:	0f1b      	lsrs	r3, r3, #28
 802ef2a:	001d      	movs	r5, r3
 802ef2c:	3508      	adds	r5, #8

    if( macMsg->FRMPayloadSize > 0 )
 802ef2e:	2228      	movs	r2, #40	; 0x28
 802ef30:	5ca2      	ldrb	r2, [r4, r2]
 802ef32:	2a00      	cmp	r2, #0
 802ef34:	d005      	beq.n	802ef42 <LoRaMacSerializerData+0x94>
    {
        macMsg->Buffer[bufItr++] = macMsg->FPort;
 802ef36:	2220      	movs	r2, #32
 802ef38:	5ca2      	ldrb	r2, [r4, r2]
 802ef3a:	6821      	ldr	r1, [r4, #0]
 802ef3c:	554a      	strb	r2, [r1, r5]
 802ef3e:	3309      	adds	r3, #9
 802ef40:	001d      	movs	r5, r3
    }

    memcpy1( &macMsg->Buffer[bufItr], macMsg->FRMPayload, macMsg->FRMPayloadSize );
 802ef42:	2628      	movs	r6, #40	; 0x28
 802ef44:	5da2      	ldrb	r2, [r4, r6]
 802ef46:	6823      	ldr	r3, [r4, #0]
 802ef48:	1958      	adds	r0, r3, r5
 802ef4a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 802ef4c:	f003 f8d9 	bl	8032102 <memcpy1>
    bufItr = bufItr + macMsg->FRMPayloadSize;
 802ef50:	5da3      	ldrb	r3, [r4, r6]
 802ef52:	195b      	adds	r3, r3, r5
 802ef54:	b29b      	uxth	r3, r3

    macMsg->Buffer[bufItr++] = macMsg->MIC & 0xFF;
 802ef56:	1c5a      	adds	r2, r3, #1
 802ef58:	b292      	uxth	r2, r2
 802ef5a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 802ef5c:	6820      	ldr	r0, [r4, #0]
 802ef5e:	54c1      	strb	r1, [r0, r3]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 8 ) & 0xFF;
 802ef60:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 802ef62:	0a08      	lsrs	r0, r1, #8
 802ef64:	1c99      	adds	r1, r3, #2
 802ef66:	b289      	uxth	r1, r1
 802ef68:	6825      	ldr	r5, [r4, #0]
 802ef6a:	54a8      	strb	r0, [r5, r2]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 16 ) & 0xFF;
 802ef6c:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
 802ef6e:	1cda      	adds	r2, r3, #3
 802ef70:	b292      	uxth	r2, r2
 802ef72:	6825      	ldr	r5, [r4, #0]
 802ef74:	5468      	strb	r0, [r5, r1]
    macMsg->Buffer[bufItr++] = ( macMsg->MIC >> 24 ) & 0xFF;
 802ef76:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 802ef78:	0e09      	lsrs	r1, r1, #24
 802ef7a:	3304      	adds	r3, #4
 802ef7c:	6820      	ldr	r0, [r4, #0]
 802ef7e:	5481      	strb	r1, [r0, r2]

    macMsg->BufSize = bufItr;
 802ef80:	7123      	strb	r3, [r4, #4]

    return LORAMAC_SERIALIZER_SUCCESS;
 802ef82:	2000      	movs	r0, #0
}
 802ef84:	bd70      	pop	{r4, r5, r6, pc}
        return LORAMAC_SERIALIZER_ERROR_NPE;
 802ef86:	2001      	movs	r0, #1
 802ef88:	e7fc      	b.n	802ef84 <LoRaMacSerializerData+0xd6>
 802ef8a:	2001      	movs	r0, #1
 802ef8c:	e7fa      	b.n	802ef84 <LoRaMacSerializerData+0xd6>
        return LORAMAC_SERIALIZER_ERROR_BUF_SIZE;
 802ef8e:	2002      	movs	r0, #2
 802ef90:	e7f8      	b.n	802ef84 <LoRaMacSerializerData+0xd6>
	...

0802ef94 <NvmDataMgmtEvent>:
#endif /* CONTEXT_MANAGEMENT_ENABLED == 1 */

void NvmDataMgmtEvent( uint16_t notifyFlags )
{
#if ( CONTEXT_MANAGEMENT_ENABLED == 1 )
    NvmNotifyFlags |= notifyFlags;
 802ef94:	4b02      	ldr	r3, [pc, #8]	; (802efa0 <NvmDataMgmtEvent+0xc>)
 802ef96:	881a      	ldrh	r2, [r3, #0]
 802ef98:	4310      	orrs	r0, r2
 802ef9a:	8018      	strh	r0, [r3, #0]
#endif /* CONTEXT_MANAGEMENT_ENABLED == 1 */
}
 802ef9c:	4770      	bx	lr
 802ef9e:	46c0      	nop			; (mov r8, r8)
 802efa0:	2000c310 	.word	0x2000c310

0802efa4 <NvmDataMgmtStoreBegin>:

int32_t NvmDataMgmtStoreBegin( void )
{
 802efa4:	b510      	push	{r4, lr}
#if ( CONTEXT_MANAGEMENT_ENABLED == 1 )
    /* Input checks */
    if( NvmNotifyFlags == LORAMAC_NVM_NOTIFY_FLAG_NONE )
 802efa6:	4b07      	ldr	r3, [pc, #28]	; (802efc4 <NvmDataMgmtStoreBegin+0x20>)
 802efa8:	881b      	ldrh	r3, [r3, #0]
 802efaa:	2b00      	cmp	r3, #0
 802efac:	d004      	beq.n	802efb8 <NvmDataMgmtStoreBegin+0x14>
    {
        /* There was no update. */
        return NVM_DATA_NO_UPDATED_DATA;
    }
    if( LoRaMacStop( ) != LORAMAC_STATUS_OK )
 802efae:	f7fe f88f 	bl	802d0d0 <LoRaMacStop>
 802efb2:	2800      	cmp	r0, #0
 802efb4:	d103      	bne.n	802efbe <NvmDataMgmtStoreBegin+0x1a>
    }
    return NVM_DATA_OK;
#else
    return NVM_DATA_DISABLED;
#endif /* CONTEXT_MANAGEMENT_ENABLED */
}
 802efb6:	bd10      	pop	{r4, pc}
        return NVM_DATA_NO_UPDATED_DATA;
 802efb8:	2002      	movs	r0, #2
 802efba:	4240      	negs	r0, r0
 802efbc:	e7fb      	b.n	802efb6 <NvmDataMgmtStoreBegin+0x12>
        return NVM_DATA_NOT_AVAILABLE;
 802efbe:	2003      	movs	r0, #3
 802efc0:	4240      	negs	r0, r0
 802efc2:	e7f8      	b.n	802efb6 <NvmDataMgmtStoreBegin+0x12>
 802efc4:	2000c310 	.word	0x2000c310

0802efc8 <NvmDataMgmtStoreEnd>:

int32_t NvmDataMgmtStoreEnd( void )
{
 802efc8:	b510      	push	{r4, lr}
#if ( CONTEXT_MANAGEMENT_ENABLED == 1 )
    /* Reset notification flags */
    NvmNotifyFlags = LORAMAC_NVM_NOTIFY_FLAG_NONE;
 802efca:	4b03      	ldr	r3, [pc, #12]	; (802efd8 <NvmDataMgmtStoreEnd+0x10>)
 802efcc:	2200      	movs	r2, #0
 802efce:	801a      	strh	r2, [r3, #0]

    /* Resume LoRaMac */
    LoRaMacStart( );
 802efd0:	f7fe f872 	bl	802d0b8 <LoRaMacStart>
    return NVM_DATA_OK;
#else
    return NVM_DATA_DISABLED;
#endif /* CONTEXT_MANAGEMENT_ENABLED */
}
 802efd4:	2000      	movs	r0, #0
 802efd6:	bd10      	pop	{r4, pc}
 802efd8:	2000c310 	.word	0x2000c310

0802efdc <RegionIsActive>:
#define RU864_RX_BEACON_SETUP( )
#endif

bool RegionIsActive( LoRaMacRegion_t region )
{
    switch( region )
 802efdc:	2805      	cmp	r0, #5
 802efde:	d005      	beq.n	802efec <RegionIsActive+0x10>
 802efe0:	2808      	cmp	r0, #8
 802efe2:	d001      	beq.n	802efe8 <RegionIsActive+0xc>
        IN865_IS_ACTIVE( );
        US915_IS_ACTIVE( );
        RU864_IS_ACTIVE( );
        default:
        {
            return false;
 802efe4:	2000      	movs	r0, #0
        }
    }
}
 802efe6:	4770      	bx	lr
    switch( region )
 802efe8:	3807      	subs	r0, #7
 802efea:	e7fc      	b.n	802efe6 <RegionIsActive+0xa>
 802efec:	2001      	movs	r0, #1
 802efee:	e7fa      	b.n	802efe6 <RegionIsActive+0xa>

0802eff0 <RegionGetPhyParam>:

PhyParam_t RegionGetPhyParam( LoRaMacRegion_t region, GetPhyParams_t* getPhy )
{
 802eff0:	b500      	push	{lr}
 802eff2:	b083      	sub	sp, #12
 802eff4:	0003      	movs	r3, r0
 802eff6:	0008      	movs	r0, r1
    PhyParam_t phyParam = { 0 };
 802eff8:	2200      	movs	r2, #0
 802effa:	9200      	str	r2, [sp, #0]
    switch( region )
 802effc:	2b05      	cmp	r3, #5
 802effe:	d004      	beq.n	802f00a <RegionGetPhyParam+0x1a>
 802f000:	2b08      	cmp	r3, #8
 802f002:	d008      	beq.n	802f016 <RegionGetPhyParam+0x26>
        IN865_GET_PHY_PARAM( );
        US915_GET_PHY_PARAM( );
        RU864_GET_PHY_PARAM( );
        default:
        {
            return phyParam;
 802f004:	9b00      	ldr	r3, [sp, #0]
 802f006:	9301      	str	r3, [sp, #4]
 802f008:	e002      	b.n	802f010 <RegionGetPhyParam+0x20>
        EU868_GET_PHY_PARAM( );
 802f00a:	f000 fe29 	bl	802fc60 <RegionEU868GetPhyParam>
 802f00e:	9001      	str	r0, [sp, #4]
        }
    }
}
 802f010:	9801      	ldr	r0, [sp, #4]
 802f012:	b003      	add	sp, #12
 802f014:	bd00      	pop	{pc}
        US915_GET_PHY_PARAM( );
 802f016:	f001 fc2f 	bl	8030878 <RegionUS915GetPhyParam>
 802f01a:	9001      	str	r0, [sp, #4]
 802f01c:	e7f8      	b.n	802f010 <RegionGetPhyParam+0x20>

0802f01e <RegionSetBandTxDone>:

void RegionSetBandTxDone( LoRaMacRegion_t region, SetBandTxDoneParams_t* txDone )
{
 802f01e:	b510      	push	{r4, lr}
 802f020:	0003      	movs	r3, r0
 802f022:	0008      	movs	r0, r1
    switch( region )
 802f024:	2b05      	cmp	r3, #5
 802f026:	d002      	beq.n	802f02e <RegionSetBandTxDone+0x10>
 802f028:	2b08      	cmp	r3, #8
 802f02a:	d003      	beq.n	802f034 <RegionSetBandTxDone+0x16>
        default:
        {
            return;
        }
    }
}
 802f02c:	bd10      	pop	{r4, pc}
        EU868_SET_BAND_TX_DONE( );
 802f02e:	f000 fec7 	bl	802fdc0 <RegionEU868SetBandTxDone>
 802f032:	e7fb      	b.n	802f02c <RegionSetBandTxDone+0xe>
        US915_SET_BAND_TX_DONE( );
 802f034:	f001 fce2 	bl	80309fc <RegionUS915SetBandTxDone>
 802f038:	e7f8      	b.n	802f02c <RegionSetBandTxDone+0xe>

0802f03a <RegionInitDefaults>:

void RegionInitDefaults( LoRaMacRegion_t region, InitDefaultsParams_t* params )
{
 802f03a:	b510      	push	{r4, lr}
 802f03c:	0003      	movs	r3, r0
 802f03e:	0008      	movs	r0, r1
    switch( region )
 802f040:	2b05      	cmp	r3, #5
 802f042:	d002      	beq.n	802f04a <RegionInitDefaults+0x10>
 802f044:	2b08      	cmp	r3, #8
 802f046:	d003      	beq.n	802f050 <RegionInitDefaults+0x16>
        default:
        {
            break;
        }
    }
}
 802f048:	bd10      	pop	{r4, pc}
        EU868_INIT_DEFAULTS( );
 802f04a:	f000 fed7 	bl	802fdfc <RegionEU868InitDefaults>
 802f04e:	e7fb      	b.n	802f048 <RegionInitDefaults+0xe>
        US915_INIT_DEFAULTS( );
 802f050:	f001 fcf2 	bl	8030a38 <RegionUS915InitDefaults>
}
 802f054:	e7f8      	b.n	802f048 <RegionInitDefaults+0xe>

0802f056 <RegionVerify>:

bool RegionVerify( LoRaMacRegion_t region, VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 802f056:	b510      	push	{r4, lr}
 802f058:	0003      	movs	r3, r0
 802f05a:	0008      	movs	r0, r1
 802f05c:	0011      	movs	r1, r2
    switch( region )
 802f05e:	2b05      	cmp	r3, #5
 802f060:	d003      	beq.n	802f06a <RegionVerify+0x14>
 802f062:	2b08      	cmp	r3, #8
 802f064:	d004      	beq.n	802f070 <RegionVerify+0x1a>
 802f066:	2000      	movs	r0, #0
        default:
        {
            return false;
        }
    }
}
 802f068:	bd10      	pop	{r4, pc}
        EU868_VERIFY( );
 802f06a:	f000 ff33 	bl	802fed4 <RegionEU868Verify>
 802f06e:	e7fb      	b.n	802f068 <RegionVerify+0x12>
        US915_VERIFY( );
 802f070:	f001 fd92 	bl	8030b98 <RegionUS915Verify>
 802f074:	e7f8      	b.n	802f068 <RegionVerify+0x12>

0802f076 <RegionApplyCFList>:

void RegionApplyCFList( LoRaMacRegion_t region, ApplyCFListParams_t* applyCFList )
{
 802f076:	b510      	push	{r4, lr}
 802f078:	0003      	movs	r3, r0
 802f07a:	0008      	movs	r0, r1
    switch( region )
 802f07c:	2b05      	cmp	r3, #5
 802f07e:	d002      	beq.n	802f086 <RegionApplyCFList+0x10>
 802f080:	2b08      	cmp	r3, #8
 802f082:	d003      	beq.n	802f08c <RegionApplyCFList+0x16>
        default:
        {
            break;
        }
    }
}
 802f084:	bd10      	pop	{r4, pc}
        EU868_APPLY_CF_LIST( );
 802f086:	f001 fb1d 	bl	80306c4 <RegionEU868ApplyCFList>
 802f08a:	e7fb      	b.n	802f084 <RegionApplyCFList+0xe>
        US915_APPLY_CF_LIST( );
 802f08c:	f001 fdbc 	bl	8030c08 <RegionUS915ApplyCFList>
}
 802f090:	e7f8      	b.n	802f084 <RegionApplyCFList+0xe>

0802f092 <RegionChanMaskSet>:

bool RegionChanMaskSet( LoRaMacRegion_t region, ChanMaskSetParams_t* chanMaskSet )
{
 802f092:	b510      	push	{r4, lr}
 802f094:	0003      	movs	r3, r0
 802f096:	0008      	movs	r0, r1
    switch( region )
 802f098:	2b05      	cmp	r3, #5
 802f09a:	d003      	beq.n	802f0a4 <RegionChanMaskSet+0x12>
 802f09c:	2b08      	cmp	r3, #8
 802f09e:	d004      	beq.n	802f0aa <RegionChanMaskSet+0x18>
 802f0a0:	2000      	movs	r0, #0
        default:
        {
            return false;
        }
    }
}
 802f0a2:	bd10      	pop	{r4, pc}
        EU868_CHAN_MASK_SET( );
 802f0a4:	f000 ff56 	bl	802ff54 <RegionEU868ChanMaskSet>
 802f0a8:	e7fb      	b.n	802f0a2 <RegionChanMaskSet+0x10>
        US915_CHAN_MASK_SET( );
 802f0aa:	f001 fde7 	bl	8030c7c <RegionUS915ChanMaskSet>
 802f0ae:	e7f8      	b.n	802f0a2 <RegionChanMaskSet+0x10>

0802f0b0 <RegionComputeRxWindowParameters>:

void RegionComputeRxWindowParameters( LoRaMacRegion_t region, int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 802f0b0:	b510      	push	{r4, lr}
 802f0b2:	0004      	movs	r4, r0
 802f0b4:	0008      	movs	r0, r1
 802f0b6:	0011      	movs	r1, r2
 802f0b8:	001a      	movs	r2, r3
    switch( region )
 802f0ba:	2c05      	cmp	r4, #5
 802f0bc:	d002      	beq.n	802f0c4 <RegionComputeRxWindowParameters+0x14>
 802f0be:	2c08      	cmp	r4, #8
 802f0c0:	d004      	beq.n	802f0cc <RegionComputeRxWindowParameters+0x1c>
        default:
        {
            break;
        }
    }
}
 802f0c2:	bd10      	pop	{r4, pc}
        EU868_COMPUTE_RX_WINDOW_PARAMETERS( );
 802f0c4:	9b02      	ldr	r3, [sp, #8]
 802f0c6:	f000 ff69 	bl	802ff9c <RegionEU868ComputeRxWindowParameters>
 802f0ca:	e7fa      	b.n	802f0c2 <RegionComputeRxWindowParameters+0x12>
        US915_COMPUTE_RX_WINDOW_PARAMETERS( );
 802f0cc:	9b02      	ldr	r3, [sp, #8]
 802f0ce:	f001 fe1f 	bl	8030d10 <RegionUS915ComputeRxWindowParameters>
}
 802f0d2:	e7f6      	b.n	802f0c2 <RegionComputeRxWindowParameters+0x12>

0802f0d4 <RegionRxConfig>:

bool RegionRxConfig( LoRaMacRegion_t region, RxConfigParams_t* rxConfig, int8_t* datarate )
{
 802f0d4:	b510      	push	{r4, lr}
 802f0d6:	0003      	movs	r3, r0
 802f0d8:	0008      	movs	r0, r1
 802f0da:	0011      	movs	r1, r2
    switch( region )
 802f0dc:	2b05      	cmp	r3, #5
 802f0de:	d003      	beq.n	802f0e8 <RegionRxConfig+0x14>
 802f0e0:	2b08      	cmp	r3, #8
 802f0e2:	d004      	beq.n	802f0ee <RegionRxConfig+0x1a>
 802f0e4:	2000      	movs	r0, #0
        default:
        {
            return false;
        }
    }
}
 802f0e6:	bd10      	pop	{r4, pc}
        EU868_RX_CONFIG( );
 802f0e8:	f000 ff90 	bl	803000c <RegionEU868RxConfig>
 802f0ec:	e7fb      	b.n	802f0e6 <RegionRxConfig+0x12>
        US915_RX_CONFIG( );
 802f0ee:	f001 fe3f 	bl	8030d70 <RegionUS915RxConfig>
 802f0f2:	e7f8      	b.n	802f0e6 <RegionRxConfig+0x12>

0802f0f4 <RegionTxConfig>:

bool RegionTxConfig( LoRaMacRegion_t region, TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 802f0f4:	b510      	push	{r4, lr}
 802f0f6:	0004      	movs	r4, r0
 802f0f8:	0008      	movs	r0, r1
 802f0fa:	0011      	movs	r1, r2
 802f0fc:	001a      	movs	r2, r3
    switch( region )
 802f0fe:	2c05      	cmp	r4, #5
 802f100:	d003      	beq.n	802f10a <RegionTxConfig+0x16>
 802f102:	2c08      	cmp	r4, #8
 802f104:	d004      	beq.n	802f110 <RegionTxConfig+0x1c>
 802f106:	2000      	movs	r0, #0
        default:
        {
            return false;
        }
    }
}
 802f108:	bd10      	pop	{r4, pc}
        EU868_TX_CONFIG( );
 802f10a:	f001 f809 	bl	8030120 <RegionEU868TxConfig>
 802f10e:	e7fb      	b.n	802f108 <RegionTxConfig+0x14>
        US915_TX_CONFIG( );
 802f110:	f001 fe8e 	bl	8030e30 <RegionUS915TxConfig>
 802f114:	e7f8      	b.n	802f108 <RegionTxConfig+0x14>

0802f116 <RegionLinkAdrReq>:

uint8_t RegionLinkAdrReq( LoRaMacRegion_t region, LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 802f116:	b510      	push	{r4, lr}
 802f118:	b082      	sub	sp, #8
 802f11a:	0004      	movs	r4, r0
 802f11c:	0008      	movs	r0, r1
 802f11e:	0011      	movs	r1, r2
 802f120:	001a      	movs	r2, r3
    switch( region )
 802f122:	2c05      	cmp	r4, #5
 802f124:	d004      	beq.n	802f130 <RegionLinkAdrReq+0x1a>
 802f126:	2c08      	cmp	r4, #8
 802f128:	d008      	beq.n	802f13c <RegionLinkAdrReq+0x26>
 802f12a:	2000      	movs	r0, #0
        default:
        {
            return 0;
        }
    }
}
 802f12c:	b002      	add	sp, #8
 802f12e:	bd10      	pop	{r4, pc}
        EU868_LINK_ADR_REQ( );
 802f130:	9b05      	ldr	r3, [sp, #20]
 802f132:	9300      	str	r3, [sp, #0]
 802f134:	9b04      	ldr	r3, [sp, #16]
 802f136:	f001 f88f 	bl	8030258 <RegionEU868LinkAdrReq>
 802f13a:	e7f7      	b.n	802f12c <RegionLinkAdrReq+0x16>
        US915_LINK_ADR_REQ( );
 802f13c:	9b05      	ldr	r3, [sp, #20]
 802f13e:	9300      	str	r3, [sp, #0]
 802f140:	9b04      	ldr	r3, [sp, #16]
 802f142:	f001 fef5 	bl	8030f30 <RegionUS915LinkAdrReq>
 802f146:	e7f1      	b.n	802f12c <RegionLinkAdrReq+0x16>

0802f148 <RegionRxParamSetupReq>:

uint8_t RegionRxParamSetupReq( LoRaMacRegion_t region, RxParamSetupReqParams_t* rxParamSetupReq )
{
 802f148:	b510      	push	{r4, lr}
 802f14a:	0003      	movs	r3, r0
 802f14c:	0008      	movs	r0, r1
    switch( region )
 802f14e:	2b05      	cmp	r3, #5
 802f150:	d003      	beq.n	802f15a <RegionRxParamSetupReq+0x12>
 802f152:	2b08      	cmp	r3, #8
 802f154:	d004      	beq.n	802f160 <RegionRxParamSetupReq+0x18>
 802f156:	2000      	movs	r0, #0
        default:
        {
            return 0;
        }
    }
}
 802f158:	bd10      	pop	{r4, pc}
        EU868_RX_PARAM_SETUP_REQ( );
 802f15a:	f001 f945 	bl	80303e8 <RegionEU868RxParamSetupReq>
 802f15e:	e7fb      	b.n	802f158 <RegionRxParamSetupReq+0x10>
        US915_RX_PARAM_SETUP_REQ( );
 802f160:	f002 f826 	bl	80311b0 <RegionUS915RxParamSetupReq>
 802f164:	e7f8      	b.n	802f158 <RegionRxParamSetupReq+0x10>

0802f166 <RegionNewChannelReq>:

int8_t RegionNewChannelReq( LoRaMacRegion_t region, NewChannelReqParams_t* newChannelReq )
{
 802f166:	b510      	push	{r4, lr}
 802f168:	0003      	movs	r3, r0
 802f16a:	0008      	movs	r0, r1
    switch( region )
 802f16c:	2b05      	cmp	r3, #5
 802f16e:	d003      	beq.n	802f178 <RegionNewChannelReq+0x12>
 802f170:	2b08      	cmp	r3, #8
 802f172:	d004      	beq.n	802f17e <RegionNewChannelReq+0x18>
 802f174:	2000      	movs	r0, #0
        default:
        {
            return 0;
        }
    }
}
 802f176:	bd10      	pop	{r4, pc}
        EU868_NEW_CHANNEL_REQ( );
 802f178:	f001 fae3 	bl	8030742 <RegionEU868NewChannelReq>
 802f17c:	e7fb      	b.n	802f176 <RegionNewChannelReq+0x10>
        US915_NEW_CHANNEL_REQ( );
 802f17e:	f002 f845 	bl	803120c <RegionUS915NewChannelReq>
 802f182:	e7f8      	b.n	802f176 <RegionNewChannelReq+0x10>

0802f184 <RegionTxParamSetupReq>:

int8_t RegionTxParamSetupReq( LoRaMacRegion_t region, TxParamSetupReqParams_t* txParamSetupReq )
{
 802f184:	b510      	push	{r4, lr}
 802f186:	0003      	movs	r3, r0
 802f188:	0008      	movs	r0, r1
    switch( region )
 802f18a:	2b05      	cmp	r3, #5
 802f18c:	d003      	beq.n	802f196 <RegionTxParamSetupReq+0x12>
 802f18e:	2b08      	cmp	r3, #8
 802f190:	d004      	beq.n	802f19c <RegionTxParamSetupReq+0x18>
 802f192:	2000      	movs	r0, #0
        default:
        {
            return 0;
        }
    }
}
 802f194:	bd10      	pop	{r4, pc}
        EU868_TX_PARAM_SETUP_REQ( );
 802f196:	f001 f94d 	bl	8030434 <RegionEU868TxParamSetupReq>
 802f19a:	e7fb      	b.n	802f194 <RegionTxParamSetupReq+0x10>
        US915_TX_PARAM_SETUP_REQ( );
 802f19c:	f002 f839 	bl	8031212 <RegionUS915TxParamSetupReq>
 802f1a0:	e7f8      	b.n	802f194 <RegionTxParamSetupReq+0x10>

0802f1a2 <RegionDlChannelReq>:

int8_t RegionDlChannelReq( LoRaMacRegion_t region, DlChannelReqParams_t* dlChannelReq )
{
 802f1a2:	b510      	push	{r4, lr}
 802f1a4:	0003      	movs	r3, r0
 802f1a6:	0008      	movs	r0, r1
    switch( region )
 802f1a8:	2b05      	cmp	r3, #5
 802f1aa:	d003      	beq.n	802f1b4 <RegionDlChannelReq+0x12>
 802f1ac:	2b08      	cmp	r3, #8
 802f1ae:	d004      	beq.n	802f1ba <RegionDlChannelReq+0x18>
 802f1b0:	2000      	movs	r0, #0
        default:
        {
            return 0;
        }
    }
}
 802f1b2:	bd10      	pop	{r4, pc}
        EU868_DL_CHANNEL_REQ( );
 802f1b4:	f001 f942 	bl	803043c <RegionEU868DlChannelReq>
 802f1b8:	e7fb      	b.n	802f1b2 <RegionDlChannelReq+0x10>
        US915_DL_CHANNEL_REQ( );
 802f1ba:	f002 f82d 	bl	8031218 <RegionUS915DlChannelReq>
 802f1be:	e7f8      	b.n	802f1b2 <RegionDlChannelReq+0x10>

0802f1c0 <RegionAlternateDr>:

int8_t RegionAlternateDr( LoRaMacRegion_t region, int8_t currentDr, AlternateDrType_t type )
{
 802f1c0:	b510      	push	{r4, lr}
 802f1c2:	0003      	movs	r3, r0
 802f1c4:	0008      	movs	r0, r1
 802f1c6:	0011      	movs	r1, r2
    switch( region )
 802f1c8:	2b05      	cmp	r3, #5
 802f1ca:	d003      	beq.n	802f1d4 <RegionAlternateDr+0x14>
 802f1cc:	2b08      	cmp	r3, #8
 802f1ce:	d004      	beq.n	802f1da <RegionAlternateDr+0x1a>
 802f1d0:	2000      	movs	r0, #0
        default:
        {
            return 0;
        }
    }
}
 802f1d2:	bd10      	pop	{r4, pc}
        EU868_ALTERNATE_DR( );
 802f1d4:	f001 f960 	bl	8030498 <RegionEU868AlternateDr>
 802f1d8:	e7fb      	b.n	802f1d2 <RegionAlternateDr+0x12>
        US915_ALTERNATE_DR( );
 802f1da:	f002 f821 	bl	8031220 <RegionUS915AlternateDr>
 802f1de:	e7f8      	b.n	802f1d2 <RegionAlternateDr+0x12>

0802f1e0 <RegionNextChannel>:

LoRaMacStatus_t RegionNextChannel( LoRaMacRegion_t region, NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 802f1e0:	b510      	push	{r4, lr}
 802f1e2:	0004      	movs	r4, r0
 802f1e4:	0008      	movs	r0, r1
 802f1e6:	0011      	movs	r1, r2
 802f1e8:	001a      	movs	r2, r3
    switch( region )
 802f1ea:	2c05      	cmp	r4, #5
 802f1ec:	d003      	beq.n	802f1f6 <RegionNextChannel+0x16>
 802f1ee:	2c08      	cmp	r4, #8
 802f1f0:	d005      	beq.n	802f1fe <RegionNextChannel+0x1e>
 802f1f2:	2009      	movs	r0, #9
        default:
        {
            return LORAMAC_STATUS_REGION_NOT_SUPPORTED;
        }
    }
}
 802f1f4:	bd10      	pop	{r4, pc}
        EU868_NEXT_CHANNEL( );
 802f1f6:	9b02      	ldr	r3, [sp, #8]
 802f1f8:	f001 f950 	bl	803049c <RegionEU868NextChannel>
 802f1fc:	e7fa      	b.n	802f1f4 <RegionNextChannel+0x14>
        US915_NEXT_CHANNEL( );
 802f1fe:	9b02      	ldr	r3, [sp, #8]
 802f200:	f002 f82c 	bl	803125c <RegionUS915NextChannel>
 802f204:	e7f6      	b.n	802f1f4 <RegionNextChannel+0x14>

0802f206 <RegionApplyDrOffset>:
    }
}
#endif /* REGION_VERSION */

uint8_t RegionApplyDrOffset( LoRaMacRegion_t region, uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
 802f206:	b510      	push	{r4, lr}
 802f208:	0004      	movs	r4, r0
 802f20a:	0008      	movs	r0, r1
 802f20c:	0011      	movs	r1, r2
 802f20e:	001a      	movs	r2, r3
    switch( region )
 802f210:	2c05      	cmp	r4, #5
 802f212:	d003      	beq.n	802f21c <RegionApplyDrOffset+0x16>
 802f214:	2c08      	cmp	r4, #8
 802f216:	d004      	beq.n	802f222 <RegionApplyDrOffset+0x1c>
        IN865_APPLY_DR_OFFSET( );
        US915_APPLY_DR_OFFSET( );
        RU864_APPLY_DR_OFFSET( );
        default:
        {
            return dr;
 802f218:	b2c8      	uxtb	r0, r1
 802f21a:	e001      	b.n	802f220 <RegionApplyDrOffset+0x1a>
        EU868_APPLY_DR_OFFSET( );
 802f21c:	f001 fabc 	bl	8030798 <RegionEU868ApplyDrOffset>
        }
    }
}
 802f220:	bd10      	pop	{r4, pc}
        US915_APPLY_DR_OFFSET( );
 802f222:	f002 f8cb 	bl	80313bc <RegionUS915ApplyDrOffset>
 802f226:	e7fb      	b.n	802f220 <RegionApplyDrOffset+0x1a>

0802f228 <RegionGetVersion>:
    Version_t version;

    version.Value = REGION_VERSION;

    return version;
}
 802f228:	4800      	ldr	r0, [pc, #0]	; (802f22c <RegionGetVersion+0x4>)
 802f22a:	4770      	bx	lr
 802f22c:	02010001 	.word	0x02010001

0802f230 <FindAvailable125kHzChannels>:
 *
 * \retval Status
 */
static LoRaMacStatus_t FindAvailable125kHzChannels( uint16_t currentChannelMaskLeft,
                                                    uint8_t* findAvailableChannelsIndex, uint8_t* availableChannels )
{
 802f230:	b510      	push	{r4, lr}
    // Nullpointer check
    if( findAvailableChannelsIndex == NULL || availableChannels == NULL )
 802f232:	2900      	cmp	r1, #0
 802f234:	d014      	beq.n	802f260 <FindAvailable125kHzChannels+0x30>
 802f236:	2a00      	cmp	r2, #0
 802f238:	d014      	beq.n	802f264 <FindAvailable125kHzChannels+0x34>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    // Initialize counter
    *availableChannels = 0;
 802f23a:	2300      	movs	r3, #0
 802f23c:	7013      	strb	r3, [r2, #0]
    for( uint8_t i = 0; i < 8; i++ )
 802f23e:	e001      	b.n	802f244 <FindAvailable125kHzChannels+0x14>
 802f240:	3301      	adds	r3, #1
 802f242:	b2db      	uxtb	r3, r3
 802f244:	2b07      	cmp	r3, #7
 802f246:	d809      	bhi.n	802f25c <FindAvailable125kHzChannels+0x2c>
    {
        // Find available channels
        if( ( currentChannelMaskLeft & ( 1 << i ) ) != 0 )
 802f248:	0004      	movs	r4, r0
 802f24a:	411c      	asrs	r4, r3
 802f24c:	07e4      	lsls	r4, r4, #31
 802f24e:	d5f7      	bpl.n	802f240 <FindAvailable125kHzChannels+0x10>
        {
            // Save available channel index
            findAvailableChannelsIndex[*availableChannels] = i;
 802f250:	7814      	ldrb	r4, [r2, #0]
 802f252:	550b      	strb	r3, [r1, r4]
            // Increment counter of available channels if the current channel is available
            ( *availableChannels )++;
 802f254:	7814      	ldrb	r4, [r2, #0]
 802f256:	3401      	adds	r4, #1
 802f258:	7014      	strb	r4, [r2, #0]
 802f25a:	e7f1      	b.n	802f240 <FindAvailable125kHzChannels+0x10>
        }
    }

    return LORAMAC_STATUS_OK;
 802f25c:	2000      	movs	r0, #0
}
 802f25e:	bd10      	pop	{r4, pc}
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802f260:	2003      	movs	r0, #3
 802f262:	e7fc      	b.n	802f25e <FindAvailable125kHzChannels+0x2e>
 802f264:	2003      	movs	r0, #3
 802f266:	e7fa      	b.n	802f25e <FindAvailable125kHzChannels+0x2e>

0802f268 <RegionBaseUSComputeNext125kHzJoinChannel>:

LoRaMacStatus_t RegionBaseUSComputeNext125kHzJoinChannel( uint16_t* channelsMaskRemaining,
                                                          uint8_t* groupsCurrentIndex, uint8_t* newChannelIndex )
{
 802f268:	b5f0      	push	{r4, r5, r6, r7, lr}
 802f26a:	b085      	sub	sp, #20
 802f26c:	0006      	movs	r6, r0
 802f26e:	000d      	movs	r5, r1
 802f270:	0017      	movs	r7, r2
    uint8_t currentChannelMaskLeftIndex;
    uint16_t currentChannelMaskLeft;
    uint8_t findAvailableChannelsIndex[8] = { 0 };
 802f272:	2300      	movs	r3, #0
 802f274:	9302      	str	r3, [sp, #8]
 802f276:	9303      	str	r3, [sp, #12]
    uint8_t availableChannels = 0;
 802f278:	466a      	mov	r2, sp
 802f27a:	71d3      	strb	r3, [r2, #7]
    uint8_t startIndex;

    // Null pointer check
    if( channelsMaskRemaining == NULL || groupsCurrentIndex == NULL || newChannelIndex == NULL )
 802f27c:	2800      	cmp	r0, #0
 802f27e:	d03b      	beq.n	802f2f8 <RegionBaseUSComputeNext125kHzJoinChannel+0x90>
 802f280:	2900      	cmp	r1, #0
 802f282:	d03b      	beq.n	802f2fc <RegionBaseUSComputeNext125kHzJoinChannel+0x94>
 802f284:	2f00      	cmp	r7, #0
 802f286:	d03b      	beq.n	802f300 <RegionBaseUSComputeNext125kHzJoinChannel+0x98>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    // copy the current index.
    startIndex = *groupsCurrentIndex;
 802f288:	780c      	ldrb	r4, [r1, #0]
 802f28a:	e015      	b.n	802f2b8 <RegionBaseUSComputeNext125kHzJoinChannel+0x50>
        {
            currentChannelMaskLeft = ( channelsMaskRemaining[currentChannelMaskLeftIndex] & 0x00FF );
        }
        else
        {
            currentChannelMaskLeft = ( ( channelsMaskRemaining[currentChannelMaskLeftIndex] >> 8 ) & 0x00FF );
 802f28c:	005b      	lsls	r3, r3, #1
 802f28e:	5b98      	ldrh	r0, [r3, r6]
 802f290:	0a00      	lsrs	r0, r0, #8
 802f292:	e018      	b.n	802f2c6 <RegionBaseUSComputeNext125kHzJoinChannel+0x5e>
        }

        if ( availableChannels > 0 )
        {
            // Choose randomly a free channel 125kHz
            *newChannelIndex = ( startIndex * 8 ) + findAvailableChannelsIndex[randr( 0, ( availableChannels - 1 ) )];
 802f294:	3901      	subs	r1, #1
 802f296:	2000      	movs	r0, #0
 802f298:	f002 ff28 	bl	80320ec <randr>
 802f29c:	ab02      	add	r3, sp, #8
 802f29e:	5c1b      	ldrb	r3, [r3, r0]
 802f2a0:	00e2      	lsls	r2, r4, #3
 802f2a2:	189b      	adds	r3, r3, r2
 802f2a4:	703b      	strb	r3, [r7, #0]
 802f2a6:	e019      	b.n	802f2dc <RegionBaseUSComputeNext125kHzJoinChannel+0x74>
        startIndex++;
        if ( startIndex > 7 )
        {
            startIndex = 0;
        }
    } while( ( availableChannels == 0 ) && ( startIndex != *groupsCurrentIndex ) );
 802f2a8:	466b      	mov	r3, sp
 802f2aa:	3307      	adds	r3, #7
 802f2ac:	781b      	ldrb	r3, [r3, #0]
 802f2ae:	2b00      	cmp	r3, #0
 802f2b0:	d11a      	bne.n	802f2e8 <RegionBaseUSComputeNext125kHzJoinChannel+0x80>
 802f2b2:	782a      	ldrb	r2, [r5, #0]
 802f2b4:	42a2      	cmp	r2, r4
 802f2b6:	d017      	beq.n	802f2e8 <RegionBaseUSComputeNext125kHzJoinChannel+0x80>
        currentChannelMaskLeftIndex = (uint8_t) startIndex / 2;
 802f2b8:	0863      	lsrs	r3, r4, #1
        if( ( startIndex % 2 ) == 0 )
 802f2ba:	07e2      	lsls	r2, r4, #31
 802f2bc:	d4e6      	bmi.n	802f28c <RegionBaseUSComputeNext125kHzJoinChannel+0x24>
            currentChannelMaskLeft = ( channelsMaskRemaining[currentChannelMaskLeftIndex] & 0x00FF );
 802f2be:	005b      	lsls	r3, r3, #1
 802f2c0:	5b9b      	ldrh	r3, [r3, r6]
 802f2c2:	20ff      	movs	r0, #255	; 0xff
 802f2c4:	4018      	ands	r0, r3
        if( FindAvailable125kHzChannels( currentChannelMaskLeft, findAvailableChannelsIndex, &availableChannels ) == LORAMAC_STATUS_PARAMETER_INVALID )
 802f2c6:	466b      	mov	r3, sp
 802f2c8:	1dda      	adds	r2, r3, #7
 802f2ca:	a902      	add	r1, sp, #8
 802f2cc:	f7ff ffb0 	bl	802f230 <FindAvailable125kHzChannels>
 802f2d0:	2803      	cmp	r0, #3
 802f2d2:	d00c      	beq.n	802f2ee <RegionBaseUSComputeNext125kHzJoinChannel+0x86>
        if ( availableChannels > 0 )
 802f2d4:	466b      	mov	r3, sp
 802f2d6:	79d9      	ldrb	r1, [r3, #7]
 802f2d8:	2900      	cmp	r1, #0
 802f2da:	d1db      	bne.n	802f294 <RegionBaseUSComputeNext125kHzJoinChannel+0x2c>
        startIndex++;
 802f2dc:	3401      	adds	r4, #1
 802f2de:	b2e4      	uxtb	r4, r4
        if ( startIndex > 7 )
 802f2e0:	2c07      	cmp	r4, #7
 802f2e2:	d9e1      	bls.n	802f2a8 <RegionBaseUSComputeNext125kHzJoinChannel+0x40>
            startIndex = 0;
 802f2e4:	2400      	movs	r4, #0
 802f2e6:	e7df      	b.n	802f2a8 <RegionBaseUSComputeNext125kHzJoinChannel+0x40>

    if ( availableChannels > 0 )
 802f2e8:	2b00      	cmp	r3, #0
 802f2ea:	d102      	bne.n	802f2f2 <RegionBaseUSComputeNext125kHzJoinChannel+0x8a>
    {
        *groupsCurrentIndex = startIndex;
        return LORAMAC_STATUS_OK;
    }

    return LORAMAC_STATUS_PARAMETER_INVALID;
 802f2ec:	2003      	movs	r0, #3
}
 802f2ee:	b005      	add	sp, #20
 802f2f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        *groupsCurrentIndex = startIndex;
 802f2f2:	702c      	strb	r4, [r5, #0]
        return LORAMAC_STATUS_OK;
 802f2f4:	2000      	movs	r0, #0
 802f2f6:	e7fa      	b.n	802f2ee <RegionBaseUSComputeNext125kHzJoinChannel+0x86>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 802f2f8:	2003      	movs	r0, #3
 802f2fa:	e7f8      	b.n	802f2ee <RegionBaseUSComputeNext125kHzJoinChannel+0x86>
 802f2fc:	2003      	movs	r0, #3
 802f2fe:	e7f6      	b.n	802f2ee <RegionBaseUSComputeNext125kHzJoinChannel+0x86>
 802f300:	2003      	movs	r0, #3
 802f302:	e7f4      	b.n	802f2ee <RegionBaseUSComputeNext125kHzJoinChannel+0x86>

0802f304 <RegionBaseUSCalcDownlinkFrequency>:

uint32_t RegionBaseUSCalcDownlinkFrequency( uint8_t channel, uint32_t frequency,
                                            uint32_t stepwidth )
{
    // Calculate the frequency
    return frequency + ( channel * stepwidth );
 802f304:	4350      	muls	r0, r2
 802f306:	1840      	adds	r0, r0, r1
}
 802f308:	4770      	bx	lr
	...

0802f30c <GetDutyCycle>:
#ifdef MW_LOG_ENABLED
static const char *EventRXSlotStrings[] = { "1", "2", "C", "Multi_C", "P", "Multi_P" };
#endif

static uint16_t GetDutyCycle( Band_t* band, bool joined, SysTime_t elapsedTimeSinceStartup )
{
 802f30c:	b082      	sub	sp, #8
 802f30e:	9200      	str	r2, [sp, #0]
 802f310:	9301      	str	r3, [sp, #4]
    uint16_t dutyCycle = band->DCycle;
 802f312:	8800      	ldrh	r0, [r0, #0]

    if( joined == false )
 802f314:	2900      	cmp	r1, #0
 802f316:	d110      	bne.n	802f33a <GetDutyCycle+0x2e>
    {
        uint16_t joinDutyCycle = BACKOFF_DC_24_HOURS;

        if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_1_HOUR_IN_S )
 802f318:	0013      	movs	r3, r2
 802f31a:	22e1      	movs	r2, #225	; 0xe1
 802f31c:	0112      	lsls	r2, r2, #4
 802f31e:	4293      	cmp	r3, r2
 802f320:	d305      	bcc.n	802f32e <GetDutyCycle+0x22>
        {
            joinDutyCycle = BACKOFF_DC_1_HOUR;
        }
        else if( elapsedTimeSinceStartup.Seconds < BACKOFF_DUTY_CYCLE_10_HOURS_IN_S )
 802f322:	4a09      	ldr	r2, [pc, #36]	; (802f348 <GetDutyCycle+0x3c>)
 802f324:	4293      	cmp	r3, r2
 802f326:	d80d      	bhi.n	802f344 <GetDutyCycle+0x38>
        {
            joinDutyCycle = BACKOFF_DC_10_HOURS;
 802f328:	23fa      	movs	r3, #250	; 0xfa
 802f32a:	009b      	lsls	r3, r3, #2
 802f32c:	e000      	b.n	802f330 <GetDutyCycle+0x24>
            joinDutyCycle = BACKOFF_DC_1_HOUR;
 802f32e:	2364      	movs	r3, #100	; 0x64
        else
        {
            joinDutyCycle = BACKOFF_DC_24_HOURS;
        }
        // Take the most restrictive duty cycle
        dutyCycle = MAX( dutyCycle, joinDutyCycle );
 802f330:	1c1a      	adds	r2, r3, #0
 802f332:	4283      	cmp	r3, r0
 802f334:	d200      	bcs.n	802f338 <GetDutyCycle+0x2c>
 802f336:	1c02      	adds	r2, r0, #0
 802f338:	b290      	uxth	r0, r2
    }

    // Prevent value of 0
    if( dutyCycle == 0 )
 802f33a:	2800      	cmp	r0, #0
 802f33c:	d100      	bne.n	802f340 <GetDutyCycle+0x34>
    {
        dutyCycle = 1;
 802f33e:	3001      	adds	r0, #1
    }

    return dutyCycle;
}
 802f340:	b002      	add	sp, #8
 802f342:	4770      	bx	lr
            joinDutyCycle = BACKOFF_DC_24_HOURS;
 802f344:	4b01      	ldr	r3, [pc, #4]	; (802f34c <GetDutyCycle+0x40>)
 802f346:	e7f3      	b.n	802f330 <GetDutyCycle+0x24>
 802f348:	00009aaf 	.word	0x00009aaf
 802f34c:	00002710 	.word	0x00002710

0802f350 <CountChannels>:

    return dutyCycle;
}

static uint8_t CountChannels( uint16_t mask, uint8_t nbBits )
{
 802f350:	b530      	push	{r4, r5, lr}
 802f352:	0005      	movs	r5, r0
    uint8_t nbActiveBits = 0;

    for( uint8_t j = 0; j < nbBits; j++ )
 802f354:	2300      	movs	r3, #0
    uint8_t nbActiveBits = 0;
 802f356:	2000      	movs	r0, #0
    for( uint8_t j = 0; j < nbBits; j++ )
 802f358:	e001      	b.n	802f35e <CountChannels+0xe>
 802f35a:	3301      	adds	r3, #1
 802f35c:	b2db      	uxtb	r3, r3
 802f35e:	428b      	cmp	r3, r1
 802f360:	d208      	bcs.n	802f374 <CountChannels+0x24>
    {
        if( ( mask & ( 1 << j ) ) == ( 1 << j ) )
 802f362:	2201      	movs	r2, #1
 802f364:	409a      	lsls	r2, r3
 802f366:	0014      	movs	r4, r2
 802f368:	402c      	ands	r4, r5
 802f36a:	42a2      	cmp	r2, r4
 802f36c:	d1f5      	bne.n	802f35a <CountChannels+0xa>
        {
            nbActiveBits++;
 802f36e:	3001      	adds	r0, #1
 802f370:	b2c0      	uxtb	r0, r0
 802f372:	e7f2      	b.n	802f35a <CountChannels+0xa>
        }
    }
    return nbActiveBits;
}
 802f374:	bd30      	pop	{r4, r5, pc}
	...

0802f378 <SetMaxTimeCredits>:
{
 802f378:	b5f0      	push	{r4, r5, r6, r7, lr}
 802f37a:	46ce      	mov	lr, r9
 802f37c:	b500      	push	{lr}
 802f37e:	b08a      	sub	sp, #40	; 0x28
 802f380:	0004      	movs	r4, r0
 802f382:	000e      	movs	r6, r1
 802f384:	9204      	str	r2, [sp, #16]
 802f386:	9305      	str	r3, [sp, #20]
 802f388:	ab10      	add	r3, sp, #64	; 0x40
 802f38a:	781f      	ldrb	r7, [r3, #0]
 802f38c:	ab11      	add	r3, sp, #68	; 0x44
 802f38e:	781b      	ldrb	r3, [r3, #0]
 802f390:	4699      	mov	r9, r3
    TimerTime_t elapsedTime = SysTimeToMs( elapsedTimeSinceStartup );
 802f392:	0010      	movs	r0, r2
 802f394:	9905      	ldr	r1, [sp, #20]
 802f396:	f005 f845 	bl	8034424 <SysTimeToMs>
 802f39a:	9003      	str	r0, [sp, #12]
    SysTime_t timeDiff = { 0 };
 802f39c:	2208      	movs	r2, #8
 802f39e:	2100      	movs	r1, #0
 802f3a0:	a806      	add	r0, sp, #24
 802f3a2:	f005 fbc8 	bl	8034b36 <memset>
    dutyCycle = GetDutyCycle( band, joined, elapsedTimeSinceStartup );
 802f3a6:	9a04      	ldr	r2, [sp, #16]
 802f3a8:	9b05      	ldr	r3, [sp, #20]
 802f3aa:	0031      	movs	r1, r6
 802f3ac:	0020      	movs	r0, r4
 802f3ae:	f7ff ffad 	bl	802f30c <GetDutyCycle>
 802f3b2:	0005      	movs	r5, r0
    if( joined == false )
 802f3b4:	2e00      	cmp	r6, #0
 802f3b6:	d151      	bne.n	802f45c <SetMaxTimeCredits+0xe4>
        if( dutyCycle == BACKOFF_DC_1_HOUR )
 802f3b8:	2864      	cmp	r0, #100	; 0x64
 802f3ba:	d027      	beq.n	802f40c <SetMaxTimeCredits+0x94>
        else if( dutyCycle == BACKOFF_DC_10_HOURS )
 802f3bc:	22fa      	movs	r2, #250	; 0xfa
 802f3be:	0092      	lsls	r2, r2, #2
 802f3c0:	4290      	cmp	r0, r2
 802f3c2:	d027      	beq.n	802f414 <SetMaxTimeCredits+0x9c>
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 24;
 802f3c4:	4e29      	ldr	r6, [pc, #164]	; (802f46c <SetMaxTimeCredits+0xf4>)
        timeDiff = SysTimeSub( elapsedTimeSinceStartup, SysTimeFromMs( band->LastMaxCreditAssignTime ) );
 802f3c6:	68a1      	ldr	r1, [r4, #8]
 802f3c8:	a808      	add	r0, sp, #32
 802f3ca:	f005 f84d 	bl	8034468 <SysTimeFromMs>
 802f3ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802f3d0:	9300      	str	r3, [sp, #0]
 802f3d2:	9b08      	ldr	r3, [sp, #32]
 802f3d4:	9904      	ldr	r1, [sp, #16]
 802f3d6:	9a05      	ldr	r2, [sp, #20]
 802f3d8:	a806      	add	r0, sp, #24
 802f3da:	f004 ffab 	bl	8034334 <SysTimeSub>
        if( ( ( dutyCycleEnabled == false ) && ( lastTxIsJoinRequest == false ) ) ||
 802f3de:	2f00      	cmp	r7, #0
 802f3e0:	d102      	bne.n	802f3e8 <SetMaxTimeCredits+0x70>
 802f3e2:	464b      	mov	r3, r9
 802f3e4:	2b00      	cmp	r3, #0
 802f3e6:	d002      	beq.n	802f3ee <SetMaxTimeCredits+0x76>
 802f3e8:	6923      	ldr	r3, [r4, #16]
 802f3ea:	42b3      	cmp	r3, r6
 802f3ec:	d016      	beq.n	802f41c <SetMaxTimeCredits+0xa4>
            band->TimeCredits = maxCredits;
 802f3ee:	60e6      	str	r6, [r4, #12]
            if( elapsedTimeSinceStartup.Seconds >= BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 802f3f0:	9804      	ldr	r0, [sp, #16]
 802f3f2:	4b1f      	ldr	r3, [pc, #124]	; (802f470 <SetMaxTimeCredits+0xf8>)
 802f3f4:	4298      	cmp	r0, r3
 802f3f6:	d816      	bhi.n	802f426 <SetMaxTimeCredits+0xae>
    if( band->LastBandUpdateTime == 0 )
 802f3f8:	6863      	ldr	r3, [r4, #4]
 802f3fa:	2b00      	cmp	r3, #0
 802f3fc:	d100      	bne.n	802f400 <SetMaxTimeCredits+0x88>
        band->TimeCredits = maxCredits;
 802f3fe:	60e6      	str	r6, [r4, #12]
    band->MaxTimeCredits = maxCredits;
 802f400:	6126      	str	r6, [r4, #16]
}
 802f402:	0028      	movs	r0, r5
 802f404:	b00a      	add	sp, #40	; 0x28
 802f406:	bc80      	pop	{r7}
 802f408:	46b9      	mov	r9, r7
 802f40a:	bdf0      	pop	{r4, r5, r6, r7, pc}
            band->LastMaxCreditAssignTime = elapsedTime;
 802f40c:	9b03      	ldr	r3, [sp, #12]
 802f40e:	60a3      	str	r3, [r4, #8]
            maxCredits = DUTY_CYCLE_TIME_PERIOD;
 802f410:	4e18      	ldr	r6, [pc, #96]	; (802f474 <SetMaxTimeCredits+0xfc>)
 802f412:	e7d8      	b.n	802f3c6 <SetMaxTimeCredits+0x4e>
            band->LastMaxCreditAssignTime = elapsedTime;
 802f414:	9b03      	ldr	r3, [sp, #12]
 802f416:	60a3      	str	r3, [r4, #8]
            maxCredits = DUTY_CYCLE_TIME_PERIOD * 10;
 802f418:	4e17      	ldr	r6, [pc, #92]	; (802f478 <SetMaxTimeCredits+0x100>)
 802f41a:	e7d4      	b.n	802f3c6 <SetMaxTimeCredits+0x4e>
            ( band->MaxTimeCredits != maxCredits ) ||
 802f41c:	4b17      	ldr	r3, [pc, #92]	; (802f47c <SetMaxTimeCredits+0x104>)
 802f41e:	9a06      	ldr	r2, [sp, #24]
 802f420:	429a      	cmp	r2, r3
 802f422:	d9e9      	bls.n	802f3f8 <SetMaxTimeCredits+0x80>
 802f424:	e7e3      	b.n	802f3ee <SetMaxTimeCredits+0x76>
                timeDiff.Seconds = ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S;
 802f426:	4b16      	ldr	r3, [pc, #88]	; (802f480 <SetMaxTimeCredits+0x108>)
 802f428:	469c      	mov	ip, r3
 802f42a:	4460      	add	r0, ip
 802f42c:	4915      	ldr	r1, [pc, #84]	; (802f484 <SetMaxTimeCredits+0x10c>)
 802f42e:	f7f0 fe73 	bl	8020118 <__udivsi3>
 802f432:	aa06      	add	r2, sp, #24
 802f434:	9006      	str	r0, [sp, #24]
                timeDiff.Seconds *= BACKOFF_24_HOURS_IN_S;
 802f436:	0043      	lsls	r3, r0, #1
 802f438:	1818      	adds	r0, r3, r0
 802f43a:	0103      	lsls	r3, r0, #4
 802f43c:	1a1b      	subs	r3, r3, r0
 802f43e:	0118      	lsls	r0, r3, #4
 802f440:	1ac0      	subs	r0, r0, r3
 802f442:	01c0      	lsls	r0, r0, #7
 802f444:	9006      	str	r0, [sp, #24]
                timeDiff.Seconds += BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 802f446:	4b10      	ldr	r3, [pc, #64]	; (802f488 <SetMaxTimeCredits+0x110>)
 802f448:	469c      	mov	ip, r3
 802f44a:	4460      	add	r0, ip
 802f44c:	9006      	str	r0, [sp, #24]
                timeDiff.SubSeconds = 0;
 802f44e:	2300      	movs	r3, #0
 802f450:	8093      	strh	r3, [r2, #4]
                band->LastMaxCreditAssignTime = SysTimeToMs( timeDiff );
 802f452:	9907      	ldr	r1, [sp, #28]
 802f454:	f004 ffe6 	bl	8034424 <SysTimeToMs>
 802f458:	60a0      	str	r0, [r4, #8]
 802f45a:	e7cd      	b.n	802f3f8 <SetMaxTimeCredits+0x80>
        if( dutyCycleEnabled == false )
 802f45c:	2f00      	cmp	r7, #0
 802f45e:	d102      	bne.n	802f466 <SetMaxTimeCredits+0xee>
            band->TimeCredits = maxCredits;
 802f460:	4e04      	ldr	r6, [pc, #16]	; (802f474 <SetMaxTimeCredits+0xfc>)
 802f462:	60e6      	str	r6, [r4, #12]
 802f464:	e7c8      	b.n	802f3f8 <SetMaxTimeCredits+0x80>
    TimerTime_t maxCredits = DUTY_CYCLE_TIME_PERIOD;
 802f466:	4e03      	ldr	r6, [pc, #12]	; (802f474 <SetMaxTimeCredits+0xfc>)
 802f468:	e7c6      	b.n	802f3f8 <SetMaxTimeCredits+0x80>
 802f46a:	46c0      	nop			; (mov r8, r8)
 802f46c:	02932e00 	.word	0x02932e00
 802f470:	0001ec2f 	.word	0x0001ec2f
 802f474:	001b7740 	.word	0x001b7740
 802f478:	0112a880 	.word	0x0112a880
 802f47c:	0001517f 	.word	0x0001517f
 802f480:	fffe13d0 	.word	0xfffe13d0
 802f484:	00015180 	.word	0x00015180
 802f488:	0001ec30 	.word	0x0001ec30

0802f48c <UpdateTimeCredits>:
{
 802f48c:	b570      	push	{r4, r5, r6, lr}
 802f48e:	b082      	sub	sp, #8
 802f490:	0004      	movs	r4, r0
 802f492:	000d      	movs	r5, r1
    uint16_t dutyCycle = SetMaxTimeCredits( band, joined, elapsedTimeSinceStartup,
 802f494:	9301      	str	r3, [sp, #4]
 802f496:	9200      	str	r2, [sp, #0]
 802f498:	9a06      	ldr	r2, [sp, #24]
 802f49a:	9b07      	ldr	r3, [sp, #28]
 802f49c:	f7ff ff6c 	bl	802f378 <SetMaxTimeCredits>
 802f4a0:	0006      	movs	r6, r0
    if( joined == true )
 802f4a2:	2d00      	cmp	r5, #0
 802f4a4:	d109      	bne.n	802f4ba <UpdateTimeCredits+0x2e>
    if( band->TimeCredits > band->MaxTimeCredits )
 802f4a6:	6923      	ldr	r3, [r4, #16]
 802f4a8:	68e2      	ldr	r2, [r4, #12]
 802f4aa:	429a      	cmp	r2, r3
 802f4ac:	d900      	bls.n	802f4b0 <UpdateTimeCredits+0x24>
        band->TimeCredits = band->MaxTimeCredits;
 802f4ae:	60e3      	str	r3, [r4, #12]
    band->LastBandUpdateTime = currentTime;
 802f4b0:	9b08      	ldr	r3, [sp, #32]
 802f4b2:	6063      	str	r3, [r4, #4]
}
 802f4b4:	0030      	movs	r0, r6
 802f4b6:	b002      	add	sp, #8
 802f4b8:	bd70      	pop	{r4, r5, r6, pc}
        band->TimeCredits += TimerGetElapsedTime( band->LastBandUpdateTime );
 802f4ba:	6860      	ldr	r0, [r4, #4]
 802f4bc:	f005 f834 	bl	8034528 <UTIL_TIMER_GetElapsedTime>
 802f4c0:	68e3      	ldr	r3, [r4, #12]
 802f4c2:	469c      	mov	ip, r3
 802f4c4:	4460      	add	r0, ip
 802f4c6:	60e0      	str	r0, [r4, #12]
 802f4c8:	e7ed      	b.n	802f4a6 <UpdateTimeCredits+0x1a>

0802f4ca <RegionCommonValueInRange>:
    return false;
}

uint8_t RegionCommonValueInRange( int8_t value, int8_t min, int8_t max )
{
    if( ( value >= min ) && ( value <= max ) )
 802f4ca:	4288      	cmp	r0, r1
 802f4cc:	db03      	blt.n	802f4d6 <RegionCommonValueInRange+0xc>
 802f4ce:	4290      	cmp	r0, r2
 802f4d0:	dd03      	ble.n	802f4da <RegionCommonValueInRange+0x10>
    {
        return 1;
    }
    return 0;
 802f4d2:	2000      	movs	r0, #0
 802f4d4:	e000      	b.n	802f4d8 <RegionCommonValueInRange+0xe>
 802f4d6:	2000      	movs	r0, #0
}
 802f4d8:	4770      	bx	lr
        return 1;
 802f4da:	2001      	movs	r0, #1
 802f4dc:	e7fc      	b.n	802f4d8 <RegionCommonValueInRange+0xe>

0802f4de <RegionCommonChanVerifyDr>:
{
 802f4de:	b5f0      	push	{r4, r5, r6, r7, lr}
 802f4e0:	46d6      	mov	lr, sl
 802f4e2:	464f      	mov	r7, r9
 802f4e4:	4646      	mov	r6, r8
 802f4e6:	b5c0      	push	{r6, r7, lr}
 802f4e8:	4682      	mov	sl, r0
 802f4ea:	000e      	movs	r6, r1
 802f4ec:	4690      	mov	r8, r2
 802f4ee:	0019      	movs	r1, r3
 802f4f0:	ab08      	add	r3, sp, #32
 802f4f2:	2200      	movs	r2, #0
 802f4f4:	569a      	ldrsb	r2, [r3, r2]
 802f4f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802f4f8:	4699      	mov	r9, r3
    if( RegionCommonValueInRange( dr, minDr, maxDr ) == 0 )
 802f4fa:	4640      	mov	r0, r8
 802f4fc:	f7ff ffe5 	bl	802f4ca <RegionCommonValueInRange>
 802f500:	2800      	cmp	r0, #0
 802f502:	d02e      	beq.n	802f562 <RegionCommonChanVerifyDr+0x84>
    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
 802f504:	2500      	movs	r5, #0
 802f506:	2700      	movs	r7, #0
 802f508:	e025      	b.n	802f556 <RegionCommonChanVerifyDr+0x78>
        for( uint8_t j = 0; j < 16; j++ )
 802f50a:	3401      	adds	r4, #1
 802f50c:	b2e4      	uxtb	r4, r4
 802f50e:	2c0f      	cmp	r4, #15
 802f510:	d81d      	bhi.n	802f54e <RegionCommonChanVerifyDr+0x70>
            if( ( ( channelsMask[k] & ( 1 << j ) ) != 0 ) )
 802f512:	006b      	lsls	r3, r5, #1
 802f514:	5b9b      	ldrh	r3, [r3, r6]
 802f516:	4123      	asrs	r3, r4
 802f518:	07db      	lsls	r3, r3, #31
 802f51a:	d5f6      	bpl.n	802f50a <RegionCommonChanVerifyDr+0x2c>
                if( RegionCommonValueInRange( dr, ( channels[i + j].DrRange.Fields.Min & 0x0F ),
 802f51c:	193a      	adds	r2, r7, r4
 802f51e:	0053      	lsls	r3, r2, #1
 802f520:	189b      	adds	r3, r3, r2
 802f522:	009b      	lsls	r3, r3, #2
 802f524:	444b      	add	r3, r9
 802f526:	7a1a      	ldrb	r2, [r3, #8]
 802f528:	0111      	lsls	r1, r2, #4
 802f52a:	b249      	sxtb	r1, r1
 802f52c:	1109      	asrs	r1, r1, #4
                                                  ( channels[i + j].DrRange.Fields.Max & 0x0F ) ) == 1 )
 802f52e:	b252      	sxtb	r2, r2
 802f530:	1112      	asrs	r2, r2, #4
                if( RegionCommonValueInRange( dr, ( channels[i + j].DrRange.Fields.Min & 0x0F ),
 802f532:	230f      	movs	r3, #15
 802f534:	401a      	ands	r2, r3
 802f536:	4019      	ands	r1, r3
 802f538:	4640      	mov	r0, r8
 802f53a:	f7ff ffc6 	bl	802f4ca <RegionCommonValueInRange>
 802f53e:	2801      	cmp	r0, #1
 802f540:	d1e3      	bne.n	802f50a <RegionCommonChanVerifyDr+0x2c>
                    return true;
 802f542:	2001      	movs	r0, #1
}
 802f544:	bce0      	pop	{r5, r6, r7}
 802f546:	46ba      	mov	sl, r7
 802f548:	46b1      	mov	r9, r6
 802f54a:	46a8      	mov	r8, r5
 802f54c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for( uint8_t i = 0, k = 0; i < nbChannels; i += 16, k++ )
 802f54e:	3710      	adds	r7, #16
 802f550:	b2ff      	uxtb	r7, r7
 802f552:	3501      	adds	r5, #1
 802f554:	b2ed      	uxtb	r5, r5
 802f556:	4557      	cmp	r7, sl
 802f558:	d201      	bcs.n	802f55e <RegionCommonChanVerifyDr+0x80>
        for( uint8_t j = 0; j < 16; j++ )
 802f55a:	2400      	movs	r4, #0
 802f55c:	e7d7      	b.n	802f50e <RegionCommonChanVerifyDr+0x30>
    return false;
 802f55e:	2000      	movs	r0, #0
 802f560:	e7f0      	b.n	802f544 <RegionCommonChanVerifyDr+0x66>
        return false;
 802f562:	2000      	movs	r0, #0
 802f564:	e7ee      	b.n	802f544 <RegionCommonChanVerifyDr+0x66>

0802f566 <RegionCommonChanDisable>:

bool RegionCommonChanDisable( uint16_t* channelsMask, uint8_t id, uint8_t maxChannels )
{
 802f566:	b510      	push	{r4, lr}
    uint8_t index = id / 16;
 802f568:	090b      	lsrs	r3, r1, #4

    if( ( index > ( maxChannels / 16 ) ) || ( id >= maxChannels ) )
 802f56a:	0914      	lsrs	r4, r2, #4
 802f56c:	429c      	cmp	r4, r3
 802f56e:	d30b      	bcc.n	802f588 <RegionCommonChanDisable+0x22>
 802f570:	4291      	cmp	r1, r2
 802f572:	d20b      	bcs.n	802f58c <RegionCommonChanDisable+0x26>
    {
        return false;
    }

    // Deactivate channel
    channelsMask[index] &= ~( 1 << ( id % 16 ) );
 802f574:	005b      	lsls	r3, r3, #1
 802f576:	220f      	movs	r2, #15
 802f578:	400a      	ands	r2, r1
 802f57a:	2101      	movs	r1, #1
 802f57c:	4091      	lsls	r1, r2
 802f57e:	5ac2      	ldrh	r2, [r0, r3]
 802f580:	438a      	bics	r2, r1
 802f582:	52c2      	strh	r2, [r0, r3]

    return true;
 802f584:	2001      	movs	r0, #1
}
 802f586:	bd10      	pop	{r4, pc}
        return false;
 802f588:	2000      	movs	r0, #0
 802f58a:	e7fc      	b.n	802f586 <RegionCommonChanDisable+0x20>
 802f58c:	2000      	movs	r0, #0
 802f58e:	e7fa      	b.n	802f586 <RegionCommonChanDisable+0x20>

0802f590 <RegionCommonCountChannels>:

uint8_t RegionCommonCountChannels( uint16_t* channelsMask, uint8_t startIdx, uint8_t stopIdx )
{
 802f590:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802f592:	0006      	movs	r6, r0
 802f594:	000c      	movs	r4, r1
 802f596:	0017      	movs	r7, r2
    uint8_t nbChannels = 0;

    if( channelsMask == NULL )
 802f598:	2800      	cmp	r0, #0
 802f59a:	d00e      	beq.n	802f5ba <RegionCommonCountChannels+0x2a>
    uint8_t nbChannels = 0;
 802f59c:	2500      	movs	r5, #0
 802f59e:	e008      	b.n	802f5b2 <RegionCommonCountChannels+0x22>
        return 0;
    }

    for( uint8_t i = startIdx; i < stopIdx; i++ )
    {
        nbChannels += CountChannels( channelsMask[i], 16 );
 802f5a0:	0063      	lsls	r3, r4, #1
 802f5a2:	5af0      	ldrh	r0, [r6, r3]
 802f5a4:	2110      	movs	r1, #16
 802f5a6:	f7ff fed3 	bl	802f350 <CountChannels>
 802f5aa:	182d      	adds	r5, r5, r0
 802f5ac:	b2ed      	uxtb	r5, r5
    for( uint8_t i = startIdx; i < stopIdx; i++ )
 802f5ae:	3401      	adds	r4, #1
 802f5b0:	b2e4      	uxtb	r4, r4
 802f5b2:	42bc      	cmp	r4, r7
 802f5b4:	d3f4      	bcc.n	802f5a0 <RegionCommonCountChannels+0x10>
    }

    return nbChannels;
}
 802f5b6:	0028      	movs	r0, r5
 802f5b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return 0;
 802f5ba:	2500      	movs	r5, #0
 802f5bc:	e7fb      	b.n	802f5b6 <RegionCommonCountChannels+0x26>

0802f5be <RegionCommonChanMaskCopy>:

void RegionCommonChanMaskCopy( uint16_t* channelsMaskDest, uint16_t* channelsMaskSrc, uint8_t len )
{
 802f5be:	b530      	push	{r4, r5, lr}
    if( ( channelsMaskDest != NULL ) && ( channelsMaskSrc != NULL ) )
 802f5c0:	2800      	cmp	r0, #0
 802f5c2:	d00a      	beq.n	802f5da <RegionCommonChanMaskCopy+0x1c>
 802f5c4:	2900      	cmp	r1, #0
 802f5c6:	d008      	beq.n	802f5da <RegionCommonChanMaskCopy+0x1c>
    {
        for( uint8_t i = 0; i < len; i++ )
 802f5c8:	2300      	movs	r3, #0
 802f5ca:	e004      	b.n	802f5d6 <RegionCommonChanMaskCopy+0x18>
        {
            channelsMaskDest[i] = channelsMaskSrc[i];
 802f5cc:	005c      	lsls	r4, r3, #1
 802f5ce:	5b0d      	ldrh	r5, [r1, r4]
 802f5d0:	5305      	strh	r5, [r0, r4]
        for( uint8_t i = 0; i < len; i++ )
 802f5d2:	3301      	adds	r3, #1
 802f5d4:	b2db      	uxtb	r3, r3
 802f5d6:	4293      	cmp	r3, r2
 802f5d8:	d3f8      	bcc.n	802f5cc <RegionCommonChanMaskCopy+0xe>
        }
    }
}
 802f5da:	bd30      	pop	{r4, r5, pc}

0802f5dc <RegionCommonSetBandTxDone>:

void RegionCommonSetBandTxDone( Band_t* band, TimerTime_t lastTxAirTime, bool joined, SysTime_t elapsedTimeSinceStartup )
{
 802f5dc:	b082      	sub	sp, #8
 802f5de:	b570      	push	{r4, r5, r6, lr}
 802f5e0:	0005      	movs	r5, r0
 802f5e2:	000c      	movs	r4, r1
 802f5e4:	0011      	movs	r1, r2
 802f5e6:	9305      	str	r3, [sp, #20]
    // Get the band duty cycle. If not joined, the function either returns the join duty cycle
    // or the band duty cycle, whichever is more restrictive.
    uint16_t dutyCycle = GetDutyCycle( band, joined, elapsedTimeSinceStartup );
 802f5e8:	001a      	movs	r2, r3
 802f5ea:	9b06      	ldr	r3, [sp, #24]
 802f5ec:	f7ff fe8e 	bl	802f30c <GetDutyCycle>

    // Reduce with transmission time
    if( band->TimeCredits > ( lastTxAirTime * dutyCycle ) )
 802f5f0:	68eb      	ldr	r3, [r5, #12]
 802f5f2:	4360      	muls	r0, r4
 802f5f4:	4283      	cmp	r3, r0
 802f5f6:	d905      	bls.n	802f604 <RegionCommonSetBandTxDone+0x28>
    {
        // Reduce time credits by the time of air
        band->TimeCredits -= ( lastTxAirTime * dutyCycle );
 802f5f8:	1a18      	subs	r0, r3, r0
 802f5fa:	60e8      	str	r0, [r5, #12]
    }
    else
    {
        band->TimeCredits = 0;
    }
}
 802f5fc:	bc70      	pop	{r4, r5, r6}
 802f5fe:	bc08      	pop	{r3}
 802f600:	b002      	add	sp, #8
 802f602:	4718      	bx	r3
        band->TimeCredits = 0;
 802f604:	2300      	movs	r3, #0
 802f606:	60eb      	str	r3, [r5, #12]
}
 802f608:	e7f8      	b.n	802f5fc <RegionCommonSetBandTxDone+0x20>
	...

0802f60c <RegionCommonUpdateBandTimeOff>:

TimerTime_t RegionCommonUpdateBandTimeOff( bool joined, Band_t* bands,
                                           uint8_t nbBands, bool dutyCycleEnabled,
                                           bool lastTxIsJoinRequest, SysTime_t elapsedTimeSinceStartup,
                                           TimerTime_t expectedTimeOnAir )
{
 802f60c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802f60e:	46de      	mov	lr, fp
 802f610:	4657      	mov	r7, sl
 802f612:	464e      	mov	r6, r9
 802f614:	4645      	mov	r5, r8
 802f616:	b5e0      	push	{r5, r6, r7, lr}
 802f618:	b089      	sub	sp, #36	; 0x24
 802f61a:	0007      	movs	r7, r0
 802f61c:	468b      	mov	fp, r1
 802f61e:	4691      	mov	r9, r2
 802f620:	4698      	mov	r8, r3
 802f622:	ab12      	add	r3, sp, #72	; 0x48
 802f624:	781b      	ldrb	r3, [r3, #0]
 802f626:	469a      	mov	sl, r3
    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
    TimerTime_t currentTime = TimerGetCurrentTime( );
 802f628:	f004 ff74 	bl	8034514 <UTIL_TIMER_GetCurrentTime>
 802f62c:	9004      	str	r0, [sp, #16]
    TimerTime_t creditCosts = 0;
    uint16_t dutyCycle = 1;
    uint8_t validBands = 0;

    for( uint8_t i = 0; i < nbBands; i++ )
 802f62e:	2500      	movs	r5, #0
    uint8_t validBands = 0;
 802f630:	2600      	movs	r6, #0
    TimerTime_t minTimeToWait = TIMERTIME_T_MAX;
 802f632:	2301      	movs	r3, #1
 802f634:	425b      	negs	r3, r3
 802f636:	9305      	str	r3, [sp, #20]
    for( uint8_t i = 0; i < nbBands; i++ )
 802f638:	e005      	b.n	802f646 <RegionCommonUpdateBandTimeOff+0x3a>
        // when the duty cycle is off, or the TimeCredits of the band
        // is higher than the credit costs for the transmission.
        if( ( bands[i].TimeCredits >= creditCosts ) ||
            ( ( dutyCycleEnabled == false ) && ( joined == true ) ) )
        {
            bands[i].ReadyForTransmission = true;
 802f63a:	2301      	movs	r3, #1
 802f63c:	7523      	strb	r3, [r4, #20]
            // This band is a potential candidate for an
            // upcoming transmission, so increase the counter.
            validBands++;
 802f63e:	3601      	adds	r6, #1
 802f640:	b2f6      	uxtb	r6, r6
    for( uint8_t i = 0; i < nbBands; i++ )
 802f642:	3501      	adds	r5, #1
 802f644:	b2ed      	uxtb	r5, r5
 802f646:	454d      	cmp	r5, r9
 802f648:	d25f      	bcs.n	802f70a <RegionCommonUpdateBandTimeOff+0xfe>
        dutyCycle = UpdateTimeCredits( &bands[i], joined, dutyCycleEnabled,
 802f64a:	006c      	lsls	r4, r5, #1
 802f64c:	1964      	adds	r4, r4, r5
 802f64e:	00e4      	lsls	r4, r4, #3
 802f650:	445c      	add	r4, fp
 802f652:	9b04      	ldr	r3, [sp, #16]
 802f654:	9302      	str	r3, [sp, #8]
 802f656:	ab13      	add	r3, sp, #76	; 0x4c
 802f658:	466a      	mov	r2, sp
 802f65a:	cb03      	ldmia	r3!, {r0, r1}
 802f65c:	c203      	stmia	r2!, {r0, r1}
 802f65e:	4653      	mov	r3, sl
 802f660:	4642      	mov	r2, r8
 802f662:	0039      	movs	r1, r7
 802f664:	0020      	movs	r0, r4
 802f666:	f7ff ff11 	bl	802f48c <UpdateTimeCredits>
 802f66a:	0003      	movs	r3, r0
        creditCosts = expectedTimeOnAir * dutyCycle;
 802f66c:	9a15      	ldr	r2, [sp, #84]	; 0x54
 802f66e:	4350      	muls	r0, r2
        if( ( bands[i].TimeCredits >= creditCosts ) ||
 802f670:	68e2      	ldr	r2, [r4, #12]
 802f672:	4282      	cmp	r2, r0
 802f674:	d2e1      	bcs.n	802f63a <RegionCommonUpdateBandTimeOff+0x2e>
 802f676:	4641      	mov	r1, r8
 802f678:	2900      	cmp	r1, #0
 802f67a:	d101      	bne.n	802f680 <RegionCommonUpdateBandTimeOff+0x74>
            ( ( dutyCycleEnabled == false ) && ( joined == true ) ) )
 802f67c:	2f00      	cmp	r7, #0
 802f67e:	d1dc      	bne.n	802f63a <RegionCommonUpdateBandTimeOff+0x2e>
        }
        else
        {
            // In this case, the band has not enough credits
            // for the next transmission.
            bands[i].ReadyForTransmission = false;
 802f680:	2100      	movs	r1, #0
 802f682:	7521      	strb	r1, [r4, #20]

            if( bands[i].MaxTimeCredits >= creditCosts )
 802f684:	6921      	ldr	r1, [r4, #16]
 802f686:	4281      	cmp	r1, r0
 802f688:	d306      	bcc.n	802f698 <RegionCommonUpdateBandTimeOff+0x8c>
                // The band can only be taken into account, if the maximum credits
                // of the band are higher than the credit costs.
                // We calculate the minTimeToWait among the bands which are not
                // ready for transmission and which are potentially available
                // for a transmission in the future.
                minTimeToWait = MIN( minTimeToWait, ( creditCosts - bands[i].TimeCredits ) );
 802f68a:	1a80      	subs	r0, r0, r2
 802f68c:	9a05      	ldr	r2, [sp, #20]
 802f68e:	4282      	cmp	r2, r0
 802f690:	d900      	bls.n	802f694 <RegionCommonUpdateBandTimeOff+0x88>
 802f692:	9005      	str	r0, [sp, #20]
                // This band is a potential candidate for an
                // upcoming transmission (even if its time credits are not enough
                // at the moment), so increase the counter.
                validBands++;
 802f694:	3601      	adds	r6, #1
 802f696:	b2f6      	uxtb	r6, r6
            }

            // Apply a special calculation if the device is not joined.
            if( joined == false )
 802f698:	2f00      	cmp	r7, #0
 802f69a:	d1d2      	bne.n	802f642 <RegionCommonUpdateBandTimeOff+0x36>
            {
                SysTime_t backoffTimeRange = {
 802f69c:	2200      	movs	r2, #0
 802f69e:	9206      	str	r2, [sp, #24]
 802f6a0:	a906      	add	r1, sp, #24
 802f6a2:	808a      	strh	r2, [r1, #4]
                    .Seconds    = 0,
                    .SubSeconds = 0,
                };
                // Get the backoff time range based on the duty cycle definition
                if( dutyCycle == BACKOFF_DC_1_HOUR )
 802f6a4:	2b64      	cmp	r3, #100	; 0x64
 802f6a6:	d029      	beq.n	802f6fc <RegionCommonUpdateBandTimeOff+0xf0>
                {
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_1_HOUR_IN_S;
                }
                else if( dutyCycle == BACKOFF_DC_10_HOURS )
 802f6a8:	22fa      	movs	r2, #250	; 0xfa
 802f6aa:	0092      	lsls	r2, r2, #2
 802f6ac:	4293      	cmp	r3, r2
 802f6ae:	d029      	beq.n	802f704 <RegionCommonUpdateBandTimeOff+0xf8>
                {
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_10_HOURS_IN_S;
                }
                else
                {
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_24_HOURS_IN_S;
 802f6b0:	4b1d      	ldr	r3, [pc, #116]	; (802f728 <RegionCommonUpdateBandTimeOff+0x11c>)
 802f6b2:	9306      	str	r3, [sp, #24]
                }
                // Calculate the time to wait.
                if( elapsedTimeSinceStartup.Seconds > BACKOFF_DUTY_CYCLE_24_HOURS_IN_S )
 802f6b4:	9813      	ldr	r0, [sp, #76]	; 0x4c
 802f6b6:	4b1c      	ldr	r3, [pc, #112]	; (802f728 <RegionCommonUpdateBandTimeOff+0x11c>)
 802f6b8:	4298      	cmp	r0, r3
 802f6ba:	d911      	bls.n	802f6e0 <RegionCommonUpdateBandTimeOff+0xd4>
                {
                    backoffTimeRange.Seconds += BACKOFF_24_HOURS_IN_S * ( ( ( elapsedTimeSinceStartup.Seconds - BACKOFF_DUTY_CYCLE_24_HOURS_IN_S ) / BACKOFF_24_HOURS_IN_S ) + 1 );
 802f6bc:	4b1b      	ldr	r3, [pc, #108]	; (802f72c <RegionCommonUpdateBandTimeOff+0x120>)
 802f6be:	469c      	mov	ip, r3
 802f6c0:	4460      	add	r0, ip
 802f6c2:	491b      	ldr	r1, [pc, #108]	; (802f730 <RegionCommonUpdateBandTimeOff+0x124>)
 802f6c4:	f7f0 fd28 	bl	8020118 <__udivsi3>
 802f6c8:	3001      	adds	r0, #1
 802f6ca:	0042      	lsls	r2, r0, #1
 802f6cc:	1812      	adds	r2, r2, r0
 802f6ce:	0113      	lsls	r3, r2, #4
 802f6d0:	1a9a      	subs	r2, r3, r2
 802f6d2:	0113      	lsls	r3, r2, #4
 802f6d4:	1a9b      	subs	r3, r3, r2
 802f6d6:	01db      	lsls	r3, r3, #7
 802f6d8:	9a06      	ldr	r2, [sp, #24]
 802f6da:	4694      	mov	ip, r2
 802f6dc:	4463      	add	r3, ip
 802f6de:	9306      	str	r3, [sp, #24]
                }
                // Calculate the time difference between now and the next range
                backoffTimeRange  = SysTimeSub( backoffTimeRange, elapsedTimeSinceStartup );
 802f6e0:	9b14      	ldr	r3, [sp, #80]	; 0x50
 802f6e2:	9300      	str	r3, [sp, #0]
 802f6e4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 802f6e6:	9906      	ldr	r1, [sp, #24]
 802f6e8:	9a07      	ldr	r2, [sp, #28]
 802f6ea:	a806      	add	r0, sp, #24
 802f6ec:	f004 fe22 	bl	8034334 <SysTimeSub>
                minTimeToWait = SysTimeToMs( backoffTimeRange );
 802f6f0:	9806      	ldr	r0, [sp, #24]
 802f6f2:	9907      	ldr	r1, [sp, #28]
 802f6f4:	f004 fe96 	bl	8034424 <SysTimeToMs>
 802f6f8:	9005      	str	r0, [sp, #20]
 802f6fa:	e7a2      	b.n	802f642 <RegionCommonUpdateBandTimeOff+0x36>
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_1_HOUR_IN_S;
 802f6fc:	23e1      	movs	r3, #225	; 0xe1
 802f6fe:	011b      	lsls	r3, r3, #4
 802f700:	9306      	str	r3, [sp, #24]
 802f702:	e7d7      	b.n	802f6b4 <RegionCommonUpdateBandTimeOff+0xa8>
                    backoffTimeRange.Seconds = BACKOFF_DUTY_CYCLE_10_HOURS_IN_S;
 802f704:	4b0b      	ldr	r3, [pc, #44]	; (802f734 <RegionCommonUpdateBandTimeOff+0x128>)
 802f706:	9306      	str	r3, [sp, #24]
 802f708:	e7d4      	b.n	802f6b4 <RegionCommonUpdateBandTimeOff+0xa8>
            }
        }
    }

    if( validBands == 0 )
 802f70a:	2e00      	cmp	r6, #0
 802f70c:	d007      	beq.n	802f71e <RegionCommonUpdateBandTimeOff+0x112>
        // There is no valid band available to handle a transmission
        // in the given DUTY_CYCLE_TIME_PERIOD.
        return TIMERTIME_T_MAX;
    }
    return minTimeToWait;
}
 802f70e:	9805      	ldr	r0, [sp, #20]
 802f710:	b009      	add	sp, #36	; 0x24
 802f712:	bcf0      	pop	{r4, r5, r6, r7}
 802f714:	46bb      	mov	fp, r7
 802f716:	46b2      	mov	sl, r6
 802f718:	46a9      	mov	r9, r5
 802f71a:	46a0      	mov	r8, r4
 802f71c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return TIMERTIME_T_MAX;
 802f71e:	2301      	movs	r3, #1
 802f720:	425b      	negs	r3, r3
 802f722:	9305      	str	r3, [sp, #20]
 802f724:	e7f3      	b.n	802f70e <RegionCommonUpdateBandTimeOff+0x102>
 802f726:	46c0      	nop			; (mov r8, r8)
 802f728:	0001ec30 	.word	0x0001ec30
 802f72c:	fffe13d0 	.word	0xfffe13d0
 802f730:	00015180 	.word	0x00015180
 802f734:	00009ab0 	.word	0x00009ab0

0802f738 <RegionCommonParseLinkAdrReq>:

uint8_t RegionCommonParseLinkAdrReq( uint8_t* payload, RegionCommonLinkAdrParams_t* linkAdrParams )
{
 802f738:	b510      	push	{r4, lr}
    uint8_t retIndex = 0;

    if( payload[0] == SRV_MAC_LINK_ADR_REQ )
 802f73a:	7803      	ldrb	r3, [r0, #0]
 802f73c:	2b03      	cmp	r3, #3
 802f73e:	d001      	beq.n	802f744 <RegionCommonParseLinkAdrReq+0xc>
    uint8_t retIndex = 0;
 802f740:	2000      	movs	r0, #0

        // LinkAdrReq has 4 bytes length + 1 byte CMD
        retIndex = 5;
    }
    return retIndex;
}
 802f742:	bd10      	pop	{r4, pc}
        linkAdrParams->Datarate = payload[1];
 802f744:	7844      	ldrb	r4, [r0, #1]
 802f746:	2201      	movs	r2, #1
 802f748:	5682      	ldrsb	r2, [r0, r2]
 802f74a:	704a      	strb	r2, [r1, #1]
        linkAdrParams->TxPower = linkAdrParams->Datarate & 0x0F;
 802f74c:	330c      	adds	r3, #12
 802f74e:	401a      	ands	r2, r3
 802f750:	708a      	strb	r2, [r1, #2]
        linkAdrParams->Datarate = ( linkAdrParams->Datarate >> 4 ) & 0x0F;
 802f752:	0924      	lsrs	r4, r4, #4
 802f754:	704c      	strb	r4, [r1, #1]
        linkAdrParams->ChMask = ( uint16_t )payload[2];
 802f756:	7882      	ldrb	r2, [r0, #2]
 802f758:	808a      	strh	r2, [r1, #4]
        linkAdrParams->ChMask |= ( uint16_t )payload[3] << 8;
 802f75a:	78c4      	ldrb	r4, [r0, #3]
 802f75c:	0224      	lsls	r4, r4, #8
 802f75e:	4322      	orrs	r2, r4
 802f760:	808a      	strh	r2, [r1, #4]
        linkAdrParams->NbRep = payload[4];
 802f762:	7902      	ldrb	r2, [r0, #4]
 802f764:	700a      	strb	r2, [r1, #0]
        linkAdrParams->ChMaskCtrl = ( linkAdrParams->NbRep >> 4 ) & 0x07;
 802f766:	0914      	lsrs	r4, r2, #4
 802f768:	2007      	movs	r0, #7
 802f76a:	4020      	ands	r0, r4
 802f76c:	70c8      	strb	r0, [r1, #3]
        linkAdrParams->NbRep &= 0x0F;
 802f76e:	4013      	ands	r3, r2
 802f770:	700b      	strb	r3, [r1, #0]
        retIndex = 5;
 802f772:	2005      	movs	r0, #5
 802f774:	e7e5      	b.n	802f742 <RegionCommonParseLinkAdrReq+0xa>

0802f776 <RegionCommonLinkAdrReqVerifyParams>:

uint8_t RegionCommonLinkAdrReqVerifyParams( RegionCommonLinkAdrReqVerifyParams_t* verifyParams, int8_t* dr, int8_t* txPow, uint8_t* nbRep )
{
 802f776:	b5f0      	push	{r4, r5, r6, r7, lr}
 802f778:	46de      	mov	lr, fp
 802f77a:	4657      	mov	r7, sl
 802f77c:	464e      	mov	r6, r9
 802f77e:	4645      	mov	r5, r8
 802f780:	b5e0      	push	{r5, r6, r7, lr}
 802f782:	b085      	sub	sp, #20
 802f784:	0004      	movs	r4, r0
 802f786:	4688      	mov	r8, r1
 802f788:	9203      	str	r2, [sp, #12]
 802f78a:	469b      	mov	fp, r3
    uint8_t status = verifyParams->Status;
 802f78c:	7905      	ldrb	r5, [r0, #4]
    int8_t datarate = verifyParams->Datarate;
 802f78e:	2306      	movs	r3, #6
 802f790:	56c3      	ldrsb	r3, [r0, r3]
 802f792:	469a      	mov	sl, r3
    int8_t txPower = verifyParams->TxPower;
 802f794:	2707      	movs	r7, #7
 802f796:	57c7      	ldrsb	r7, [r0, r7]
    int8_t nbRepetitions = verifyParams->NbRep;
 802f798:	2608      	movs	r6, #8
 802f79a:	5786      	ldrsb	r6, [r0, r6]

    // Handle the case when ADR is off.
    if( verifyParams->AdrEnabled == false )
 802f79c:	7943      	ldrb	r3, [r0, #5]
 802f79e:	2b00      	cmp	r3, #0
 802f7a0:	d106      	bne.n	802f7b0 <RegionCommonLinkAdrReqVerifyParams+0x3a>
    {
        // When ADR is off, we are allowed to change the channels mask
        nbRepetitions = verifyParams->CurrentNbRep;
 802f7a2:	260b      	movs	r6, #11
 802f7a4:	5786      	ldrsb	r6, [r0, r6]
        datarate =  verifyParams->CurrentDatarate;
 802f7a6:	2309      	movs	r3, #9
 802f7a8:	56c3      	ldrsb	r3, [r0, r3]
 802f7aa:	469a      	mov	sl, r3
        txPower =  verifyParams->CurrentTxPower;
 802f7ac:	270a      	movs	r7, #10
 802f7ae:	57c7      	ldrsb	r7, [r0, r7]
    }

    if( status != 0 )
 802f7b0:	2d00      	cmp	r5, #0
 802f7b2:	d02a      	beq.n	802f80a <RegionCommonLinkAdrReqVerifyParams+0x94>
    {
        // Verify datarate. The variable phyParam. Value contains the minimum allowed datarate.
        if( datarate == 0x0F )
 802f7b4:	4653      	mov	r3, sl
 802f7b6:	2b0f      	cmp	r3, #15
 802f7b8:	d114      	bne.n	802f7e4 <RegionCommonLinkAdrReqVerifyParams+0x6e>
        { // 0xF means that the device MUST ignore that field, and keep the current parameter value.
            datarate =  verifyParams->CurrentDatarate;
 802f7ba:	2309      	movs	r3, #9
 802f7bc:	56e3      	ldrsb	r3, [r4, r3]
 802f7be:	469a      	mov	sl, r3
        {
            status &= 0xFD; // Datarate KO
        }

        // Verify tx power
        if( txPower == 0x0F )
 802f7c0:	2f0f      	cmp	r7, #15
 802f7c2:	d020      	beq.n	802f806 <RegionCommonLinkAdrReqVerifyParams+0x90>
        { // 0xF means that the device MUST ignore that field, and keep the current parameter value.
            txPower =  verifyParams->CurrentTxPower;
        }
        else if( RegionCommonValueInRange( txPower, verifyParams->MaxTxPower, verifyParams->MinTxPower ) == 0 )
 802f7c4:	231d      	movs	r3, #29
 802f7c6:	56e3      	ldrsb	r3, [r4, r3]
 802f7c8:	4699      	mov	r9, r3
 802f7ca:	221c      	movs	r2, #28
 802f7cc:	56a2      	ldrsb	r2, [r4, r2]
 802f7ce:	0019      	movs	r1, r3
 802f7d0:	0038      	movs	r0, r7
 802f7d2:	f7ff fe7a 	bl	802f4ca <RegionCommonValueInRange>
 802f7d6:	2800      	cmp	r0, #0
 802f7d8:	d117      	bne.n	802f80a <RegionCommonLinkAdrReqVerifyParams+0x94>
        {
            // Verify if the maximum TX power is exceeded
            if( verifyParams->MaxTxPower > txPower )
 802f7da:	45b9      	cmp	r9, r7
 802f7dc:	dc26      	bgt.n	802f82c <RegionCommonLinkAdrReqVerifyParams+0xb6>
            { // Apply maximum TX power. Accept TX power.
                txPower = verifyParams->MaxTxPower;
            }
            else
            {
                status &= 0xFB; // TxPower KO
 802f7de:	2304      	movs	r3, #4
 802f7e0:	439d      	bics	r5, r3
 802f7e2:	e012      	b.n	802f80a <RegionCommonLinkAdrReqVerifyParams+0x94>
        else if( RegionCommonChanVerifyDr( verifyParams->NbChannels, verifyParams->ChannelsMask, datarate,
 802f7e4:	2314      	movs	r3, #20
 802f7e6:	56e3      	ldrsb	r3, [r4, r3]
 802f7e8:	7b20      	ldrb	r0, [r4, #12]
 802f7ea:	69a2      	ldr	r2, [r4, #24]
 802f7ec:	9201      	str	r2, [sp, #4]
 802f7ee:	2215      	movs	r2, #21
 802f7f0:	56a2      	ldrsb	r2, [r4, r2]
 802f7f2:	9200      	str	r2, [sp, #0]
 802f7f4:	4652      	mov	r2, sl
 802f7f6:	6921      	ldr	r1, [r4, #16]
 802f7f8:	f7ff fe71 	bl	802f4de <RegionCommonChanVerifyDr>
 802f7fc:	2800      	cmp	r0, #0
 802f7fe:	d1df      	bne.n	802f7c0 <RegionCommonLinkAdrReqVerifyParams+0x4a>
            status &= 0xFD; // Datarate KO
 802f800:	2302      	movs	r3, #2
 802f802:	439d      	bics	r5, r3
 802f804:	e7dc      	b.n	802f7c0 <RegionCommonLinkAdrReqVerifyParams+0x4a>
            txPower =  verifyParams->CurrentTxPower;
 802f806:	270a      	movs	r7, #10
 802f808:	57e7      	ldrsb	r7, [r4, r7]
            }
        }
    }

    // If the status is ok, verify the NbRep
    if( status == 0x07 )
 802f80a:	2d07      	cmp	r5, #7
 802f80c:	d010      	beq.n	802f830 <RegionCommonLinkAdrReqVerifyParams+0xba>
            nbRepetitions = 1;
        }
    }

    // Apply changes
    *dr = datarate;
 802f80e:	4643      	mov	r3, r8
 802f810:	4652      	mov	r2, sl
 802f812:	701a      	strb	r2, [r3, #0]
    *txPow = txPower;
 802f814:	9b03      	ldr	r3, [sp, #12]
 802f816:	701f      	strb	r7, [r3, #0]
    *nbRep = nbRepetitions;
 802f818:	465b      	mov	r3, fp
 802f81a:	701e      	strb	r6, [r3, #0]

    return status;
}
 802f81c:	0028      	movs	r0, r5
 802f81e:	b005      	add	sp, #20
 802f820:	bcf0      	pop	{r4, r5, r6, r7}
 802f822:	46bb      	mov	fp, r7
 802f824:	46b2      	mov	sl, r6
 802f826:	46a9      	mov	r9, r5
 802f828:	46a0      	mov	r8, r4
 802f82a:	bdf0      	pop	{r4, r5, r6, r7, pc}
                txPower = verifyParams->MaxTxPower;
 802f82c:	464f      	mov	r7, r9
 802f82e:	e7ec      	b.n	802f80a <RegionCommonLinkAdrReqVerifyParams+0x94>
        if( nbRepetitions == 0 )
 802f830:	2e00      	cmp	r6, #0
 802f832:	d1ec      	bne.n	802f80e <RegionCommonLinkAdrReqVerifyParams+0x98>
            nbRepetitions = 1;
 802f834:	3601      	adds	r6, #1
 802f836:	e7ea      	b.n	802f80e <RegionCommonLinkAdrReqVerifyParams+0x98>

0802f838 <RegionCommonComputeSymbolTimeLoRa>:

uint32_t RegionCommonComputeSymbolTimeLoRa( uint8_t phyDr, uint32_t bandwidthInHz )
{
 802f838:	b510      	push	{r4, lr}
    return ( 1 << phyDr ) * 1000000 / bandwidthInHz;
 802f83a:	4b03      	ldr	r3, [pc, #12]	; (802f848 <RegionCommonComputeSymbolTimeLoRa+0x10>)
 802f83c:	4083      	lsls	r3, r0
 802f83e:	0018      	movs	r0, r3
 802f840:	f7f0 fc6a 	bl	8020118 <__udivsi3>
}
 802f844:	bd10      	pop	{r4, pc}
 802f846:	46c0      	nop			; (mov r8, r8)
 802f848:	000f4240 	.word	0x000f4240

0802f84c <RegionCommonComputeSymbolTimeFsk>:

uint32_t RegionCommonComputeSymbolTimeFsk( uint8_t phyDrInKbps )
{
 802f84c:	b510      	push	{r4, lr}
 802f84e:	0001      	movs	r1, r0
    return 8000 / ( uint32_t )phyDrInKbps; // 1 symbol equals 1 byte
 802f850:	20fa      	movs	r0, #250	; 0xfa
 802f852:	0140      	lsls	r0, r0, #5
 802f854:	f7f0 fc60 	bl	8020118 <__udivsi3>
}
 802f858:	bd10      	pop	{r4, pc}
	...

0802f85c <RegionCommonComputeRxWindowParameters>:

void RegionCommonComputeRxWindowParameters( uint32_t tSymbolInUs, uint8_t minRxSymbols, uint32_t rxErrorInMs, uint32_t wakeUpTimeInMs, uint32_t* windowTimeoutInSymbols, int32_t* windowOffsetInMs )
{
 802f85c:	b570      	push	{r4, r5, r6, lr}
 802f85e:	0005      	movs	r5, r0
 802f860:	000c      	movs	r4, r1
 802f862:	001e      	movs	r6, r3
    *windowTimeoutInSymbols = MAX( DIV_CEIL( ( ( 2 * minRxSymbols - 8 ) * tSymbolInUs + 2 * ( rxErrorInMs * 1000 ) ),  tSymbolInUs ), minRxSymbols ); // Computed number of symbols
 802f864:	3904      	subs	r1, #4
 802f866:	4341      	muls	r1, r0
 802f868:	0153      	lsls	r3, r2, #5
 802f86a:	1a9b      	subs	r3, r3, r2
 802f86c:	009b      	lsls	r3, r3, #2
 802f86e:	1898      	adds	r0, r3, r2
 802f870:	00c0      	lsls	r0, r0, #3
 802f872:	1840      	adds	r0, r0, r1
 802f874:	0040      	lsls	r0, r0, #1
 802f876:	d022      	beq.n	802f8be <RegionCommonComputeRxWindowParameters+0x62>
 802f878:	1940      	adds	r0, r0, r5
 802f87a:	3801      	subs	r0, #1
 802f87c:	0029      	movs	r1, r5
 802f87e:	f7f0 fc4b 	bl	8020118 <__udivsi3>
 802f882:	4284      	cmp	r4, r0
 802f884:	d200      	bcs.n	802f888 <RegionCommonComputeRxWindowParameters+0x2c>
 802f886:	0004      	movs	r4, r0
 802f888:	9b04      	ldr	r3, [sp, #16]
 802f88a:	601c      	str	r4, [r3, #0]
    *windowOffsetInMs = ( int32_t )DIV_CEIL( ( int32_t )( 4 * tSymbolInUs ) -
 802f88c:	00a8      	lsls	r0, r5, #2
 802f88e:	4365      	muls	r5, r4
 802f890:	2d00      	cmp	r5, #0
 802f892:	d018      	beq.n	802f8c6 <RegionCommonComputeRxWindowParameters+0x6a>
 802f894:	3501      	adds	r5, #1
 802f896:	086d      	lsrs	r5, r5, #1
 802f898:	1b45      	subs	r5, r0, r5
 802f89a:	0170      	lsls	r0, r6, #5
 802f89c:	1b80      	subs	r0, r0, r6
 802f89e:	0080      	lsls	r0, r0, #2
 802f8a0:	1980      	adds	r0, r0, r6
 802f8a2:	00c0      	lsls	r0, r0, #3
 802f8a4:	1a28      	subs	r0, r5, r0
 802f8a6:	2800      	cmp	r0, #0
 802f8a8:	dd0f      	ble.n	802f8ca <RegionCommonComputeRxWindowParameters+0x6e>
 802f8aa:	4b0a      	ldr	r3, [pc, #40]	; (802f8d4 <RegionCommonComputeRxWindowParameters+0x78>)
 802f8ac:	469c      	mov	ip, r3
 802f8ae:	4460      	add	r0, ip
 802f8b0:	21fa      	movs	r1, #250	; 0xfa
 802f8b2:	0089      	lsls	r1, r1, #2
 802f8b4:	f7f0 fcba 	bl	802022c <__divsi3>
 802f8b8:	9b05      	ldr	r3, [sp, #20]
 802f8ba:	6018      	str	r0, [r3, #0]
                                               ( int32_t )DIV_CEIL( ( *windowTimeoutInSymbols * tSymbolInUs ), 2 ) -
                                               ( int32_t )( wakeUpTimeInMs * 1000 ), 1000 );
}
 802f8bc:	bd70      	pop	{r4, r5, r6, pc}
    *windowTimeoutInSymbols = MAX( DIV_CEIL( ( ( 2 * minRxSymbols - 8 ) * tSymbolInUs + 2 * ( rxErrorInMs * 1000 ) ),  tSymbolInUs ), minRxSymbols ); // Computed number of symbols
 802f8be:	0029      	movs	r1, r5
 802f8c0:	f7f0 fc2a 	bl	8020118 <__udivsi3>
 802f8c4:	e7dd      	b.n	802f882 <RegionCommonComputeRxWindowParameters+0x26>
    *windowOffsetInMs = ( int32_t )DIV_CEIL( ( int32_t )( 4 * tSymbolInUs ) -
 802f8c6:	086d      	lsrs	r5, r5, #1
 802f8c8:	e7e6      	b.n	802f898 <RegionCommonComputeRxWindowParameters+0x3c>
 802f8ca:	21fa      	movs	r1, #250	; 0xfa
 802f8cc:	0089      	lsls	r1, r1, #2
 802f8ce:	f7f0 fcad 	bl	802022c <__divsi3>
 802f8d2:	e7f1      	b.n	802f8b8 <RegionCommonComputeRxWindowParameters+0x5c>
 802f8d4:	000003e7 	.word	0x000003e7

0802f8d8 <RegionCommonComputeTxPower>:

int8_t RegionCommonComputeTxPower( int8_t txPowerIndex, float maxEirp, float antennaGain )
{
 802f8d8:	b570      	push	{r4, r5, r6, lr}
 802f8da:	1c0d      	adds	r5, r1, #0
 802f8dc:	1c14      	adds	r4, r2, #0
    int8_t phyTxPower = 0;

    phyTxPower = ( int8_t )floor( ( maxEirp - ( txPowerIndex * 2U ) ) - antennaGain );
 802f8de:	0040      	lsls	r0, r0, #1
 802f8e0:	f7f1 f896 	bl	8020a10 <__aeabi_ui2f>
 802f8e4:	1c01      	adds	r1, r0, #0
 802f8e6:	1c28      	adds	r0, r5, #0
 802f8e8:	f7f0 fee4 	bl	80206b4 <__aeabi_fsub>
 802f8ec:	1c21      	adds	r1, r4, #0
 802f8ee:	f7f0 fee1 	bl	80206b4 <__aeabi_fsub>
 802f8f2:	f7f1 fd4d 	bl	8021390 <__aeabi_f2d>
 802f8f6:	f005 f927 	bl	8034b48 <floor>
 802f8fa:	f7f1 fd13 	bl	8021324 <__aeabi_d2iz>
 802f8fe:	b240      	sxtb	r0, r0

    return phyTxPower;
}
 802f900:	bd70      	pop	{r4, r5, r6, pc}

0802f902 <RegionCommonCountNbOfEnabledChannels>:
    MW_LOG(TS_ON, VLEVEL_M, "RX_BC on freq %d Hz at DR %d\r\n", rxBeaconSetupParams->Frequency, rxBeaconSetupParams->BeaconDatarate );
}

void RegionCommonCountNbOfEnabledChannels( RegionCommonCountNbOfEnabledChannelsParams_t* countNbOfEnabledChannelsParams,
                                           uint8_t* enabledChannels, uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels )
{
 802f902:	b5f0      	push	{r4, r5, r6, r7, lr}
 802f904:	46de      	mov	lr, fp
 802f906:	4657      	mov	r7, sl
 802f908:	464e      	mov	r6, r9
 802f90a:	4645      	mov	r5, r8
 802f90c:	b5e0      	push	{r5, r6, r7, lr}
 802f90e:	b083      	sub	sp, #12
 802f910:	0005      	movs	r5, r0
 802f912:	468b      	mov	fp, r1
 802f914:	9200      	str	r2, [sp, #0]
 802f916:	9301      	str	r3, [sp, #4]
    uint8_t nbChannelCount = 0;
    uint8_t nbRestrictedChannelsCount = 0;

    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 802f918:	2700      	movs	r7, #0
 802f91a:	2300      	movs	r3, #0
 802f91c:	4698      	mov	r8, r3
    uint8_t nbRestrictedChannelsCount = 0;
 802f91e:	469a      	mov	sl, r3
    uint8_t nbChannelCount = 0;
 802f920:	4699      	mov	r9, r3
    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 802f922:	e049      	b.n	802f9b8 <RegionCommonCountNbOfEnabledChannels+0xb6>
                    {
                        continue;
                    }
                }
                if( RegionCommonValueInRange( countNbOfEnabledChannelsParams->Datarate,
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Min,
 802f924:	7a32      	ldrb	r2, [r6, #8]
 802f926:	0111      	lsls	r1, r2, #4
 802f928:	b249      	sxtb	r1, r1
 802f92a:	1109      	asrs	r1, r1, #4
                                              countNbOfEnabledChannelsParams->Channels[i + j].DrRange.Fields.Max ) == false )
 802f92c:	b252      	sxtb	r2, r2
 802f92e:	1112      	asrs	r2, r2, #4
                if( RegionCommonValueInRange( countNbOfEnabledChannelsParams->Datarate,
 802f930:	2001      	movs	r0, #1
 802f932:	5628      	ldrsb	r0, [r5, r0]
 802f934:	f7ff fdc9 	bl	802f4ca <RegionCommonValueInRange>
 802f938:	2800      	cmp	r0, #0
 802f93a:	d012      	beq.n	802f962 <RegionCommonCountNbOfEnabledChannels+0x60>
                { // Check if the current channel selection supports the given datarate
                    continue;
                }
                if( countNbOfEnabledChannelsParams->Bands[countNbOfEnabledChannelsParams->Channels[i + j].Band].ReadyForTransmission == false )
 802f93c:	7a72      	ldrb	r2, [r6, #9]
 802f93e:	0053      	lsls	r3, r2, #1
 802f940:	189b      	adds	r3, r3, r2
 802f942:	00db      	lsls	r3, r3, #3
 802f944:	68ea      	ldr	r2, [r5, #12]
 802f946:	4694      	mov	ip, r2
 802f948:	4463      	add	r3, ip
 802f94a:	7d1b      	ldrb	r3, [r3, #20]
 802f94c:	2b00      	cmp	r3, #0
 802f94e:	d028      	beq.n	802f9a2 <RegionCommonCountNbOfEnabledChannels+0xa0>
                { // Check if the band is available for transmission
                    nbRestrictedChannelsCount++;
                    continue;
                }
                enabledChannels[nbChannelCount++] = i + j;
 802f950:	464b      	mov	r3, r9
 802f952:	3301      	adds	r3, #1
 802f954:	4642      	mov	r2, r8
 802f956:	1912      	adds	r2, r2, r4
 802f958:	4659      	mov	r1, fp
 802f95a:	4648      	mov	r0, r9
 802f95c:	540a      	strb	r2, [r1, r0]
 802f95e:	b2db      	uxtb	r3, r3
 802f960:	4699      	mov	r9, r3
        for( uint8_t j = 0; j < 16; j++ )
 802f962:	3401      	adds	r4, #1
 802f964:	b2e4      	uxtb	r4, r4
 802f966:	2c0f      	cmp	r4, #15
 802f968:	d820      	bhi.n	802f9ac <RegionCommonCountNbOfEnabledChannels+0xaa>
            if( ( countNbOfEnabledChannelsParams->ChannelsMask[k] & ( 1 << j ) ) != 0 )
 802f96a:	0079      	lsls	r1, r7, #1
 802f96c:	686b      	ldr	r3, [r5, #4]
 802f96e:	5a5b      	ldrh	r3, [r3, r1]
 802f970:	4123      	asrs	r3, r4
 802f972:	07db      	lsls	r3, r3, #31
 802f974:	d5f5      	bpl.n	802f962 <RegionCommonCountNbOfEnabledChannels+0x60>
                if( countNbOfEnabledChannelsParams->Channels[i + j].Frequency == 0 )
 802f976:	4643      	mov	r3, r8
 802f978:	1918      	adds	r0, r3, r4
 802f97a:	0043      	lsls	r3, r0, #1
 802f97c:	181b      	adds	r3, r3, r0
 802f97e:	009e      	lsls	r6, r3, #2
 802f980:	68ab      	ldr	r3, [r5, #8]
 802f982:	469c      	mov	ip, r3
 802f984:	4466      	add	r6, ip
 802f986:	6833      	ldr	r3, [r6, #0]
 802f988:	2b00      	cmp	r3, #0
 802f98a:	d0ea      	beq.n	802f962 <RegionCommonCountNbOfEnabledChannels+0x60>
                if( ( countNbOfEnabledChannelsParams->Joined == false ) &&
 802f98c:	782b      	ldrb	r3, [r5, #0]
 802f98e:	2b00      	cmp	r3, #0
 802f990:	d1c8      	bne.n	802f924 <RegionCommonCountNbOfEnabledChannels+0x22>
                    ( countNbOfEnabledChannelsParams->JoinChannels != NULL ) )
 802f992:	696b      	ldr	r3, [r5, #20]
                if( ( countNbOfEnabledChannelsParams->Joined == false ) &&
 802f994:	2b00      	cmp	r3, #0
 802f996:	d0c5      	beq.n	802f924 <RegionCommonCountNbOfEnabledChannels+0x22>
                    if( ( countNbOfEnabledChannelsParams->JoinChannels[k] & ( 1 << j ) ) == 0 )
 802f998:	5a5b      	ldrh	r3, [r3, r1]
 802f99a:	4123      	asrs	r3, r4
 802f99c:	07db      	lsls	r3, r3, #31
 802f99e:	d4c1      	bmi.n	802f924 <RegionCommonCountNbOfEnabledChannels+0x22>
 802f9a0:	e7df      	b.n	802f962 <RegionCommonCountNbOfEnabledChannels+0x60>
                    nbRestrictedChannelsCount++;
 802f9a2:	4653      	mov	r3, sl
 802f9a4:	3301      	adds	r3, #1
 802f9a6:	b2db      	uxtb	r3, r3
 802f9a8:	469a      	mov	sl, r3
                    continue;
 802f9aa:	e7da      	b.n	802f962 <RegionCommonCountNbOfEnabledChannels+0x60>
    for( uint8_t i = 0, k = 0; i < countNbOfEnabledChannelsParams->MaxNbChannels; i += 16, k++ )
 802f9ac:	4646      	mov	r6, r8
 802f9ae:	3610      	adds	r6, #16
 802f9b0:	b2f3      	uxtb	r3, r6
 802f9b2:	4698      	mov	r8, r3
 802f9b4:	3701      	adds	r7, #1
 802f9b6:	b2ff      	uxtb	r7, r7
 802f9b8:	4643      	mov	r3, r8
 802f9ba:	b29b      	uxth	r3, r3
 802f9bc:	8a2a      	ldrh	r2, [r5, #16]
 802f9be:	4293      	cmp	r3, r2
 802f9c0:	d201      	bcs.n	802f9c6 <RegionCommonCountNbOfEnabledChannels+0xc4>
        for( uint8_t j = 0; j < 16; j++ )
 802f9c2:	2400      	movs	r4, #0
 802f9c4:	e7cf      	b.n	802f966 <RegionCommonCountNbOfEnabledChannels+0x64>
            }
        }
    }
    *nbEnabledChannels = nbChannelCount;
 802f9c6:	9b00      	ldr	r3, [sp, #0]
 802f9c8:	464a      	mov	r2, r9
 802f9ca:	701a      	strb	r2, [r3, #0]
    *nbRestrictedChannels = nbRestrictedChannelsCount;
 802f9cc:	9b01      	ldr	r3, [sp, #4]
 802f9ce:	4652      	mov	r2, sl
 802f9d0:	701a      	strb	r2, [r3, #0]
}
 802f9d2:	b003      	add	sp, #12
 802f9d4:	bcf0      	pop	{r4, r5, r6, r7}
 802f9d6:	46bb      	mov	fp, r7
 802f9d8:	46b2      	mov	sl, r6
 802f9da:	46a9      	mov	r9, r5
 802f9dc:	46a0      	mov	r8, r4
 802f9de:	bdf0      	pop	{r4, r5, r6, r7, pc}

0802f9e0 <RegionCommonIdentifyChannels>:

LoRaMacStatus_t RegionCommonIdentifyChannels( RegionCommonIdentifyChannelsParam_t* identifyChannelsParam,
                                              TimerTime_t* aggregatedTimeOff, uint8_t* enabledChannels,
                                              uint8_t* nbEnabledChannels, uint8_t* nbRestrictedChannels,
                                              TimerTime_t* nextTxDelay )
{
 802f9e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 802f9e2:	46d6      	mov	lr, sl
 802f9e4:	4647      	mov	r7, r8
 802f9e6:	b580      	push	{r7, lr}
 802f9e8:	b087      	sub	sp, #28
 802f9ea:	0004      	movs	r4, r0
 802f9ec:	000e      	movs	r6, r1
 802f9ee:	9205      	str	r2, [sp, #20]
 802f9f0:	001d      	movs	r5, r3
 802f9f2:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    TimerTime_t elapsed = TimerGetElapsedTime( identifyChannelsParam->LastAggrTx );
 802f9f4:	6840      	ldr	r0, [r0, #4]
 802f9f6:	f004 fd97 	bl	8034528 <UTIL_TIMER_GetElapsedTime>
    *nextTxDelay = identifyChannelsParam->AggrTimeOff - elapsed;
 802f9fa:	6823      	ldr	r3, [r4, #0]
 802f9fc:	1a1b      	subs	r3, r3, r0
 802f9fe:	603b      	str	r3, [r7, #0]
    *nbRestrictedChannels = 1;
 802fa00:	2301      	movs	r3, #1
 802fa02:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 802fa04:	7013      	strb	r3, [r2, #0]
    *nbEnabledChannels = 0;
 802fa06:	2300      	movs	r3, #0
 802fa08:	702b      	strb	r3, [r5, #0]

    if( ( identifyChannelsParam->LastAggrTx == 0 ) ||
 802fa0a:	6863      	ldr	r3, [r4, #4]
 802fa0c:	2b00      	cmp	r3, #0
 802fa0e:	d002      	beq.n	802fa16 <RegionCommonIdentifyChannels+0x36>
 802fa10:	6823      	ldr	r3, [r4, #0]
 802fa12:	4283      	cmp	r3, r0
 802fa14:	d81e      	bhi.n	802fa54 <RegionCommonIdentifyChannels+0x74>
        ( identifyChannelsParam->AggrTimeOff <= elapsed ) )
    {
        // Reset Aggregated time off
        *aggregatedTimeOff = 0;
 802fa16:	2300      	movs	r3, #0
 802fa18:	6033      	str	r3, [r6, #0]

        // Update bands Time OFF
        *nextTxDelay = RegionCommonUpdateBandTimeOff( identifyChannelsParam->CountNbOfEnabledChannelsParam->Joined,
 802fa1a:	69e0      	ldr	r0, [r4, #28]
 802fa1c:	7a23      	ldrb	r3, [r4, #8]
 802fa1e:	4698      	mov	r8, r3
 802fa20:	7a63      	ldrb	r3, [r4, #9]
 802fa22:	469c      	mov	ip, r3
 802fa24:	68c3      	ldr	r3, [r0, #12]
 802fa26:	469a      	mov	sl, r3
 802fa28:	7800      	ldrb	r0, [r0, #0]
 802fa2a:	69a3      	ldr	r3, [r4, #24]
 802fa2c:	9303      	str	r3, [sp, #12]
 802fa2e:	aa01      	add	r2, sp, #4
 802fa30:	0023      	movs	r3, r4
 802fa32:	330c      	adds	r3, #12
 802fa34:	cb42      	ldmia	r3!, {r1, r6}
 802fa36:	c242      	stmia	r2!, {r1, r6}
 802fa38:	7d23      	ldrb	r3, [r4, #20]
 802fa3a:	9300      	str	r3, [sp, #0]
 802fa3c:	4643      	mov	r3, r8
 802fa3e:	4662      	mov	r2, ip
 802fa40:	4651      	mov	r1, sl
 802fa42:	f7ff fde3 	bl	802f60c <RegionCommonUpdateBandTimeOff>
 802fa46:	6038      	str	r0, [r7, #0]
                                                      identifyChannelsParam->DutyCycleEnabled,
                                                      identifyChannelsParam->LastTxIsJoinRequest,
                                                      identifyChannelsParam->ElapsedTimeSinceStartUp,
                                                      identifyChannelsParam->ExpectedTimeOnAir );

        RegionCommonCountNbOfEnabledChannels( identifyChannelsParam->CountNbOfEnabledChannelsParam, enabledChannels,
 802fa48:	69e0      	ldr	r0, [r4, #28]
 802fa4a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802fa4c:	002a      	movs	r2, r5
 802fa4e:	9905      	ldr	r1, [sp, #20]
 802fa50:	f7ff ff57 	bl	802f902 <RegionCommonCountNbOfEnabledChannels>
                                              nbEnabledChannels, nbRestrictedChannels );
    }

    if( *nbEnabledChannels > 0 )
 802fa54:	782b      	ldrb	r3, [r5, #0]
 802fa56:	2b00      	cmp	r3, #0
 802fa58:	d105      	bne.n	802fa66 <RegionCommonIdentifyChannels+0x86>
    {
        *nextTxDelay = 0;
        return LORAMAC_STATUS_OK;
    }
    else if( *nbRestrictedChannels > 0 )
 802fa5a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802fa5c:	781b      	ldrb	r3, [r3, #0]
 802fa5e:	2b00      	cmp	r3, #0
 802fa60:	d009      	beq.n	802fa76 <RegionCommonIdentifyChannels+0x96>
    {
        return LORAMAC_STATUS_DUTYCYCLE_RESTRICTED;
 802fa62:	200b      	movs	r0, #11
 802fa64:	e002      	b.n	802fa6c <RegionCommonIdentifyChannels+0x8c>
        *nextTxDelay = 0;
 802fa66:	2300      	movs	r3, #0
 802fa68:	603b      	str	r3, [r7, #0]
        return LORAMAC_STATUS_OK;
 802fa6a:	2000      	movs	r0, #0
    }
    else
    {
        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
    }
}
 802fa6c:	b007      	add	sp, #28
 802fa6e:	bcc0      	pop	{r6, r7}
 802fa70:	46ba      	mov	sl, r7
 802fa72:	46b0      	mov	r8, r6
 802fa74:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_STATUS_NO_CHANNEL_FOUND;
 802fa76:	200c      	movs	r0, #12
 802fa78:	e7f8      	b.n	802fa6c <RegionCommonIdentifyChannels+0x8c>

0802fa7a <RegionCommonGetNextLowerTxDr>:

int8_t RegionCommonGetNextLowerTxDr( RegionCommonGetNextLowerTxDrParams_t *params )
{
 802fa7a:	b570      	push	{r4, r5, r6, lr}
 802fa7c:	b082      	sub	sp, #8
 802fa7e:	0005      	movs	r5, r0
    int8_t drLocal = params->CurrentDr;
 802fa80:	2400      	movs	r4, #0
 802fa82:	5704      	ldrsb	r4, [r0, r4]

    if( params->CurrentDr == params->MinDr )
 802fa84:	2602      	movs	r6, #2
 802fa86:	5786      	ldrsb	r6, [r0, r6]
 802fa88:	42a6      	cmp	r6, r4
 802fa8a:	d011      	beq.n	802fab0 <RegionCommonGetNextLowerTxDr+0x36>
    }
    else
    {
        do
        {
            drLocal = ( drLocal - 1 );
 802fa8c:	3c01      	subs	r4, #1
 802fa8e:	b264      	sxtb	r4, r4
        } while( ( drLocal != params->MinDr ) &&
                 ( RegionCommonChanVerifyDr( params->NbChannels, params->ChannelsMask, drLocal, params->MinDr, params->MaxDr, params->Channels  ) == false ) );
 802fa90:	42a6      	cmp	r6, r4
 802fa92:	d00e      	beq.n	802fab2 <RegionCommonGetNextLowerTxDr+0x38>
 802fa94:	78e8      	ldrb	r0, [r5, #3]
 802fa96:	68ab      	ldr	r3, [r5, #8]
 802fa98:	9301      	str	r3, [sp, #4]
 802fa9a:	2301      	movs	r3, #1
 802fa9c:	56eb      	ldrsb	r3, [r5, r3]
 802fa9e:	9300      	str	r3, [sp, #0]
 802faa0:	0033      	movs	r3, r6
 802faa2:	0022      	movs	r2, r4
 802faa4:	6869      	ldr	r1, [r5, #4]
 802faa6:	f7ff fd1a 	bl	802f4de <RegionCommonChanVerifyDr>
        } while( ( drLocal != params->MinDr ) &&
 802faaa:	2800      	cmp	r0, #0
 802faac:	d0ee      	beq.n	802fa8c <RegionCommonGetNextLowerTxDr+0x12>
 802faae:	e000      	b.n	802fab2 <RegionCommonGetNextLowerTxDr+0x38>
        return params->MinDr;
 802fab0:	0034      	movs	r4, r6

        return drLocal;
    }
}
 802fab2:	0020      	movs	r0, r4
 802fab4:	b002      	add	sp, #8
 802fab6:	bd70      	pop	{r4, r5, r6, pc}

0802fab8 <RegionCommonLimitTxPower>:

int8_t RegionCommonLimitTxPower( int8_t txPower, int8_t maxBandTxPower )
{
    // Limit tx power to the band max
    return MAX( txPower, maxBandTxPower );
 802fab8:	1c0b      	adds	r3, r1, #0
 802faba:	4281      	cmp	r1, r0
 802fabc:	da00      	bge.n	802fac0 <RegionCommonLimitTxPower+0x8>
 802fabe:	1c03      	adds	r3, r0, #0
 802fac0:	b258      	sxtb	r0, r3
}
 802fac2:	4770      	bx	lr

0802fac4 <RegionCommonGetBandwidth>:

uint32_t RegionCommonGetBandwidth( uint32_t drIndex, const uint32_t* bandwidths )
{
    switch( bandwidths[drIndex] )
 802fac4:	0080      	lsls	r0, r0, #2
 802fac6:	5843      	ldr	r3, [r0, r1]
 802fac8:	4a05      	ldr	r2, [pc, #20]	; (802fae0 <RegionCommonGetBandwidth+0x1c>)
 802faca:	4293      	cmp	r3, r2
 802facc:	d004      	beq.n	802fad8 <RegionCommonGetBandwidth+0x14>
 802face:	4a05      	ldr	r2, [pc, #20]	; (802fae4 <RegionCommonGetBandwidth+0x20>)
 802fad0:	4293      	cmp	r3, r2
 802fad2:	d103      	bne.n	802fadc <RegionCommonGetBandwidth+0x18>
        case 125000:
            return 0;
        case 250000:
            return 1;
        case 500000:
            return 2;
 802fad4:	2002      	movs	r0, #2
    }
}
 802fad6:	4770      	bx	lr
            return 1;
 802fad8:	2001      	movs	r0, #1
 802fada:	e7fc      	b.n	802fad6 <RegionCommonGetBandwidth+0x12>
    switch( bandwidths[drIndex] )
 802fadc:	2000      	movs	r0, #0
 802fade:	e7fa      	b.n	802fad6 <RegionCommonGetBandwidth+0x12>
 802fae0:	0003d090 	.word	0x0003d090
 802fae4:	0007a120 	.word	0x0007a120

0802fae8 <RegionCommonRxConfigPrint>:

void RegionCommonRxConfigPrint(LoRaMacRxSlot_t rxSlot, uint32_t frequency, int8_t dr)
{
 802fae8:	b500      	push	{lr}
 802faea:	b085      	sub	sp, #20
    if ( rxSlot < RX_SLOT_NONE )
 802faec:	2805      	cmp	r0, #5
 802faee:	d80d      	bhi.n	802fb0c <RegionCommonRxConfigPrint+0x24>
    {
        MW_LOG(TS_ON, VLEVEL_M,  "RX_%s on freq %d Hz at DR %d\r\n", EventRXSlotStrings[rxSlot], frequency, dr );
 802faf0:	9202      	str	r2, [sp, #8]
 802faf2:	9101      	str	r1, [sp, #4]
 802faf4:	0080      	lsls	r0, r0, #2
 802faf6:	4b0a      	ldr	r3, [pc, #40]	; (802fb20 <RegionCommonRxConfigPrint+0x38>)
 802faf8:	58c3      	ldr	r3, [r0, r3]
 802fafa:	9300      	str	r3, [sp, #0]
 802fafc:	4b09      	ldr	r3, [pc, #36]	; (802fb24 <RegionCommonRxConfigPrint+0x3c>)
 802fafe:	2201      	movs	r2, #1
 802fb00:	2100      	movs	r1, #0
 802fb02:	2002      	movs	r0, #2
 802fb04:	f004 f9b4 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
    }
    else
    {
        MW_LOG(TS_ON, VLEVEL_M,  "RX on freq %d Hz at DR %d\r\n", frequency, dr );
    }
}
 802fb08:	b005      	add	sp, #20
 802fb0a:	bd00      	pop	{pc}
        MW_LOG(TS_ON, VLEVEL_M,  "RX on freq %d Hz at DR %d\r\n", frequency, dr );
 802fb0c:	9201      	str	r2, [sp, #4]
 802fb0e:	9100      	str	r1, [sp, #0]
 802fb10:	4b05      	ldr	r3, [pc, #20]	; (802fb28 <RegionCommonRxConfigPrint+0x40>)
 802fb12:	2201      	movs	r2, #1
 802fb14:	2100      	movs	r1, #0
 802fb16:	2002      	movs	r0, #2
 802fb18:	f004 f9aa 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
}
 802fb1c:	e7f4      	b.n	802fb08 <RegionCommonRxConfigPrint+0x20>
 802fb1e:	46c0      	nop			; (mov r8, r8)
 802fb20:	08035768 	.word	0x08035768
 802fb24:	080356f0 	.word	0x080356f0
 802fb28:	08035710 	.word	0x08035710

0802fb2c <RegionCommonTxConfigPrint>:

void RegionCommonTxConfigPrint(uint32_t frequency, int8_t dr)
{
 802fb2c:	b500      	push	{lr}
 802fb2e:	b083      	sub	sp, #12
    MW_LOG(TS_ON, VLEVEL_M,  "TX on freq %d Hz at DR %d\r\n", frequency, dr );
 802fb30:	9101      	str	r1, [sp, #4]
 802fb32:	9000      	str	r0, [sp, #0]
 802fb34:	4b03      	ldr	r3, [pc, #12]	; (802fb44 <RegionCommonTxConfigPrint+0x18>)
 802fb36:	2201      	movs	r2, #1
 802fb38:	2100      	movs	r1, #0
 802fb3a:	2002      	movs	r0, #2
 802fb3c:	f004 f998 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
}
 802fb40:	b003      	add	sp, #12
 802fb42:	bd00      	pop	{pc}
 802fb44:	0803572c 	.word	0x0803572c

0802fb48 <VerifyRfFreq>:
static Band_t* RegionBands;
#endif /* REGION_VERSION */

// Static functions
static bool VerifyRfFreq( uint32_t freq, uint8_t *band )
{
 802fb48:	b570      	push	{r4, r5, r6, lr}
 802fb4a:	0004      	movs	r4, r0
 802fb4c:	000d      	movs	r5, r1
    // Check radio driver support
    if( Radio.CheckRfFrequency( freq ) == false )
 802fb4e:	4b1c      	ldr	r3, [pc, #112]	; (802fbc0 <VerifyRfFreq+0x78>)
 802fb50:	6a1b      	ldr	r3, [r3, #32]
 802fb52:	4798      	blx	r3
 802fb54:	2800      	cmp	r0, #0
 802fb56:	d006      	beq.n	802fb66 <VerifyRfFreq+0x1e>
    {
        return false;
    }

    // Check frequency bands
    if( ( freq >= 863000000 ) && ( freq < 865000000 ) )
 802fb58:	4a1a      	ldr	r2, [pc, #104]	; (802fbc4 <VerifyRfFreq+0x7c>)
 802fb5a:	4b1b      	ldr	r3, [pc, #108]	; (802fbc8 <VerifyRfFreq+0x80>)
 802fb5c:	18e3      	adds	r3, r4, r3
 802fb5e:	4293      	cmp	r3, r2
 802fb60:	d802      	bhi.n	802fb68 <VerifyRfFreq+0x20>
    {
        *band = 2;
 802fb62:	2302      	movs	r3, #2
 802fb64:	702b      	strb	r3, [r5, #0]
    else
    {
        return false;
    }
    return true;
}
 802fb66:	bd70      	pop	{r4, r5, r6, pc}
    else if( ( freq >= 865000000 ) && ( freq <= 868000000 ) )
 802fb68:	4a18      	ldr	r2, [pc, #96]	; (802fbcc <VerifyRfFreq+0x84>)
 802fb6a:	4b19      	ldr	r3, [pc, #100]	; (802fbd0 <VerifyRfFreq+0x88>)
 802fb6c:	18e3      	adds	r3, r4, r3
 802fb6e:	4293      	cmp	r3, r2
 802fb70:	d802      	bhi.n	802fb78 <VerifyRfFreq+0x30>
        *band = 0;
 802fb72:	2300      	movs	r3, #0
 802fb74:	702b      	strb	r3, [r5, #0]
 802fb76:	e7f6      	b.n	802fb66 <VerifyRfFreq+0x1e>
    else if( ( freq > 868000000 ) && ( freq <= 868600000 ) )
 802fb78:	4a16      	ldr	r2, [pc, #88]	; (802fbd4 <VerifyRfFreq+0x8c>)
 802fb7a:	4b17      	ldr	r3, [pc, #92]	; (802fbd8 <VerifyRfFreq+0x90>)
 802fb7c:	18e3      	adds	r3, r4, r3
 802fb7e:	4293      	cmp	r3, r2
 802fb80:	d802      	bhi.n	802fb88 <VerifyRfFreq+0x40>
        *band = 1;
 802fb82:	2301      	movs	r3, #1
 802fb84:	702b      	strb	r3, [r5, #0]
 802fb86:	e7ee      	b.n	802fb66 <VerifyRfFreq+0x1e>
    else if( ( freq >= 868700000 ) && ( freq <= 869200000 ) )
 802fb88:	4a14      	ldr	r2, [pc, #80]	; (802fbdc <VerifyRfFreq+0x94>)
 802fb8a:	4b15      	ldr	r3, [pc, #84]	; (802fbe0 <VerifyRfFreq+0x98>)
 802fb8c:	18e3      	adds	r3, r4, r3
 802fb8e:	4293      	cmp	r3, r2
 802fb90:	d802      	bhi.n	802fb98 <VerifyRfFreq+0x50>
        *band = 5;
 802fb92:	2305      	movs	r3, #5
 802fb94:	702b      	strb	r3, [r5, #0]
 802fb96:	e7e6      	b.n	802fb66 <VerifyRfFreq+0x1e>
    else if( ( freq >= 869400000 ) && ( freq <= 869650000 ) )
 802fb98:	4a12      	ldr	r2, [pc, #72]	; (802fbe4 <VerifyRfFreq+0x9c>)
 802fb9a:	4b13      	ldr	r3, [pc, #76]	; (802fbe8 <VerifyRfFreq+0xa0>)
 802fb9c:	18e3      	adds	r3, r4, r3
 802fb9e:	4293      	cmp	r3, r2
 802fba0:	d802      	bhi.n	802fba8 <VerifyRfFreq+0x60>
        *band = 3;
 802fba2:	2303      	movs	r3, #3
 802fba4:	702b      	strb	r3, [r5, #0]
 802fba6:	e7de      	b.n	802fb66 <VerifyRfFreq+0x1e>
    else if( ( freq >= 869700000 ) && ( freq <= 870000000 ) )
 802fba8:	4b10      	ldr	r3, [pc, #64]	; (802fbec <VerifyRfFreq+0xa4>)
 802fbaa:	469c      	mov	ip, r3
 802fbac:	4464      	add	r4, ip
 802fbae:	4b10      	ldr	r3, [pc, #64]	; (802fbf0 <VerifyRfFreq+0xa8>)
 802fbb0:	429c      	cmp	r4, r3
 802fbb2:	d802      	bhi.n	802fbba <VerifyRfFreq+0x72>
        *band = 4;
 802fbb4:	2304      	movs	r3, #4
 802fbb6:	702b      	strb	r3, [r5, #0]
 802fbb8:	e7d5      	b.n	802fb66 <VerifyRfFreq+0x1e>
        return false;
 802fbba:	2000      	movs	r0, #0
 802fbbc:	e7d3      	b.n	802fb66 <VerifyRfFreq+0x1e>
 802fbbe:	46c0      	nop			; (mov r8, r8)
 802fbc0:	08035d8c 	.word	0x08035d8c
 802fbc4:	001e847f 	.word	0x001e847f
 802fbc8:	cc8faa40 	.word	0xcc8faa40
 802fbcc:	002dc6c0 	.word	0x002dc6c0
 802fbd0:	cc7125c0 	.word	0xcc7125c0
 802fbd4:	000927bf 	.word	0x000927bf
 802fbd8:	cc435eff 	.word	0xcc435eff
 802fbdc:	0007a120 	.word	0x0007a120
 802fbe0:	cc38b0a0 	.word	0xcc38b0a0
 802fbe4:	0003d090 	.word	0x0003d090
 802fbe8:	cc2e0240 	.word	0xcc2e0240
 802fbec:	cc296e60 	.word	0xcc296e60
 802fbf0:	000493e0 	.word	0x000493e0

0802fbf4 <GetTimeOnAir>:

static TimerTime_t GetTimeOnAir( int8_t datarate, uint16_t pktLen )
{
 802fbf4:	b570      	push	{r4, r5, r6, lr}
 802fbf6:	b084      	sub	sp, #16
 802fbf8:	0005      	movs	r5, r0
 802fbfa:	000c      	movs	r4, r1
    int8_t phyDr = DataratesEU868[datarate];
 802fbfc:	4b15      	ldr	r3, [pc, #84]	; (802fc54 <GetTimeOnAir+0x60>)
 802fbfe:	561e      	ldrsb	r6, [r3, r0]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsEU868 );
 802fc00:	4915      	ldr	r1, [pc, #84]	; (802fc58 <GetTimeOnAir+0x64>)
 802fc02:	f7ff ff5f 	bl	802fac4 <RegionCommonGetBandwidth>
 802fc06:	0001      	movs	r1, r0
    TimerTime_t timeOnAir = 0;

    if( datarate == DR_7 )
 802fc08:	2d07      	cmp	r5, #7
 802fc0a:	d00f      	beq.n	802fc2c <GetTimeOnAir+0x38>
    { // High Speed FSK channel
        timeOnAir = Radio.TimeOnAir( MODEM_FSK, bandwidth, phyDr * 1000, 0, 5, false, pktLen, true );
    }
    else
    {
        timeOnAir = Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 802fc0c:	4b13      	ldr	r3, [pc, #76]	; (802fc5c <GetTimeOnAir+0x68>)
 802fc0e:	6a5d      	ldr	r5, [r3, #36]	; 0x24
 802fc10:	2301      	movs	r3, #1
 802fc12:	9303      	str	r3, [sp, #12]
 802fc14:	b2e4      	uxtb	r4, r4
 802fc16:	9402      	str	r4, [sp, #8]
 802fc18:	2300      	movs	r3, #0
 802fc1a:	9301      	str	r3, [sp, #4]
 802fc1c:	3308      	adds	r3, #8
 802fc1e:	9300      	str	r3, [sp, #0]
 802fc20:	3b07      	subs	r3, #7
 802fc22:	0032      	movs	r2, r6
 802fc24:	2001      	movs	r0, #1
 802fc26:	47a8      	blx	r5
    }
    return timeOnAir;
}
 802fc28:	b004      	add	sp, #16
 802fc2a:	bd70      	pop	{r4, r5, r6, pc}
        timeOnAir = Radio.TimeOnAir( MODEM_FSK, bandwidth, phyDr * 1000, 0, 5, false, pktLen, true );
 802fc2c:	4b0b      	ldr	r3, [pc, #44]	; (802fc5c <GetTimeOnAir+0x68>)
 802fc2e:	6a5d      	ldr	r5, [r3, #36]	; 0x24
 802fc30:	0172      	lsls	r2, r6, #5
 802fc32:	1b92      	subs	r2, r2, r6
 802fc34:	0092      	lsls	r2, r2, #2
 802fc36:	1992      	adds	r2, r2, r6
 802fc38:	00d2      	lsls	r2, r2, #3
 802fc3a:	2301      	movs	r3, #1
 802fc3c:	9303      	str	r3, [sp, #12]
 802fc3e:	b2e4      	uxtb	r4, r4
 802fc40:	9402      	str	r4, [sp, #8]
 802fc42:	2300      	movs	r3, #0
 802fc44:	9301      	str	r3, [sp, #4]
 802fc46:	3305      	adds	r3, #5
 802fc48:	9300      	str	r3, [sp, #0]
 802fc4a:	2300      	movs	r3, #0
 802fc4c:	2000      	movs	r0, #0
 802fc4e:	47a8      	blx	r5
 802fc50:	e7ea      	b.n	802fc28 <GetTimeOnAir+0x34>
 802fc52:	46c0      	nop			; (mov r8, r8)
 802fc54:	08035898 	.word	0x08035898
 802fc58:	08035878 	.word	0x08035878
 802fc5c:	08035d8c 	.word	0x08035d8c

0802fc60 <RegionEU868GetPhyParam>:
#endif /* REGION_EU868 */

PhyParam_t RegionEU868GetPhyParam( GetPhyParams_t* getPhy )
{
 802fc60:	b500      	push	{lr}
 802fc62:	b087      	sub	sp, #28
    PhyParam_t phyParam = { 0 };
 802fc64:	2300      	movs	r3, #0
 802fc66:	9304      	str	r3, [sp, #16]

#if defined( REGION_EU868 )
    switch( getPhy->Attribute )
 802fc68:	7803      	ldrb	r3, [r0, #0]
 802fc6a:	3b0b      	subs	r3, #11
 802fc6c:	b2da      	uxtb	r2, r3
 802fc6e:	2a2d      	cmp	r2, #45	; 0x2d
 802fc70:	d817      	bhi.n	802fca2 <RegionEU868GetPhyParam+0x42>
 802fc72:	0093      	lsls	r3, r2, #2
 802fc74:	4a46      	ldr	r2, [pc, #280]	; (802fd90 <RegionEU868GetPhyParam+0x130>)
 802fc76:	58d3      	ldr	r3, [r2, r3]
 802fc78:	469f      	mov	pc, r3
        }
        case PHY_NEXT_LOWER_TX_DR:
        {
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
            {
                .CurrentDr = getPhy->Datarate,
 802fc7a:	2301      	movs	r3, #1
 802fc7c:	56c3      	ldrsb	r3, [r0, r3]
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 802fc7e:	a801      	add	r0, sp, #4
 802fc80:	7003      	strb	r3, [r0, #0]
 802fc82:	2307      	movs	r3, #7
 802fc84:	7043      	strb	r3, [r0, #1]
 802fc86:	2300      	movs	r3, #0
 802fc88:	7083      	strb	r3, [r0, #2]
 802fc8a:	3310      	adds	r3, #16
 802fc8c:	70c3      	strb	r3, [r0, #3]
                .MaxDr = ( int8_t )EU868_TX_MAX_DATARATE,
                .MinDr = ( int8_t )EU868_TX_MIN_DATARATE,
                .NbChannels = EU868_MAX_NB_CHANNELS,
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 802fc8e:	4b41      	ldr	r3, [pc, #260]	; (802fd94 <RegionEU868GetPhyParam+0x134>)
 802fc90:	681b      	ldr	r3, [r3, #0]
 802fc92:	22d8      	movs	r2, #216	; 0xd8
 802fc94:	0092      	lsls	r2, r2, #2
 802fc96:	189a      	adds	r2, r3, r2
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 802fc98:	6042      	str	r2, [r0, #4]
 802fc9a:	6083      	str	r3, [r0, #8]
                .Channels = RegionNvmGroup2->Channels,
            };
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 802fc9c:	f7ff feed 	bl	802fa7a <RegionCommonGetNextLowerTxDr>
 802fca0:	9004      	str	r0, [sp, #16]
            break;
        }
    }

#endif /* REGION_EU868 */
    return phyParam;
 802fca2:	9b04      	ldr	r3, [sp, #16]
 802fca4:	9305      	str	r3, [sp, #20]
}
 802fca6:	0018      	movs	r0, r3
 802fca8:	b007      	add	sp, #28
 802fcaa:	bd00      	pop	{pc}
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_LIMIT;
 802fcac:	2340      	movs	r3, #64	; 0x40
 802fcae:	9304      	str	r3, [sp, #16]
            break;
 802fcb0:	e7f7      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_DELAY;
 802fcb2:	2320      	movs	r3, #32
 802fcb4:	9304      	str	r3, [sp, #16]
            break;
 802fcb6:	e7f4      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = MaxPayloadOfDatarateEU868[getPhy->Datarate];
 802fcb8:	2301      	movs	r3, #1
 802fcba:	56c3      	ldrsb	r3, [r0, r3]
 802fcbc:	4a36      	ldr	r2, [pc, #216]	; (802fd98 <RegionEU868GetPhyParam+0x138>)
 802fcbe:	5cd3      	ldrb	r3, [r2, r3]
 802fcc0:	9304      	str	r3, [sp, #16]
            break;
 802fcc2:	e7ee      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = MaxPayloadOfDatarateRepeaterEU868[getPhy->Datarate];
 802fcc4:	2301      	movs	r3, #1
 802fcc6:	56c3      	ldrsb	r3, [r0, r3]
 802fcc8:	4a34      	ldr	r2, [pc, #208]	; (802fd9c <RegionEU868GetPhyParam+0x13c>)
 802fcca:	5cd3      	ldrb	r3, [r2, r3]
 802fccc:	9304      	str	r3, [sp, #16]
            break;
 802fcce:	e7e8      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = EU868_DUTY_CYCLE_ENABLED;
 802fcd0:	2301      	movs	r3, #1
 802fcd2:	9304      	str	r3, [sp, #16]
            break;
 802fcd4:	e7e5      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = EU868_MAX_RX_WINDOW;
 802fcd6:	4b32      	ldr	r3, [pc, #200]	; (802fda0 <RegionEU868GetPhyParam+0x140>)
 802fcd8:	9304      	str	r3, [sp, #16]
            break;
 802fcda:	e7e2      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY1;
 802fcdc:	23fa      	movs	r3, #250	; 0xfa
 802fcde:	009b      	lsls	r3, r3, #2
 802fce0:	9304      	str	r3, [sp, #16]
            break;
 802fce2:	e7de      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY2;
 802fce4:	23fa      	movs	r3, #250	; 0xfa
 802fce6:	00db      	lsls	r3, r3, #3
 802fce8:	9304      	str	r3, [sp, #16]
            break;
 802fcea:	e7da      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY1;
 802fcec:	4b2d      	ldr	r3, [pc, #180]	; (802fda4 <RegionEU868GetPhyParam+0x144>)
 802fcee:	9304      	str	r3, [sp, #16]
            break;
 802fcf0:	e7d7      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY2;
 802fcf2:	4b2d      	ldr	r3, [pc, #180]	; (802fda8 <RegionEU868GetPhyParam+0x148>)
 802fcf4:	9304      	str	r3, [sp, #16]
            break;
 802fcf6:	e7d4      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = ( REGION_COMMON_DEFAULT_RETRANSMIT_TIMEOUT + randr( -REGION_COMMON_DEFAULT_RETRANSMIT_TIMEOUT_RND, REGION_COMMON_DEFAULT_RETRANSMIT_TIMEOUT_RND ) );
 802fcf8:	21fa      	movs	r1, #250	; 0xfa
 802fcfa:	0089      	lsls	r1, r1, #2
 802fcfc:	482b      	ldr	r0, [pc, #172]	; (802fdac <RegionEU868GetPhyParam+0x14c>)
 802fcfe:	f002 f9f5 	bl	80320ec <randr>
 802fd02:	23fa      	movs	r3, #250	; 0xfa
 802fd04:	00db      	lsls	r3, r3, #3
 802fd06:	469c      	mov	ip, r3
 802fd08:	4460      	add	r0, ip
 802fd0a:	9004      	str	r0, [sp, #16]
            break;
 802fd0c:	e7c9      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = EU868_RX_WND_2_FREQ;
 802fd0e:	4b28      	ldr	r3, [pc, #160]	; (802fdb0 <RegionEU868GetPhyParam+0x150>)
 802fd10:	9304      	str	r3, [sp, #16]
            break;
 802fd12:	e7c6      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 802fd14:	4b1f      	ldr	r3, [pc, #124]	; (802fd94 <RegionEU868GetPhyParam+0x134>)
 802fd16:	681b      	ldr	r3, [r3, #0]
 802fd18:	22d8      	movs	r2, #216	; 0xd8
 802fd1a:	0092      	lsls	r2, r2, #2
 802fd1c:	4694      	mov	ip, r2
 802fd1e:	4463      	add	r3, ip
 802fd20:	9304      	str	r3, [sp, #16]
            break;
 802fd22:	e7be      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsDefaultMask;
 802fd24:	4b1b      	ldr	r3, [pc, #108]	; (802fd94 <RegionEU868GetPhyParam+0x134>)
 802fd26:	681b      	ldr	r3, [r3, #0]
 802fd28:	22db      	movs	r2, #219	; 0xdb
 802fd2a:	0092      	lsls	r2, r2, #2
 802fd2c:	4694      	mov	ip, r2
 802fd2e:	4463      	add	r3, ip
 802fd30:	9304      	str	r3, [sp, #16]
            break;
 802fd32:	e7b6      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = EU868_MAX_NB_CHANNELS;
 802fd34:	2310      	movs	r3, #16
 802fd36:	9304      	str	r3, [sp, #16]
            break;
 802fd38:	e7b3      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Channels = RegionNvmGroup2->Channels;
 802fd3a:	4b16      	ldr	r3, [pc, #88]	; (802fd94 <RegionEU868GetPhyParam+0x134>)
 802fd3c:	681b      	ldr	r3, [r3, #0]
 802fd3e:	9304      	str	r3, [sp, #16]
            break;
 802fd40:	e7af      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.fValue = EU868_DEFAULT_MAX_EIRP;
 802fd42:	2383      	movs	r3, #131	; 0x83
 802fd44:	05db      	lsls	r3, r3, #23
 802fd46:	9304      	str	r3, [sp, #16]
            break;
 802fd48:	e7ab      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.fValue = EU868_DEFAULT_ANTENNA_GAIN;
 802fd4a:	4b1a      	ldr	r3, [pc, #104]	; (802fdb4 <RegionEU868GetPhyParam+0x154>)
 802fd4c:	9304      	str	r3, [sp, #16]
            break;
 802fd4e:	e7a8      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = EU868_BEACON_CHANNEL_FREQ;
 802fd50:	4b17      	ldr	r3, [pc, #92]	; (802fdb0 <RegionEU868GetPhyParam+0x150>)
 802fd52:	9304      	str	r3, [sp, #16]
            break;
 802fd54:	e7a5      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.BeaconFormat.BeaconSize = EU868_BEACON_SIZE;
 802fd56:	ab04      	add	r3, sp, #16
 802fd58:	2211      	movs	r2, #17
 802fd5a:	701a      	strb	r2, [r3, #0]
            phyParam.BeaconFormat.Rfu1Size = EU868_RFU1_SIZE;
 802fd5c:	3a10      	subs	r2, #16
 802fd5e:	705a      	strb	r2, [r3, #1]
            break;
 802fd60:	e79f      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = EU868_BEACON_CHANNEL_DR;
 802fd62:	2303      	movs	r3, #3
 802fd64:	9304      	str	r3, [sp, #16]
            break;
 802fd66:	e79c      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = EU868_PING_SLOT_CHANNEL_FREQ;
 802fd68:	4b11      	ldr	r3, [pc, #68]	; (802fdb0 <RegionEU868GetPhyParam+0x150>)
 802fd6a:	9304      	str	r3, [sp, #16]
            break;
 802fd6c:	e799      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = EU868_PING_SLOT_CHANNEL_DR;
 802fd6e:	2303      	movs	r3, #3
 802fd70:	9304      	str	r3, [sp, #16]
            break;
 802fd72:	e796      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = DataratesEU868[getPhy->Datarate];
 802fd74:	2301      	movs	r3, #1
 802fd76:	56c3      	ldrsb	r3, [r0, r3]
 802fd78:	4a0f      	ldr	r2, [pc, #60]	; (802fdb8 <RegionEU868GetPhyParam+0x158>)
 802fd7a:	5cd3      	ldrb	r3, [r2, r3]
 802fd7c:	9304      	str	r3, [sp, #16]
            break;
 802fd7e:	e790      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsEU868 );
 802fd80:	7840      	ldrb	r0, [r0, #1]
 802fd82:	b240      	sxtb	r0, r0
 802fd84:	490d      	ldr	r1, [pc, #52]	; (802fdbc <RegionEU868GetPhyParam+0x15c>)
 802fd86:	f7ff fe9d 	bl	802fac4 <RegionCommonGetBandwidth>
 802fd8a:	9004      	str	r0, [sp, #16]
            break;
 802fd8c:	e789      	b.n	802fca2 <RegionEU868GetPhyParam+0x42>
 802fd8e:	46c0      	nop			; (mov r8, r8)
 802fd90:	08035780 	.word	0x08035780
 802fd94:	2000c318 	.word	0x2000c318
 802fd98:	080358a0 	.word	0x080358a0
 802fd9c:	080358a8 	.word	0x080358a8
 802fda0:	00000bb8 	.word	0x00000bb8
 802fda4:	00001388 	.word	0x00001388
 802fda8:	00001770 	.word	0x00001770
 802fdac:	fffffc18 	.word	0xfffffc18
 802fdb0:	33d3e608 	.word	0x33d3e608
 802fdb4:	4009999a 	.word	0x4009999a
 802fdb8:	08035898 	.word	0x08035898
 802fdbc:	08035878 	.word	0x08035878

0802fdc0 <RegionEU868SetBandTxDone>:

void RegionEU868SetBandTxDone( SetBandTxDoneParams_t* txDone )
{
 802fdc0:	b510      	push	{r4, lr}
 802fdc2:	b082      	sub	sp, #8
 802fdc4:	0003      	movs	r3, r0
#if defined( REGION_EU868 )
#if (defined( REGION_VERSION ) && ( REGION_VERSION == 0x01010003 ))
    RegionCommonSetBandTxDone( &RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txDone->Channel].Band],
                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
#elif (defined( REGION_VERSION ) && ( REGION_VERSION == 0x02010001 ))
    RegionCommonSetBandTxDone( &RegionBands[RegionNvmGroup2->Channels[txDone->Channel].Band],
 802fdc6:	4a0b      	ldr	r2, [pc, #44]	; (802fdf4 <RegionEU868SetBandTxDone+0x34>)
 802fdc8:	6811      	ldr	r1, [r2, #0]
 802fdca:	7800      	ldrb	r0, [r0, #0]
 802fdcc:	0042      	lsls	r2, r0, #1
 802fdce:	1812      	adds	r2, r2, r0
 802fdd0:	0092      	lsls	r2, r2, #2
 802fdd2:	188a      	adds	r2, r1, r2
 802fdd4:	7a52      	ldrb	r2, [r2, #9]
 802fdd6:	0050      	lsls	r0, r2, #1
 802fdd8:	1880      	adds	r0, r0, r2
 802fdda:	00c0      	lsls	r0, r0, #3
 802fddc:	785a      	ldrb	r2, [r3, #1]
 802fdde:	6899      	ldr	r1, [r3, #8]
 802fde0:	4c05      	ldr	r4, [pc, #20]	; (802fdf8 <RegionEU868SetBandTxDone+0x38>)
 802fde2:	6824      	ldr	r4, [r4, #0]
 802fde4:	1820      	adds	r0, r4, r0
 802fde6:	691c      	ldr	r4, [r3, #16]
 802fde8:	9400      	str	r4, [sp, #0]
 802fdea:	68db      	ldr	r3, [r3, #12]
 802fdec:	f7ff fbf6 	bl	802f5dc <RegionCommonSetBandTxDone>
                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
#endif /* REGION_VERSION */
#endif /* REGION_EU868 */
}
 802fdf0:	b002      	add	sp, #8
 802fdf2:	bd10      	pop	{r4, pc}
 802fdf4:	2000c318 	.word	0x2000c318
 802fdf8:	2000c314 	.word	0x2000c314

0802fdfc <RegionEU868InitDefaults>:

void RegionEU868InitDefaults( InitDefaultsParams_t* params )
{
 802fdfc:	b570      	push	{r4, r5, r6, lr}
 802fdfe:	b0a4      	sub	sp, #144	; 0x90
 802fe00:	0004      	movs	r4, r0
#if defined( REGION_EU868 )
    Band_t bands[EU868_MAX_NB_BANDS] =
 802fe02:	2290      	movs	r2, #144	; 0x90
 802fe04:	2100      	movs	r1, #0
 802fe06:	4668      	mov	r0, sp
 802fe08:	f004 fe95 	bl	8034b36 <memset>
 802fe0c:	2364      	movs	r3, #100	; 0x64
 802fe0e:	466a      	mov	r2, sp
 802fe10:	8013      	strh	r3, [r2, #0]
 802fe12:	8313      	strh	r3, [r2, #24]
 802fe14:	22fa      	movs	r2, #250	; 0xfa
 802fe16:	0092      	lsls	r2, r2, #2
 802fe18:	4669      	mov	r1, sp
 802fe1a:	860a      	strh	r2, [r1, #48]	; 0x30
 802fe1c:	2148      	movs	r1, #72	; 0x48
 802fe1e:	200a      	movs	r0, #10
 802fe20:	466d      	mov	r5, sp
 802fe22:	5268      	strh	r0, [r5, r1]
 802fe24:	3118      	adds	r1, #24
 802fe26:	526b      	strh	r3, [r5, r1]
 802fe28:	3314      	adds	r3, #20
 802fe2a:	4669      	mov	r1, sp
 802fe2c:	52ea      	strh	r2, [r5, r3]
        EU868_BAND3,
        EU868_BAND4,
        EU868_BAND5,
    };

    switch( params->Type )
 802fe2e:	7b23      	ldrb	r3, [r4, #12]
 802fe30:	2b01      	cmp	r3, #1
 802fe32:	d02d      	beq.n	802fe90 <RegionEU868InitDefaults+0x94>
 802fe34:	2b02      	cmp	r3, #2
 802fe36:	d03b      	beq.n	802feb0 <RegionEU868InitDefaults+0xb4>
 802fe38:	2b00      	cmp	r3, #0
 802fe3a:	d001      	beq.n	802fe40 <RegionEU868InitDefaults+0x44>
        {
            break;
        }
    }
#endif /* REGION_EU868 */
}
 802fe3c:	b024      	add	sp, #144	; 0x90
 802fe3e:	bd70      	pop	{r4, r5, r6, pc}
            if( ( params->NvmGroup1 == NULL ) || ( params->NvmGroup2 == NULL ) )
 802fe40:	6823      	ldr	r3, [r4, #0]
 802fe42:	2b00      	cmp	r3, #0
 802fe44:	d0fa      	beq.n	802fe3c <RegionEU868InitDefaults+0x40>
 802fe46:	6863      	ldr	r3, [r4, #4]
 802fe48:	2b00      	cmp	r3, #0
 802fe4a:	d0f7      	beq.n	802fe3c <RegionEU868InitDefaults+0x40>
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 802fe4c:	4d1e      	ldr	r5, [pc, #120]	; (802fec8 <RegionEU868InitDefaults+0xcc>)
 802fe4e:	602b      	str	r3, [r5, #0]
            RegionBands = (Band_t*) params->Bands;
 802fe50:	68a0      	ldr	r0, [r4, #8]
 802fe52:	4b1e      	ldr	r3, [pc, #120]	; (802fecc <RegionEU868InitDefaults+0xd0>)
 802fe54:	6018      	str	r0, [r3, #0]
            memcpy1( ( uint8_t* )RegionBands, ( uint8_t* )bands, sizeof( Band_t ) * EU868_MAX_NB_BANDS );
 802fe56:	2290      	movs	r2, #144	; 0x90
 802fe58:	f002 f953 	bl	8032102 <memcpy1>
            RegionNvmGroup2->Channels[0] = ( ChannelParams_t ) EU868_LC1;
 802fe5c:	6829      	ldr	r1, [r5, #0]
 802fe5e:	4b1c      	ldr	r3, [pc, #112]	; (802fed0 <RegionEU868InitDefaults+0xd4>)
 802fe60:	0008      	movs	r0, r1
 802fe62:	001a      	movs	r2, r3
 802fe64:	ca70      	ldmia	r2!, {r4, r5, r6}
 802fe66:	c070      	stmia	r0!, {r4, r5, r6}
            RegionNvmGroup2->Channels[1] = ( ChannelParams_t ) EU868_LC2;
 802fe68:	ca70      	ldmia	r2!, {r4, r5, r6}
 802fe6a:	c070      	stmia	r0!, {r4, r5, r6}
            RegionNvmGroup2->Channels[2] = ( ChannelParams_t ) EU868_LC3;
 802fe6c:	000a      	movs	r2, r1
 802fe6e:	3218      	adds	r2, #24
 802fe70:	3318      	adds	r3, #24
 802fe72:	cb31      	ldmia	r3!, {r0, r4, r5}
 802fe74:	c231      	stmia	r2!, {r0, r4, r5}
            RegionNvmGroup2->ChannelsDefaultMask[0] = LC( 1 ) + LC( 2 ) + LC( 3 );
 802fe76:	23db      	movs	r3, #219	; 0xdb
 802fe78:	009b      	lsls	r3, r3, #2
 802fe7a:	2207      	movs	r2, #7
 802fe7c:	52ca      	strh	r2, [r1, r3]
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 802fe7e:	3b0c      	subs	r3, #12
 802fe80:	18c8      	adds	r0, r1, r3
 802fe82:	330c      	adds	r3, #12
 802fe84:	469c      	mov	ip, r3
 802fe86:	4461      	add	r1, ip
 802fe88:	3a06      	subs	r2, #6
 802fe8a:	f7ff fb98 	bl	802f5be <RegionCommonChanMaskCopy>
            break;
 802fe8e:	e7d5      	b.n	802fe3c <RegionEU868InitDefaults+0x40>
            RegionNvmGroup2->Channels[0].Rx1Frequency = 0;
 802fe90:	4b0d      	ldr	r3, [pc, #52]	; (802fec8 <RegionEU868InitDefaults+0xcc>)
 802fe92:	6819      	ldr	r1, [r3, #0]
 802fe94:	2300      	movs	r3, #0
 802fe96:	604b      	str	r3, [r1, #4]
            RegionNvmGroup2->Channels[1].Rx1Frequency = 0;
 802fe98:	610b      	str	r3, [r1, #16]
            RegionNvmGroup2->Channels[2].Rx1Frequency = 0;
 802fe9a:	61cb      	str	r3, [r1, #28]
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 802fe9c:	23d8      	movs	r3, #216	; 0xd8
 802fe9e:	009b      	lsls	r3, r3, #2
 802fea0:	18c8      	adds	r0, r1, r3
 802fea2:	330c      	adds	r3, #12
 802fea4:	469c      	mov	ip, r3
 802fea6:	4461      	add	r1, ip
 802fea8:	2201      	movs	r2, #1
 802feaa:	f7ff fb88 	bl	802f5be <RegionCommonChanMaskCopy>
            break;
 802feae:	e7c5      	b.n	802fe3c <RegionEU868InitDefaults+0x40>
            RegionNvmGroup2->ChannelsMask[0] |= RegionNvmGroup2->ChannelsDefaultMask[0];
 802feb0:	4b05      	ldr	r3, [pc, #20]	; (802fec8 <RegionEU868InitDefaults+0xcc>)
 802feb2:	681b      	ldr	r3, [r3, #0]
 802feb4:	22db      	movs	r2, #219	; 0xdb
 802feb6:	0092      	lsls	r2, r2, #2
 802feb8:	5a9a      	ldrh	r2, [r3, r2]
 802feba:	21d8      	movs	r1, #216	; 0xd8
 802febc:	0089      	lsls	r1, r1, #2
 802febe:	5a58      	ldrh	r0, [r3, r1]
 802fec0:	4302      	orrs	r2, r0
 802fec2:	525a      	strh	r2, [r3, r1]
            break;
 802fec4:	e7ba      	b.n	802fe3c <RegionEU868InitDefaults+0x40>
 802fec6:	46c0      	nop			; (mov r8, r8)
 802fec8:	2000c318 	.word	0x2000c318
 802fecc:	2000c314 	.word	0x2000c314
 802fed0:	08034cec 	.word	0x08034cec

0802fed4 <RegionEU868Verify>:

bool RegionEU868Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 802fed4:	b500      	push	{lr}
 802fed6:	b083      	sub	sp, #12
#if defined( REGION_EU868 )
    switch( phyAttribute )
 802fed8:	290f      	cmp	r1, #15
 802feda:	d835      	bhi.n	802ff48 <RegionEU868Verify+0x74>
 802fedc:	0089      	lsls	r1, r1, #2
 802fede:	4b1c      	ldr	r3, [pc, #112]	; (802ff50 <RegionEU868Verify+0x7c>)
 802fee0:	585b      	ldr	r3, [r3, r1]
 802fee2:	469f      	mov	pc, r3
 802fee4:	2001      	movs	r0, #1
 802fee6:	e030      	b.n	802ff4a <RegionEU868Verify+0x76>
    {
        case PHY_FREQUENCY:
        {
            uint8_t band = 0;
 802fee8:	466b      	mov	r3, sp
 802feea:	1dd9      	adds	r1, r3, #7
 802feec:	2300      	movs	r3, #0
 802feee:	700b      	strb	r3, [r1, #0]
            return VerifyRfFreq( verify->Frequency, &band );
 802fef0:	6800      	ldr	r0, [r0, #0]
 802fef2:	f7ff fe29 	bl	802fb48 <VerifyRfFreq>
 802fef6:	e028      	b.n	802ff4a <RegionEU868Verify+0x76>
        }
        case PHY_TX_DR:
        {
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE );
 802fef8:	7800      	ldrb	r0, [r0, #0]
 802fefa:	b240      	sxtb	r0, r0
 802fefc:	2207      	movs	r2, #7
 802fefe:	2100      	movs	r1, #0
 802ff00:	f7ff fae3 	bl	802f4ca <RegionCommonValueInRange>
 802ff04:	1e43      	subs	r3, r0, #1
 802ff06:	4198      	sbcs	r0, r3
 802ff08:	b2c0      	uxtb	r0, r0
 802ff0a:	e01e      	b.n	802ff4a <RegionEU868Verify+0x76>
        }
        case PHY_DEF_TX_DR:
        {
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, DR_0, DR_5 );
 802ff0c:	7800      	ldrb	r0, [r0, #0]
 802ff0e:	b240      	sxtb	r0, r0
 802ff10:	2205      	movs	r2, #5
 802ff12:	2100      	movs	r1, #0
 802ff14:	f7ff fad9 	bl	802f4ca <RegionCommonValueInRange>
 802ff18:	1e43      	subs	r3, r0, #1
 802ff1a:	4198      	sbcs	r0, r3
 802ff1c:	b2c0      	uxtb	r0, r0
 802ff1e:	e014      	b.n	802ff4a <RegionEU868Verify+0x76>
        }
        case PHY_RX_DR:
        {
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE );
 802ff20:	7800      	ldrb	r0, [r0, #0]
 802ff22:	b240      	sxtb	r0, r0
 802ff24:	2207      	movs	r2, #7
 802ff26:	2100      	movs	r1, #0
 802ff28:	f7ff facf 	bl	802f4ca <RegionCommonValueInRange>
 802ff2c:	1e43      	subs	r3, r0, #1
 802ff2e:	4198      	sbcs	r0, r3
 802ff30:	b2c0      	uxtb	r0, r0
 802ff32:	e00a      	b.n	802ff4a <RegionEU868Verify+0x76>
        }
        case PHY_DEF_TX_POWER:
        case PHY_TX_POWER:
        {
            // Remark: switched min and max!
            return RegionCommonValueInRange( verify->TxPower, EU868_MAX_TX_POWER, EU868_MIN_TX_POWER );
 802ff34:	7800      	ldrb	r0, [r0, #0]
 802ff36:	b240      	sxtb	r0, r0
 802ff38:	2207      	movs	r2, #7
 802ff3a:	2100      	movs	r1, #0
 802ff3c:	f7ff fac5 	bl	802f4ca <RegionCommonValueInRange>
 802ff40:	1e43      	subs	r3, r0, #1
 802ff42:	4198      	sbcs	r0, r3
 802ff44:	b2c0      	uxtb	r0, r0
 802ff46:	e000      	b.n	802ff4a <RegionEU868Verify+0x76>
        case PHY_DUTY_CYCLE:
        {
            return EU868_DUTY_CYCLE_ENABLED;
        }
        default:
            return false;
 802ff48:	2000      	movs	r0, #0
    }
#else
    return false;
#endif /* REGION_EU868 */
}
 802ff4a:	b003      	add	sp, #12
 802ff4c:	bd00      	pop	{pc}
 802ff4e:	46c0      	nop			; (mov r8, r8)
 802ff50:	08035838 	.word	0x08035838

0802ff54 <RegionEU868ChanMaskSet>:
    }
#endif /* REGION_EU868 */
}

bool RegionEU868ChanMaskSet( ChanMaskSetParams_t* chanMaskSet )
{
 802ff54:	b510      	push	{r4, lr}
 802ff56:	0003      	movs	r3, r0
#if defined( REGION_EU868 )
    switch( chanMaskSet->ChannelsMaskType )
 802ff58:	7902      	ldrb	r2, [r0, #4]
 802ff5a:	2a00      	cmp	r2, #0
 802ff5c:	d003      	beq.n	802ff66 <RegionEU868ChanMaskSet+0x12>
 802ff5e:	2a01      	cmp	r2, #1
 802ff60:	d00d      	beq.n	802ff7e <RegionEU868ChanMaskSet+0x2a>
 802ff62:	2000      	movs	r0, #0
    }
    return true;
#else
    return false;
#endif /* REGION_EU868 */
}
 802ff64:	bd10      	pop	{r4, pc}
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 802ff66:	4a0c      	ldr	r2, [pc, #48]	; (802ff98 <RegionEU868ChanMaskSet+0x44>)
 802ff68:	6810      	ldr	r0, [r2, #0]
 802ff6a:	22d8      	movs	r2, #216	; 0xd8
 802ff6c:	0092      	lsls	r2, r2, #2
 802ff6e:	4694      	mov	ip, r2
 802ff70:	4460      	add	r0, ip
 802ff72:	6819      	ldr	r1, [r3, #0]
 802ff74:	2201      	movs	r2, #1
 802ff76:	f7ff fb22 	bl	802f5be <RegionCommonChanMaskCopy>
    return true;
 802ff7a:	2001      	movs	r0, #1
            break;
 802ff7c:	e7f2      	b.n	802ff64 <RegionEU868ChanMaskSet+0x10>
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 802ff7e:	4a06      	ldr	r2, [pc, #24]	; (802ff98 <RegionEU868ChanMaskSet+0x44>)
 802ff80:	6810      	ldr	r0, [r2, #0]
 802ff82:	22db      	movs	r2, #219	; 0xdb
 802ff84:	0092      	lsls	r2, r2, #2
 802ff86:	4694      	mov	ip, r2
 802ff88:	4460      	add	r0, ip
 802ff8a:	6819      	ldr	r1, [r3, #0]
 802ff8c:	2201      	movs	r2, #1
 802ff8e:	f7ff fb16 	bl	802f5be <RegionCommonChanMaskCopy>
    return true;
 802ff92:	2001      	movs	r0, #1
            break;
 802ff94:	e7e6      	b.n	802ff64 <RegionEU868ChanMaskSet+0x10>
 802ff96:	46c0      	nop			; (mov r8, r8)
 802ff98:	2000c318 	.word	0x2000c318

0802ff9c <RegionEU868ComputeRxWindowParameters>:

void RegionEU868ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 802ff9c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802ff9e:	b083      	sub	sp, #12
 802ffa0:	000e      	movs	r6, r1
 802ffa2:	0017      	movs	r7, r2
 802ffa4:	001c      	movs	r4, r3
#if defined( REGION_EU868 )
    uint32_t tSymbolInUs = 0;

    // Get the datarate, perform a boundary check
    rxConfigParams->Datarate = MIN( datarate, EU868_RX_MAX_DATARATE );
 802ffa6:	1c03      	adds	r3, r0, #0
 802ffa8:	2807      	cmp	r0, #7
 802ffaa:	dd00      	ble.n	802ffae <RegionEU868ComputeRxWindowParameters+0x12>
 802ffac:	2307      	movs	r3, #7
 802ffae:	b258      	sxtb	r0, r3
 802ffb0:	7063      	strb	r3, [r4, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsEU868 );
 802ffb2:	4913      	ldr	r1, [pc, #76]	; (8030000 <RegionEU868ComputeRxWindowParameters+0x64>)
 802ffb4:	f7ff fd86 	bl	802fac4 <RegionCommonGetBandwidth>
 802ffb8:	70a0      	strb	r0, [r4, #2]

    if( rxConfigParams->Datarate == DR_7 )
 802ffba:	2301      	movs	r3, #1
 802ffbc:	56e3      	ldrsb	r3, [r4, r3]
 802ffbe:	2b07      	cmp	r3, #7
 802ffc0:	d017      	beq.n	802fff2 <RegionEU868ComputeRxWindowParameters+0x56>
    { // FSK
        tSymbolInUs = RegionCommonComputeSymbolTimeFsk( DataratesEU868[rxConfigParams->Datarate] );
    }
    else
    { // LoRa
        tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesEU868[rxConfigParams->Datarate], BandwidthsEU868[rxConfigParams->Datarate] );
 802ffc2:	0099      	lsls	r1, r3, #2
 802ffc4:	4a0e      	ldr	r2, [pc, #56]	; (8030000 <RegionEU868ComputeRxWindowParameters+0x64>)
 802ffc6:	5889      	ldr	r1, [r1, r2]
 802ffc8:	4a0e      	ldr	r2, [pc, #56]	; (8030004 <RegionEU868ComputeRxWindowParameters+0x68>)
 802ffca:	5cd0      	ldrb	r0, [r2, r3]
 802ffcc:	f7ff fc34 	bl	802f838 <RegionCommonComputeSymbolTimeLoRa>
 802ffd0:	0005      	movs	r5, r0
    }

    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 802ffd2:	4b0d      	ldr	r3, [pc, #52]	; (8030008 <RegionEU868ComputeRxWindowParameters+0x6c>)
 802ffd4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 802ffd6:	4798      	blx	r3
 802ffd8:	0003      	movs	r3, r0
 802ffda:	0022      	movs	r2, r4
 802ffdc:	320c      	adds	r2, #12
 802ffde:	9201      	str	r2, [sp, #4]
 802ffe0:	3408      	adds	r4, #8
 802ffe2:	9400      	str	r4, [sp, #0]
 802ffe4:	003a      	movs	r2, r7
 802ffe6:	0031      	movs	r1, r6
 802ffe8:	0028      	movs	r0, r5
 802ffea:	f7ff fc37 	bl	802f85c <RegionCommonComputeRxWindowParameters>
#endif /* REGION_EU868 */
}
 802ffee:	b003      	add	sp, #12
 802fff0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        tSymbolInUs = RegionCommonComputeSymbolTimeFsk( DataratesEU868[rxConfigParams->Datarate] );
 802fff2:	4a04      	ldr	r2, [pc, #16]	; (8030004 <RegionEU868ComputeRxWindowParameters+0x68>)
 802fff4:	5cd0      	ldrb	r0, [r2, r3]
 802fff6:	f7ff fc29 	bl	802f84c <RegionCommonComputeSymbolTimeFsk>
 802fffa:	0005      	movs	r5, r0
 802fffc:	e7e9      	b.n	802ffd2 <RegionEU868ComputeRxWindowParameters+0x36>
 802fffe:	46c0      	nop			; (mov r8, r8)
 8030000:	08035878 	.word	0x08035878
 8030004:	08035898 	.word	0x08035898
 8030008:	08035d8c 	.word	0x08035d8c

0803000c <RegionEU868RxConfig>:

bool RegionEU868RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate )
{
 803000c:	b5f0      	push	{r4, r5, r6, r7, lr}
 803000e:	46d6      	mov	lr, sl
 8030010:	464f      	mov	r7, r9
 8030012:	b580      	push	{r7, lr}
 8030014:	b08d      	sub	sp, #52	; 0x34
 8030016:	0004      	movs	r4, r0
 8030018:	910b      	str	r1, [sp, #44]	; 0x2c
#if defined( REGION_EU868 )
    RadioModems_t modem;
    int8_t dr = rxConfig->Datarate;
 803001a:	2601      	movs	r6, #1
 803001c:	5786      	ldrsb	r6, [r0, r6]
    uint8_t maxPayload = 0;
    int8_t phyDr = 0;
    uint32_t frequency = rxConfig->Frequency;
 803001e:	6847      	ldr	r7, [r0, #4]

    if( Radio.GetStatus( ) != RF_IDLE )
 8030020:	4b38      	ldr	r3, [pc, #224]	; (8030104 <RegionEU868RxConfig+0xf8>)
 8030022:	685b      	ldr	r3, [r3, #4]
 8030024:	4798      	blx	r3
 8030026:	1e05      	subs	r5, r0, #0
 8030028:	d169      	bne.n	80300fe <RegionEU868RxConfig+0xf2>
    {
        return false;
    }

    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
 803002a:	7ce3      	ldrb	r3, [r4, #19]
 803002c:	2b00      	cmp	r3, #0
 803002e:	d10d      	bne.n	803004c <RegionEU868RxConfig+0x40>
    {
        // Apply window 1 frequency
        frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Frequency;
 8030030:	4b35      	ldr	r3, [pc, #212]	; (8030108 <RegionEU868RxConfig+0xfc>)
 8030032:	681a      	ldr	r2, [r3, #0]
 8030034:	7821      	ldrb	r1, [r4, #0]
 8030036:	004b      	lsls	r3, r1, #1
 8030038:	1858      	adds	r0, r3, r1
 803003a:	0080      	lsls	r0, r0, #2
 803003c:	5880      	ldr	r0, [r0, r2]
        // Apply the alternative RX 1 window frequency, if it is available
        if( RegionNvmGroup2->Channels[rxConfig->Channel].Rx1Frequency != 0 )
 803003e:	185b      	adds	r3, r3, r1
 8030040:	009b      	lsls	r3, r3, #2
 8030042:	18d3      	adds	r3, r2, r3
 8030044:	685f      	ldr	r7, [r3, #4]
 8030046:	2f00      	cmp	r7, #0
 8030048:	d100      	bne.n	803004c <RegionEU868RxConfig+0x40>
        frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Frequency;
 803004a:	0007      	movs	r7, r0
            frequency = RegionNvmGroup2->Channels[rxConfig->Channel].Rx1Frequency;
        }
    }

    // Read the physical datarate from the datarates table
    phyDr = DataratesEU868[dr];
 803004c:	4b2f      	ldr	r3, [pc, #188]	; (803010c <RegionEU868RxConfig+0x100>)
 803004e:	579b      	ldrsb	r3, [r3, r6]
 8030050:	469a      	mov	sl, r3

    Radio.SetChannel( frequency );
 8030052:	4b2c      	ldr	r3, [pc, #176]	; (8030104 <RegionEU868RxConfig+0xf8>)
 8030054:	68db      	ldr	r3, [r3, #12]
 8030056:	0038      	movs	r0, r7
 8030058:	4798      	blx	r3

    // Radio configuration
    if( dr == DR_7 )
 803005a:	2e07      	cmp	r6, #7
 803005c:	d02e      	beq.n	80300bc <RegionEU868RxConfig+0xb0>
        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
    }
    else
    {
        modem = MODEM_LORA;
        Radio.SetRxConfig( modem, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 803005e:	4b29      	ldr	r3, [pc, #164]	; (8030104 <RegionEU868RxConfig+0xf8>)
 8030060:	699d      	ldr	r5, [r3, #24]
 8030062:	78a1      	ldrb	r1, [r4, #2]
 8030064:	7ca3      	ldrb	r3, [r4, #18]
 8030066:	9309      	str	r3, [sp, #36]	; 0x24
 8030068:	2301      	movs	r3, #1
 803006a:	9308      	str	r3, [sp, #32]
 803006c:	2300      	movs	r3, #0
 803006e:	9307      	str	r3, [sp, #28]
 8030070:	9306      	str	r3, [sp, #24]
 8030072:	9305      	str	r3, [sp, #20]
 8030074:	9304      	str	r3, [sp, #16]
 8030076:	9303      	str	r3, [sp, #12]
 8030078:	8922      	ldrh	r2, [r4, #8]
 803007a:	9202      	str	r2, [sp, #8]
 803007c:	2208      	movs	r2, #8
 803007e:	9201      	str	r2, [sp, #4]
 8030080:	9300      	str	r3, [sp, #0]
 8030082:	3301      	adds	r3, #1
 8030084:	4652      	mov	r2, sl
 8030086:	2001      	movs	r0, #1
 8030088:	47a8      	blx	r5
        modem = MODEM_LORA;
 803008a:	2501      	movs	r5, #1
    }

    if( rxConfig->RepeaterSupport == true )
 803008c:	7c63      	ldrb	r3, [r4, #17]
 803008e:	2b00      	cmp	r3, #0
 8030090:	d032      	beq.n	80300f8 <RegionEU868RxConfig+0xec>
    {
        maxPayload = MaxPayloadOfDatarateRepeaterEU868[dr];
 8030092:	4b1f      	ldr	r3, [pc, #124]	; (8030110 <RegionEU868RxConfig+0x104>)
 8030094:	5d99      	ldrb	r1, [r3, r6]
    else
    {
        maxPayload = MaxPayloadOfDatarateEU868[dr];
    }

    Radio.SetMaxPayloadLength( modem, maxPayload + LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE );
 8030096:	4b1b      	ldr	r3, [pc, #108]	; (8030104 <RegionEU868RxConfig+0xf8>)
 8030098:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 803009a:	310d      	adds	r1, #13
 803009c:	b2c9      	uxtb	r1, r1
 803009e:	0028      	movs	r0, r5
 80300a0:	4798      	blx	r3

    RegionCommonRxConfigPrint(rxConfig->RxSlot, frequency, dr);
 80300a2:	7ce0      	ldrb	r0, [r4, #19]
 80300a4:	0032      	movs	r2, r6
 80300a6:	0039      	movs	r1, r7
 80300a8:	f7ff fd1e 	bl	802fae8 <RegionCommonRxConfigPrint>

    *datarate = (uint8_t) dr;
 80300ac:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80300ae:	701e      	strb	r6, [r3, #0]
    return true;
 80300b0:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_EU868 */
}
 80300b2:	b00d      	add	sp, #52	; 0x34
 80300b4:	bcc0      	pop	{r6, r7}
 80300b6:	46ba      	mov	sl, r7
 80300b8:	46b1      	mov	r9, r6
 80300ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
        Radio.SetRxConfig( modem, 50000, phyDr * 1000, 0, 83333, 5, rxConfig->WindowTimeout, false, 0, true, 0, 0, false, rxConfig->RxContinuous );
 80300bc:	4b11      	ldr	r3, [pc, #68]	; (8030104 <RegionEU868RxConfig+0xf8>)
 80300be:	699b      	ldr	r3, [r3, #24]
 80300c0:	4699      	mov	r9, r3
 80300c2:	4653      	mov	r3, sl
 80300c4:	015a      	lsls	r2, r3, #5
 80300c6:	1ad2      	subs	r2, r2, r3
 80300c8:	0092      	lsls	r2, r2, #2
 80300ca:	4452      	add	r2, sl
 80300cc:	00d2      	lsls	r2, r2, #3
 80300ce:	7ca3      	ldrb	r3, [r4, #18]
 80300d0:	9309      	str	r3, [sp, #36]	; 0x24
 80300d2:	2300      	movs	r3, #0
 80300d4:	9308      	str	r3, [sp, #32]
 80300d6:	9307      	str	r3, [sp, #28]
 80300d8:	9306      	str	r3, [sp, #24]
 80300da:	2101      	movs	r1, #1
 80300dc:	9105      	str	r1, [sp, #20]
 80300de:	9304      	str	r3, [sp, #16]
 80300e0:	9303      	str	r3, [sp, #12]
 80300e2:	8923      	ldrh	r3, [r4, #8]
 80300e4:	9302      	str	r3, [sp, #8]
 80300e6:	2305      	movs	r3, #5
 80300e8:	9301      	str	r3, [sp, #4]
 80300ea:	4b0a      	ldr	r3, [pc, #40]	; (8030114 <RegionEU868RxConfig+0x108>)
 80300ec:	9300      	str	r3, [sp, #0]
 80300ee:	2300      	movs	r3, #0
 80300f0:	4909      	ldr	r1, [pc, #36]	; (8030118 <RegionEU868RxConfig+0x10c>)
 80300f2:	2000      	movs	r0, #0
 80300f4:	47c8      	blx	r9
 80300f6:	e7c9      	b.n	803008c <RegionEU868RxConfig+0x80>
        maxPayload = MaxPayloadOfDatarateEU868[dr];
 80300f8:	4b08      	ldr	r3, [pc, #32]	; (803011c <RegionEU868RxConfig+0x110>)
 80300fa:	5d99      	ldrb	r1, [r3, r6]
 80300fc:	e7cb      	b.n	8030096 <RegionEU868RxConfig+0x8a>
        return false;
 80300fe:	2000      	movs	r0, #0
 8030100:	e7d7      	b.n	80300b2 <RegionEU868RxConfig+0xa6>
 8030102:	46c0      	nop			; (mov r8, r8)
 8030104:	08035d8c 	.word	0x08035d8c
 8030108:	2000c318 	.word	0x2000c318
 803010c:	08035898 	.word	0x08035898
 8030110:	080358a8 	.word	0x080358a8
 8030114:	00014585 	.word	0x00014585
 8030118:	0000c350 	.word	0x0000c350
 803011c:	080358a0 	.word	0x080358a0

08030120 <RegionEU868TxConfig>:

bool RegionEU868TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 8030120:	b5f0      	push	{r4, r5, r6, r7, lr}
 8030122:	46de      	mov	lr, fp
 8030124:	4657      	mov	r7, sl
 8030126:	464e      	mov	r6, r9
 8030128:	4645      	mov	r5, r8
 803012a:	b5e0      	push	{r5, r6, r7, lr}
 803012c:	b08b      	sub	sp, #44	; 0x2c
 803012e:	0004      	movs	r4, r0
 8030130:	468b      	mov	fp, r1
 8030132:	4690      	mov	r8, r2
#if defined( REGION_EU868 )
    RadioModems_t modem;
    int8_t phyDr = DataratesEU868[txConfig->Datarate];
 8030134:	2301      	movs	r3, #1
 8030136:	56c3      	ldrsb	r3, [r0, r3]
 8030138:	4a41      	ldr	r2, [pc, #260]	; (8030240 <RegionEU868TxConfig+0x120>)
 803013a:	56d7      	ldrsb	r7, [r2, r3]
#if (defined( REGION_VERSION ) && ( REGION_VERSION == 0x01010003 ))
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
#elif (defined( REGION_VERSION ) && ( REGION_VERSION == 0x02010001 ))
    int8_t txPowerLimited = RegionCommonLimitTxPower( txConfig->TxPower, RegionBands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower );
 803013c:	4d41      	ldr	r5, [pc, #260]	; (8030244 <RegionEU868TxConfig+0x124>)
 803013e:	7802      	ldrb	r2, [r0, #0]
 8030140:	0053      	lsls	r3, r2, #1
 8030142:	189b      	adds	r3, r3, r2
 8030144:	009b      	lsls	r3, r3, #2
 8030146:	682a      	ldr	r2, [r5, #0]
 8030148:	4694      	mov	ip, r2
 803014a:	4463      	add	r3, ip
 803014c:	7a5a      	ldrb	r2, [r3, #9]
 803014e:	0053      	lsls	r3, r2, #1
 8030150:	189b      	adds	r3, r3, r2
 8030152:	00db      	lsls	r3, r3, #3
 8030154:	4a3c      	ldr	r2, [pc, #240]	; (8030248 <RegionEU868TxConfig+0x128>)
 8030156:	6812      	ldr	r2, [r2, #0]
 8030158:	18d3      	adds	r3, r2, r3
 803015a:	2102      	movs	r1, #2
 803015c:	5659      	ldrsb	r1, [r3, r1]
 803015e:	2002      	movs	r0, #2
 8030160:	5620      	ldrsb	r0, [r4, r0]
 8030162:	f7ff fca9 	bl	802fab8 <RegionCommonLimitTxPower>
 8030166:	0006      	movs	r6, r0
#endif /* REGION_VERSION */
    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsEU868 );
 8030168:	2001      	movs	r0, #1
 803016a:	5620      	ldrsb	r0, [r4, r0]
 803016c:	4937      	ldr	r1, [pc, #220]	; (803024c <RegionEU868TxConfig+0x12c>)
 803016e:	f7ff fca9 	bl	802fac4 <RegionCommonGetBandwidth>
 8030172:	4682      	mov	sl, r0
    int8_t phyTxPower = 0;

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, txConfig->MaxEirp, txConfig->AntennaGain );
 8030174:	68a2      	ldr	r2, [r4, #8]
 8030176:	6861      	ldr	r1, [r4, #4]
 8030178:	0030      	movs	r0, r6
 803017a:	f7ff fbad 	bl	802f8d8 <RegionCommonComputeTxPower>
 803017e:	4681      	mov	r9, r0

    // Setup the radio frequency
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 8030180:	4b33      	ldr	r3, [pc, #204]	; (8030250 <RegionEU868TxConfig+0x130>)
 8030182:	68db      	ldr	r3, [r3, #12]
 8030184:	6829      	ldr	r1, [r5, #0]
 8030186:	7822      	ldrb	r2, [r4, #0]
 8030188:	0055      	lsls	r5, r2, #1
 803018a:	18ad      	adds	r5, r5, r2
 803018c:	00ad      	lsls	r5, r5, #2
 803018e:	5868      	ldr	r0, [r5, r1]
 8030190:	4798      	blx	r3

    if( txConfig->Datarate == DR_7 )
 8030192:	2301      	movs	r3, #1
 8030194:	56e3      	ldrsb	r3, [r4, r3]
 8030196:	2b07      	cmp	r3, #7
 8030198:	d036      	beq.n	8030208 <RegionEU868TxConfig+0xe8>
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
    }
    else
    {
        modem = MODEM_LORA;
        Radio.SetTxConfig( modem, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
 803019a:	4b2d      	ldr	r3, [pc, #180]	; (8030250 <RegionEU868TxConfig+0x130>)
 803019c:	69dd      	ldr	r5, [r3, #28]
 803019e:	23fa      	movs	r3, #250	; 0xfa
 80301a0:	011b      	lsls	r3, r3, #4
 80301a2:	9308      	str	r3, [sp, #32]
 80301a4:	2300      	movs	r3, #0
 80301a6:	9307      	str	r3, [sp, #28]
 80301a8:	9306      	str	r3, [sp, #24]
 80301aa:	9305      	str	r3, [sp, #20]
 80301ac:	2201      	movs	r2, #1
 80301ae:	9204      	str	r2, [sp, #16]
 80301b0:	9303      	str	r3, [sp, #12]
 80301b2:	3308      	adds	r3, #8
 80301b4:	9302      	str	r3, [sp, #8]
 80301b6:	9201      	str	r2, [sp, #4]
 80301b8:	9700      	str	r7, [sp, #0]
 80301ba:	4653      	mov	r3, sl
 80301bc:	2200      	movs	r2, #0
 80301be:	4649      	mov	r1, r9
 80301c0:	2001      	movs	r0, #1
 80301c2:	47a8      	blx	r5
        modem = MODEM_LORA;
 80301c4:	2501      	movs	r5, #1
    }
    RegionCommonTxConfigPrint(RegionNvmGroup2->Channels[txConfig->Channel].Frequency, txConfig->Datarate);
 80301c6:	4b1f      	ldr	r3, [pc, #124]	; (8030244 <RegionEU868TxConfig+0x124>)
 80301c8:	6818      	ldr	r0, [r3, #0]
 80301ca:	7822      	ldrb	r2, [r4, #0]
 80301cc:	2101      	movs	r1, #1
 80301ce:	5661      	ldrsb	r1, [r4, r1]
 80301d0:	0053      	lsls	r3, r2, #1
 80301d2:	189b      	adds	r3, r3, r2
 80301d4:	009b      	lsls	r3, r3, #2
 80301d6:	5818      	ldr	r0, [r3, r0]
 80301d8:	f7ff fca8 	bl	802fb2c <RegionCommonTxConfigPrint>

    // Update time-on-air
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 80301dc:	89a1      	ldrh	r1, [r4, #12]
 80301de:	2001      	movs	r0, #1
 80301e0:	5620      	ldrsb	r0, [r4, r0]
 80301e2:	f7ff fd07 	bl	802fbf4 <GetTimeOnAir>
 80301e6:	4643      	mov	r3, r8
 80301e8:	6018      	str	r0, [r3, #0]

    // Setup maximum payload length of the radio driver
    Radio.SetMaxPayloadLength( modem, txConfig->PktLen );
 80301ea:	4b19      	ldr	r3, [pc, #100]	; (8030250 <RegionEU868TxConfig+0x130>)
 80301ec:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80301ee:	7b21      	ldrb	r1, [r4, #12]
 80301f0:	0028      	movs	r0, r5
 80301f2:	4798      	blx	r3

    *txPower = txPowerLimited;
 80301f4:	465b      	mov	r3, fp
 80301f6:	701e      	strb	r6, [r3, #0]
    return true;
#else
    return false;
#endif /* REGION_EU868 */
}
 80301f8:	2001      	movs	r0, #1
 80301fa:	b00b      	add	sp, #44	; 0x2c
 80301fc:	bcf0      	pop	{r4, r5, r6, r7}
 80301fe:	46bb      	mov	fp, r7
 8030200:	46b2      	mov	sl, r6
 8030202:	46a9      	mov	r9, r5
 8030204:	46a0      	mov	r8, r4
 8030206:	bdf0      	pop	{r4, r5, r6, r7, pc}
        Radio.SetTxConfig( modem, phyTxPower, 25000, bandwidth, phyDr * 1000, 0, 5, false, true, 0, 0, false, 4000 );
 8030208:	4b11      	ldr	r3, [pc, #68]	; (8030250 <RegionEU868TxConfig+0x130>)
 803020a:	69dd      	ldr	r5, [r3, #28]
 803020c:	017b      	lsls	r3, r7, #5
 803020e:	1bdb      	subs	r3, r3, r7
 8030210:	009b      	lsls	r3, r3, #2
 8030212:	19db      	adds	r3, r3, r7
 8030214:	00db      	lsls	r3, r3, #3
 8030216:	22fa      	movs	r2, #250	; 0xfa
 8030218:	0112      	lsls	r2, r2, #4
 803021a:	9208      	str	r2, [sp, #32]
 803021c:	2200      	movs	r2, #0
 803021e:	9207      	str	r2, [sp, #28]
 8030220:	9206      	str	r2, [sp, #24]
 8030222:	9205      	str	r2, [sp, #20]
 8030224:	2101      	movs	r1, #1
 8030226:	9104      	str	r1, [sp, #16]
 8030228:	9203      	str	r2, [sp, #12]
 803022a:	3104      	adds	r1, #4
 803022c:	9102      	str	r1, [sp, #8]
 803022e:	9201      	str	r2, [sp, #4]
 8030230:	9300      	str	r3, [sp, #0]
 8030232:	4653      	mov	r3, sl
 8030234:	4a07      	ldr	r2, [pc, #28]	; (8030254 <RegionEU868TxConfig+0x134>)
 8030236:	4649      	mov	r1, r9
 8030238:	2000      	movs	r0, #0
 803023a:	47a8      	blx	r5
        modem = MODEM_FSK;
 803023c:	2500      	movs	r5, #0
 803023e:	e7c2      	b.n	80301c6 <RegionEU868TxConfig+0xa6>
 8030240:	08035898 	.word	0x08035898
 8030244:	2000c318 	.word	0x2000c318
 8030248:	2000c314 	.word	0x2000c314
 803024c:	08035878 	.word	0x08035878
 8030250:	08035d8c 	.word	0x08035d8c
 8030254:	000061a8 	.word	0x000061a8

08030258 <RegionEU868LinkAdrReq>:

uint8_t RegionEU868LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 8030258:	b5f0      	push	{r4, r5, r6, r7, lr}
 803025a:	46d6      	mov	lr, sl
 803025c:	464f      	mov	r7, r9
 803025e:	4646      	mov	r6, r8
 8030260:	b5c0      	push	{r6, r7, lr}
 8030262:	b08e      	sub	sp, #56	; 0x38
 8030264:	0006      	movs	r6, r0
 8030266:	468a      	mov	sl, r1
 8030268:	4691      	mov	r9, r2
 803026a:	4698      	mov	r8, r3
    uint8_t status = 0x07;
#if defined( REGION_EU868 )
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 803026c:	2206      	movs	r2, #6
 803026e:	2100      	movs	r1, #0
 8030270:	a80c      	add	r0, sp, #48	; 0x30
 8030272:	f004 fc60 	bl	8034b36 <memset>
    uint8_t nextIndex = 0;
    uint8_t bytesProcessed = 0;
    uint16_t chMask = 0;
 8030276:	232e      	movs	r3, #46	; 0x2e
 8030278:	446b      	add	r3, sp
 803027a:	2200      	movs	r2, #0
 803027c:	801a      	strh	r2, [r3, #0]
    uint8_t bytesProcessed = 0;
 803027e:	2500      	movs	r5, #0
    uint8_t status = 0x07;
 8030280:	2707      	movs	r7, #7
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;
    RegionCommonLinkAdrReqVerifyParams_t linkAdrVerifyParams;

    while( bytesProcessed < linkAdrReq->PayloadSize )
 8030282:	e02b      	b.n	80302dc <RegionEU868LinkAdrReq+0x84>
            // RFU
            status &= 0xFE; // Channel mask KO
        }
        else
        {
            for( uint8_t i = 0; i < EU868_MAX_NB_CHANNELS; i++ )
 8030284:	2400      	movs	r4, #0
        status = 0x07;
 8030286:	2707      	movs	r7, #7
 8030288:	e010      	b.n	80302ac <RegionEU868LinkAdrReq+0x54>
            {
                if( linkAdrParams.ChMaskCtrl == 6 )
                {
                    if( RegionNvmGroup2->Channels[i].Frequency != 0 )
 803028a:	4a56      	ldr	r2, [pc, #344]	; (80303e4 <RegionEU868LinkAdrReq+0x18c>)
 803028c:	6811      	ldr	r1, [r2, #0]
 803028e:	0062      	lsls	r2, r4, #1
 8030290:	1912      	adds	r2, r2, r4
 8030292:	0092      	lsls	r2, r2, #2
 8030294:	5852      	ldr	r2, [r2, r1]
 8030296:	2a00      	cmp	r2, #0
 8030298:	d006      	beq.n	80302a8 <RegionEU868LinkAdrReq+0x50>
                    {
                        chMask |= 1 << i;
 803029a:	2001      	movs	r0, #1
 803029c:	40a0      	lsls	r0, r4
 803029e:	212e      	movs	r1, #46	; 0x2e
 80302a0:	4469      	add	r1, sp
 80302a2:	880a      	ldrh	r2, [r1, #0]
 80302a4:	4302      	orrs	r2, r0
 80302a6:	800a      	strh	r2, [r1, #0]
            for( uint8_t i = 0; i < EU868_MAX_NB_CHANNELS; i++ )
 80302a8:	3401      	adds	r4, #1
 80302aa:	b2e4      	uxtb	r4, r4
 80302ac:	2c0f      	cmp	r4, #15
 80302ae:	d815      	bhi.n	80302dc <RegionEU868LinkAdrReq+0x84>
                if( linkAdrParams.ChMaskCtrl == 6 )
 80302b0:	2b06      	cmp	r3, #6
 80302b2:	d0ea      	beq.n	803028a <RegionEU868LinkAdrReq+0x32>
                    }
                }
                else
                {
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 80302b4:	222e      	movs	r2, #46	; 0x2e
 80302b6:	446a      	add	r2, sp
 80302b8:	8812      	ldrh	r2, [r2, #0]
 80302ba:	4122      	asrs	r2, r4
 80302bc:	07d2      	lsls	r2, r2, #31
 80302be:	d5f3      	bpl.n	80302a8 <RegionEU868LinkAdrReq+0x50>
                        ( RegionNvmGroup2->Channels[i].Frequency == 0 ) )
 80302c0:	4a48      	ldr	r2, [pc, #288]	; (80303e4 <RegionEU868LinkAdrReq+0x18c>)
 80302c2:	6811      	ldr	r1, [r2, #0]
 80302c4:	0062      	lsls	r2, r4, #1
 80302c6:	1912      	adds	r2, r2, r4
 80302c8:	0092      	lsls	r2, r2, #2
 80302ca:	5852      	ldr	r2, [r2, r1]
                    if( ( ( chMask & ( 1 << i ) ) != 0 ) &&
 80302cc:	2a00      	cmp	r2, #0
 80302ce:	d1eb      	bne.n	80302a8 <RegionEU868LinkAdrReq+0x50>
                    {// Trying to enable an undefined channel
                        status &= 0xFE; // Channel mask KO
 80302d0:	3201      	adds	r2, #1
 80302d2:	4397      	bics	r7, r2
 80302d4:	e7e8      	b.n	80302a8 <RegionEU868LinkAdrReq+0x50>
            status &= 0xFE; // Channel mask KO
 80302d6:	2706      	movs	r7, #6
 80302d8:	e000      	b.n	80302dc <RegionEU868LinkAdrReq+0x84>
            status &= 0xFE; // Channel mask KO
 80302da:	2706      	movs	r7, #6
    while( bytesProcessed < linkAdrReq->PayloadSize )
 80302dc:	7a33      	ldrb	r3, [r6, #8]
 80302de:	42ab      	cmp	r3, r5
 80302e0:	d91a      	bls.n	8030318 <RegionEU868LinkAdrReq+0xc0>
        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
 80302e2:	6873      	ldr	r3, [r6, #4]
 80302e4:	1958      	adds	r0, r3, r5
 80302e6:	a90c      	add	r1, sp, #48	; 0x30
 80302e8:	f7ff fa26 	bl	802f738 <RegionCommonParseLinkAdrReq>
        if( nextIndex == 0 )
 80302ec:	2800      	cmp	r0, #0
 80302ee:	d013      	beq.n	8030318 <RegionEU868LinkAdrReq+0xc0>
        bytesProcessed += nextIndex;
 80302f0:	182d      	adds	r5, r5, r0
 80302f2:	b2ed      	uxtb	r5, r5
        chMask = linkAdrParams.ChMask;
 80302f4:	ab0c      	add	r3, sp, #48	; 0x30
 80302f6:	889a      	ldrh	r2, [r3, #4]
 80302f8:	212e      	movs	r1, #46	; 0x2e
 80302fa:	4469      	add	r1, sp
 80302fc:	800a      	strh	r2, [r1, #0]
        if( ( linkAdrParams.ChMaskCtrl == 0 ) && ( chMask == 0 ) )
 80302fe:	78db      	ldrb	r3, [r3, #3]
 8030300:	2b00      	cmp	r3, #0
 8030302:	d101      	bne.n	8030308 <RegionEU868LinkAdrReq+0xb0>
 8030304:	2a00      	cmp	r2, #0
 8030306:	d0e6      	beq.n	80302d6 <RegionEU868LinkAdrReq+0x7e>
        else if( ( ( linkAdrParams.ChMaskCtrl >= 1 ) && ( linkAdrParams.ChMaskCtrl <= 5 )) ||
 8030308:	1e5a      	subs	r2, r3, #1
 803030a:	b2d2      	uxtb	r2, r2
 803030c:	2a04      	cmp	r2, #4
 803030e:	d9e4      	bls.n	80302da <RegionEU868LinkAdrReq+0x82>
 8030310:	2b06      	cmp	r3, #6
 8030312:	d9b7      	bls.n	8030284 <RegionEU868LinkAdrReq+0x2c>
            status &= 0xFE; // Channel mask KO
 8030314:	2706      	movs	r7, #6
 8030316:	e7e1      	b.n	80302dc <RegionEU868LinkAdrReq+0x84>
            }
        }
    }

    // Get the minimum possible datarate
    getPhy.Attribute = PHY_MIN_TX_DR;
 8030318:	2302      	movs	r3, #2
 803031a:	466a      	mov	r2, sp
 803031c:	2128      	movs	r1, #40	; 0x28
 803031e:	1852      	adds	r2, r2, r1
 8030320:	7013      	strb	r3, [r2, #0]
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
 8030322:	7a73      	ldrb	r3, [r6, #9]
 8030324:	466a      	mov	r2, sp
 8030326:	3102      	adds	r1, #2
 8030328:	1852      	adds	r2, r2, r1
 803032a:	7013      	strb	r3, [r2, #0]
    phyParam = RegionEU868GetPhyParam( &getPhy );
 803032c:	a80a      	add	r0, sp, #40	; 0x28
 803032e:	f7ff fc97 	bl	802fc60 <RegionEU868GetPhyParam>
 8030332:	0002      	movs	r2, r0
 8030334:	9009      	str	r0, [sp, #36]	; 0x24

    linkAdrVerifyParams.Status = status;
 8030336:	a801      	add	r0, sp, #4
 8030338:	7107      	strb	r7, [r0, #4]
    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
 803033a:	7ab3      	ldrb	r3, [r6, #10]
 803033c:	7143      	strb	r3, [r0, #5]
    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
 803033e:	ab0c      	add	r3, sp, #48	; 0x30
 8030340:	2101      	movs	r1, #1
 8030342:	5659      	ldrsb	r1, [r3, r1]
 8030344:	7181      	strb	r1, [r0, #6]
    linkAdrVerifyParams.TxPower = linkAdrParams.TxPower;
 8030346:	2102      	movs	r1, #2
 8030348:	5659      	ldrsb	r1, [r3, r1]
 803034a:	71c1      	strb	r1, [r0, #7]
    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
 803034c:	7819      	ldrb	r1, [r3, #0]
 803034e:	7201      	strb	r1, [r0, #8]
    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
 8030350:	210b      	movs	r1, #11
 8030352:	5671      	ldrsb	r1, [r6, r1]
 8030354:	7241      	strb	r1, [r0, #9]
    linkAdrVerifyParams.CurrentTxPower = linkAdrReq->CurrentTxPower;
 8030356:	210c      	movs	r1, #12
 8030358:	5671      	ldrsb	r1, [r6, r1]
 803035a:	7281      	strb	r1, [r0, #10]
    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
 803035c:	210d      	movs	r1, #13
 803035e:	5671      	ldrsb	r1, [r6, r1]
 8030360:	72c1      	strb	r1, [r0, #11]
    linkAdrVerifyParams.NbChannels = EU868_MAX_NB_CHANNELS;
 8030362:	2110      	movs	r1, #16
 8030364:	7301      	strb	r1, [r0, #12]
    linkAdrVerifyParams.ChannelsMask = &chMask;
 8030366:	311e      	adds	r1, #30
 8030368:	4469      	add	r1, sp
 803036a:	6101      	str	r1, [r0, #16]
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
 803036c:	7502      	strb	r2, [r0, #20]
    linkAdrVerifyParams.MaxDatarate = EU868_TX_MAX_DATARATE;
 803036e:	2207      	movs	r2, #7
 8030370:	7542      	strb	r2, [r0, #21]
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 8030372:	491c      	ldr	r1, [pc, #112]	; (80303e4 <RegionEU868LinkAdrReq+0x18c>)
 8030374:	6809      	ldr	r1, [r1, #0]
 8030376:	6181      	str	r1, [r0, #24]
    linkAdrVerifyParams.MinTxPower = EU868_MIN_TX_POWER;
 8030378:	7702      	strb	r2, [r0, #28]
    linkAdrVerifyParams.MaxTxPower = EU868_MAX_TX_POWER;
 803037a:	2200      	movs	r2, #0
 803037c:	7742      	strb	r2, [r0, #29]
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 803037e:	6832      	ldr	r2, [r6, #0]
 8030380:	9201      	str	r2, [sp, #4]

    // Verify the parameters and update, if necessary
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 8030382:	2232      	movs	r2, #50	; 0x32
 8030384:	446a      	add	r2, sp
 8030386:	2131      	movs	r1, #49	; 0x31
 8030388:	4469      	add	r1, sp
 803038a:	f7ff f9f4 	bl	802f776 <RegionCommonLinkAdrReqVerifyParams>
 803038e:	0004      	movs	r4, r0

    // Update channelsMask if everything is correct
    if( status == 0x07 )
 8030390:	2807      	cmp	r0, #7
 8030392:	d014      	beq.n	80303be <RegionEU868LinkAdrReq+0x166>
        // Update the channels mask
        RegionNvmGroup2->ChannelsMask[0] = chMask;
    }

    // Update status variables
    *drOut = linkAdrParams.Datarate;
 8030394:	ab0c      	add	r3, sp, #48	; 0x30
 8030396:	2201      	movs	r2, #1
 8030398:	569a      	ldrsb	r2, [r3, r2]
 803039a:	4651      	mov	r1, sl
 803039c:	700a      	strb	r2, [r1, #0]
    *txPowOut = linkAdrParams.TxPower;
 803039e:	2202      	movs	r2, #2
 80303a0:	569a      	ldrsb	r2, [r3, r2]
 80303a2:	4649      	mov	r1, r9
 80303a4:	700a      	strb	r2, [r1, #0]
    *nbRepOut = linkAdrParams.NbRep;
 80303a6:	781b      	ldrb	r3, [r3, #0]
 80303a8:	4642      	mov	r2, r8
 80303aa:	7013      	strb	r3, [r2, #0]
    *nbBytesParsed = bytesProcessed;
 80303ac:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80303ae:	701d      	strb	r5, [r3, #0]

#endif /* REGION_EU868 */
    return status;
}
 80303b0:	0020      	movs	r0, r4
 80303b2:	b00e      	add	sp, #56	; 0x38
 80303b4:	bce0      	pop	{r5, r6, r7}
 80303b6:	46ba      	mov	sl, r7
 80303b8:	46b1      	mov	r9, r6
 80303ba:	46a8      	mov	r8, r5
 80303bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
        memset1( ( uint8_t* ) RegionNvmGroup2->ChannelsMask, 0, sizeof( RegionNvmGroup2->ChannelsMask ) );
 80303be:	4e09      	ldr	r6, [pc, #36]	; (80303e4 <RegionEU868LinkAdrReq+0x18c>)
 80303c0:	6830      	ldr	r0, [r6, #0]
 80303c2:	23d8      	movs	r3, #216	; 0xd8
 80303c4:	009b      	lsls	r3, r3, #2
 80303c6:	469c      	mov	ip, r3
 80303c8:	4460      	add	r0, ip
 80303ca:	220c      	movs	r2, #12
 80303cc:	2100      	movs	r1, #0
 80303ce:	f001 feb0 	bl	8032132 <memset1>
        RegionNvmGroup2->ChannelsMask[0] = chMask;
 80303d2:	6832      	ldr	r2, [r6, #0]
 80303d4:	232e      	movs	r3, #46	; 0x2e
 80303d6:	446b      	add	r3, sp
 80303d8:	8819      	ldrh	r1, [r3, #0]
 80303da:	23d8      	movs	r3, #216	; 0xd8
 80303dc:	009b      	lsls	r3, r3, #2
 80303de:	52d1      	strh	r1, [r2, r3]
 80303e0:	e7d8      	b.n	8030394 <RegionEU868LinkAdrReq+0x13c>
 80303e2:	46c0      	nop			; (mov r8, r8)
 80303e4:	2000c318 	.word	0x2000c318

080303e8 <RegionEU868RxParamSetupReq>:

uint8_t RegionEU868RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq )
{
 80303e8:	b530      	push	{r4, r5, lr}
 80303ea:	b083      	sub	sp, #12
 80303ec:	0004      	movs	r4, r0
    uint8_t status = 0x07;
#if defined( REGION_EU868 )
    uint8_t band = 0;
 80303ee:	466b      	mov	r3, sp
 80303f0:	1dd9      	adds	r1, r3, #7
 80303f2:	2300      	movs	r3, #0
 80303f4:	700b      	strb	r3, [r1, #0]

    // Verify radio frequency
    if( VerifyRfFreq( rxParamSetupReq->Frequency, &band ) == false )
 80303f6:	6840      	ldr	r0, [r0, #4]
 80303f8:	f7ff fba6 	bl	802fb48 <VerifyRfFreq>
 80303fc:	2800      	cmp	r0, #0
 80303fe:	d017      	beq.n	8030430 <RegionEU868RxParamSetupReq+0x48>
    uint8_t status = 0x07;
 8030400:	2507      	movs	r5, #7
    {
        status &= 0xFE; // Channel frequency KO
    }

    // Verify datarate
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, EU868_RX_MIN_DATARATE, EU868_RX_MAX_DATARATE ) == false )
 8030402:	2000      	movs	r0, #0
 8030404:	5620      	ldrsb	r0, [r4, r0]
 8030406:	2207      	movs	r2, #7
 8030408:	2100      	movs	r1, #0
 803040a:	f7ff f85e 	bl	802f4ca <RegionCommonValueInRange>
 803040e:	2800      	cmp	r0, #0
 8030410:	d101      	bne.n	8030416 <RegionEU868RxParamSetupReq+0x2e>
    {
        status &= 0xFD; // Datarate KO
 8030412:	2302      	movs	r3, #2
 8030414:	439d      	bics	r5, r3
    }

    // Verify datarate offset
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, EU868_MIN_RX1_DR_OFFSET, EU868_MAX_RX1_DR_OFFSET ) == false )
 8030416:	2001      	movs	r0, #1
 8030418:	5620      	ldrsb	r0, [r4, r0]
 803041a:	2205      	movs	r2, #5
 803041c:	2100      	movs	r1, #0
 803041e:	f7ff f854 	bl	802f4ca <RegionCommonValueInRange>
 8030422:	2800      	cmp	r0, #0
 8030424:	d101      	bne.n	803042a <RegionEU868RxParamSetupReq+0x42>
    {
        status &= 0xFB; // Rx1DrOffset range KO
 8030426:	2304      	movs	r3, #4
 8030428:	439d      	bics	r5, r3
    }

#endif /* REGION_EU868 */
    return status;
}
 803042a:	0028      	movs	r0, r5
 803042c:	b003      	add	sp, #12
 803042e:	bd30      	pop	{r4, r5, pc}
        status &= 0xFE; // Channel frequency KO
 8030430:	2506      	movs	r5, #6
 8030432:	e7e6      	b.n	8030402 <RegionEU868RxParamSetupReq+0x1a>

08030434 <RegionEU868TxParamSetupReq>:
}

int8_t RegionEU868TxParamSetupReq( TxParamSetupReqParams_t* txParamSetupReq )
{
    // Do not accept the request
    return -1;
 8030434:	2001      	movs	r0, #1
}
 8030436:	4240      	negs	r0, r0
 8030438:	4770      	bx	lr
	...

0803043c <RegionEU868DlChannelReq>:

int8_t RegionEU868DlChannelReq( DlChannelReqParams_t* dlChannelReq )
{
 803043c:	b510      	push	{r4, lr}
 803043e:	b082      	sub	sp, #8
 8030440:	0004      	movs	r4, r0
    uint8_t status = 0x03;

#if defined( REGION_EU868 )
    uint8_t band = 0;
 8030442:	466b      	mov	r3, sp
 8030444:	2200      	movs	r2, #0
 8030446:	71da      	strb	r2, [r3, #7]

    if( dlChannelReq->ChannelId >= ( CHANNELS_MASK_SIZE * 16 ) )
 8030448:	7803      	ldrb	r3, [r0, #0]
 803044a:	2b0f      	cmp	r3, #15
 803044c:	d902      	bls.n	8030454 <RegionEU868DlChannelReq+0x18>
    {
        return 0;
 803044e:	2000      	movs	r0, #0
        RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Rx1Frequency = dlChannelReq->Rx1Frequency;
    }

#endif /* REGION_EU868 */
    return status;
}
 8030450:	b002      	add	sp, #8
 8030452:	bd10      	pop	{r4, pc}
    if( VerifyRfFreq( dlChannelReq->Rx1Frequency, &band ) == false )
 8030454:	466b      	mov	r3, sp
 8030456:	1dd9      	adds	r1, r3, #7
 8030458:	6840      	ldr	r0, [r0, #4]
 803045a:	f7ff fb75 	bl	802fb48 <VerifyRfFreq>
 803045e:	2800      	cmp	r0, #0
 8030460:	d00f      	beq.n	8030482 <RegionEU868DlChannelReq+0x46>
    uint8_t status = 0x03;
 8030462:	2003      	movs	r0, #3
    if( RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Frequency == 0 )
 8030464:	4b0b      	ldr	r3, [pc, #44]	; (8030494 <RegionEU868DlChannelReq+0x58>)
 8030466:	6819      	ldr	r1, [r3, #0]
 8030468:	7822      	ldrb	r2, [r4, #0]
 803046a:	0053      	lsls	r3, r2, #1
 803046c:	189b      	adds	r3, r3, r2
 803046e:	009b      	lsls	r3, r3, #2
 8030470:	585b      	ldr	r3, [r3, r1]
 8030472:	2b00      	cmp	r3, #0
 8030474:	d101      	bne.n	803047a <RegionEU868DlChannelReq+0x3e>
        status &= 0xFD;
 8030476:	3302      	adds	r3, #2
 8030478:	4398      	bics	r0, r3
    if( status == 0x03 )
 803047a:	2803      	cmp	r0, #3
 803047c:	d003      	beq.n	8030486 <RegionEU868DlChannelReq+0x4a>
    return status;
 803047e:	b240      	sxtb	r0, r0
 8030480:	e7e6      	b.n	8030450 <RegionEU868DlChannelReq+0x14>
        status &= 0xFE;
 8030482:	2002      	movs	r0, #2
 8030484:	e7ee      	b.n	8030464 <RegionEU868DlChannelReq+0x28>
        RegionNvmGroup2->Channels[dlChannelReq->ChannelId].Rx1Frequency = dlChannelReq->Rx1Frequency;
 8030486:	6864      	ldr	r4, [r4, #4]
 8030488:	0053      	lsls	r3, r2, #1
 803048a:	189a      	adds	r2, r3, r2
 803048c:	0092      	lsls	r2, r2, #2
 803048e:	1889      	adds	r1, r1, r2
 8030490:	604c      	str	r4, [r1, #4]
 8030492:	e7f4      	b.n	803047e <RegionEU868DlChannelReq+0x42>
 8030494:	2000c318 	.word	0x2000c318

08030498 <RegionEU868AlternateDr>:
#if defined( REGION_EU868 )
    return currentDr;
#else
    return -1;
#endif /* REGION_EU868 */
}
 8030498:	4770      	bx	lr
	...

0803049c <RegionEU868NextChannel>:

LoRaMacStatus_t RegionEU868NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 803049c:	b5f0      	push	{r4, r5, r6, r7, lr}
 803049e:	46c6      	mov	lr, r8
 80304a0:	b500      	push	{lr}
 80304a2:	b098      	sub	sp, #96	; 0x60
 80304a4:	0004      	movs	r4, r0
 80304a6:	9103      	str	r1, [sp, #12]
 80304a8:	0017      	movs	r7, r2
 80304aa:	4698      	mov	r8, r3
#if defined( REGION_EU868 )
    uint8_t nbEnabledChannels = 0;
 80304ac:	2300      	movs	r3, #0
 80304ae:	2257      	movs	r2, #87	; 0x57
 80304b0:	a902      	add	r1, sp, #8
 80304b2:	468c      	mov	ip, r1
 80304b4:	4462      	add	r2, ip
 80304b6:	7013      	strb	r3, [r2, #0]
    uint8_t nbRestrictedChannels = 0;
 80304b8:	2256      	movs	r2, #86	; 0x56
 80304ba:	4462      	add	r2, ip
 80304bc:	7013      	strb	r3, [r2, #0]
    uint8_t enabledChannels[EU868_MAX_NB_CHANNELS] = { 0 };
 80304be:	9313      	str	r3, [sp, #76]	; 0x4c
 80304c0:	220c      	movs	r2, #12
 80304c2:	2100      	movs	r1, #0
 80304c4:	a814      	add	r0, sp, #80	; 0x50
 80304c6:	f004 fb36 	bl	8034b36 <memset>
    RegionCommonIdentifyChannelsParam_t identifyChannelsParam;
    RegionCommonCountNbOfEnabledChannelsParams_t countChannelsParams;
    LoRaMacStatus_t status = LORAMAC_STATUS_NO_CHANNEL_FOUND;
    uint16_t joinChannels = EU868_JOIN_CHANNELS;
 80304ca:	230a      	movs	r3, #10
 80304cc:	aa02      	add	r2, sp, #8
 80304ce:	4694      	mov	ip, r2
 80304d0:	4463      	add	r3, ip
 80304d2:	2207      	movs	r2, #7
 80304d4:	801a      	strh	r2, [r3, #0]

    if( RegionCommonCountChannels( RegionNvmGroup2->ChannelsMask, 0, 1 ) == 0 )
 80304d6:	4b37      	ldr	r3, [pc, #220]	; (80305b4 <RegionEU868NextChannel+0x118>)
 80304d8:	6818      	ldr	r0, [r3, #0]
 80304da:	23d8      	movs	r3, #216	; 0xd8
 80304dc:	009b      	lsls	r3, r3, #2
 80304de:	469c      	mov	ip, r3
 80304e0:	4460      	add	r0, ip
 80304e2:	3a06      	subs	r2, #6
 80304e4:	2100      	movs	r1, #0
 80304e6:	f7ff f853 	bl	802f590 <RegionCommonCountChannels>
 80304ea:	2800      	cmp	r0, #0
 80304ec:	d107      	bne.n	80304fe <RegionEU868NextChannel+0x62>
    { // Reactivate default channels
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 80304ee:	4b31      	ldr	r3, [pc, #196]	; (80305b4 <RegionEU868NextChannel+0x118>)
 80304f0:	6819      	ldr	r1, [r3, #0]
 80304f2:	22d8      	movs	r2, #216	; 0xd8
 80304f4:	0092      	lsls	r2, r2, #2
 80304f6:	5a8b      	ldrh	r3, [r1, r2]
 80304f8:	2007      	movs	r0, #7
 80304fa:	4303      	orrs	r3, r0
 80304fc:	528b      	strh	r3, [r1, r2]
    }

    // Search how many channels are enabled
    countChannelsParams.Joined = nextChanParams->Joined;
 80304fe:	7a63      	ldrb	r3, [r4, #9]
 8030500:	ad05      	add	r5, sp, #20
 8030502:	702b      	strb	r3, [r5, #0]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 8030504:	7a23      	ldrb	r3, [r4, #8]
 8030506:	706b      	strb	r3, [r5, #1]
    countChannelsParams.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 8030508:	4b2a      	ldr	r3, [pc, #168]	; (80305b4 <RegionEU868NextChannel+0x118>)
 803050a:	681b      	ldr	r3, [r3, #0]
 803050c:	22d8      	movs	r2, #216	; 0xd8
 803050e:	0092      	lsls	r2, r2, #2
 8030510:	189a      	adds	r2, r3, r2
 8030512:	9206      	str	r2, [sp, #24]
    countChannelsParams.Channels = RegionNvmGroup2->Channels;
 8030514:	9307      	str	r3, [sp, #28]
#if (defined( REGION_VERSION ) && ( REGION_VERSION == 0x01010003 ))
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
#elif (defined( REGION_VERSION ) && ( REGION_VERSION == 0x02010001 ))
    countChannelsParams.Bands = RegionBands;
 8030516:	4b28      	ldr	r3, [pc, #160]	; (80305b8 <RegionEU868NextChannel+0x11c>)
 8030518:	681b      	ldr	r3, [r3, #0]
 803051a:	9308      	str	r3, [sp, #32]
#endif /* REGION_VERSION */
    countChannelsParams.MaxNbChannels = EU868_MAX_NB_CHANNELS;
 803051c:	2310      	movs	r3, #16
 803051e:	822b      	strh	r3, [r5, #16]
    countChannelsParams.JoinChannels = &joinChannels;
 8030520:	3b06      	subs	r3, #6
 8030522:	aa02      	add	r2, sp, #8
 8030524:	4694      	mov	ip, r2
 8030526:	4463      	add	r3, ip
 8030528:	930a      	str	r3, [sp, #40]	; 0x28

    identifyChannelsParam.AggrTimeOff = nextChanParams->AggrTimeOff;
 803052a:	ae0b      	add	r6, sp, #44	; 0x2c
 803052c:	6823      	ldr	r3, [r4, #0]
 803052e:	930b      	str	r3, [sp, #44]	; 0x2c
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 8030530:	6863      	ldr	r3, [r4, #4]
 8030532:	930c      	str	r3, [sp, #48]	; 0x30
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 8030534:	7aa3      	ldrb	r3, [r4, #10]
 8030536:	7233      	strb	r3, [r6, #8]
    identifyChannelsParam.MaxBands = EU868_MAX_NB_BANDS;
 8030538:	2306      	movs	r3, #6
 803053a:	7273      	strb	r3, [r6, #9]

    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 803053c:	a80e      	add	r0, sp, #56	; 0x38
 803053e:	0021      	movs	r1, r4
 8030540:	310c      	adds	r1, #12
 8030542:	c90c      	ldmia	r1!, {r2, r3}
 8030544:	c00c      	stmia	r0!, {r2, r3}
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 8030546:	7d23      	ldrb	r3, [r4, #20]
 8030548:	7533      	strb	r3, [r6, #20]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 803054a:	8ae1      	ldrh	r1, [r4, #22]
 803054c:	2008      	movs	r0, #8
 803054e:	5620      	ldrsb	r0, [r4, r0]
 8030550:	f7ff fb50 	bl	802fbf4 <GetTimeOnAir>
 8030554:	9011      	str	r0, [sp, #68]	; 0x44

    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
 8030556:	9512      	str	r5, [sp, #72]	; 0x48

    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 8030558:	9701      	str	r7, [sp, #4]
 803055a:	2356      	movs	r3, #86	; 0x56
 803055c:	aa02      	add	r2, sp, #8
 803055e:	4694      	mov	ip, r2
 8030560:	4463      	add	r3, ip
 8030562:	9300      	str	r3, [sp, #0]
 8030564:	2357      	movs	r3, #87	; 0x57
 8030566:	4463      	add	r3, ip
 8030568:	aa13      	add	r2, sp, #76	; 0x4c
 803056a:	4641      	mov	r1, r8
 803056c:	0030      	movs	r0, r6
 803056e:	f7ff fa37 	bl	802f9e0 <RegionCommonIdentifyChannels>
 8030572:	0004      	movs	r4, r0
 8030574:	1e03      	subs	r3, r0, #0
                                           &nbEnabledChannels, &nbRestrictedChannels, time );

    if( status == LORAMAC_STATUS_OK )
 8030576:	d006      	beq.n	8030586 <RegionEU868NextChannel+0xea>
    {
        // We found a valid channel
        *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
    }
    else if( status == LORAMAC_STATUS_NO_CHANNEL_FOUND )
 8030578:	280c      	cmp	r0, #12
 803057a:	d012      	beq.n	80305a2 <RegionEU868NextChannel+0x106>
    }
    return status;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_EU868 */
}
 803057c:	0020      	movs	r0, r4
 803057e:	b018      	add	sp, #96	; 0x60
 8030580:	bc80      	pop	{r7}
 8030582:	46b8      	mov	r8, r7
 8030584:	bdf0      	pop	{r4, r5, r6, r7, pc}
        *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
 8030586:	3357      	adds	r3, #87	; 0x57
 8030588:	aa02      	add	r2, sp, #8
 803058a:	4694      	mov	ip, r2
 803058c:	4463      	add	r3, ip
 803058e:	7819      	ldrb	r1, [r3, #0]
 8030590:	3901      	subs	r1, #1
 8030592:	2000      	movs	r0, #0
 8030594:	f001 fdaa 	bl	80320ec <randr>
 8030598:	ab13      	add	r3, sp, #76	; 0x4c
 803059a:	5c1b      	ldrb	r3, [r3, r0]
 803059c:	9a03      	ldr	r2, [sp, #12]
 803059e:	7013      	strb	r3, [r2, #0]
 80305a0:	e7ec      	b.n	803057c <RegionEU868NextChannel+0xe0>
        RegionNvmGroup2->ChannelsMask[0] |= LC( 1 ) + LC( 2 ) + LC( 3 );
 80305a2:	4b04      	ldr	r3, [pc, #16]	; (80305b4 <RegionEU868NextChannel+0x118>)
 80305a4:	6819      	ldr	r1, [r3, #0]
 80305a6:	22d8      	movs	r2, #216	; 0xd8
 80305a8:	0092      	lsls	r2, r2, #2
 80305aa:	5a8b      	ldrh	r3, [r1, r2]
 80305ac:	2007      	movs	r0, #7
 80305ae:	4303      	orrs	r3, r0
 80305b0:	528b      	strh	r3, [r1, r2]
 80305b2:	e7e3      	b.n	803057c <RegionEU868NextChannel+0xe0>
 80305b4:	2000c318 	.word	0x2000c318
 80305b8:	2000c314 	.word	0x2000c314

080305bc <RegionEU868ChannelAdd>:

LoRaMacStatus_t RegionEU868ChannelAdd( ChannelAddParams_t* channelAdd )
{
 80305bc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80305be:	b083      	sub	sp, #12
 80305c0:	0004      	movs	r4, r0
#if defined( REGION_EU868 )
    uint8_t band = 0;
 80305c2:	466b      	mov	r3, sp
 80305c4:	2200      	movs	r2, #0
 80305c6:	71da      	strb	r2, [r3, #7]
    bool drInvalid = false;
    bool freqInvalid = false;
    uint8_t id = channelAdd->ChannelId;
 80305c8:	7905      	ldrb	r5, [r0, #4]

    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 80305ca:	2d02      	cmp	r5, #2
 80305cc:	d952      	bls.n	8030674 <RegionEU868ChannelAdd+0xb8>
    {
        return LORAMAC_STATUS_FREQ_AND_DR_INVALID;
    }

    if( id >= EU868_MAX_NB_CHANNELS )
 80305ce:	2d0f      	cmp	r5, #15
 80305d0:	d852      	bhi.n	8030678 <RegionEU868ChannelAdd+0xbc>
    {
        return LORAMAC_STATUS_PARAMETER_INVALID;
    }

    // Validate the datarate range
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Min, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 80305d2:	6803      	ldr	r3, [r0, #0]
 80305d4:	7a18      	ldrb	r0, [r3, #8]
 80305d6:	0100      	lsls	r0, r0, #4
 80305d8:	b240      	sxtb	r0, r0
 80305da:	1100      	asrs	r0, r0, #4
 80305dc:	3207      	adds	r2, #7
 80305de:	2100      	movs	r1, #0
 80305e0:	f7fe ff73 	bl	802f4ca <RegionCommonValueInRange>
 80305e4:	2800      	cmp	r0, #0
 80305e6:	d041      	beq.n	803066c <RegionEU868ChannelAdd+0xb0>
    bool drInvalid = false;
 80305e8:	2600      	movs	r6, #0
    {
        drInvalid = true;
    }
    if( RegionCommonValueInRange( channelAdd->NewChannel->DrRange.Fields.Max, EU868_TX_MIN_DATARATE, EU868_TX_MAX_DATARATE ) == false )
 80305ea:	6823      	ldr	r3, [r4, #0]
 80305ec:	2008      	movs	r0, #8
 80305ee:	5618      	ldrsb	r0, [r3, r0]
 80305f0:	1100      	asrs	r0, r0, #4
 80305f2:	2207      	movs	r2, #7
 80305f4:	2100      	movs	r1, #0
 80305f6:	f7fe ff68 	bl	802f4ca <RegionCommonValueInRange>
 80305fa:	2800      	cmp	r0, #0
 80305fc:	d100      	bne.n	8030600 <RegionEU868ChannelAdd+0x44>
    {
        drInvalid = true;
 80305fe:	2601      	movs	r6, #1
    }
    if( channelAdd->NewChannel->DrRange.Fields.Min > channelAdd->NewChannel->DrRange.Fields.Max )
 8030600:	6821      	ldr	r1, [r4, #0]
 8030602:	7a0b      	ldrb	r3, [r1, #8]
 8030604:	011a      	lsls	r2, r3, #4
 8030606:	b252      	sxtb	r2, r2
 8030608:	1112      	asrs	r2, r2, #4
 803060a:	b25b      	sxtb	r3, r3
 803060c:	111b      	asrs	r3, r3, #4
 803060e:	429a      	cmp	r2, r3
 8030610:	dd00      	ble.n	8030614 <RegionEU868ChannelAdd+0x58>
    {
        drInvalid = true;
 8030612:	2601      	movs	r6, #1
    }

    // Check frequency
    if( freqInvalid == false )
    {
        if( VerifyRfFreq( channelAdd->NewChannel->Frequency, &band ) == false )
 8030614:	6808      	ldr	r0, [r1, #0]
 8030616:	466b      	mov	r3, sp
 8030618:	1dd9      	adds	r1, r3, #7
 803061a:	f7ff fa95 	bl	802fb48 <VerifyRfFreq>
 803061e:	2800      	cmp	r0, #0
 8030620:	d026      	beq.n	8030670 <RegionEU868ChannelAdd+0xb4>
    bool freqInvalid = false;
 8030622:	2300      	movs	r3, #0
            freqInvalid = true;
        }
    }

    // Check status
    if( ( drInvalid == true ) && ( freqInvalid == true ) )
 8030624:	2e00      	cmp	r6, #0
 8030626:	d001      	beq.n	803062c <RegionEU868ChannelAdd+0x70>
 8030628:	2b00      	cmp	r3, #0
 803062a:	d128      	bne.n	803067e <RegionEU868ChannelAdd+0xc2>
    {
        return LORAMAC_STATUS_FREQ_AND_DR_INVALID;
    }
    if( drInvalid == true )
 803062c:	2e00      	cmp	r6, #0
 803062e:	d128      	bne.n	8030682 <RegionEU868ChannelAdd+0xc6>
    {
        return LORAMAC_STATUS_DATARATE_INVALID;
    }
    if( freqInvalid == true )
 8030630:	2b00      	cmp	r3, #0
 8030632:	d128      	bne.n	8030686 <RegionEU868ChannelAdd+0xca>
    {
        return LORAMAC_STATUS_FREQUENCY_INVALID;
    }

    memcpy1( ( uint8_t* ) &(RegionNvmGroup2->Channels[id]), ( uint8_t* ) channelAdd->NewChannel, sizeof( RegionNvmGroup2->Channels[id] ) );
 8030634:	4f15      	ldr	r7, [pc, #84]	; (803068c <RegionEU868ChannelAdd+0xd0>)
 8030636:	006e      	lsls	r6, r5, #1
 8030638:	1970      	adds	r0, r6, r5
 803063a:	0080      	lsls	r0, r0, #2
 803063c:	683b      	ldr	r3, [r7, #0]
 803063e:	469c      	mov	ip, r3
 8030640:	4460      	add	r0, ip
 8030642:	6821      	ldr	r1, [r4, #0]
 8030644:	220c      	movs	r2, #12
 8030646:	f001 fd5c 	bl	8032102 <memcpy1>
    RegionNvmGroup2->Channels[id].Band = band;
 803064a:	683b      	ldr	r3, [r7, #0]
 803064c:	1976      	adds	r6, r6, r5
 803064e:	00b6      	lsls	r6, r6, #2
 8030650:	199e      	adds	r6, r3, r6
 8030652:	466a      	mov	r2, sp
 8030654:	3207      	adds	r2, #7
 8030656:	7812      	ldrb	r2, [r2, #0]
 8030658:	7272      	strb	r2, [r6, #9]
    RegionNvmGroup2->ChannelsMask[0] |= ( 1 << id );
 803065a:	2101      	movs	r1, #1
 803065c:	40a9      	lsls	r1, r5
 803065e:	20d8      	movs	r0, #216	; 0xd8
 8030660:	0080      	lsls	r0, r0, #2
 8030662:	5a1a      	ldrh	r2, [r3, r0]
 8030664:	430a      	orrs	r2, r1
 8030666:	521a      	strh	r2, [r3, r0]
    return LORAMAC_STATUS_OK;
 8030668:	2000      	movs	r0, #0
 803066a:	e006      	b.n	803067a <RegionEU868ChannelAdd+0xbe>
        drInvalid = true;
 803066c:	2601      	movs	r6, #1
 803066e:	e7bc      	b.n	80305ea <RegionEU868ChannelAdd+0x2e>
            freqInvalid = true;
 8030670:	2301      	movs	r3, #1
 8030672:	e7d7      	b.n	8030624 <RegionEU868ChannelAdd+0x68>
        return LORAMAC_STATUS_FREQ_AND_DR_INVALID;
 8030674:	2006      	movs	r0, #6
 8030676:	e000      	b.n	803067a <RegionEU868ChannelAdd+0xbe>
        return LORAMAC_STATUS_PARAMETER_INVALID;
 8030678:	2003      	movs	r0, #3
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_EU868 */
}
 803067a:	b003      	add	sp, #12
 803067c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return LORAMAC_STATUS_FREQ_AND_DR_INVALID;
 803067e:	2006      	movs	r0, #6
 8030680:	e7fb      	b.n	803067a <RegionEU868ChannelAdd+0xbe>
        return LORAMAC_STATUS_DATARATE_INVALID;
 8030682:	2005      	movs	r0, #5
 8030684:	e7f9      	b.n	803067a <RegionEU868ChannelAdd+0xbe>
        return LORAMAC_STATUS_FREQUENCY_INVALID;
 8030686:	2004      	movs	r0, #4
 8030688:	e7f7      	b.n	803067a <RegionEU868ChannelAdd+0xbe>
 803068a:	46c0      	nop			; (mov r8, r8)
 803068c:	2000c318 	.word	0x2000c318

08030690 <RegionEU868ChannelsRemove>:

bool RegionEU868ChannelsRemove( ChannelRemoveParams_t* channelRemove  )
{
 8030690:	b570      	push	{r4, r5, r6, lr}
#if defined( REGION_EU868 )
    uint8_t id = channelRemove->ChannelId;
 8030692:	7804      	ldrb	r4, [r0, #0]

    if( id < EU868_NUMB_DEFAULT_CHANNELS )
 8030694:	2c02      	cmp	r4, #2
 8030696:	d801      	bhi.n	803069c <RegionEU868ChannelsRemove+0xc>
    {
        return false;
 8030698:	2000      	movs	r0, #0

    return RegionCommonChanDisable( RegionNvmGroup2->ChannelsMask, id, EU868_MAX_NB_CHANNELS );
#else
    return false;
#endif /* REGION_EU868 */
}
 803069a:	bd70      	pop	{r4, r5, r6, pc}
    RegionNvmGroup2->Channels[id] = ( ChannelParams_t ){ 0, 0, { 0 }, 0 };
 803069c:	4b08      	ldr	r3, [pc, #32]	; (80306c0 <RegionEU868ChannelsRemove+0x30>)
 803069e:	681d      	ldr	r5, [r3, #0]
 80306a0:	0060      	lsls	r0, r4, #1
 80306a2:	1900      	adds	r0, r0, r4
 80306a4:	0080      	lsls	r0, r0, #2
 80306a6:	1828      	adds	r0, r5, r0
 80306a8:	220c      	movs	r2, #12
 80306aa:	2100      	movs	r1, #0
 80306ac:	f004 fa43 	bl	8034b36 <memset>
    return RegionCommonChanDisable( RegionNvmGroup2->ChannelsMask, id, EU868_MAX_NB_CHANNELS );
 80306b0:	23d8      	movs	r3, #216	; 0xd8
 80306b2:	009b      	lsls	r3, r3, #2
 80306b4:	18e8      	adds	r0, r5, r3
 80306b6:	2210      	movs	r2, #16
 80306b8:	0021      	movs	r1, r4
 80306ba:	f7fe ff54 	bl	802f566 <RegionCommonChanDisable>
 80306be:	e7ec      	b.n	803069a <RegionEU868ChannelsRemove+0xa>
 80306c0:	2000c318 	.word	0x2000c318

080306c4 <RegionEU868ApplyCFList>:
{
 80306c4:	b570      	push	{r4, r5, r6, lr}
 80306c6:	b086      	sub	sp, #24
 80306c8:	0006      	movs	r6, r0
    newChannel.DrRange.Value = ( DR_5 << 4 ) | DR_0;
 80306ca:	ab03      	add	r3, sp, #12
 80306cc:	2250      	movs	r2, #80	; 0x50
 80306ce:	721a      	strb	r2, [r3, #8]
    if( applyCFList->Size != 16 )
 80306d0:	7a03      	ldrb	r3, [r0, #8]
 80306d2:	2b10      	cmp	r3, #16
 80306d4:	d133      	bne.n	803073e <RegionEU868ApplyCFList+0x7a>
    if( applyCFList->Payload[15] != 0 )
 80306d6:	6843      	ldr	r3, [r0, #4]
 80306d8:	7bdd      	ldrb	r5, [r3, #15]
 80306da:	2d00      	cmp	r5, #0
 80306dc:	d12f      	bne.n	803073e <RegionEU868ApplyCFList+0x7a>
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 80306de:	2403      	movs	r4, #3
 80306e0:	e01a      	b.n	8030718 <RegionEU868ApplyCFList+0x54>
            newChannel.Frequency = (uint32_t) applyCFList->Payload[i];
 80306e2:	6872      	ldr	r2, [r6, #4]
 80306e4:	5d53      	ldrb	r3, [r2, r5]
 80306e6:	9303      	str	r3, [sp, #12]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 1] << 8 );
 80306e8:	1952      	adds	r2, r2, r5
 80306ea:	7851      	ldrb	r1, [r2, #1]
 80306ec:	0209      	lsls	r1, r1, #8
 80306ee:	430b      	orrs	r3, r1
 80306f0:	9303      	str	r3, [sp, #12]
            newChannel.Frequency |= ( (uint32_t) applyCFList->Payload[i + 2] << 16 );
 80306f2:	7892      	ldrb	r2, [r2, #2]
 80306f4:	0412      	lsls	r2, r2, #16
 80306f6:	4313      	orrs	r3, r2
 80306f8:	9303      	str	r3, [sp, #12]
            newChannel.Frequency *= 100;
 80306fa:	2264      	movs	r2, #100	; 0x64
 80306fc:	4353      	muls	r3, r2
 80306fe:	9303      	str	r3, [sp, #12]
            newChannel.Rx1Frequency = 0;
 8030700:	2300      	movs	r3, #0
 8030702:	9304      	str	r3, [sp, #16]
 8030704:	e011      	b.n	803072a <RegionEU868ApplyCFList+0x66>
            channelRemove.ChannelId = chanIdx;
 8030706:	466b      	mov	r3, sp
 8030708:	701c      	strb	r4, [r3, #0]
            RegionEU868ChannelsRemove( &channelRemove );
 803070a:	4668      	mov	r0, sp
 803070c:	f7ff ffc0 	bl	8030690 <RegionEU868ChannelsRemove>
    for( uint8_t i = 0, chanIdx = EU868_NUMB_DEFAULT_CHANNELS; chanIdx < EU868_MAX_NB_CHANNELS; i+=3, chanIdx++ )
 8030710:	3503      	adds	r5, #3
 8030712:	b2ed      	uxtb	r5, r5
 8030714:	3401      	adds	r4, #1
 8030716:	b2e4      	uxtb	r4, r4
 8030718:	2c0f      	cmp	r4, #15
 803071a:	d810      	bhi.n	803073e <RegionEU868ApplyCFList+0x7a>
        if( chanIdx < ( EU868_NUMB_CHANNELS_CF_LIST + EU868_NUMB_DEFAULT_CHANNELS ) )
 803071c:	2c07      	cmp	r4, #7
 803071e:	d9e0      	bls.n	80306e2 <RegionEU868ApplyCFList+0x1e>
            newChannel.Frequency = 0;
 8030720:	aa03      	add	r2, sp, #12
 8030722:	2300      	movs	r3, #0
 8030724:	9303      	str	r3, [sp, #12]
            newChannel.DrRange.Value = 0;
 8030726:	7213      	strb	r3, [r2, #8]
            newChannel.Rx1Frequency = 0;
 8030728:	9304      	str	r3, [sp, #16]
        if( newChannel.Frequency != 0 )
 803072a:	9b03      	ldr	r3, [sp, #12]
 803072c:	2b00      	cmp	r3, #0
 803072e:	d0ea      	beq.n	8030706 <RegionEU868ApplyCFList+0x42>
            channelAdd.NewChannel = &newChannel;
 8030730:	a801      	add	r0, sp, #4
 8030732:	ab03      	add	r3, sp, #12
 8030734:	9301      	str	r3, [sp, #4]
            channelAdd.ChannelId = chanIdx;
 8030736:	7104      	strb	r4, [r0, #4]
            RegionEU868ChannelAdd( &channelAdd );
 8030738:	f7ff ff40 	bl	80305bc <RegionEU868ChannelAdd>
 803073c:	e7e8      	b.n	8030710 <RegionEU868ApplyCFList+0x4c>
}
 803073e:	b006      	add	sp, #24
 8030740:	bd70      	pop	{r4, r5, r6, pc}

08030742 <RegionEU868NewChannelReq>:
{
 8030742:	b500      	push	{lr}
 8030744:	b085      	sub	sp, #20
 8030746:	0003      	movs	r3, r0
    if( newChannelReq->NewChannel->Frequency == 0 )
 8030748:	6802      	ldr	r2, [r0, #0]
 803074a:	6811      	ldr	r1, [r2, #0]
 803074c:	2900      	cmp	r1, #0
 803074e:	d108      	bne.n	8030762 <RegionEU868NewChannelReq+0x20>
        channelRemove.ChannelId = newChannelReq->ChannelId;
 8030750:	7903      	ldrb	r3, [r0, #4]
 8030752:	a801      	add	r0, sp, #4
 8030754:	7003      	strb	r3, [r0, #0]
        if( RegionEU868ChannelsRemove( &channelRemove ) == false )
 8030756:	f7ff ff9b 	bl	8030690 <RegionEU868ChannelsRemove>
 803075a:	2800      	cmp	r0, #0
 803075c:	d012      	beq.n	8030784 <RegionEU868NewChannelReq+0x42>
    uint8_t status = 0x03;
 803075e:	2003      	movs	r0, #3
 8030760:	e00d      	b.n	803077e <RegionEU868NewChannelReq+0x3c>
        channelAdd.NewChannel = newChannelReq->NewChannel;
 8030762:	a802      	add	r0, sp, #8
 8030764:	9202      	str	r2, [sp, #8]
        channelAdd.ChannelId = newChannelReq->ChannelId;
 8030766:	791b      	ldrb	r3, [r3, #4]
 8030768:	7103      	strb	r3, [r0, #4]
        switch( RegionEU868ChannelAdd( &channelAdd ) )
 803076a:	f7ff ff27 	bl	80305bc <RegionEU868ChannelAdd>
 803076e:	2805      	cmp	r0, #5
 8030770:	d00a      	beq.n	8030788 <RegionEU868NewChannelReq+0x46>
 8030772:	d80b      	bhi.n	803078c <RegionEU868NewChannelReq+0x4a>
 8030774:	2800      	cmp	r0, #0
 8030776:	d00b      	beq.n	8030790 <RegionEU868NewChannelReq+0x4e>
 8030778:	2804      	cmp	r0, #4
 803077a:	d10b      	bne.n	8030794 <RegionEU868NewChannelReq+0x52>
                status &= 0xFE;
 803077c:	3802      	subs	r0, #2
    return status;
 803077e:	b240      	sxtb	r0, r0
}
 8030780:	b005      	add	sp, #20
 8030782:	bd00      	pop	{pc}
            status &= 0xFC;
 8030784:	2000      	movs	r0, #0
 8030786:	e7fa      	b.n	803077e <RegionEU868NewChannelReq+0x3c>
                status &= 0xFD;
 8030788:	2001      	movs	r0, #1
 803078a:	e7f8      	b.n	803077e <RegionEU868NewChannelReq+0x3c>
                status &= 0xFC;
 803078c:	2000      	movs	r0, #0
 803078e:	e7f6      	b.n	803077e <RegionEU868NewChannelReq+0x3c>
        switch( RegionEU868ChannelAdd( &channelAdd ) )
 8030790:	2003      	movs	r0, #3
 8030792:	e7f4      	b.n	803077e <RegionEU868NewChannelReq+0x3c>
                status &= 0xFC;
 8030794:	2000      	movs	r0, #0
 8030796:	e7f2      	b.n	803077e <RegionEU868NewChannelReq+0x3c>

08030798 <RegionEU868ApplyDrOffset>:
#endif /* REGION_VERSION */

uint8_t RegionEU868ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
#if defined( REGION_EU868 )
    int8_t datarate = dr - drOffset;
 8030798:	1a8a      	subs	r2, r1, r2
 803079a:	b250      	sxtb	r0, r2

    if( datarate < 0 )
 803079c:	0613      	lsls	r3, r2, #24
 803079e:	d401      	bmi.n	80307a4 <RegionEU868ApplyDrOffset+0xc>
    {
        datarate = DR_0;
    }
    return datarate;
 80307a0:	b2c0      	uxtb	r0, r0
#else
    return 0;
#endif /* REGION_EU868 */
}
 80307a2:	4770      	bx	lr
        datarate = DR_0;
 80307a4:	2000      	movs	r0, #0
 80307a6:	e7fb      	b.n	80307a0 <RegionEU868ApplyDrOffset+0x8>

080307a8 <VerifyRfFreq>:
    }
    return txPowerResult;
}

static bool VerifyRfFreq( uint32_t freq )
{
 80307a8:	b570      	push	{r4, r5, r6, lr}
 80307aa:	0004      	movs	r4, r0
    // Check radio driver support
    if( Radio.CheckRfFrequency( freq ) == false )
 80307ac:	4b0d      	ldr	r3, [pc, #52]	; (80307e4 <VerifyRfFreq+0x3c>)
 80307ae:	6a1b      	ldr	r3, [r3, #32]
 80307b0:	4798      	blx	r3
 80307b2:	1e05      	subs	r5, r0, #0
 80307b4:	d012      	beq.n	80307dc <VerifyRfFreq+0x34>
    {
        return false;
    }

    // Rx frequencies
    if( ( freq < US915_FIRST_RX1_CHANNEL ) ||
 80307b6:	4b0c      	ldr	r3, [pc, #48]	; (80307e8 <VerifyRfFreq+0x40>)
 80307b8:	18e0      	adds	r0, r4, r3
 80307ba:	4b0c      	ldr	r3, [pc, #48]	; (80307ec <VerifyRfFreq+0x44>)
 80307bc:	4298      	cmp	r0, r3
 80307be:	d80c      	bhi.n	80307da <VerifyRfFreq+0x32>
        ( freq > US915_LAST_RX1_CHANNEL ) ||
        ( ( ( freq - ( uint32_t ) US915_FIRST_RX1_CHANNEL ) % ( uint32_t ) US915_STEPWIDTH_RX1_CHANNEL ) != 0 ) )
 80307c0:	490b      	ldr	r1, [pc, #44]	; (80307f0 <VerifyRfFreq+0x48>)
 80307c2:	f7ef fd2f 	bl	8020224 <__aeabi_uidivmod>
        ( freq > US915_LAST_RX1_CHANNEL ) ||
 80307c6:	2900      	cmp	r1, #0
 80307c8:	d10a      	bne.n	80307e0 <VerifyRfFreq+0x38>
    {
        return false;
    }

    // Test for frequency range - take RX and TX frequencies into account
    if( ( freq < 902300000 ) ||  ( freq > 927500000 ) )
 80307ca:	4b0a      	ldr	r3, [pc, #40]	; (80307f4 <VerifyRfFreq+0x4c>)
 80307cc:	469c      	mov	ip, r3
 80307ce:	4464      	add	r4, ip
 80307d0:	4b09      	ldr	r3, [pc, #36]	; (80307f8 <VerifyRfFreq+0x50>)
 80307d2:	429c      	cmp	r4, r3
 80307d4:	d902      	bls.n	80307dc <VerifyRfFreq+0x34>
    {
        return false;
 80307d6:	2500      	movs	r5, #0
 80307d8:	e000      	b.n	80307dc <VerifyRfFreq+0x34>
        return false;
 80307da:	2500      	movs	r5, #0
    }
    return true;
}
 80307dc:	0028      	movs	r0, r5
 80307de:	bd70      	pop	{r4, r5, r6, pc}
        return false;
 80307e0:	2500      	movs	r5, #0
 80307e2:	e7fb      	b.n	80307dc <VerifyRfFreq+0x34>
 80307e4:	08035d8c 	.word	0x08035d8c
 80307e8:	c8f78f60 	.word	0xc8f78f60
 80307ec:	00401640 	.word	0x00401640
 80307f0:	000927c0 	.word	0x000927c0
 80307f4:	ca37fea0 	.word	0xca37fea0
 80307f8:	01808580 	.word	0x01808580

080307fc <GetTimeOnAir>:

static TimerTime_t GetTimeOnAir( int8_t datarate, uint16_t pktLen )
{
 80307fc:	b570      	push	{r4, r5, r6, lr}
 80307fe:	b084      	sub	sp, #16
 8030800:	000c      	movs	r4, r1
    int8_t phyDr = DataratesUS915[datarate];
 8030802:	4b0b      	ldr	r3, [pc, #44]	; (8030830 <GetTimeOnAir+0x34>)
 8030804:	561e      	ldrsb	r6, [r3, r0]
    uint32_t bandwidth = RegionCommonGetBandwidth( datarate, BandwidthsUS915 );
 8030806:	490b      	ldr	r1, [pc, #44]	; (8030834 <GetTimeOnAir+0x38>)
 8030808:	f7ff f95c 	bl	802fac4 <RegionCommonGetBandwidth>
 803080c:	0001      	movs	r1, r0

    return Radio.TimeOnAir( MODEM_LORA, bandwidth, phyDr, 1, 8, false, pktLen, true );
 803080e:	4b0a      	ldr	r3, [pc, #40]	; (8030838 <GetTimeOnAir+0x3c>)
 8030810:	6a5d      	ldr	r5, [r3, #36]	; 0x24
 8030812:	2301      	movs	r3, #1
 8030814:	9303      	str	r3, [sp, #12]
 8030816:	b2e4      	uxtb	r4, r4
 8030818:	9402      	str	r4, [sp, #8]
 803081a:	2300      	movs	r3, #0
 803081c:	9301      	str	r3, [sp, #4]
 803081e:	3308      	adds	r3, #8
 8030820:	9300      	str	r3, [sp, #0]
 8030822:	3b07      	subs	r3, #7
 8030824:	0032      	movs	r2, r6
 8030826:	2001      	movs	r0, #1
 8030828:	47a8      	blx	r5
}
 803082a:	b004      	add	sp, #16
 803082c:	bd70      	pop	{r4, r5, r6, pc}
 803082e:	46c0      	nop			; (mov r8, r8)
 8030830:	08035a14 	.word	0x08035a14
 8030834:	080359c0 	.word	0x080359c0
 8030838:	08035d8c 	.word	0x08035d8c

0803083c <LimitTxPower>:
{
 803083c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803083e:	0005      	movs	r5, r0
 8030840:	0017      	movs	r7, r2
 8030842:	001e      	movs	r6, r3
    txPowerResult =  RegionCommonLimitTxPower( txPower, maxBandTxPower );
 8030844:	f7ff f938 	bl	802fab8 <RegionCommonLimitTxPower>
 8030848:	0004      	movs	r4, r0
    if( datarate == DR_4 )
 803084a:	2f04      	cmp	r7, #4
 803084c:	d107      	bne.n	803085e <LimitTxPower+0x22>
        txPowerResult = MAX( txPower, TX_POWER_2 );
 803084e:	1c2c      	adds	r4, r5, #0
 8030850:	2d01      	cmp	r5, #1
 8030852:	dd02      	ble.n	803085a <LimitTxPower+0x1e>
 8030854:	b264      	sxtb	r4, r4
}
 8030856:	0020      	movs	r0, r4
 8030858:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        txPowerResult = MAX( txPower, TX_POWER_2 );
 803085a:	2402      	movs	r4, #2
 803085c:	e7fa      	b.n	8030854 <LimitTxPower+0x18>
        if( RegionCommonCountChannels( channelsMask, 0, 4 ) < 50 )
 803085e:	2204      	movs	r2, #4
 8030860:	2100      	movs	r1, #0
 8030862:	0030      	movs	r0, r6
 8030864:	f7fe fe94 	bl	802f590 <RegionCommonCountChannels>
 8030868:	2831      	cmp	r0, #49	; 0x31
 803086a:	d8f4      	bhi.n	8030856 <LimitTxPower+0x1a>
            txPowerResult = MAX( txPower, TX_POWER_5 );
 803086c:	1c2c      	adds	r4, r5, #0
 803086e:	2d04      	cmp	r5, #4
 8030870:	dc00      	bgt.n	8030874 <LimitTxPower+0x38>
 8030872:	2405      	movs	r4, #5
 8030874:	b264      	sxtb	r4, r4
 8030876:	e7ee      	b.n	8030856 <LimitTxPower+0x1a>

08030878 <RegionUS915GetPhyParam>:
#endif /* REGION_US915 */

PhyParam_t RegionUS915GetPhyParam( GetPhyParams_t* getPhy )
{
 8030878:	b500      	push	{lr}
 803087a:	b087      	sub	sp, #28
    PhyParam_t phyParam = { 0 };
 803087c:	2300      	movs	r3, #0
 803087e:	9304      	str	r3, [sp, #16]

#if defined( REGION_US915 )
    switch( getPhy->Attribute )
 8030880:	7803      	ldrb	r3, [r0, #0]
 8030882:	2b38      	cmp	r3, #56	; 0x38
 8030884:	d805      	bhi.n	8030892 <RegionUS915GetPhyParam+0x1a>
 8030886:	009b      	lsls	r3, r3, #2
 8030888:	4a4f      	ldr	r2, [pc, #316]	; (80309c8 <RegionUS915GetPhyParam+0x150>)
 803088a:	58d3      	ldr	r3, [r2, r3]
 803088c:	469f      	mov	pc, r3
    {
        case PHY_MIN_RX_DR:
        {
            phyParam.Value = US915_RX_MIN_DATARATE;
 803088e:	2308      	movs	r3, #8
 8030890:	9304      	str	r3, [sp, #16]
            break;
        }
    }

#endif /* REGION_US915 */
    return phyParam;
 8030892:	9b04      	ldr	r3, [sp, #16]
 8030894:	9305      	str	r3, [sp, #20]
}
 8030896:	0018      	movs	r0, r3
 8030898:	b007      	add	sp, #28
 803089a:	bd00      	pop	{pc}
                .CurrentDr = getPhy->Datarate,
 803089c:	2301      	movs	r3, #1
 803089e:	56c3      	ldrsb	r3, [r0, r3]
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 80308a0:	a801      	add	r0, sp, #4
 80308a2:	7003      	strb	r3, [r0, #0]
 80308a4:	2304      	movs	r3, #4
 80308a6:	7043      	strb	r3, [r0, #1]
 80308a8:	2300      	movs	r3, #0
 80308aa:	7083      	strb	r3, [r0, #2]
 80308ac:	3348      	adds	r3, #72	; 0x48
 80308ae:	70c3      	strb	r3, [r0, #3]
                .ChannelsMask = RegionNvmGroup2->ChannelsMask,
 80308b0:	4b46      	ldr	r3, [pc, #280]	; (80309cc <RegionUS915GetPhyParam+0x154>)
 80308b2:	681b      	ldr	r3, [r3, #0]
 80308b4:	22d8      	movs	r2, #216	; 0xd8
 80308b6:	0092      	lsls	r2, r2, #2
 80308b8:	189a      	adds	r2, r3, r2
            RegionCommonGetNextLowerTxDrParams_t nextLowerTxDrParams =
 80308ba:	6042      	str	r2, [r0, #4]
 80308bc:	6083      	str	r3, [r0, #8]
            phyParam.Value = RegionCommonGetNextLowerTxDr( &nextLowerTxDrParams );
 80308be:	f7ff f8dc 	bl	802fa7a <RegionCommonGetNextLowerTxDr>
 80308c2:	9004      	str	r0, [sp, #16]
            break;
 80308c4:	e7e5      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_LIMIT;
 80308c6:	2340      	movs	r3, #64	; 0x40
 80308c8:	9304      	str	r3, [sp, #16]
            break;
 80308ca:	e7e2      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = REGION_COMMON_DEFAULT_ADR_ACK_DELAY;
 80308cc:	2320      	movs	r3, #32
 80308ce:	9304      	str	r3, [sp, #16]
            break;
 80308d0:	e7df      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = MaxPayloadOfDatarateUS915[getPhy->Datarate];
 80308d2:	2301      	movs	r3, #1
 80308d4:	56c3      	ldrsb	r3, [r0, r3]
 80308d6:	4a3e      	ldr	r2, [pc, #248]	; (80309d0 <RegionUS915GetPhyParam+0x158>)
 80308d8:	5cd3      	ldrb	r3, [r2, r3]
 80308da:	9304      	str	r3, [sp, #16]
            break;
 80308dc:	e7d9      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = MaxPayloadOfDatarateRepeaterUS915[getPhy->Datarate];
 80308de:	2301      	movs	r3, #1
 80308e0:	56c3      	ldrsb	r3, [r0, r3]
 80308e2:	4a3c      	ldr	r2, [pc, #240]	; (80309d4 <RegionUS915GetPhyParam+0x15c>)
 80308e4:	5cd3      	ldrb	r3, [r2, r3]
 80308e6:	9304      	str	r3, [sp, #16]
            break;
 80308e8:	e7d3      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = US915_MAX_RX_WINDOW;
 80308ea:	4b3b      	ldr	r3, [pc, #236]	; (80309d8 <RegionUS915GetPhyParam+0x160>)
 80308ec:	9304      	str	r3, [sp, #16]
            break;
 80308ee:	e7d0      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY1;
 80308f0:	23fa      	movs	r3, #250	; 0xfa
 80308f2:	009b      	lsls	r3, r3, #2
 80308f4:	9304      	str	r3, [sp, #16]
            break;
 80308f6:	e7cc      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = REGION_COMMON_DEFAULT_RECEIVE_DELAY2;
 80308f8:	23fa      	movs	r3, #250	; 0xfa
 80308fa:	00db      	lsls	r3, r3, #3
 80308fc:	9304      	str	r3, [sp, #16]
            break;
 80308fe:	e7c8      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY1;
 8030900:	4b36      	ldr	r3, [pc, #216]	; (80309dc <RegionUS915GetPhyParam+0x164>)
 8030902:	9304      	str	r3, [sp, #16]
            break;
 8030904:	e7c5      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = REGION_COMMON_DEFAULT_JOIN_ACCEPT_DELAY2;
 8030906:	4b36      	ldr	r3, [pc, #216]	; (80309e0 <RegionUS915GetPhyParam+0x168>)
 8030908:	9304      	str	r3, [sp, #16]
            break;
 803090a:	e7c2      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = ( REGION_COMMON_DEFAULT_RETRANSMIT_TIMEOUT + randr( -REGION_COMMON_DEFAULT_RETRANSMIT_TIMEOUT_RND, REGION_COMMON_DEFAULT_RETRANSMIT_TIMEOUT_RND ) );
 803090c:	21fa      	movs	r1, #250	; 0xfa
 803090e:	0089      	lsls	r1, r1, #2
 8030910:	4834      	ldr	r0, [pc, #208]	; (80309e4 <RegionUS915GetPhyParam+0x16c>)
 8030912:	f001 fbeb 	bl	80320ec <randr>
 8030916:	23fa      	movs	r3, #250	; 0xfa
 8030918:	00db      	lsls	r3, r3, #3
 803091a:	469c      	mov	ip, r3
 803091c:	4460      	add	r0, ip
 803091e:	9004      	str	r0, [sp, #16]
            break;
 8030920:	e7b7      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = US915_RX_WND_2_FREQ;
 8030922:	4b31      	ldr	r3, [pc, #196]	; (80309e8 <RegionUS915GetPhyParam+0x170>)
 8030924:	9304      	str	r3, [sp, #16]
            break;
 8030926:	e7b4      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = US915_RX_WND_2_DR;
 8030928:	2308      	movs	r3, #8
 803092a:	9304      	str	r3, [sp, #16]
            break;
 803092c:	e7b1      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsMask;
 803092e:	4b27      	ldr	r3, [pc, #156]	; (80309cc <RegionUS915GetPhyParam+0x154>)
 8030930:	681b      	ldr	r3, [r3, #0]
 8030932:	22d8      	movs	r2, #216	; 0xd8
 8030934:	0092      	lsls	r2, r2, #2
 8030936:	4694      	mov	ip, r2
 8030938:	4463      	add	r3, ip
 803093a:	9304      	str	r3, [sp, #16]
            break;
 803093c:	e7a9      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.ChannelsMask = RegionNvmGroup2->ChannelsDefaultMask;
 803093e:	4b23      	ldr	r3, [pc, #140]	; (80309cc <RegionUS915GetPhyParam+0x154>)
 8030940:	681b      	ldr	r3, [r3, #0]
 8030942:	22db      	movs	r2, #219	; 0xdb
 8030944:	0092      	lsls	r2, r2, #2
 8030946:	4694      	mov	ip, r2
 8030948:	4463      	add	r3, ip
 803094a:	9304      	str	r3, [sp, #16]
            break;
 803094c:	e7a1      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = US915_MAX_NB_CHANNELS;
 803094e:	2348      	movs	r3, #72	; 0x48
 8030950:	9304      	str	r3, [sp, #16]
            break;
 8030952:	e79e      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Channels = RegionNvmGroup2->Channels;
 8030954:	4b1d      	ldr	r3, [pc, #116]	; (80309cc <RegionUS915GetPhyParam+0x154>)
 8030956:	681b      	ldr	r3, [r3, #0]
 8030958:	9304      	str	r3, [sp, #16]
            break;
 803095a:	e79a      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.fValue = US915_DEFAULT_MAX_ERP + 2.15f;
 803095c:	4b23      	ldr	r3, [pc, #140]	; (80309ec <RegionUS915GetPhyParam+0x174>)
 803095e:	9304      	str	r3, [sp, #16]
            break;
 8030960:	e797      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.fValue = 0;
 8030962:	2300      	movs	r3, #0
 8030964:	9304      	str	r3, [sp, #16]
            break;
 8030966:	e794      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = RegionBaseUSCalcDownlinkFrequency( getPhy->Channel,
 8030968:	7900      	ldrb	r0, [r0, #4]
 803096a:	4a21      	ldr	r2, [pc, #132]	; (80309f0 <RegionUS915GetPhyParam+0x178>)
 803096c:	491e      	ldr	r1, [pc, #120]	; (80309e8 <RegionUS915GetPhyParam+0x170>)
 803096e:	f7fe fcc9 	bl	802f304 <RegionBaseUSCalcDownlinkFrequency>
 8030972:	9004      	str	r0, [sp, #16]
            break;
 8030974:	e78d      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.BeaconFormat.BeaconSize = US915_BEACON_SIZE;
 8030976:	ab04      	add	r3, sp, #16
 8030978:	2217      	movs	r2, #23
 803097a:	701a      	strb	r2, [r3, #0]
            phyParam.BeaconFormat.Rfu1Size = US915_RFU1_SIZE;
 803097c:	3a13      	subs	r2, #19
 803097e:	705a      	strb	r2, [r3, #1]
            phyParam.BeaconFormat.Rfu2Size = US915_RFU2_SIZE;
 8030980:	3a01      	subs	r2, #1
 8030982:	709a      	strb	r2, [r3, #2]
            break;
 8030984:	e785      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = US915_BEACON_CHANNEL_DR;
 8030986:	2308      	movs	r3, #8
 8030988:	9304      	str	r3, [sp, #16]
            break;
 803098a:	e782      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = US915_BEACON_NB_CHANNELS;
 803098c:	2308      	movs	r3, #8
 803098e:	9304      	str	r3, [sp, #16]
            break;
 8030990:	e77f      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = RegionBaseUSCalcDownlinkFrequency( getPhy->Channel,
 8030992:	7900      	ldrb	r0, [r0, #4]
 8030994:	4a16      	ldr	r2, [pc, #88]	; (80309f0 <RegionUS915GetPhyParam+0x178>)
 8030996:	4914      	ldr	r1, [pc, #80]	; (80309e8 <RegionUS915GetPhyParam+0x170>)
 8030998:	f7fe fcb4 	bl	802f304 <RegionBaseUSCalcDownlinkFrequency>
 803099c:	9004      	str	r0, [sp, #16]
            break;
 803099e:	e778      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = US915_PING_SLOT_CHANNEL_DR;
 80309a0:	2308      	movs	r3, #8
 80309a2:	9304      	str	r3, [sp, #16]
            break;
 80309a4:	e775      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = US915_BEACON_NB_CHANNELS;
 80309a6:	2308      	movs	r3, #8
 80309a8:	9304      	str	r3, [sp, #16]
            break;
 80309aa:	e772      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = DataratesUS915[getPhy->Datarate];
 80309ac:	2301      	movs	r3, #1
 80309ae:	56c3      	ldrsb	r3, [r0, r3]
 80309b0:	4a10      	ldr	r2, [pc, #64]	; (80309f4 <RegionUS915GetPhyParam+0x17c>)
 80309b2:	5cd3      	ldrb	r3, [r2, r3]
 80309b4:	9304      	str	r3, [sp, #16]
            break;
 80309b6:	e76c      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
            phyParam.Value = RegionCommonGetBandwidth( getPhy->Datarate, BandwidthsUS915 );
 80309b8:	7840      	ldrb	r0, [r0, #1]
 80309ba:	b240      	sxtb	r0, r0
 80309bc:	490e      	ldr	r1, [pc, #56]	; (80309f8 <RegionUS915GetPhyParam+0x180>)
 80309be:	f7ff f881 	bl	802fac4 <RegionCommonGetBandwidth>
 80309c2:	9004      	str	r0, [sp, #16]
            break;
 80309c4:	e765      	b.n	8030892 <RegionUS915GetPhyParam+0x1a>
 80309c6:	46c0      	nop			; (mov r8, r8)
 80309c8:	080358b0 	.word	0x080358b0
 80309cc:	2000c324 	.word	0x2000c324
 80309d0:	08035a34 	.word	0x08035a34
 80309d4:	08035a24 	.word	0x08035a24
 80309d8:	00000bb8 	.word	0x00000bb8
 80309dc:	00001388 	.word	0x00001388
 80309e0:	00001770 	.word	0x00001770
 80309e4:	fffffc18 	.word	0xfffffc18
 80309e8:	370870a0 	.word	0x370870a0
 80309ec:	4200999a 	.word	0x4200999a
 80309f0:	000927c0 	.word	0x000927c0
 80309f4:	08035a14 	.word	0x08035a14
 80309f8:	080359c0 	.word	0x080359c0

080309fc <RegionUS915SetBandTxDone>:

void RegionUS915SetBandTxDone( SetBandTxDoneParams_t* txDone )
{
 80309fc:	b510      	push	{r4, lr}
 80309fe:	b082      	sub	sp, #8
 8030a00:	0003      	movs	r3, r0
#if defined( REGION_US915 )
#if (defined( REGION_VERSION ) && ( REGION_VERSION == 0x01010003 ))
    RegionCommonSetBandTxDone( &RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txDone->Channel].Band],
                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
#elif (defined( REGION_VERSION ) && ( REGION_VERSION == 0x02010001 ))
    RegionCommonSetBandTxDone( &RegionBands[RegionNvmGroup2->Channels[txDone->Channel].Band],
 8030a02:	4a0b      	ldr	r2, [pc, #44]	; (8030a30 <RegionUS915SetBandTxDone+0x34>)
 8030a04:	6811      	ldr	r1, [r2, #0]
 8030a06:	7800      	ldrb	r0, [r0, #0]
 8030a08:	0042      	lsls	r2, r0, #1
 8030a0a:	1812      	adds	r2, r2, r0
 8030a0c:	0092      	lsls	r2, r2, #2
 8030a0e:	188a      	adds	r2, r1, r2
 8030a10:	7a52      	ldrb	r2, [r2, #9]
 8030a12:	0050      	lsls	r0, r2, #1
 8030a14:	1880      	adds	r0, r0, r2
 8030a16:	00c0      	lsls	r0, r0, #3
 8030a18:	785a      	ldrb	r2, [r3, #1]
 8030a1a:	6899      	ldr	r1, [r3, #8]
 8030a1c:	4c05      	ldr	r4, [pc, #20]	; (8030a34 <RegionUS915SetBandTxDone+0x38>)
 8030a1e:	6824      	ldr	r4, [r4, #0]
 8030a20:	1820      	adds	r0, r4, r0
 8030a22:	691c      	ldr	r4, [r3, #16]
 8030a24:	9400      	str	r4, [sp, #0]
 8030a26:	68db      	ldr	r3, [r3, #12]
 8030a28:	f7fe fdd8 	bl	802f5dc <RegionCommonSetBandTxDone>
                               txDone->LastTxAirTime, txDone->Joined, txDone->ElapsedTimeSinceStartUp );
#endif /* REGION_VERSION */
#endif /* REGION_US915 */
}
 8030a2c:	b002      	add	sp, #8
 8030a2e:	bd10      	pop	{r4, pc}
 8030a30:	2000c324 	.word	0x2000c324
 8030a34:	2000c31c 	.word	0x2000c31c

08030a38 <RegionUS915InitDefaults>:

void RegionUS915InitDefaults( InitDefaultsParams_t* params )
{
 8030a38:	b510      	push	{r4, lr}
 8030a3a:	b086      	sub	sp, #24
#if defined( REGION_US915 )
    Band_t bands[US915_MAX_NB_BANDS] =
 8030a3c:	2301      	movs	r3, #1
 8030a3e:	466a      	mov	r2, sp
 8030a40:	8013      	strh	r3, [r2, #0]
 8030a42:	2300      	movs	r3, #0
 8030a44:	7093      	strb	r3, [r2, #2]
 8030a46:	9301      	str	r3, [sp, #4]
 8030a48:	9302      	str	r3, [sp, #8]
 8030a4a:	9303      	str	r3, [sp, #12]
 8030a4c:	9304      	str	r3, [sp, #16]
 8030a4e:	7513      	strb	r3, [r2, #20]
    {
       US915_BAND0
    };

    switch( params->Type )
 8030a50:	7b04      	ldrb	r4, [r0, #12]
 8030a52:	2c00      	cmp	r4, #0
 8030a54:	d011      	beq.n	8030a7a <RegionUS915InitDefaults+0x42>
 8030a56:	3c01      	subs	r4, #1
 8030a58:	b2e4      	uxtb	r4, r4
 8030a5a:	2c01      	cmp	r4, #1
 8030a5c:	d900      	bls.n	8030a60 <RegionUS915InitDefaults+0x28>
 8030a5e:	e085      	b.n	8030b6c <RegionUS915InitDefaults+0x134>
            // Intentional fallthrough
        }
        case INIT_TYPE_ACTIVATE_DEFAULT_CHANNELS:
        {
            // Copy channels default mask
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 8030a60:	4b43      	ldr	r3, [pc, #268]	; (8030b70 <RegionUS915InitDefaults+0x138>)
 8030a62:	6819      	ldr	r1, [r3, #0]
 8030a64:	23d8      	movs	r3, #216	; 0xd8
 8030a66:	009b      	lsls	r3, r3, #2
 8030a68:	18c8      	adds	r0, r1, r3
 8030a6a:	330c      	adds	r3, #12
 8030a6c:	469c      	mov	ip, r3
 8030a6e:	4461      	add	r1, ip
 8030a70:	2206      	movs	r2, #6
 8030a72:	f7fe fda4 	bl	802f5be <RegionCommonChanMaskCopy>

#if (defined( REGION_VERSION ) && ( REGION_VERSION == 0x01010003 ))
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
#elif (defined( REGION_VERSION ) && ( REGION_VERSION == 0x02010001 ))
            for( uint8_t i = 0; i < 6; i++ )
 8030a76:	2300      	movs	r3, #0
 8030a78:	e076      	b.n	8030b68 <RegionUS915InitDefaults+0x130>
            if( ( params->NvmGroup1 == NULL ) || ( params->NvmGroup2 == NULL ) )
 8030a7a:	6803      	ldr	r3, [r0, #0]
 8030a7c:	2b00      	cmp	r3, #0
 8030a7e:	d075      	beq.n	8030b6c <RegionUS915InitDefaults+0x134>
 8030a80:	6842      	ldr	r2, [r0, #4]
 8030a82:	2a00      	cmp	r2, #0
 8030a84:	d072      	beq.n	8030b6c <RegionUS915InitDefaults+0x134>
            RegionNvmGroup1 = (RegionNvmDataGroup1_t*) params->NvmGroup1;
 8030a86:	493b      	ldr	r1, [pc, #236]	; (8030b74 <RegionUS915InitDefaults+0x13c>)
 8030a88:	600b      	str	r3, [r1, #0]
            RegionNvmGroup2 = (RegionNvmDataGroup2_t*) params->NvmGroup2;
 8030a8a:	4939      	ldr	r1, [pc, #228]	; (8030b70 <RegionUS915InitDefaults+0x138>)
 8030a8c:	600a      	str	r2, [r1, #0]
            RegionBands = (Band_t*) params->Bands;
 8030a8e:	6880      	ldr	r0, [r0, #8]
 8030a90:	4a39      	ldr	r2, [pc, #228]	; (8030b78 <RegionUS915InitDefaults+0x140>)
 8030a92:	6010      	str	r0, [r2, #0]
            RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
 8030a94:	2200      	movs	r2, #0
 8030a96:	731a      	strb	r2, [r3, #12]
            RegionNvmGroup1->JoinTrialsCounter = 0;
 8030a98:	735a      	strb	r2, [r3, #13]
            memcpy1( ( uint8_t* )RegionBands, ( uint8_t* )bands, sizeof( Band_t ) * US915_MAX_NB_BANDS );
 8030a9a:	3218      	adds	r2, #24
 8030a9c:	4669      	mov	r1, sp
 8030a9e:	f001 fb30 	bl	8032102 <memcpy1>
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 8030aa2:	e011      	b.n	8030ac8 <RegionUS915InitDefaults+0x90>
                RegionNvmGroup2->Channels[i].Frequency = 902300000 + i * 200000;
 8030aa4:	4935      	ldr	r1, [pc, #212]	; (8030b7c <RegionUS915InitDefaults+0x144>)
 8030aa6:	4361      	muls	r1, r4
 8030aa8:	4b31      	ldr	r3, [pc, #196]	; (8030b70 <RegionUS915InitDefaults+0x138>)
 8030aaa:	681a      	ldr	r2, [r3, #0]
 8030aac:	4b34      	ldr	r3, [pc, #208]	; (8030b80 <RegionUS915InitDefaults+0x148>)
 8030aae:	469c      	mov	ip, r3
 8030ab0:	4461      	add	r1, ip
 8030ab2:	0063      	lsls	r3, r4, #1
 8030ab4:	1918      	adds	r0, r3, r4
 8030ab6:	0080      	lsls	r0, r0, #2
 8030ab8:	5081      	str	r1, [r0, r2]
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_3 << 4 ) | DR_0;
 8030aba:	1811      	adds	r1, r2, r0
 8030abc:	2030      	movs	r0, #48	; 0x30
 8030abe:	7208      	strb	r0, [r1, #8]
                RegionNvmGroup2->Channels[i].Band = 0;
 8030ac0:	2200      	movs	r2, #0
 8030ac2:	724a      	strb	r2, [r1, #9]
            for( uint8_t i = 0; i < US915_MAX_NB_CHANNELS - 8; i++ )
 8030ac4:	3401      	adds	r4, #1
 8030ac6:	b2e4      	uxtb	r4, r4
 8030ac8:	2c3f      	cmp	r4, #63	; 0x3f
 8030aca:	d9eb      	bls.n	8030aa4 <RegionUS915InitDefaults+0x6c>
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 8030acc:	2340      	movs	r3, #64	; 0x40
 8030ace:	2b47      	cmp	r3, #71	; 0x47
 8030ad0:	d814      	bhi.n	8030afc <RegionUS915InitDefaults+0xc4>
                RegionNvmGroup2->Channels[i].Frequency = 903000000 + ( i - ( US915_MAX_NB_CHANNELS - 8 ) ) * 1600000;
 8030ad2:	001a      	movs	r2, r3
 8030ad4:	3a40      	subs	r2, #64	; 0x40
 8030ad6:	482b      	ldr	r0, [pc, #172]	; (8030b84 <RegionUS915InitDefaults+0x14c>)
 8030ad8:	4350      	muls	r0, r2
 8030ada:	4a25      	ldr	r2, [pc, #148]	; (8030b70 <RegionUS915InitDefaults+0x138>)
 8030adc:	6811      	ldr	r1, [r2, #0]
 8030ade:	4a2a      	ldr	r2, [pc, #168]	; (8030b88 <RegionUS915InitDefaults+0x150>)
 8030ae0:	4694      	mov	ip, r2
 8030ae2:	4460      	add	r0, ip
 8030ae4:	005a      	lsls	r2, r3, #1
 8030ae6:	18d4      	adds	r4, r2, r3
 8030ae8:	00a4      	lsls	r4, r4, #2
 8030aea:	5060      	str	r0, [r4, r1]
                RegionNvmGroup2->Channels[i].DrRange.Value = ( DR_4 << 4 ) | DR_4;
 8030aec:	1908      	adds	r0, r1, r4
 8030aee:	2444      	movs	r4, #68	; 0x44
 8030af0:	7204      	strb	r4, [r0, #8]
                RegionNvmGroup2->Channels[i].Band = 0;
 8030af2:	2100      	movs	r1, #0
 8030af4:	7241      	strb	r1, [r0, #9]
            for( uint8_t i = US915_MAX_NB_CHANNELS - 8; i < US915_MAX_NB_CHANNELS; i++ )
 8030af6:	3301      	adds	r3, #1
 8030af8:	b2db      	uxtb	r3, r3
 8030afa:	e7e8      	b.n	8030ace <RegionUS915InitDefaults+0x96>
            RegionNvmGroup2->ChannelsDefaultMask[0] = 0xFFFF;
 8030afc:	4c1c      	ldr	r4, [pc, #112]	; (8030b70 <RegionUS915InitDefaults+0x138>)
 8030afe:	6821      	ldr	r1, [r4, #0]
 8030b00:	2301      	movs	r3, #1
 8030b02:	425b      	negs	r3, r3
 8030b04:	22db      	movs	r2, #219	; 0xdb
 8030b06:	0092      	lsls	r2, r2, #2
 8030b08:	528b      	strh	r3, [r1, r2]
            RegionNvmGroup2->ChannelsDefaultMask[1] = 0xFFFF;
 8030b0a:	4a20      	ldr	r2, [pc, #128]	; (8030b8c <RegionUS915InitDefaults+0x154>)
 8030b0c:	528b      	strh	r3, [r1, r2]
            RegionNvmGroup2->ChannelsDefaultMask[2] = 0xFFFF;
 8030b0e:	3202      	adds	r2, #2
 8030b10:	528b      	strh	r3, [r1, r2]
            RegionNvmGroup2->ChannelsDefaultMask[3] = 0xFFFF;
 8030b12:	4a1f      	ldr	r2, [pc, #124]	; (8030b90 <RegionUS915InitDefaults+0x158>)
 8030b14:	528b      	strh	r3, [r1, r2]
            RegionNvmGroup2->ChannelsDefaultMask[4] = 0x00FF;
 8030b16:	23dd      	movs	r3, #221	; 0xdd
 8030b18:	009b      	lsls	r3, r3, #2
 8030b1a:	22ff      	movs	r2, #255	; 0xff
 8030b1c:	52ca      	strh	r2, [r1, r3]
            RegionNvmGroup2->ChannelsDefaultMask[5] = 0x0000;
 8030b1e:	4b1d      	ldr	r3, [pc, #116]	; (8030b94 <RegionUS915InitDefaults+0x15c>)
 8030b20:	2200      	movs	r2, #0
 8030b22:	52ca      	strh	r2, [r1, r3]
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, RegionNvmGroup2->ChannelsDefaultMask, CHANNELS_MASK_SIZE );
 8030b24:	3b16      	subs	r3, #22
 8030b26:	18c8      	adds	r0, r1, r3
 8030b28:	330c      	adds	r3, #12
 8030b2a:	469c      	mov	ip, r3
 8030b2c:	4461      	add	r1, ip
 8030b2e:	3206      	adds	r2, #6
 8030b30:	f7fe fd45 	bl	802f5be <RegionCommonChanMaskCopy>
            RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 8030b34:	4b0f      	ldr	r3, [pc, #60]	; (8030b74 <RegionUS915InitDefaults+0x13c>)
 8030b36:	6818      	ldr	r0, [r3, #0]
 8030b38:	6821      	ldr	r1, [r4, #0]
 8030b3a:	23d8      	movs	r3, #216	; 0xd8
 8030b3c:	009b      	lsls	r3, r3, #2
 8030b3e:	469c      	mov	ip, r3
 8030b40:	4461      	add	r1, ip
 8030b42:	2206      	movs	r2, #6
 8030b44:	f7fe fd3b 	bl	802f5be <RegionCommonChanMaskCopy>
            break;
 8030b48:	e010      	b.n	8030b6c <RegionUS915InitDefaults+0x134>
#endif /* REGION_VERSION */
            { // Copy-And the channels mask
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 8030b4a:	4a0a      	ldr	r2, [pc, #40]	; (8030b74 <RegionUS915InitDefaults+0x13c>)
 8030b4c:	6811      	ldr	r1, [r2, #0]
 8030b4e:	4a08      	ldr	r2, [pc, #32]	; (8030b70 <RegionUS915InitDefaults+0x138>)
 8030b50:	6810      	ldr	r0, [r2, #0]
 8030b52:	001a      	movs	r2, r3
 8030b54:	32b1      	adds	r2, #177	; 0xb1
 8030b56:	32ff      	adds	r2, #255	; 0xff
 8030b58:	0052      	lsls	r2, r2, #1
 8030b5a:	5a14      	ldrh	r4, [r2, r0]
 8030b5c:	0058      	lsls	r0, r3, #1
 8030b5e:	5a42      	ldrh	r2, [r0, r1]
 8030b60:	4022      	ands	r2, r4
 8030b62:	5242      	strh	r2, [r0, r1]
            for( uint8_t i = 0; i < 6; i++ )
 8030b64:	3301      	adds	r3, #1
 8030b66:	b2db      	uxtb	r3, r3
 8030b68:	2b05      	cmp	r3, #5
 8030b6a:	d9ee      	bls.n	8030b4a <RegionUS915InitDefaults+0x112>
        {
            break;
        }
    }
#endif /* REGION_US915 */
}
 8030b6c:	b006      	add	sp, #24
 8030b6e:	bd10      	pop	{r4, pc}
 8030b70:	2000c324 	.word	0x2000c324
 8030b74:	2000c320 	.word	0x2000c320
 8030b78:	2000c31c 	.word	0x2000c31c
 8030b7c:	00030d40 	.word	0x00030d40
 8030b80:	35c80160 	.word	0x35c80160
 8030b84:	00186a00 	.word	0x00186a00
 8030b88:	35d2afc0 	.word	0x35d2afc0
 8030b8c:	0000036e 	.word	0x0000036e
 8030b90:	00000372 	.word	0x00000372
 8030b94:	00000376 	.word	0x00000376

08030b98 <RegionUS915Verify>:

bool RegionUS915Verify( VerifyParams_t* verify, PhyAttribute_t phyAttribute )
{
 8030b98:	b510      	push	{r4, lr}
#if defined( REGION_US915 )
    switch( phyAttribute )
 8030b9a:	290a      	cmp	r1, #10
 8030b9c:	d82f      	bhi.n	8030bfe <RegionUS915Verify+0x66>
 8030b9e:	0089      	lsls	r1, r1, #2
 8030ba0:	4b18      	ldr	r3, [pc, #96]	; (8030c04 <RegionUS915Verify+0x6c>)
 8030ba2:	585b      	ldr	r3, [r3, r1]
 8030ba4:	469f      	mov	pc, r3
    {
        case PHY_FREQUENCY:
        {
            return VerifyRfFreq( verify->Frequency );
 8030ba6:	6800      	ldr	r0, [r0, #0]
 8030ba8:	f7ff fdfe 	bl	80307a8 <VerifyRfFreq>
 8030bac:	e028      	b.n	8030c00 <RegionUS915Verify+0x68>
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, US915_TX_MIN_DATARATE, US915_TX_MAX_DATARATE );
        }
#elif (defined( REGION_VERSION ) && ( REGION_VERSION == 0x02010001 ))
        case PHY_TX_DR:
        {
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, US915_TX_MIN_DATARATE, US915_TX_MAX_DATARATE );
 8030bae:	7800      	ldrb	r0, [r0, #0]
 8030bb0:	b240      	sxtb	r0, r0
 8030bb2:	2204      	movs	r2, #4
 8030bb4:	2100      	movs	r1, #0
 8030bb6:	f7fe fc88 	bl	802f4ca <RegionCommonValueInRange>
 8030bba:	1e43      	subs	r3, r0, #1
 8030bbc:	4198      	sbcs	r0, r3
 8030bbe:	b2c0      	uxtb	r0, r0
 8030bc0:	e01e      	b.n	8030c00 <RegionUS915Verify+0x68>
        }
        case PHY_DEF_TX_DR:
        {
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, DR_0, DR_5 );
 8030bc2:	7800      	ldrb	r0, [r0, #0]
 8030bc4:	b240      	sxtb	r0, r0
 8030bc6:	2205      	movs	r2, #5
 8030bc8:	2100      	movs	r1, #0
 8030bca:	f7fe fc7e 	bl	802f4ca <RegionCommonValueInRange>
 8030bce:	1e43      	subs	r3, r0, #1
 8030bd0:	4198      	sbcs	r0, r3
 8030bd2:	b2c0      	uxtb	r0, r0
 8030bd4:	e014      	b.n	8030c00 <RegionUS915Verify+0x68>
        }
#endif /* REGION_VERSION */
        case PHY_RX_DR:
        {
            return RegionCommonValueInRange( verify->DatarateParams.Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE );
 8030bd6:	7800      	ldrb	r0, [r0, #0]
 8030bd8:	b240      	sxtb	r0, r0
 8030bda:	220d      	movs	r2, #13
 8030bdc:	2108      	movs	r1, #8
 8030bde:	f7fe fc74 	bl	802f4ca <RegionCommonValueInRange>
 8030be2:	1e43      	subs	r3, r0, #1
 8030be4:	4198      	sbcs	r0, r3
 8030be6:	b2c0      	uxtb	r0, r0
 8030be8:	e00a      	b.n	8030c00 <RegionUS915Verify+0x68>
        }
        case PHY_DEF_TX_POWER:
        case PHY_TX_POWER:
        {
            // Remark: switched min and max!
            return RegionCommonValueInRange( verify->TxPower, US915_MAX_TX_POWER, US915_MIN_TX_POWER );
 8030bea:	7800      	ldrb	r0, [r0, #0]
 8030bec:	b240      	sxtb	r0, r0
 8030bee:	220e      	movs	r2, #14
 8030bf0:	2100      	movs	r1, #0
 8030bf2:	f7fe fc6a 	bl	802f4ca <RegionCommonValueInRange>
 8030bf6:	1e43      	subs	r3, r0, #1
 8030bf8:	4198      	sbcs	r0, r3
 8030bfa:	b2c0      	uxtb	r0, r0
 8030bfc:	e000      	b.n	8030c00 <RegionUS915Verify+0x68>
    switch( phyAttribute )
 8030bfe:	2000      	movs	r0, #0
            return false;
    }
#else
    return false;
#endif /* REGION_US915 */
}
 8030c00:	bd10      	pop	{r4, pc}
 8030c02:	46c0      	nop			; (mov r8, r8)
 8030c04:	08035994 	.word	0x08035994

08030c08 <RegionUS915ApplyCFList>:

void RegionUS915ApplyCFList( ApplyCFListParams_t* applyCFList )
{
 8030c08:	b5f0      	push	{r4, r5, r6, r7, lr}
#if defined( REGION_US915 )
    // Size of the optional CF list must be 16 byte
    if( applyCFList->Size != 16 )
 8030c0a:	7a03      	ldrb	r3, [r0, #8]
 8030c0c:	2b10      	cmp	r3, #16
 8030c0e:	d12f      	bne.n	8030c70 <RegionUS915ApplyCFList+0x68>
    {
        return;
    }

    // Last byte CFListType must be 0x01 to indicate the CFList contains a series of ChMask fields
    if( applyCFList->Payload[15] != 0x01 )
 8030c10:	6843      	ldr	r3, [r0, #4]
 8030c12:	7bdb      	ldrb	r3, [r3, #15]
 8030c14:	2b01      	cmp	r3, #1
 8030c16:	d12b      	bne.n	8030c70 <RegionUS915ApplyCFList+0x68>
    {
        return;
    }

    // ChMask0 - ChMask4 must be set (every ChMask has 16 bit)
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
 8030c18:	2200      	movs	r2, #0
 8030c1a:	2300      	movs	r3, #0
 8030c1c:	e00e      	b.n	8030c3c <RegionUS915ApplyCFList+0x34>
        if( chMaskItr == 4 )
        {
            RegionNvmGroup2->ChannelsMask[chMaskItr] = RegionNvmGroup2->ChannelsMask[chMaskItr] & CHANNELS_MASK_500KHZ_MASK;
        }
        // Set the channel mask to the remaining
        RegionNvmGroup1->ChannelsMaskRemaining[chMaskItr] &= RegionNvmGroup2->ChannelsMask[chMaskItr];
 8030c1e:	4c15      	ldr	r4, [pc, #84]	; (8030c74 <RegionUS915ApplyCFList+0x6c>)
 8030c20:	6825      	ldr	r5, [r4, #0]
 8030c22:	000c      	movs	r4, r1
 8030c24:	34b1      	adds	r4, #177	; 0xb1
 8030c26:	34ff      	adds	r4, #255	; 0xff
 8030c28:	0064      	lsls	r4, r4, #1
 8030c2a:	5ba6      	ldrh	r6, [r4, r6]
 8030c2c:	0049      	lsls	r1, r1, #1
 8030c2e:	5b4c      	ldrh	r4, [r1, r5]
 8030c30:	4034      	ands	r4, r6
 8030c32:	534c      	strh	r4, [r1, r5]
    for( uint8_t chMaskItr = 0, cntPayload = 0; chMaskItr <= 4; chMaskItr++, cntPayload+=2 )
 8030c34:	3301      	adds	r3, #1
 8030c36:	b2db      	uxtb	r3, r3
 8030c38:	3202      	adds	r2, #2
 8030c3a:	b2d2      	uxtb	r2, r2
 8030c3c:	2b04      	cmp	r3, #4
 8030c3e:	d817      	bhi.n	8030c70 <RegionUS915ApplyCFList+0x68>
        RegionNvmGroup2->ChannelsMask[chMaskItr] = (uint16_t) (0x00FF & applyCFList->Payload[cntPayload]);
 8030c40:	490d      	ldr	r1, [pc, #52]	; (8030c78 <RegionUS915ApplyCFList+0x70>)
 8030c42:	680e      	ldr	r6, [r1, #0]
 8030c44:	0019      	movs	r1, r3
 8030c46:	6844      	ldr	r4, [r0, #4]
 8030c48:	5ca4      	ldrb	r4, [r4, r2]
 8030c4a:	001d      	movs	r5, r3
 8030c4c:	35b1      	adds	r5, #177	; 0xb1
 8030c4e:	35ff      	adds	r5, #255	; 0xff
 8030c50:	006d      	lsls	r5, r5, #1
 8030c52:	53ac      	strh	r4, [r5, r6]
        RegionNvmGroup2->ChannelsMask[chMaskItr] |= (uint16_t) (applyCFList->Payload[cntPayload+1] << 8);
 8030c54:	6847      	ldr	r7, [r0, #4]
 8030c56:	18bf      	adds	r7, r7, r2
 8030c58:	787f      	ldrb	r7, [r7, #1]
 8030c5a:	023f      	lsls	r7, r7, #8
 8030c5c:	433c      	orrs	r4, r7
 8030c5e:	53ac      	strh	r4, [r5, r6]
        if( chMaskItr == 4 )
 8030c60:	2b04      	cmp	r3, #4
 8030c62:	d1dc      	bne.n	8030c1e <RegionUS915ApplyCFList+0x16>
            RegionNvmGroup2->ChannelsMask[chMaskItr] = RegionNvmGroup2->ChannelsMask[chMaskItr] & CHANNELS_MASK_500KHZ_MASK;
 8030c64:	25ff      	movs	r5, #255	; 0xff
 8030c66:	402c      	ands	r4, r5
 8030c68:	35b5      	adds	r5, #181	; 0xb5
 8030c6a:	006d      	lsls	r5, r5, #1
 8030c6c:	53ac      	strh	r4, [r5, r6]
 8030c6e:	e7d6      	b.n	8030c1e <RegionUS915ApplyCFList+0x16>
    }
#endif /* REGION_US915 */
}
 8030c70:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8030c72:	46c0      	nop			; (mov r8, r8)
 8030c74:	2000c320 	.word	0x2000c320
 8030c78:	2000c324 	.word	0x2000c324

08030c7c <RegionUS915ChanMaskSet>:

bool RegionUS915ChanMaskSet( ChanMaskSetParams_t* chanMaskSet )
{
 8030c7c:	b570      	push	{r4, r5, r6, lr}
 8030c7e:	0005      	movs	r5, r0
#if defined( REGION_US915 )
    uint8_t nbChannels = RegionCommonCountChannels( chanMaskSet->ChannelsMaskIn, 0, 4 );
 8030c80:	2204      	movs	r2, #4
 8030c82:	2100      	movs	r1, #0
 8030c84:	6800      	ldr	r0, [r0, #0]
 8030c86:	f7fe fc83 	bl	802f590 <RegionCommonCountChannels>

    // Check the number of active channels
    if( ( nbChannels < 2 ) &&
 8030c8a:	2801      	cmp	r0, #1
 8030c8c:	d038      	beq.n	8030d00 <RegionUS915ChanMaskSet+0x84>
        ( nbChannels > 0 ) )
    {
        return false;
    }

    switch( chanMaskSet->ChannelsMaskType )
 8030c8e:	792c      	ldrb	r4, [r5, #4]
 8030c90:	2c00      	cmp	r4, #0
 8030c92:	d003      	beq.n	8030c9c <RegionUS915ChanMaskSet+0x20>
 8030c94:	2c01      	cmp	r4, #1
 8030c96:	d027      	beq.n	8030ce8 <RegionUS915ChanMaskSet+0x6c>
 8030c98:	2000      	movs	r0, #0
    }
    return true;
#else
    return false;
#endif /* REGION_US915 */
}
 8030c9a:	bd70      	pop	{r4, r5, r6, pc}
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 8030c9c:	4e19      	ldr	r6, [pc, #100]	; (8030d04 <RegionUS915ChanMaskSet+0x88>)
 8030c9e:	6830      	ldr	r0, [r6, #0]
 8030ca0:	23d8      	movs	r3, #216	; 0xd8
 8030ca2:	009b      	lsls	r3, r3, #2
 8030ca4:	469c      	mov	ip, r3
 8030ca6:	4460      	add	r0, ip
 8030ca8:	6829      	ldr	r1, [r5, #0]
 8030caa:	2206      	movs	r2, #6
 8030cac:	f7fe fc87 	bl	802f5be <RegionCommonChanMaskCopy>
            RegionNvmGroup2->ChannelsDefaultMask[4] = RegionNvmGroup2->ChannelsDefaultMask[4] & CHANNELS_MASK_500KHZ_MASK;
 8030cb0:	6835      	ldr	r5, [r6, #0]
 8030cb2:	22dd      	movs	r2, #221	; 0xdd
 8030cb4:	0092      	lsls	r2, r2, #2
 8030cb6:	5aa9      	ldrh	r1, [r5, r2]
 8030cb8:	23ff      	movs	r3, #255	; 0xff
 8030cba:	400b      	ands	r3, r1
 8030cbc:	52ab      	strh	r3, [r5, r2]
            RegionNvmGroup2->ChannelsDefaultMask[5] = 0x0000;
 8030cbe:	4b12      	ldr	r3, [pc, #72]	; (8030d08 <RegionUS915ChanMaskSet+0x8c>)
 8030cc0:	2200      	movs	r2, #0
 8030cc2:	52ea      	strh	r2, [r5, r3]
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 8030cc4:	e00c      	b.n	8030ce0 <RegionUS915ChanMaskSet+0x64>
                RegionNvmGroup1->ChannelsMaskRemaining[i] &= RegionNvmGroup2->ChannelsMask[i];
 8030cc6:	4b11      	ldr	r3, [pc, #68]	; (8030d0c <RegionUS915ChanMaskSet+0x90>)
 8030cc8:	681a      	ldr	r2, [r3, #0]
 8030cca:	0023      	movs	r3, r4
 8030ccc:	33b1      	adds	r3, #177	; 0xb1
 8030cce:	33ff      	adds	r3, #255	; 0xff
 8030cd0:	005b      	lsls	r3, r3, #1
 8030cd2:	5b58      	ldrh	r0, [r3, r5]
 8030cd4:	0061      	lsls	r1, r4, #1
 8030cd6:	5a8b      	ldrh	r3, [r1, r2]
 8030cd8:	4003      	ands	r3, r0
 8030cda:	528b      	strh	r3, [r1, r2]
            for( uint8_t i = 0; i < CHANNELS_MASK_SIZE; i++ )
 8030cdc:	3401      	adds	r4, #1
 8030cde:	b2e4      	uxtb	r4, r4
 8030ce0:	2c05      	cmp	r4, #5
 8030ce2:	d9f0      	bls.n	8030cc6 <RegionUS915ChanMaskSet+0x4a>
    return true;
 8030ce4:	2001      	movs	r0, #1
 8030ce6:	e7d8      	b.n	8030c9a <RegionUS915ChanMaskSet+0x1e>
            RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsDefaultMask, chanMaskSet->ChannelsMaskIn, CHANNELS_MASK_SIZE );
 8030ce8:	4b06      	ldr	r3, [pc, #24]	; (8030d04 <RegionUS915ChanMaskSet+0x88>)
 8030cea:	6818      	ldr	r0, [r3, #0]
 8030cec:	23db      	movs	r3, #219	; 0xdb
 8030cee:	009b      	lsls	r3, r3, #2
 8030cf0:	469c      	mov	ip, r3
 8030cf2:	4460      	add	r0, ip
 8030cf4:	6829      	ldr	r1, [r5, #0]
 8030cf6:	2206      	movs	r2, #6
 8030cf8:	f7fe fc61 	bl	802f5be <RegionCommonChanMaskCopy>
    return true;
 8030cfc:	2001      	movs	r0, #1
            break;
 8030cfe:	e7cc      	b.n	8030c9a <RegionUS915ChanMaskSet+0x1e>
        return false;
 8030d00:	2000      	movs	r0, #0
 8030d02:	e7ca      	b.n	8030c9a <RegionUS915ChanMaskSet+0x1e>
 8030d04:	2000c324 	.word	0x2000c324
 8030d08:	00000376 	.word	0x00000376
 8030d0c:	2000c320 	.word	0x2000c320

08030d10 <RegionUS915ComputeRxWindowParameters>:

void RegionUS915ComputeRxWindowParameters( int8_t datarate, uint8_t minRxSymbols, uint32_t rxError, RxConfigParams_t *rxConfigParams )
{
 8030d10:	b5f0      	push	{r4, r5, r6, r7, lr}
 8030d12:	b083      	sub	sp, #12
 8030d14:	000e      	movs	r6, r1
 8030d16:	0017      	movs	r7, r2
 8030d18:	001c      	movs	r4, r3
#if defined( REGION_US915 )
    uint32_t tSymbolInUs = 0;

    // Get the datarate, perform a boundary check
    rxConfigParams->Datarate = MIN( datarate, US915_RX_MAX_DATARATE );
 8030d1a:	1c03      	adds	r3, r0, #0
 8030d1c:	280d      	cmp	r0, #13
 8030d1e:	dd00      	ble.n	8030d22 <RegionUS915ComputeRxWindowParameters+0x12>
 8030d20:	230d      	movs	r3, #13
 8030d22:	b258      	sxtb	r0, r3
 8030d24:	7063      	strb	r3, [r4, #1]
    rxConfigParams->Bandwidth = RegionCommonGetBandwidth( rxConfigParams->Datarate, BandwidthsUS915 );
 8030d26:	4d0f      	ldr	r5, [pc, #60]	; (8030d64 <RegionUS915ComputeRxWindowParameters+0x54>)
 8030d28:	0029      	movs	r1, r5
 8030d2a:	f7fe fecb 	bl	802fac4 <RegionCommonGetBandwidth>
 8030d2e:	70a0      	strb	r0, [r4, #2]

    tSymbolInUs = RegionCommonComputeSymbolTimeLoRa( DataratesUS915[rxConfigParams->Datarate], BandwidthsUS915[rxConfigParams->Datarate] );
 8030d30:	2301      	movs	r3, #1
 8030d32:	56e3      	ldrsb	r3, [r4, r3]
 8030d34:	009a      	lsls	r2, r3, #2
 8030d36:	5951      	ldr	r1, [r2, r5]
 8030d38:	4a0b      	ldr	r2, [pc, #44]	; (8030d68 <RegionUS915ComputeRxWindowParameters+0x58>)
 8030d3a:	5cd0      	ldrb	r0, [r2, r3]
 8030d3c:	f7fe fd7c 	bl	802f838 <RegionCommonComputeSymbolTimeLoRa>
 8030d40:	0005      	movs	r5, r0

    RegionCommonComputeRxWindowParameters( tSymbolInUs, minRxSymbols, rxError, Radio.GetWakeupTime( ), &rxConfigParams->WindowTimeout, &rxConfigParams->WindowOffset );
 8030d42:	4b0a      	ldr	r3, [pc, #40]	; (8030d6c <RegionUS915ComputeRxWindowParameters+0x5c>)
 8030d44:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8030d46:	4798      	blx	r3
 8030d48:	0003      	movs	r3, r0
 8030d4a:	0022      	movs	r2, r4
 8030d4c:	320c      	adds	r2, #12
 8030d4e:	9201      	str	r2, [sp, #4]
 8030d50:	3408      	adds	r4, #8
 8030d52:	9400      	str	r4, [sp, #0]
 8030d54:	003a      	movs	r2, r7
 8030d56:	0031      	movs	r1, r6
 8030d58:	0028      	movs	r0, r5
 8030d5a:	f7fe fd7f 	bl	802f85c <RegionCommonComputeRxWindowParameters>
#endif /* REGION_US915 */
}
 8030d5e:	b003      	add	sp, #12
 8030d60:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8030d62:	46c0      	nop			; (mov r8, r8)
 8030d64:	080359c0 	.word	0x080359c0
 8030d68:	08035a14 	.word	0x08035a14
 8030d6c:	08035d8c 	.word	0x08035d8c

08030d70 <RegionUS915RxConfig>:

bool RegionUS915RxConfig( RxConfigParams_t* rxConfig, int8_t* datarate )
{
 8030d70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8030d72:	46ce      	mov	lr, r9
 8030d74:	4647      	mov	r7, r8
 8030d76:	b580      	push	{r7, lr}
 8030d78:	b08d      	sub	sp, #52	; 0x34
 8030d7a:	0004      	movs	r4, r0
 8030d7c:	910b      	str	r1, [sp, #44]	; 0x2c
#if defined( REGION_US915 )
    int8_t dr = rxConfig->Datarate;
 8030d7e:	2701      	movs	r7, #1
 8030d80:	57c7      	ldrsb	r7, [r0, r7]
    uint8_t maxPayload = 0;
    int8_t phyDr = 0;
    uint32_t frequency = rxConfig->Frequency;
 8030d82:	6845      	ldr	r5, [r0, #4]

    if( Radio.GetStatus( ) != RF_IDLE )
 8030d84:	4b24      	ldr	r3, [pc, #144]	; (8030e18 <RegionUS915RxConfig+0xa8>)
 8030d86:	685b      	ldr	r3, [r3, #4]
 8030d88:	4798      	blx	r3
 8030d8a:	2800      	cmp	r0, #0
 8030d8c:	d142      	bne.n	8030e14 <RegionUS915RxConfig+0xa4>
    {
        return false;
    }

    if( rxConfig->RxSlot == RX_SLOT_WIN_1 )
 8030d8e:	7ce3      	ldrb	r3, [r4, #19]
 8030d90:	2b00      	cmp	r3, #0
 8030d92:	d107      	bne.n	8030da4 <RegionUS915RxConfig+0x34>
    {
        // Apply window 1 frequency
        frequency = US915_FIRST_RX1_CHANNEL + ( rxConfig->Channel % 8 ) * US915_STEPWIDTH_RX1_CHANNEL;
 8030d94:	7823      	ldrb	r3, [r4, #0]
 8030d96:	2507      	movs	r5, #7
 8030d98:	402b      	ands	r3, r5
 8030d9a:	4d20      	ldr	r5, [pc, #128]	; (8030e1c <RegionUS915RxConfig+0xac>)
 8030d9c:	435d      	muls	r5, r3
 8030d9e:	4b20      	ldr	r3, [pc, #128]	; (8030e20 <RegionUS915RxConfig+0xb0>)
 8030da0:	469c      	mov	ip, r3
 8030da2:	4465      	add	r5, ip
    }

    // Read the physical datarate from the datarates table
    phyDr = DataratesUS915[dr];
 8030da4:	4b1f      	ldr	r3, [pc, #124]	; (8030e24 <RegionUS915RxConfig+0xb4>)
 8030da6:	57db      	ldrsb	r3, [r3, r7]
 8030da8:	4699      	mov	r9, r3

    Radio.SetChannel( frequency );
 8030daa:	4e1b      	ldr	r6, [pc, #108]	; (8030e18 <RegionUS915RxConfig+0xa8>)
 8030dac:	0028      	movs	r0, r5
 8030dae:	68f3      	ldr	r3, [r6, #12]
 8030db0:	4798      	blx	r3

    // Radio configuration
    Radio.SetRxConfig( MODEM_LORA, rxConfig->Bandwidth, phyDr, 1, 0, 8, rxConfig->WindowTimeout, false, 0, false, 0, 0, true, rxConfig->RxContinuous );
 8030db2:	69b3      	ldr	r3, [r6, #24]
 8030db4:	4698      	mov	r8, r3
 8030db6:	78a1      	ldrb	r1, [r4, #2]
 8030db8:	7ca3      	ldrb	r3, [r4, #18]
 8030dba:	9309      	str	r3, [sp, #36]	; 0x24
 8030dbc:	2301      	movs	r3, #1
 8030dbe:	9308      	str	r3, [sp, #32]
 8030dc0:	2300      	movs	r3, #0
 8030dc2:	9307      	str	r3, [sp, #28]
 8030dc4:	9306      	str	r3, [sp, #24]
 8030dc6:	9305      	str	r3, [sp, #20]
 8030dc8:	9304      	str	r3, [sp, #16]
 8030dca:	9303      	str	r3, [sp, #12]
 8030dcc:	8922      	ldrh	r2, [r4, #8]
 8030dce:	9202      	str	r2, [sp, #8]
 8030dd0:	2208      	movs	r2, #8
 8030dd2:	9201      	str	r2, [sp, #4]
 8030dd4:	9300      	str	r3, [sp, #0]
 8030dd6:	3301      	adds	r3, #1
 8030dd8:	464a      	mov	r2, r9
 8030dda:	2001      	movs	r0, #1
 8030ddc:	47c0      	blx	r8

    if( rxConfig->RepeaterSupport == true )
 8030dde:	7c63      	ldrb	r3, [r4, #17]
 8030de0:	2b00      	cmp	r3, #0
 8030de2:	d014      	beq.n	8030e0e <RegionUS915RxConfig+0x9e>
    {
        maxPayload = MaxPayloadOfDatarateRepeaterUS915[dr];
 8030de4:	4b10      	ldr	r3, [pc, #64]	; (8030e28 <RegionUS915RxConfig+0xb8>)
 8030de6:	5dd9      	ldrb	r1, [r3, r7]
    else
    {
        maxPayload = MaxPayloadOfDatarateUS915[dr];
    }

    Radio.SetMaxPayloadLength( MODEM_LORA, maxPayload + LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE );
 8030de8:	4b0b      	ldr	r3, [pc, #44]	; (8030e18 <RegionUS915RxConfig+0xa8>)
 8030dea:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8030dec:	310d      	adds	r1, #13
 8030dee:	b2c9      	uxtb	r1, r1
 8030df0:	2001      	movs	r0, #1
 8030df2:	4798      	blx	r3

    RegionCommonRxConfigPrint(rxConfig->RxSlot, frequency, dr);
 8030df4:	7ce0      	ldrb	r0, [r4, #19]
 8030df6:	003a      	movs	r2, r7
 8030df8:	0029      	movs	r1, r5
 8030dfa:	f7fe fe75 	bl	802fae8 <RegionCommonRxConfigPrint>

    *datarate = (uint8_t) dr;
 8030dfe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8030e00:	701f      	strb	r7, [r3, #0]
    return true;
 8030e02:	2001      	movs	r0, #1
#else
    return false;
#endif /* REGION_US915 */
}
 8030e04:	b00d      	add	sp, #52	; 0x34
 8030e06:	bcc0      	pop	{r6, r7}
 8030e08:	46b9      	mov	r9, r7
 8030e0a:	46b0      	mov	r8, r6
 8030e0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        maxPayload = MaxPayloadOfDatarateUS915[dr];
 8030e0e:	4b07      	ldr	r3, [pc, #28]	; (8030e2c <RegionUS915RxConfig+0xbc>)
 8030e10:	5dd9      	ldrb	r1, [r3, r7]
 8030e12:	e7e9      	b.n	8030de8 <RegionUS915RxConfig+0x78>
        return false;
 8030e14:	2000      	movs	r0, #0
 8030e16:	e7f5      	b.n	8030e04 <RegionUS915RxConfig+0x94>
 8030e18:	08035d8c 	.word	0x08035d8c
 8030e1c:	000927c0 	.word	0x000927c0
 8030e20:	370870a0 	.word	0x370870a0
 8030e24:	08035a14 	.word	0x08035a14
 8030e28:	08035a24 	.word	0x08035a24
 8030e2c:	08035a34 	.word	0x08035a34

08030e30 <RegionUS915TxConfig>:

bool RegionUS915TxConfig( TxConfigParams_t* txConfig, int8_t* txPower, TimerTime_t* txTimeOnAir )
{
 8030e30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8030e32:	46de      	mov	lr, fp
 8030e34:	4657      	mov	r7, sl
 8030e36:	464e      	mov	r6, r9
 8030e38:	4645      	mov	r5, r8
 8030e3a:	b5e0      	push	{r5, r6, r7, lr}
 8030e3c:	b08d      	sub	sp, #52	; 0x34
 8030e3e:	0004      	movs	r4, r0
 8030e40:	4689      	mov	r9, r1
 8030e42:	920a      	str	r2, [sp, #40]	; 0x28
#if defined( REGION_US915 )
    int8_t phyDr = DataratesUS915[txConfig->Datarate];
 8030e44:	2201      	movs	r2, #1
 8030e46:	5682      	ldrsb	r2, [r0, r2]
 8030e48:	4b33      	ldr	r3, [pc, #204]	; (8030f18 <RegionUS915TxConfig+0xe8>)
 8030e4a:	569b      	ldrsb	r3, [r3, r2]
 8030e4c:	469b      	mov	fp, r3
#if (defined( REGION_VERSION ) && ( REGION_VERSION == 0x01010003 ))
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionNvmGroup1->Bands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
#elif (defined( REGION_VERSION ) && ( REGION_VERSION == 0x02010001 ))
    int8_t txPowerLimited = LimitTxPower( txConfig->TxPower, RegionBands[RegionNvmGroup2->Channels[txConfig->Channel].Band].TxMaxPower, txConfig->Datarate, RegionNvmGroup2->ChannelsMask );
 8030e4e:	4d33      	ldr	r5, [pc, #204]	; (8030f1c <RegionUS915TxConfig+0xec>)
 8030e50:	682b      	ldr	r3, [r5, #0]
 8030e52:	7800      	ldrb	r0, [r0, #0]
 8030e54:	0041      	lsls	r1, r0, #1
 8030e56:	1809      	adds	r1, r1, r0
 8030e58:	0089      	lsls	r1, r1, #2
 8030e5a:	1859      	adds	r1, r3, r1
 8030e5c:	7a48      	ldrb	r0, [r1, #9]
 8030e5e:	0041      	lsls	r1, r0, #1
 8030e60:	1809      	adds	r1, r1, r0
 8030e62:	00c9      	lsls	r1, r1, #3
 8030e64:	482e      	ldr	r0, [pc, #184]	; (8030f20 <RegionUS915TxConfig+0xf0>)
 8030e66:	6800      	ldr	r0, [r0, #0]
 8030e68:	1841      	adds	r1, r0, r1
 8030e6a:	20d8      	movs	r0, #216	; 0xd8
 8030e6c:	0080      	lsls	r0, r0, #2
 8030e6e:	4684      	mov	ip, r0
 8030e70:	4463      	add	r3, ip
 8030e72:	7889      	ldrb	r1, [r1, #2]
 8030e74:	b249      	sxtb	r1, r1
 8030e76:	2002      	movs	r0, #2
 8030e78:	5620      	ldrsb	r0, [r4, r0]
 8030e7a:	f7ff fcdf 	bl	803083c <LimitTxPower>
 8030e7e:	0006      	movs	r6, r0
#endif /* REGION_VERSION */

    uint32_t bandwidth = RegionCommonGetBandwidth( txConfig->Datarate, BandwidthsUS915 );
 8030e80:	2001      	movs	r0, #1
 8030e82:	5620      	ldrsb	r0, [r4, r0]
 8030e84:	4927      	ldr	r1, [pc, #156]	; (8030f24 <RegionUS915TxConfig+0xf4>)
 8030e86:	f7fe fe1d 	bl	802fac4 <RegionCommonGetBandwidth>
 8030e8a:	4682      	mov	sl, r0
    int8_t phyTxPower = 0;

    // Calculate physical TX power
    phyTxPower = RegionCommonComputeTxPower( txPowerLimited, US915_DEFAULT_MAX_ERP, 0 );
 8030e8c:	2200      	movs	r2, #0
 8030e8e:	4926      	ldr	r1, [pc, #152]	; (8030f28 <RegionUS915TxConfig+0xf8>)
 8030e90:	960b      	str	r6, [sp, #44]	; 0x2c
 8030e92:	0030      	movs	r0, r6
 8030e94:	f7fe fd20 	bl	802f8d8 <RegionCommonComputeTxPower>
 8030e98:	4680      	mov	r8, r0

    // Setup the radio frequency
    Radio.SetChannel( RegionNvmGroup2->Channels[txConfig->Channel].Frequency );
 8030e9a:	4e24      	ldr	r6, [pc, #144]	; (8030f2c <RegionUS915TxConfig+0xfc>)
 8030e9c:	7822      	ldrb	r2, [r4, #0]
 8030e9e:	0053      	lsls	r3, r2, #1
 8030ea0:	189b      	adds	r3, r3, r2
 8030ea2:	009b      	lsls	r3, r3, #2
 8030ea4:	682a      	ldr	r2, [r5, #0]
 8030ea6:	5898      	ldr	r0, [r3, r2]
 8030ea8:	68f3      	ldr	r3, [r6, #12]
 8030eaa:	4798      	blx	r3

    Radio.SetTxConfig( MODEM_LORA, phyTxPower, 0, bandwidth, phyDr, 1, 8, false, true, 0, 0, false, 4000 );
 8030eac:	23fa      	movs	r3, #250	; 0xfa
 8030eae:	011b      	lsls	r3, r3, #4
 8030eb0:	9308      	str	r3, [sp, #32]
 8030eb2:	2300      	movs	r3, #0
 8030eb4:	9307      	str	r3, [sp, #28]
 8030eb6:	9306      	str	r3, [sp, #24]
 8030eb8:	9305      	str	r3, [sp, #20]
 8030eba:	2201      	movs	r2, #1
 8030ebc:	9204      	str	r2, [sp, #16]
 8030ebe:	9303      	str	r3, [sp, #12]
 8030ec0:	3308      	adds	r3, #8
 8030ec2:	9302      	str	r3, [sp, #8]
 8030ec4:	9201      	str	r2, [sp, #4]
 8030ec6:	465b      	mov	r3, fp
 8030ec8:	9300      	str	r3, [sp, #0]
 8030eca:	4653      	mov	r3, sl
 8030ecc:	2200      	movs	r2, #0
 8030ece:	4641      	mov	r1, r8
 8030ed0:	2001      	movs	r0, #1
 8030ed2:	69f7      	ldr	r7, [r6, #28]
 8030ed4:	47b8      	blx	r7
    RegionCommonTxConfigPrint(RegionNvmGroup2->Channels[txConfig->Channel].Frequency, txConfig->Datarate);
 8030ed6:	6828      	ldr	r0, [r5, #0]
 8030ed8:	7822      	ldrb	r2, [r4, #0]
 8030eda:	2101      	movs	r1, #1
 8030edc:	5661      	ldrsb	r1, [r4, r1]
 8030ede:	0053      	lsls	r3, r2, #1
 8030ee0:	189b      	adds	r3, r3, r2
 8030ee2:	009b      	lsls	r3, r3, #2
 8030ee4:	5818      	ldr	r0, [r3, r0]
 8030ee6:	f7fe fe21 	bl	802fb2c <RegionCommonTxConfigPrint>

    // Setup maximum payload length of the radio driver
    Radio.SetMaxPayloadLength( MODEM_LORA, txConfig->PktLen );
 8030eea:	6d73      	ldr	r3, [r6, #84]	; 0x54
 8030eec:	7b21      	ldrb	r1, [r4, #12]
 8030eee:	2001      	movs	r0, #1
 8030ef0:	4798      	blx	r3

    // Update time-on-air
    *txTimeOnAir = GetTimeOnAir( txConfig->Datarate, txConfig->PktLen );
 8030ef2:	89a1      	ldrh	r1, [r4, #12]
 8030ef4:	2001      	movs	r0, #1
 8030ef6:	5620      	ldrsb	r0, [r4, r0]
 8030ef8:	f7ff fc80 	bl	80307fc <GetTimeOnAir>
 8030efc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8030efe:	6018      	str	r0, [r3, #0]

    *txPower = txPowerLimited;
 8030f00:	464b      	mov	r3, r9
 8030f02:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8030f04:	701a      	strb	r2, [r3, #0]
    return true;
#else
    return false;
#endif /* REGION_US915 */
}
 8030f06:	2001      	movs	r0, #1
 8030f08:	b00d      	add	sp, #52	; 0x34
 8030f0a:	bcf0      	pop	{r4, r5, r6, r7}
 8030f0c:	46bb      	mov	fp, r7
 8030f0e:	46b2      	mov	sl, r6
 8030f10:	46a9      	mov	r9, r5
 8030f12:	46a0      	mov	r8, r4
 8030f14:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8030f16:	46c0      	nop			; (mov r8, r8)
 8030f18:	08035a14 	.word	0x08035a14
 8030f1c:	2000c324 	.word	0x2000c324
 8030f20:	2000c31c 	.word	0x2000c31c
 8030f24:	080359c0 	.word	0x080359c0
 8030f28:	41f00000 	.word	0x41f00000
 8030f2c:	08035d8c 	.word	0x08035d8c

08030f30 <RegionUS915LinkAdrReq>:

uint8_t RegionUS915LinkAdrReq( LinkAdrReqParams_t* linkAdrReq, int8_t* drOut, int8_t* txPowOut, uint8_t* nbRepOut, uint8_t* nbBytesParsed )
{
 8030f30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8030f32:	46de      	mov	lr, fp
 8030f34:	4657      	mov	r7, sl
 8030f36:	464e      	mov	r6, r9
 8030f38:	4645      	mov	r5, r8
 8030f3a:	b5e0      	push	{r5, r6, r7, lr}
 8030f3c:	b093      	sub	sp, #76	; 0x4c
 8030f3e:	0005      	movs	r5, r0
 8030f40:	4688      	mov	r8, r1
 8030f42:	9201      	str	r2, [sp, #4]
 8030f44:	469b      	mov	fp, r3
    uint8_t status = 0x07;
#if defined( REGION_US915 )
    RegionCommonLinkAdrParams_t linkAdrParams = { 0 };
 8030f46:	2206      	movs	r2, #6
 8030f48:	2100      	movs	r1, #0
 8030f4a:	a810      	add	r0, sp, #64	; 0x40
 8030f4c:	f003 fdf3 	bl	8034b36 <memset>
    uint8_t nextIndex = 0;
    uint8_t bytesProcessed = 0;
#if (defined( REGION_VERSION ) && ( REGION_VERSION == 0x01010003 ))
    uint16_t channelsMask[CHANNELS_MASK_SIZE] = { 0, 0, 0, 0, 0, 0 };
#elif (defined( REGION_VERSION ) && ( REGION_VERSION == 0x02010001 ))
    uint16_t channelsMask[6] = { 0, 0, 0, 0, 0, 0 };
 8030f50:	220c      	movs	r2, #12
 8030f52:	2100      	movs	r1, #0
 8030f54:	a80d      	add	r0, sp, #52	; 0x34
 8030f56:	f003 fdee 	bl	8034b36 <memset>
    GetPhyParams_t getPhy;
    PhyParam_t phyParam;
    RegionCommonLinkAdrReqVerifyParams_t linkAdrVerifyParams;

    // Initialize local copy of channels mask
    RegionCommonChanMaskCopy( channelsMask, RegionNvmGroup2->ChannelsMask, CHANNELS_MASK_SIZE );
 8030f5a:	4b8f      	ldr	r3, [pc, #572]	; (8031198 <RegionUS915LinkAdrReq+0x268>)
 8030f5c:	6819      	ldr	r1, [r3, #0]
 8030f5e:	23d8      	movs	r3, #216	; 0xd8
 8030f60:	009b      	lsls	r3, r3, #2
 8030f62:	469c      	mov	ip, r3
 8030f64:	4461      	add	r1, ip
 8030f66:	2206      	movs	r2, #6
 8030f68:	a80d      	add	r0, sp, #52	; 0x34
 8030f6a:	f7fe fb28 	bl	802f5be <RegionCommonChanMaskCopy>
    uint8_t bytesProcessed = 0;
 8030f6e:	2400      	movs	r4, #0

    while( bytesProcessed < linkAdrReq->PayloadSize )
 8030f70:	e00a      	b.n	8030f88 <RegionUS915LinkAdrReq+0x58>
        status = 0x07;

        if( linkAdrParams.ChMaskCtrl == 6 )
        {
            // Enable all 125 kHz channels
            channelsMask[0] = 0xFFFF;
 8030f72:	aa0d      	add	r2, sp, #52	; 0x34
 8030f74:	3b07      	subs	r3, #7
 8030f76:	8013      	strh	r3, [r2, #0]
            channelsMask[1] = 0xFFFF;
 8030f78:	8053      	strh	r3, [r2, #2]
            channelsMask[2] = 0xFFFF;
 8030f7a:	8093      	strh	r3, [r2, #4]
            channelsMask[3] = 0xFFFF;
 8030f7c:	80d3      	strh	r3, [r2, #6]
            // Apply chMask to channels 64 to 71
            channelsMask[4] = linkAdrParams.ChMask & CHANNELS_MASK_500KHZ_MASK;
 8030f7e:	ab10      	add	r3, sp, #64	; 0x40
 8030f80:	8899      	ldrh	r1, [r3, #4]
 8030f82:	23ff      	movs	r3, #255	; 0xff
 8030f84:	400b      	ands	r3, r1
 8030f86:	8113      	strh	r3, [r2, #8]
    while( bytesProcessed < linkAdrReq->PayloadSize )
 8030f88:	7a2b      	ldrb	r3, [r5, #8]
 8030f8a:	42a3      	cmp	r3, r4
 8030f8c:	d969      	bls.n	8031062 <RegionUS915LinkAdrReq+0x132>
        nextIndex = RegionCommonParseLinkAdrReq( &( linkAdrReq->Payload[bytesProcessed] ), &linkAdrParams );
 8030f8e:	686b      	ldr	r3, [r5, #4]
 8030f90:	1918      	adds	r0, r3, r4
 8030f92:	a910      	add	r1, sp, #64	; 0x40
 8030f94:	f7fe fbd0 	bl	802f738 <RegionCommonParseLinkAdrReq>
        if( nextIndex == 0 )
 8030f98:	2800      	cmp	r0, #0
 8030f9a:	d062      	beq.n	8031062 <RegionUS915LinkAdrReq+0x132>
        bytesProcessed += nextIndex;
 8030f9c:	1824      	adds	r4, r4, r0
 8030f9e:	b2e4      	uxtb	r4, r4
        if( linkAdrParams.ChMaskCtrl == 6 )
 8030fa0:	ab10      	add	r3, sp, #64	; 0x40
 8030fa2:	78db      	ldrb	r3, [r3, #3]
 8030fa4:	2b06      	cmp	r3, #6
 8030fa6:	d0e4      	beq.n	8030f72 <RegionUS915LinkAdrReq+0x42>
        }
        else if( linkAdrParams.ChMaskCtrl == 7 )
 8030fa8:	2b07      	cmp	r3, #7
 8030faa:	d007      	beq.n	8030fbc <RegionUS915LinkAdrReq+0x8c>
            channelsMask[2] = 0x0000;
            channelsMask[3] = 0x0000;
            // Apply chMask to channels 64 to 71
            channelsMask[4] = linkAdrParams.ChMask & CHANNELS_MASK_500KHZ_MASK;
        }
        else if( linkAdrParams.ChMaskCtrl == 5 )
 8030fac:	2b05      	cmp	r3, #5
 8030fae:	d054      	beq.n	803105a <RegionUS915LinkAdrReq+0x12a>
                }
            }
        }
        else
        {
            channelsMask[linkAdrParams.ChMaskCtrl] = linkAdrParams.ChMask;
 8030fb0:	aa10      	add	r2, sp, #64	; 0x40
 8030fb2:	8891      	ldrh	r1, [r2, #4]
 8030fb4:	005b      	lsls	r3, r3, #1
 8030fb6:	aa0d      	add	r2, sp, #52	; 0x34
 8030fb8:	5299      	strh	r1, [r3, r2]
 8030fba:	e7e5      	b.n	8030f88 <RegionUS915LinkAdrReq+0x58>
            channelsMask[0] = 0x0000;
 8030fbc:	ab0d      	add	r3, sp, #52	; 0x34
 8030fbe:	2200      	movs	r2, #0
 8030fc0:	801a      	strh	r2, [r3, #0]
            channelsMask[1] = 0x0000;
 8030fc2:	805a      	strh	r2, [r3, #2]
            channelsMask[2] = 0x0000;
 8030fc4:	809a      	strh	r2, [r3, #4]
            channelsMask[3] = 0x0000;
 8030fc6:	80da      	strh	r2, [r3, #6]
            channelsMask[4] = linkAdrParams.ChMask & CHANNELS_MASK_500KHZ_MASK;
 8030fc8:	aa10      	add	r2, sp, #64	; 0x40
 8030fca:	8891      	ldrh	r1, [r2, #4]
 8030fcc:	22ff      	movs	r2, #255	; 0xff
 8030fce:	400a      	ands	r2, r1
 8030fd0:	811a      	strh	r2, [r3, #8]
 8030fd2:	e7d9      	b.n	8030f88 <RegionUS915LinkAdrReq+0x58>
                        channelsMask[cntChannelMask] |= 0xFF00;
 8030fd4:	a90d      	add	r1, sp, #52	; 0x34
 8030fd6:	4648      	mov	r0, r9
 8030fd8:	0046      	lsls	r6, r0, #1
 8030fda:	5a77      	ldrh	r7, [r6, r1]
 8030fdc:	486f      	ldr	r0, [pc, #444]	; (803119c <RegionUS915LinkAdrReq+0x26c>)
 8030fde:	4307      	orrs	r7, r0
 8030fe0:	5277      	strh	r7, [r6, r1]
                        channelsMask[4] |= ( bitMask << i );
 8030fe2:	890e      	ldrh	r6, [r1, #8]
 8030fe4:	4332      	orrs	r2, r6
 8030fe6:	810a      	strh	r2, [r1, #8]
                        cntChannelMask++;
 8030fe8:	4648      	mov	r0, r9
 8030fea:	3001      	adds	r0, #1
 8030fec:	b2c2      	uxtb	r2, r0
 8030fee:	4691      	mov	r9, r2
            for( uint8_t i = 0; i <= 7; i++ )
 8030ff0:	3301      	adds	r3, #1
 8030ff2:	b2db      	uxtb	r3, r3
 8030ff4:	2b07      	cmp	r3, #7
 8030ff6:	d8c7      	bhi.n	8030f88 <RegionUS915LinkAdrReq+0x58>
                if( ( ( linkAdrParams.ChMask & 0x00FF ) & ( bitMask << i ) ) != 0 )
 8030ff8:	aa10      	add	r2, sp, #64	; 0x40
 8030ffa:	8892      	ldrh	r2, [r2, #4]
 8030ffc:	21ff      	movs	r1, #255	; 0xff
 8030ffe:	4011      	ands	r1, r2
 8031000:	2201      	movs	r2, #1
 8031002:	409a      	lsls	r2, r3
 8031004:	420a      	tst	r2, r1
 8031006:	d00c      	beq.n	8031022 <RegionUS915LinkAdrReq+0xf2>
                    if( ( i % 2 ) == 0 )
 8031008:	07d9      	lsls	r1, r3, #31
 803100a:	d4e3      	bmi.n	8030fd4 <RegionUS915LinkAdrReq+0xa4>
                        channelsMask[cntChannelMask] |= 0x00FF;
 803100c:	a90d      	add	r1, sp, #52	; 0x34
 803100e:	4648      	mov	r0, r9
 8031010:	0046      	lsls	r6, r0, #1
 8031012:	5a70      	ldrh	r0, [r6, r1]
 8031014:	27ff      	movs	r7, #255	; 0xff
 8031016:	4307      	orrs	r7, r0
 8031018:	5277      	strh	r7, [r6, r1]
                        channelsMask[4] |= ( bitMask << i );
 803101a:	890e      	ldrh	r6, [r1, #8]
 803101c:	4332      	orrs	r2, r6
 803101e:	810a      	strh	r2, [r1, #8]
 8031020:	e7e6      	b.n	8030ff0 <RegionUS915LinkAdrReq+0xc0>
                    if( ( i % 2 ) == 0 )
 8031022:	07d9      	lsls	r1, r3, #31
 8031024:	d40a      	bmi.n	803103c <RegionUS915LinkAdrReq+0x10c>
                        channelsMask[cntChannelMask] &= 0xFF00;
 8031026:	a90d      	add	r1, sp, #52	; 0x34
 8031028:	4648      	mov	r0, r9
 803102a:	0046      	lsls	r6, r0, #1
 803102c:	5a77      	ldrh	r7, [r6, r1]
 803102e:	20ff      	movs	r0, #255	; 0xff
 8031030:	4387      	bics	r7, r0
 8031032:	5277      	strh	r7, [r6, r1]
                        channelsMask[4] &= ~( bitMask << i );
 8031034:	890e      	ldrh	r6, [r1, #8]
 8031036:	4396      	bics	r6, r2
 8031038:	810e      	strh	r6, [r1, #8]
 803103a:	e7d9      	b.n	8030ff0 <RegionUS915LinkAdrReq+0xc0>
                        channelsMask[cntChannelMask] &= 0x00FF;
 803103c:	a90d      	add	r1, sp, #52	; 0x34
 803103e:	4648      	mov	r0, r9
 8031040:	0046      	lsls	r6, r0, #1
 8031042:	5a77      	ldrh	r7, [r6, r1]
 8031044:	20ff      	movs	r0, #255	; 0xff
 8031046:	4038      	ands	r0, r7
 8031048:	5270      	strh	r0, [r6, r1]
                        channelsMask[4] &= ~( bitMask << i );
 803104a:	890e      	ldrh	r6, [r1, #8]
 803104c:	4396      	bics	r6, r2
 803104e:	810e      	strh	r6, [r1, #8]
                        cntChannelMask++;
 8031050:	4648      	mov	r0, r9
 8031052:	3001      	adds	r0, #1
 8031054:	b2c2      	uxtb	r2, r0
 8031056:	4691      	mov	r9, r2
 8031058:	e7ca      	b.n	8030ff0 <RegionUS915LinkAdrReq+0xc0>
            for( uint8_t i = 0; i <= 7; i++ )
 803105a:	2300      	movs	r3, #0
            uint8_t cntChannelMask = 0;
 803105c:	2200      	movs	r2, #0
 803105e:	4691      	mov	r9, r2
 8031060:	e7c8      	b.n	8030ff4 <RegionUS915LinkAdrReq+0xc4>
        }
    }

    // FCC 15.247 paragraph F mandates to hop on at least 2 125 kHz channels
    if( ( linkAdrParams.Datarate < DR_4 ) && ( RegionCommonCountChannels( channelsMask, 0, 4 ) < 2 ) )
 8031062:	ab10      	add	r3, sp, #64	; 0x40
 8031064:	785b      	ldrb	r3, [r3, #1]
 8031066:	b25b      	sxtb	r3, r3
 8031068:	2b03      	cmp	r3, #3
 803106a:	dd5a      	ble.n	8031122 <RegionUS915LinkAdrReq+0x1f2>
 803106c:	2307      	movs	r3, #7
 803106e:	4699      	mov	r9, r3
    {
        status &= 0xFE; // Channel mask KO
    }

    // Get the minimum possible datarate
    getPhy.Attribute = PHY_MIN_TX_DR;
 8031070:	2302      	movs	r3, #2
 8031072:	aa02      	add	r2, sp, #8
 8031074:	2124      	movs	r1, #36	; 0x24
 8031076:	1852      	adds	r2, r2, r1
 8031078:	7013      	strb	r3, [r2, #0]
    getPhy.UplinkDwellTime = linkAdrReq->UplinkDwellTime;
 803107a:	7a6b      	ldrb	r3, [r5, #9]
 803107c:	aa02      	add	r2, sp, #8
 803107e:	3102      	adds	r1, #2
 8031080:	1852      	adds	r2, r2, r1
 8031082:	7013      	strb	r3, [r2, #0]
    phyParam = RegionUS915GetPhyParam( &getPhy );
 8031084:	a80b      	add	r0, sp, #44	; 0x2c
 8031086:	f7ff fbf7 	bl	8030878 <RegionUS915GetPhyParam>
 803108a:	900a      	str	r0, [sp, #40]	; 0x28

    linkAdrVerifyParams.Status = status;
 803108c:	ab02      	add	r3, sp, #8
 803108e:	464a      	mov	r2, r9
 8031090:	711a      	strb	r2, [r3, #4]
    linkAdrVerifyParams.AdrEnabled = linkAdrReq->AdrEnabled;
 8031092:	7aab      	ldrb	r3, [r5, #10]
 8031094:	aa02      	add	r2, sp, #8
 8031096:	7153      	strb	r3, [r2, #5]
    linkAdrVerifyParams.Datarate = linkAdrParams.Datarate;
 8031098:	ab10      	add	r3, sp, #64	; 0x40
 803109a:	2201      	movs	r2, #1
 803109c:	569a      	ldrsb	r2, [r3, r2]
 803109e:	a902      	add	r1, sp, #8
 80310a0:	718a      	strb	r2, [r1, #6]
    linkAdrVerifyParams.TxPower = linkAdrParams.TxPower;
 80310a2:	2202      	movs	r2, #2
 80310a4:	569a      	ldrsb	r2, [r3, r2]
 80310a6:	71ca      	strb	r2, [r1, #7]
    linkAdrVerifyParams.NbRep = linkAdrParams.NbRep;
 80310a8:	781a      	ldrb	r2, [r3, #0]
 80310aa:	720a      	strb	r2, [r1, #8]
    linkAdrVerifyParams.CurrentDatarate = linkAdrReq->CurrentDatarate;
 80310ac:	220b      	movs	r2, #11
 80310ae:	56aa      	ldrsb	r2, [r5, r2]
 80310b0:	724a      	strb	r2, [r1, #9]
    linkAdrVerifyParams.CurrentTxPower = linkAdrReq->CurrentTxPower;
 80310b2:	220c      	movs	r2, #12
 80310b4:	56aa      	ldrsb	r2, [r5, r2]
 80310b6:	728a      	strb	r2, [r1, #10]
    linkAdrVerifyParams.CurrentNbRep = linkAdrReq->CurrentNbRep;
 80310b8:	220d      	movs	r2, #13
 80310ba:	56aa      	ldrsb	r2, [r5, r2]
 80310bc:	72ca      	strb	r2, [r1, #11]
    linkAdrVerifyParams.NbChannels = US915_MAX_NB_CHANNELS;
 80310be:	2248      	movs	r2, #72	; 0x48
 80310c0:	730a      	strb	r2, [r1, #12]
    linkAdrVerifyParams.ChannelsMask = channelsMask;
 80310c2:	aa0d      	add	r2, sp, #52	; 0x34
 80310c4:	9206      	str	r2, [sp, #24]
    linkAdrVerifyParams.MinDatarate = ( int8_t )phyParam.Value;
 80310c6:	7508      	strb	r0, [r1, #20]
    linkAdrVerifyParams.MaxDatarate = US915_TX_MAX_DATARATE;
 80310c8:	2204      	movs	r2, #4
 80310ca:	754a      	strb	r2, [r1, #21]
    linkAdrVerifyParams.Channels = RegionNvmGroup2->Channels;
 80310cc:	4a32      	ldr	r2, [pc, #200]	; (8031198 <RegionUS915LinkAdrReq+0x268>)
 80310ce:	6812      	ldr	r2, [r2, #0]
 80310d0:	9200      	str	r2, [sp, #0]
 80310d2:	9208      	str	r2, [sp, #32]
    linkAdrVerifyParams.MinTxPower = US915_MIN_TX_POWER;
 80310d4:	220e      	movs	r2, #14
 80310d6:	770a      	strb	r2, [r1, #28]
    linkAdrVerifyParams.MaxTxPower = US915_MAX_TX_POWER;
 80310d8:	2200      	movs	r2, #0
 80310da:	774a      	strb	r2, [r1, #29]
    linkAdrVerifyParams.Version = linkAdrReq->Version;
 80310dc:	682a      	ldr	r2, [r5, #0]
 80310de:	9202      	str	r2, [sp, #8]

    // Verify the parameters and update, if necessary
    status = RegionCommonLinkAdrReqVerifyParams( &linkAdrVerifyParams, &linkAdrParams.Datarate, &linkAdrParams.TxPower, &linkAdrParams.NbRep );
 80310e0:	223a      	movs	r2, #58	; 0x3a
 80310e2:	468c      	mov	ip, r1
 80310e4:	4462      	add	r2, ip
 80310e6:	2139      	movs	r1, #57	; 0x39
 80310e8:	4660      	mov	r0, ip
 80310ea:	4461      	add	r1, ip
 80310ec:	f7fe fb43 	bl	802f776 <RegionCommonLinkAdrReqVerifyParams>
 80310f0:	0005      	movs	r5, r0

    // Update channelsMask if everything is correct
    if( status == 0x07 )
 80310f2:	2807      	cmp	r0, #7
 80310f4:	d022      	beq.n	803113c <RegionUS915LinkAdrReq+0x20c>
        RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
        RegionNvmGroup1->ChannelsMaskRemaining[5] = RegionNvmGroup2->ChannelsMask[5];
    }

    // Update status variables
    *drOut = linkAdrParams.Datarate;
 80310f6:	ab10      	add	r3, sp, #64	; 0x40
 80310f8:	2201      	movs	r2, #1
 80310fa:	569a      	ldrsb	r2, [r3, r2]
 80310fc:	4641      	mov	r1, r8
 80310fe:	700a      	strb	r2, [r1, #0]
    *txPowOut = linkAdrParams.TxPower;
 8031100:	2202      	movs	r2, #2
 8031102:	569a      	ldrsb	r2, [r3, r2]
 8031104:	9901      	ldr	r1, [sp, #4]
 8031106:	700a      	strb	r2, [r1, #0]
    *nbRepOut = linkAdrParams.NbRep;
 8031108:	781b      	ldrb	r3, [r3, #0]
 803110a:	465a      	mov	r2, fp
 803110c:	7013      	strb	r3, [r2, #0]
    *nbBytesParsed = bytesProcessed;
 803110e:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8031110:	701c      	strb	r4, [r3, #0]

#endif /* REGION_US915 */
    return status;
}
 8031112:	0028      	movs	r0, r5
 8031114:	b013      	add	sp, #76	; 0x4c
 8031116:	bcf0      	pop	{r4, r5, r6, r7}
 8031118:	46bb      	mov	fp, r7
 803111a:	46b2      	mov	sl, r6
 803111c:	46a9      	mov	r9, r5
 803111e:	46a0      	mov	r8, r4
 8031120:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if( ( linkAdrParams.Datarate < DR_4 ) && ( RegionCommonCountChannels( channelsMask, 0, 4 ) < 2 ) )
 8031122:	2204      	movs	r2, #4
 8031124:	2100      	movs	r1, #0
 8031126:	a80d      	add	r0, sp, #52	; 0x34
 8031128:	f7fe fa32 	bl	802f590 <RegionCommonCountChannels>
 803112c:	2801      	cmp	r0, #1
 803112e:	d902      	bls.n	8031136 <RegionUS915LinkAdrReq+0x206>
 8031130:	2307      	movs	r3, #7
 8031132:	4699      	mov	r9, r3
 8031134:	e79c      	b.n	8031070 <RegionUS915LinkAdrReq+0x140>
        status &= 0xFE; // Channel mask KO
 8031136:	2306      	movs	r3, #6
 8031138:	4699      	mov	r9, r3
 803113a:	e799      	b.n	8031070 <RegionUS915LinkAdrReq+0x140>
        RegionCommonChanMaskCopy( RegionNvmGroup2->ChannelsMask, channelsMask, 6 );
 803113c:	4b16      	ldr	r3, [pc, #88]	; (8031198 <RegionUS915LinkAdrReq+0x268>)
 803113e:	4699      	mov	r9, r3
 8031140:	6818      	ldr	r0, [r3, #0]
 8031142:	23d8      	movs	r3, #216	; 0xd8
 8031144:	009b      	lsls	r3, r3, #2
 8031146:	469c      	mov	ip, r3
 8031148:	4460      	add	r0, ip
 803114a:	2206      	movs	r2, #6
 803114c:	a90d      	add	r1, sp, #52	; 0x34
 803114e:	f7fe fa36 	bl	802f5be <RegionCommonChanMaskCopy>
        RegionNvmGroup1->ChannelsMaskRemaining[0] &= RegionNvmGroup2->ChannelsMask[0];
 8031152:	4b13      	ldr	r3, [pc, #76]	; (80311a0 <RegionUS915LinkAdrReq+0x270>)
 8031154:	681b      	ldr	r3, [r3, #0]
 8031156:	464a      	mov	r2, r9
 8031158:	6812      	ldr	r2, [r2, #0]
 803115a:	21d8      	movs	r1, #216	; 0xd8
 803115c:	0089      	lsls	r1, r1, #2
 803115e:	5a50      	ldrh	r0, [r2, r1]
 8031160:	8819      	ldrh	r1, [r3, #0]
 8031162:	4001      	ands	r1, r0
 8031164:	8019      	strh	r1, [r3, #0]
        RegionNvmGroup1->ChannelsMaskRemaining[1] &= RegionNvmGroup2->ChannelsMask[1];
 8031166:	490f      	ldr	r1, [pc, #60]	; (80311a4 <RegionUS915LinkAdrReq+0x274>)
 8031168:	5a50      	ldrh	r0, [r2, r1]
 803116a:	8859      	ldrh	r1, [r3, #2]
 803116c:	4001      	ands	r1, r0
 803116e:	8059      	strh	r1, [r3, #2]
        RegionNvmGroup1->ChannelsMaskRemaining[2] &= RegionNvmGroup2->ChannelsMask[2];
 8031170:	21d9      	movs	r1, #217	; 0xd9
 8031172:	0089      	lsls	r1, r1, #2
 8031174:	5a50      	ldrh	r0, [r2, r1]
 8031176:	8899      	ldrh	r1, [r3, #4]
 8031178:	4001      	ands	r1, r0
 803117a:	8099      	strh	r1, [r3, #4]
        RegionNvmGroup1->ChannelsMaskRemaining[3] &= RegionNvmGroup2->ChannelsMask[3];
 803117c:	490a      	ldr	r1, [pc, #40]	; (80311a8 <RegionUS915LinkAdrReq+0x278>)
 803117e:	5a50      	ldrh	r0, [r2, r1]
 8031180:	88d9      	ldrh	r1, [r3, #6]
 8031182:	4001      	ands	r1, r0
 8031184:	80d9      	strh	r1, [r3, #6]
        RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 8031186:	21da      	movs	r1, #218	; 0xda
 8031188:	0089      	lsls	r1, r1, #2
 803118a:	5a51      	ldrh	r1, [r2, r1]
 803118c:	8119      	strh	r1, [r3, #8]
        RegionNvmGroup1->ChannelsMaskRemaining[5] = RegionNvmGroup2->ChannelsMask[5];
 803118e:	4907      	ldr	r1, [pc, #28]	; (80311ac <RegionUS915LinkAdrReq+0x27c>)
 8031190:	5a52      	ldrh	r2, [r2, r1]
 8031192:	815a      	strh	r2, [r3, #10]
 8031194:	e7af      	b.n	80310f6 <RegionUS915LinkAdrReq+0x1c6>
 8031196:	46c0      	nop			; (mov r8, r8)
 8031198:	2000c324 	.word	0x2000c324
 803119c:	ffffff00 	.word	0xffffff00
 80311a0:	2000c320 	.word	0x2000c320
 80311a4:	00000362 	.word	0x00000362
 80311a8:	00000366 	.word	0x00000366
 80311ac:	0000036a 	.word	0x0000036a

080311b0 <RegionUS915RxParamSetupReq>:

uint8_t RegionUS915RxParamSetupReq( RxParamSetupReqParams_t* rxParamSetupReq )
{
 80311b0:	b570      	push	{r4, r5, r6, lr}
 80311b2:	0004      	movs	r4, r0
    uint8_t status = 0x07;
#if defined( REGION_US915 )

    // Verify radio frequency
    if( VerifyRfFreq( rxParamSetupReq->Frequency ) == false )
 80311b4:	6840      	ldr	r0, [r0, #4]
 80311b6:	f7ff faf7 	bl	80307a8 <VerifyRfFreq>
 80311ba:	2800      	cmp	r0, #0
 80311bc:	d024      	beq.n	8031208 <RegionUS915RxParamSetupReq+0x58>
    uint8_t status = 0x07;
 80311be:	2507      	movs	r5, #7
    {
        status &= 0xFE; // Channel frequency KO
    }

    // Verify datarate
    if( RegionCommonValueInRange( rxParamSetupReq->Datarate, US915_RX_MIN_DATARATE, US915_RX_MAX_DATARATE ) == false )
 80311c0:	2000      	movs	r0, #0
 80311c2:	5620      	ldrsb	r0, [r4, r0]
 80311c4:	220d      	movs	r2, #13
 80311c6:	2108      	movs	r1, #8
 80311c8:	f7fe f97f 	bl	802f4ca <RegionCommonValueInRange>
 80311cc:	2800      	cmp	r0, #0
 80311ce:	d101      	bne.n	80311d4 <RegionUS915RxParamSetupReq+0x24>
    {
        status &= 0xFD; // Datarate KO
 80311d0:	2302      	movs	r3, #2
 80311d2:	439d      	bics	r5, r3
    }
    if( ( RegionCommonValueInRange( rxParamSetupReq->Datarate, DR_5, DR_7 ) == true ) ||
 80311d4:	2000      	movs	r0, #0
 80311d6:	5620      	ldrsb	r0, [r4, r0]
 80311d8:	2207      	movs	r2, #7
 80311da:	2105      	movs	r1, #5
 80311dc:	f7fe f975 	bl	802f4ca <RegionCommonValueInRange>
 80311e0:	2801      	cmp	r0, #1
 80311e2:	d003      	beq.n	80311ec <RegionUS915RxParamSetupReq+0x3c>
        ( rxParamSetupReq->Datarate > DR_13 ) )
 80311e4:	2300      	movs	r3, #0
 80311e6:	56e3      	ldrsb	r3, [r4, r3]
    if( ( RegionCommonValueInRange( rxParamSetupReq->Datarate, DR_5, DR_7 ) == true ) ||
 80311e8:	2b0d      	cmp	r3, #13
 80311ea:	dd01      	ble.n	80311f0 <RegionUS915RxParamSetupReq+0x40>
    {
        status &= 0xFD; // Datarate KO
 80311ec:	2302      	movs	r3, #2
 80311ee:	439d      	bics	r5, r3
    }

    // Verify datarate offset
    if( RegionCommonValueInRange( rxParamSetupReq->DrOffset, US915_MIN_RX1_DR_OFFSET, US915_MAX_RX1_DR_OFFSET ) == false )
 80311f0:	2001      	movs	r0, #1
 80311f2:	5620      	ldrsb	r0, [r4, r0]
 80311f4:	2203      	movs	r2, #3
 80311f6:	2100      	movs	r1, #0
 80311f8:	f7fe f967 	bl	802f4ca <RegionCommonValueInRange>
 80311fc:	2800      	cmp	r0, #0
 80311fe:	d101      	bne.n	8031204 <RegionUS915RxParamSetupReq+0x54>
    {
        status &= 0xFB; // Rx1DrOffset range KO
 8031200:	2304      	movs	r3, #4
 8031202:	439d      	bics	r5, r3
    }

#endif /* REGION_US915 */
    return status;
}
 8031204:	0028      	movs	r0, r5
 8031206:	bd70      	pop	{r4, r5, r6, pc}
        status &= 0xFE; // Channel frequency KO
 8031208:	2506      	movs	r5, #6
 803120a:	e7d9      	b.n	80311c0 <RegionUS915RxParamSetupReq+0x10>

0803120c <RegionUS915NewChannelReq>:

int8_t RegionUS915NewChannelReq( NewChannelReqParams_t* newChannelReq )
{
    // Do not accept the request
    return -1;
 803120c:	2001      	movs	r0, #1
}
 803120e:	4240      	negs	r0, r0
 8031210:	4770      	bx	lr

08031212 <RegionUS915TxParamSetupReq>:

int8_t RegionUS915TxParamSetupReq( TxParamSetupReqParams_t* txParamSetupReq )
{
    // Do not accept the request
    return -1;
 8031212:	2001      	movs	r0, #1
}
 8031214:	4240      	negs	r0, r0
 8031216:	4770      	bx	lr

08031218 <RegionUS915DlChannelReq>:

int8_t RegionUS915DlChannelReq( DlChannelReqParams_t* dlChannelReq )
{
    // Do not accept the request
    return -1;
 8031218:	2001      	movs	r0, #1
}
 803121a:	4240      	negs	r0, r0
 803121c:	4770      	bx	lr
	...

08031220 <RegionUS915AlternateDr>:

int8_t RegionUS915AlternateDr( int8_t currentDr, AlternateDrType_t type )
{
 8031220:	b510      	push	{r4, lr}
#if defined( REGION_US915 )
    // Alternates the data rate according to the channel sequence:
    // Eight times a 125kHz DR_0 and then one 500kHz DR_4 channel
    if( type == ALTERNATE_DR )
 8031222:	2900      	cmp	r1, #0
 8031224:	d10f      	bne.n	8031246 <RegionUS915AlternateDr+0x26>
    {
        RegionNvmGroup1->JoinTrialsCounter++;
 8031226:	4b0c      	ldr	r3, [pc, #48]	; (8031258 <RegionUS915AlternateDr+0x38>)
 8031228:	681a      	ldr	r2, [r3, #0]
 803122a:	7b53      	ldrb	r3, [r2, #13]
 803122c:	3301      	adds	r3, #1
 803122e:	7353      	strb	r3, [r2, #13]
    else
    {
        RegionNvmGroup1->JoinTrialsCounter--;
    }

    if( RegionNvmGroup1->JoinTrialsCounter % 9 == 0 )
 8031230:	4b09      	ldr	r3, [pc, #36]	; (8031258 <RegionUS915AlternateDr+0x38>)
 8031232:	681b      	ldr	r3, [r3, #0]
 8031234:	7b58      	ldrb	r0, [r3, #13]
 8031236:	2109      	movs	r1, #9
 8031238:	f7ee fff4 	bl	8020224 <__aeabi_uidivmod>
 803123c:	b2c9      	uxtb	r1, r1
 803123e:	2900      	cmp	r1, #0
 8031240:	d007      	beq.n	8031252 <RegionUS915AlternateDr+0x32>
        // Use DR_4 every 9th times.
        currentDr = DR_4;
    }
    else
    {
        currentDr = DR_0;
 8031242:	2000      	movs	r0, #0
    }
    return currentDr;
#else
    return -1;
#endif /* REGION_US915 */
}
 8031244:	bd10      	pop	{r4, pc}
        RegionNvmGroup1->JoinTrialsCounter--;
 8031246:	4b04      	ldr	r3, [pc, #16]	; (8031258 <RegionUS915AlternateDr+0x38>)
 8031248:	681a      	ldr	r2, [r3, #0]
 803124a:	7b53      	ldrb	r3, [r2, #13]
 803124c:	3b01      	subs	r3, #1
 803124e:	7353      	strb	r3, [r2, #13]
 8031250:	e7ee      	b.n	8031230 <RegionUS915AlternateDr+0x10>
        currentDr = DR_4;
 8031252:	2004      	movs	r0, #4
 8031254:	e7f6      	b.n	8031244 <RegionUS915AlternateDr+0x24>
 8031256:	46c0      	nop			; (mov r8, r8)
 8031258:	2000c320 	.word	0x2000c320

0803125c <RegionUS915NextChannel>:

LoRaMacStatus_t RegionUS915NextChannel( NextChanParams_t* nextChanParams, uint8_t* channel, TimerTime_t* time, TimerTime_t* aggregatedTimeOff )
{
 803125c:	b5f0      	push	{r4, r5, r6, r7, lr}
 803125e:	46ce      	mov	lr, r9
 8031260:	4647      	mov	r7, r8
 8031262:	b580      	push	{r7, lr}
 8031264:	b0a5      	sub	sp, #148	; 0x94
 8031266:	0004      	movs	r4, r0
 8031268:	000d      	movs	r5, r1
 803126a:	4691      	mov	r9, r2
 803126c:	4698      	mov	r8, r3
#if defined( REGION_US915 )
    uint8_t nbEnabledChannels = 0;
 803126e:	2300      	movs	r3, #0
 8031270:	228f      	movs	r2, #143	; 0x8f
 8031272:	446a      	add	r2, sp
 8031274:	7013      	strb	r3, [r2, #0]
    uint8_t nbRestrictedChannels = 0;
 8031276:	228e      	movs	r2, #142	; 0x8e
 8031278:	446a      	add	r2, sp
 803127a:	7013      	strb	r3, [r2, #0]
    uint8_t enabledChannels[US915_MAX_NB_CHANNELS] = { 0 };
 803127c:	9311      	str	r3, [sp, #68]	; 0x44
 803127e:	2244      	movs	r2, #68	; 0x44
 8031280:	2100      	movs	r1, #0
 8031282:	a812      	add	r0, sp, #72	; 0x48
 8031284:	f003 fc57 	bl	8034b36 <memset>
    RegionCommonIdentifyChannelsParam_t identifyChannelsParam;
    RegionCommonCountNbOfEnabledChannelsParams_t countChannelsParams;
    LoRaMacStatus_t status = LORAMAC_STATUS_NO_CHANNEL_FOUND;

    // Count 125kHz channels
    if( RegionCommonCountChannels( RegionNvmGroup1->ChannelsMaskRemaining, 0, 4 ) == 0 )
 8031288:	4b49      	ldr	r3, [pc, #292]	; (80313b0 <RegionUS915NextChannel+0x154>)
 803128a:	6818      	ldr	r0, [r3, #0]
 803128c:	2204      	movs	r2, #4
 803128e:	2100      	movs	r1, #0
 8031290:	f7fe f97e 	bl	802f590 <RegionCommonCountChannels>
 8031294:	2800      	cmp	r0, #0
 8031296:	d058      	beq.n	803134a <RegionUS915NextChannel+0xee>
        RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, 4  );

        RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
    }
    // Check other channels
    if( nextChanParams->Datarate >= DR_4 )
 8031298:	2308      	movs	r3, #8
 803129a:	56e3      	ldrsb	r3, [r4, r3]
 803129c:	2b03      	cmp	r3, #3
 803129e:	dd0b      	ble.n	80312b8 <RegionUS915NextChannel+0x5c>
    {
        if( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) == 0 )
 80312a0:	4b43      	ldr	r3, [pc, #268]	; (80313b0 <RegionUS915NextChannel+0x154>)
 80312a2:	681b      	ldr	r3, [r3, #0]
 80312a4:	891a      	ldrh	r2, [r3, #8]
 80312a6:	21ff      	movs	r1, #255	; 0xff
 80312a8:	4211      	tst	r1, r2
 80312aa:	d105      	bne.n	80312b8 <RegionUS915NextChannel+0x5c>
        {
            RegionNvmGroup1->ChannelsMaskRemaining[4] = RegionNvmGroup2->ChannelsMask[4];
 80312ac:	4a41      	ldr	r2, [pc, #260]	; (80313b4 <RegionUS915NextChannel+0x158>)
 80312ae:	6811      	ldr	r1, [r2, #0]
 80312b0:	22da      	movs	r2, #218	; 0xda
 80312b2:	0092      	lsls	r2, r2, #2
 80312b4:	5a8a      	ldrh	r2, [r1, r2]
 80312b6:	811a      	strh	r2, [r3, #8]
        }
    }

    // Search how many channels are enabled
    countChannelsParams.Joined = nextChanParams->Joined;
 80312b8:	7a63      	ldrb	r3, [r4, #9]
 80312ba:	a803      	add	r0, sp, #12
 80312bc:	7003      	strb	r3, [r0, #0]
    countChannelsParams.Datarate = nextChanParams->Datarate;
 80312be:	7a23      	ldrb	r3, [r4, #8]
 80312c0:	7043      	strb	r3, [r0, #1]
    countChannelsParams.ChannelsMask = RegionNvmGroup1->ChannelsMaskRemaining;
 80312c2:	4b3b      	ldr	r3, [pc, #236]	; (80313b0 <RegionUS915NextChannel+0x154>)
 80312c4:	681b      	ldr	r3, [r3, #0]
 80312c6:	9304      	str	r3, [sp, #16]
    countChannelsParams.Channels = RegionNvmGroup2->Channels;
 80312c8:	4b3a      	ldr	r3, [pc, #232]	; (80313b4 <RegionUS915NextChannel+0x158>)
 80312ca:	681b      	ldr	r3, [r3, #0]
 80312cc:	9305      	str	r3, [sp, #20]
#if (defined( REGION_VERSION ) && ( REGION_VERSION == 0x01010003 ))
    countChannelsParams.Bands = RegionNvmGroup1->Bands;
#elif (defined( REGION_VERSION ) && ( REGION_VERSION == 0x02010001 ))
    countChannelsParams.Bands = RegionBands;
 80312ce:	4b3a      	ldr	r3, [pc, #232]	; (80313b8 <RegionUS915NextChannel+0x15c>)
 80312d0:	681b      	ldr	r3, [r3, #0]
 80312d2:	9306      	str	r3, [sp, #24]
#endif /* REGION_VERSION */
    countChannelsParams.MaxNbChannels = US915_MAX_NB_CHANNELS;
 80312d4:	2348      	movs	r3, #72	; 0x48
 80312d6:	8203      	strh	r3, [r0, #16]
    countChannelsParams.JoinChannels = NULL;
 80312d8:	2300      	movs	r3, #0
 80312da:	9308      	str	r3, [sp, #32]

    identifyChannelsParam.AggrTimeOff = nextChanParams->AggrTimeOff;
 80312dc:	ae09      	add	r6, sp, #36	; 0x24
 80312de:	6823      	ldr	r3, [r4, #0]
 80312e0:	9309      	str	r3, [sp, #36]	; 0x24
    identifyChannelsParam.LastAggrTx = nextChanParams->LastAggrTx;
 80312e2:	6863      	ldr	r3, [r4, #4]
 80312e4:	930a      	str	r3, [sp, #40]	; 0x28
    identifyChannelsParam.DutyCycleEnabled = nextChanParams->DutyCycleEnabled;
 80312e6:	7aa3      	ldrb	r3, [r4, #10]
 80312e8:	7233      	strb	r3, [r6, #8]
    identifyChannelsParam.MaxBands = US915_MAX_NB_BANDS;
 80312ea:	2301      	movs	r3, #1
 80312ec:	7273      	strb	r3, [r6, #9]
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );

    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
#elif (defined( REGION_VERSION ) && ( REGION_VERSION == 0x02010001 ))
    identifyChannelsParam.CountNbOfEnabledChannelsParam = &countChannelsParams;
 80312ee:	9010      	str	r0, [sp, #64]	; 0x40

    identifyChannelsParam.ElapsedTimeSinceStartUp = nextChanParams->ElapsedTimeSinceStartUp;
 80312f0:	a80c      	add	r0, sp, #48	; 0x30
 80312f2:	0027      	movs	r7, r4
 80312f4:	370c      	adds	r7, #12
 80312f6:	cf0c      	ldmia	r7!, {r2, r3}
 80312f8:	c00c      	stmia	r0!, {r2, r3}
    identifyChannelsParam.LastTxIsJoinRequest = nextChanParams->LastTxIsJoinRequest;
 80312fa:	7d23      	ldrb	r3, [r4, #20]
 80312fc:	7533      	strb	r3, [r6, #20]
    identifyChannelsParam.ExpectedTimeOnAir = GetTimeOnAir( nextChanParams->Datarate, nextChanParams->PktLen );
 80312fe:	8ae1      	ldrh	r1, [r4, #22]
 8031300:	2008      	movs	r0, #8
 8031302:	5620      	ldrsb	r0, [r4, r0]
 8031304:	f7ff fa7a 	bl	80307fc <GetTimeOnAir>
 8031308:	900f      	str	r0, [sp, #60]	; 0x3c
#endif /* REGION_VERSION */

    status = RegionCommonIdentifyChannels( &identifyChannelsParam, aggregatedTimeOff, enabledChannels,
 803130a:	464b      	mov	r3, r9
 803130c:	9301      	str	r3, [sp, #4]
 803130e:	238e      	movs	r3, #142	; 0x8e
 8031310:	446b      	add	r3, sp
 8031312:	9300      	str	r3, [sp, #0]
 8031314:	238f      	movs	r3, #143	; 0x8f
 8031316:	446b      	add	r3, sp
 8031318:	aa11      	add	r2, sp, #68	; 0x44
 803131a:	4641      	mov	r1, r8
 803131c:	0030      	movs	r0, r6
 803131e:	f7fe fb5f 	bl	802f9e0 <RegionCommonIdentifyChannels>
 8031322:	1e06      	subs	r6, r0, #0
                                           &nbEnabledChannels, &nbRestrictedChannels, time );

    if( status == LORAMAC_STATUS_OK )
 8031324:	d13d      	bne.n	80313a2 <RegionUS915NextChannel+0x146>
    {
        if( nextChanParams->Joined == true )
 8031326:	7a63      	ldrb	r3, [r4, #9]
 8031328:	2b00      	cmp	r3, #0
 803132a:	d11d      	bne.n	8031368 <RegionUS915NextChannel+0x10c>
            // follow a random channel selection sequence. It probes alternating one out of a
            // group of eight 125 kHz channels followed by probing one 500 kHz channel each pass.
            // Each time a 125 kHz channel will be selected from another group.

            // 125kHz Channels (0 - 63) DR0
            if( nextChanParams->Datarate == DR_0 )
 803132c:	2308      	movs	r3, #8
 803132e:	56e3      	ldrsb	r3, [r4, r3]
 8031330:	2b00      	cmp	r3, #0
 8031332:	d126      	bne.n	8031382 <RegionUS915NextChannel+0x126>
            {
                if( RegionBaseUSComputeNext125kHzJoinChannel( ( uint16_t* ) RegionNvmGroup1->ChannelsMaskRemaining,
 8031334:	4b1e      	ldr	r3, [pc, #120]	; (80313b0 <RegionUS915NextChannel+0x154>)
 8031336:	6818      	ldr	r0, [r3, #0]
 8031338:	0001      	movs	r1, r0
 803133a:	310c      	adds	r1, #12
 803133c:	002a      	movs	r2, r5
 803133e:	f7fd ff93 	bl	802f268 <RegionBaseUSComputeNext125kHzJoinChannel>
 8031342:	2803      	cmp	r0, #3
 8031344:	d127      	bne.n	8031396 <RegionUS915NextChannel+0x13a>
                    &RegionNvmGroup1->JoinChannelGroupsCurrentIndex, channel ) == LORAMAC_STATUS_PARAMETER_INVALID )
                {
                    return LORAMAC_STATUS_PARAMETER_INVALID;
 8031346:	0006      	movs	r6, r0
 8031348:	e02b      	b.n	80313a2 <RegionUS915NextChannel+0x146>
        RegionCommonChanMaskCopy( RegionNvmGroup1->ChannelsMaskRemaining, RegionNvmGroup2->ChannelsMask, 4  );
 803134a:	4e19      	ldr	r6, [pc, #100]	; (80313b0 <RegionUS915NextChannel+0x154>)
 803134c:	4b19      	ldr	r3, [pc, #100]	; (80313b4 <RegionUS915NextChannel+0x158>)
 803134e:	6819      	ldr	r1, [r3, #0]
 8031350:	23d8      	movs	r3, #216	; 0xd8
 8031352:	009b      	lsls	r3, r3, #2
 8031354:	469c      	mov	ip, r3
 8031356:	4461      	add	r1, ip
 8031358:	2204      	movs	r2, #4
 803135a:	6830      	ldr	r0, [r6, #0]
 803135c:	f7fe f92f 	bl	802f5be <RegionCommonChanMaskCopy>
        RegionNvmGroup1->JoinChannelGroupsCurrentIndex = 0;
 8031360:	6833      	ldr	r3, [r6, #0]
 8031362:	2200      	movs	r2, #0
 8031364:	731a      	strb	r2, [r3, #12]
 8031366:	e797      	b.n	8031298 <RegionUS915NextChannel+0x3c>
            *channel = enabledChannels[randr( 0, nbEnabledChannels - 1 )];
 8031368:	238f      	movs	r3, #143	; 0x8f
 803136a:	446b      	add	r3, sp
 803136c:	7819      	ldrb	r1, [r3, #0]
 803136e:	3901      	subs	r1, #1
 8031370:	2000      	movs	r0, #0
 8031372:	f000 febb 	bl	80320ec <randr>
 8031376:	ab11      	add	r3, sp, #68	; 0x44
 8031378:	5c1b      	ldrb	r3, [r3, r0]
 803137a:	702b      	strb	r3, [r5, #0]
 803137c:	e00b      	b.n	8031396 <RegionUS915NextChannel+0x13a>
            {
                // Choose the next available channel
                uint8_t i = 0;
                while( ( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) & ( 1 << i ) ) == 0 )
                {
                    i++;
 803137e:	3001      	adds	r0, #1
 8031380:	b2c0      	uxtb	r0, r0
                while( ( ( RegionNvmGroup1->ChannelsMaskRemaining[4] & CHANNELS_MASK_500KHZ_MASK ) & ( 1 << i ) ) == 0 )
 8031382:	4b0b      	ldr	r3, [pc, #44]	; (80313b0 <RegionUS915NextChannel+0x154>)
 8031384:	681b      	ldr	r3, [r3, #0]
 8031386:	891a      	ldrh	r2, [r3, #8]
 8031388:	23ff      	movs	r3, #255	; 0xff
 803138a:	4013      	ands	r3, r2
 803138c:	4103      	asrs	r3, r0
 803138e:	07db      	lsls	r3, r3, #31
 8031390:	d5f5      	bpl.n	803137e <RegionUS915NextChannel+0x122>
                }
                *channel = 64 + i;
 8031392:	3040      	adds	r0, #64	; 0x40
 8031394:	7028      	strb	r0, [r5, #0]
            }
        }

        // Disable the channel in the mask
        RegionCommonChanDisable( RegionNvmGroup1->ChannelsMaskRemaining, *channel, US915_MAX_NB_CHANNELS );
 8031396:	4b06      	ldr	r3, [pc, #24]	; (80313b0 <RegionUS915NextChannel+0x154>)
 8031398:	6818      	ldr	r0, [r3, #0]
 803139a:	7829      	ldrb	r1, [r5, #0]
 803139c:	2248      	movs	r2, #72	; 0x48
 803139e:	f7fe f8e2 	bl	802f566 <RegionCommonChanDisable>
    }
    return status;
#else
    return LORAMAC_STATUS_NO_CHANNEL_FOUND;
#endif /* REGION_US915 */
}
 80313a2:	0030      	movs	r0, r6
 80313a4:	b025      	add	sp, #148	; 0x94
 80313a6:	bcc0      	pop	{r6, r7}
 80313a8:	46b9      	mov	r9, r7
 80313aa:	46b0      	mov	r8, r6
 80313ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80313ae:	46c0      	nop			; (mov r8, r8)
 80313b0:	2000c320 	.word	0x2000c320
 80313b4:	2000c324 	.word	0x2000c324
 80313b8:	2000c31c 	.word	0x2000c31c

080313bc <RegionUS915ApplyDrOffset>:
#endif /* REGION_VERSION */

uint8_t RegionUS915ApplyDrOffset( uint8_t downlinkDwellTime, int8_t dr, int8_t drOffset )
{
#if defined( REGION_US915 )
    int8_t datarate = DatarateOffsetsUS915[dr][drOffset];
 80313bc:	008b      	lsls	r3, r1, #2
 80313be:	4904      	ldr	r1, [pc, #16]	; (80313d0 <RegionUS915ApplyDrOffset+0x14>)
 80313c0:	18c9      	adds	r1, r1, r3
 80313c2:	5688      	ldrsb	r0, [r1, r2]

    if( datarate < 0 )
 80313c4:	2800      	cmp	r0, #0
 80313c6:	db01      	blt.n	80313cc <RegionUS915ApplyDrOffset+0x10>
    {
        datarate = DR_0;
    }
    return datarate;
 80313c8:	b2c0      	uxtb	r0, r0
#else
    return 0;
#endif /* REGION_US915 */
}
 80313ca:	4770      	bx	lr
        datarate = DR_0;
 80313cc:	2000      	movs	r0, #0
 80313ce:	e7fb      	b.n	80313c8 <RegionUS915ApplyDrOffset+0xc>
 80313d0:	08035a00 	.word	0x08035a00

080313d4 <GetKeyIndexByID>:
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
}

#else /* LORAWAN_KMS == 1 */
static SecureElementStatus_t GetKeyIndexByID( KeyIdentifier_t keyID, CK_OBJECT_HANDLE *keyIndex )
{
 80313d4:	b530      	push	{r4, r5, lr}
    if( keyIndex == NULL )
 80313d6:	2900      	cmp	r1, #0
 80313d8:	d012      	beq.n	8031400 <GetKeyIndexByID+0x2c>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )
 80313da:	2300      	movs	r3, #0
 80313dc:	2b0b      	cmp	r3, #11
 80313de:	d80d      	bhi.n	80313fc <GetKeyIndexByID+0x28>
    {
        if( KeyList[i].KeyID == keyID )
 80313e0:	00da      	lsls	r2, r3, #3
 80313e2:	4c08      	ldr	r4, [pc, #32]	; (8031404 <GetKeyIndexByID+0x30>)
 80313e4:	5d12      	ldrb	r2, [r2, r4]
 80313e6:	4282      	cmp	r2, r0
 80313e8:	d002      	beq.n	80313f0 <GetKeyIndexByID+0x1c>
    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )
 80313ea:	3301      	adds	r3, #1
 80313ec:	b2db      	uxtb	r3, r3
 80313ee:	e7f5      	b.n	80313dc <GetKeyIndexByID+0x8>
        {
            *keyIndex = KeyList[i].Object_Index;
 80313f0:	00dd      	lsls	r5, r3, #3
 80313f2:	1965      	adds	r5, r4, r5
 80313f4:	686b      	ldr	r3, [r5, #4]
 80313f6:	600b      	str	r3, [r1, #0]
            return SECURE_ELEMENT_SUCCESS;
 80313f8:	2000      	movs	r0, #0
 80313fa:	e000      	b.n	80313fe <GetKeyIndexByID+0x2a>
        }
    }
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 80313fc:	2003      	movs	r0, #3
}
 80313fe:	bd30      	pop	{r4, r5, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 8031400:	2002      	movs	r0, #2
 8031402:	e7fc      	b.n	80313fe <GetKeyIndexByID+0x2a>
 8031404:	2000b0d4 	.word	0x2000b0d4

08031408 <GetSpecificLabelByID>:

static SecureElementStatus_t GetSpecificLabelByID( KeyIdentifier_t keyID, uint32_t *keyLabel )
{
 8031408:	b530      	push	{r4, r5, lr}
    if( keyLabel == NULL )
 803140a:	2900      	cmp	r1, #0
 803140c:	d017      	beq.n	803143e <GetSpecificLabelByID+0x36>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )
 803140e:	2300      	movs	r3, #0
 8031410:	2b0b      	cmp	r3, #11
 8031412:	d812      	bhi.n	803143a <GetSpecificLabelByID+0x32>
    {
        if( KeyLabel[i].keyID == keyID )
 8031414:	001d      	movs	r5, r3
 8031416:	005a      	lsls	r2, r3, #1
 8031418:	18d2      	adds	r2, r2, r3
 803141a:	0092      	lsls	r2, r2, #2
 803141c:	4c09      	ldr	r4, [pc, #36]	; (8031444 <GetSpecificLabelByID+0x3c>)
 803141e:	5d12      	ldrb	r2, [r2, r4]
 8031420:	4282      	cmp	r2, r0
 8031422:	d002      	beq.n	803142a <GetSpecificLabelByID+0x22>
    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )
 8031424:	3301      	adds	r3, #1
 8031426:	b2db      	uxtb	r3, r3
 8031428:	e7f2      	b.n	8031410 <GetSpecificLabelByID+0x8>
        {
            *keyLabel = KeyLabel[i].keyLabel;
 803142a:	005b      	lsls	r3, r3, #1
 803142c:	195d      	adds	r5, r3, r5
 803142e:	00ad      	lsls	r5, r5, #2
 8031430:	1965      	adds	r5, r4, r5
 8031432:	686b      	ldr	r3, [r5, #4]
 8031434:	600b      	str	r3, [r1, #0]
            return SECURE_ELEMENT_SUCCESS;
 8031436:	2000      	movs	r0, #0
 8031438:	e000      	b.n	803143c <GetSpecificLabelByID+0x34>
        }
    }
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 803143a:	2003      	movs	r0, #3
}
 803143c:	bd30      	pop	{r4, r5, pc}
        return SECURE_ELEMENT_ERROR_NPE;
 803143e:	2002      	movs	r0, #2
 8031440:	e7fc      	b.n	803143c <GetSpecificLabelByID+0x34>
 8031442:	46c0      	nop			; (mov r8, r8)
 8031444:	08035bdc 	.word	0x08035bdc

08031448 <ComputeCmac>:
#endif /* LORAWAN_KMS */

static SecureElementStatus_t ComputeCmac( uint8_t *micBxBuffer, uint8_t *buffer, uint32_t size, KeyIdentifier_t keyID,
                                          uint32_t *cmac )
{
 8031448:	b5f0      	push	{r4, r5, r6, r7, lr}
 803144a:	46ce      	mov	lr, r9
 803144c:	b500      	push	{lr}
 803144e:	b08a      	sub	sp, #40	; 0x28
 8031450:	0007      	movs	r7, r0
 8031452:	000d      	movs	r5, r1
 8031454:	9203      	str	r2, [sp, #12]
 8031456:	0018      	movs	r0, r3
    if( ( buffer == NULL ) || ( cmac == NULL ) )
 8031458:	2900      	cmp	r1, #0
 803145a:	d100      	bne.n	803145e <ComputeCmac+0x16>
 803145c:	e069      	b.n	8031532 <ComputeCmac+0xea>
 803145e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8031460:	2b00      	cmp	r3, #0
 8031462:	d068      	beq.n	8031536 <ComputeCmac+0xee>
    }
#else /* LORAWAN_KMS == 1 */
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;    /* Read ONLY session */
    uint32_t tag_length = sizeof( tag );
 8031464:	2310      	movs	r3, #16
 8031466:	9308      	str	r3, [sp, #32]
    uint32_t max_allocated_size = 0;
    uint32_t buffer_addr = ( uint32_t )buffer;
#endif /* 0 */

    /* AES CMAC Authentication variables */
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, ( CK_VOID_PTR )NULL, 0 };
 8031468:	4b34      	ldr	r3, [pc, #208]	; (803153c <ComputeCmac+0xf4>)
 803146a:	9304      	str	r3, [sp, #16]
 803146c:	2300      	movs	r3, #0
 803146e:	9305      	str	r3, [sp, #20]
 8031470:	9306      	str	r3, [sp, #24]

    SecureElementStatus_t retval = GetKeyIndexByID( keyID, &key_handle );
 8031472:	a907      	add	r1, sp, #28
 8031474:	f7ff ffae 	bl	80313d4 <GetKeyIndexByID>
 8031478:	1e04      	subs	r4, r0, #0
    if( retval != SECURE_ELEMENT_SUCCESS )
 803147a:	d004      	beq.n	8031486 <ComputeCmac+0x3e>
    {
        retval = SECURE_ELEMENT_ERROR;
    }
#endif /* LORAWAN_KMS */
    return retval;
}
 803147c:	0020      	movs	r0, r4
 803147e:	b00a      	add	sp, #40	; 0x28
 8031480:	bc80      	pop	{r7}
 8031482:	46b9      	mov	r9, r7
 8031484:	bdf0      	pop	{r4, r5, r6, r7, pc}
    rv = C_OpenSession( 0,    session_flags, NULL, 0, &session );
 8031486:	ab09      	add	r3, sp, #36	; 0x24
 8031488:	9300      	str	r3, [sp, #0]
 803148a:	2300      	movs	r3, #0
 803148c:	2200      	movs	r2, #0
 803148e:	2104      	movs	r1, #4
 8031490:	2000      	movs	r0, #0
 8031492:	f7f5 ffdd 	bl	8027450 <KMS_OpenSession>
 8031496:	1e06      	subs	r6, r0, #0
    if( rv == CKR_OK )
 8031498:	d033      	beq.n	8031502 <ComputeCmac+0xba>
    if( rv == CKR_OK )
 803149a:	2e00      	cmp	r6, #0
 803149c:	d10f      	bne.n	80314be <ComputeCmac+0x76>
        if( micBxBuffer != NULL )
 803149e:	2f00      	cmp	r7, #0
 80314a0:	d036      	beq.n	8031510 <ComputeCmac+0xc8>
            memcpy1( ( uint8_t * ) &input_align_combined_buf[0], ( uint8_t * ) micBxBuffer, SE_KEY_SIZE );
 80314a2:	4b27      	ldr	r3, [pc, #156]	; (8031540 <ComputeCmac+0xf8>)
 80314a4:	4699      	mov	r9, r3
 80314a6:	2210      	movs	r2, #16
 80314a8:	0039      	movs	r1, r7
 80314aa:	0018      	movs	r0, r3
 80314ac:	f000 fe29 	bl	8032102 <memcpy1>
            memcpy1( ( uint8_t * ) &input_align_combined_buf[SE_KEY_SIZE], ( uint8_t * ) buffer, size );
 80314b0:	466b      	mov	r3, sp
 80314b2:	899a      	ldrh	r2, [r3, #12]
 80314b4:	4648      	mov	r0, r9
 80314b6:	3010      	adds	r0, #16
 80314b8:	0029      	movs	r1, r5
 80314ba:	f000 fe22 	bl	8032102 <memcpy1>
    if( rv == CKR_OK )
 80314be:	2e00      	cmp	r6, #0
 80314c0:	d10b      	bne.n	80314da <ComputeCmac+0x92>
        if( micBxBuffer != NULL )
 80314c2:	2f00      	cmp	r7, #0
 80314c4:	d02b      	beq.n	803151e <ComputeCmac+0xd6>
            rv = C_Sign( session, ( CK_BYTE_PTR )&input_align_combined_buf[0], size + SE_KEY_SIZE, &tag[0],
 80314c6:	9a03      	ldr	r2, [sp, #12]
 80314c8:	3210      	adds	r2, #16
 80314ca:	ab08      	add	r3, sp, #32
 80314cc:	9300      	str	r3, [sp, #0]
 80314ce:	4b1d      	ldr	r3, [pc, #116]	; (8031544 <ComputeCmac+0xfc>)
 80314d0:	491b      	ldr	r1, [pc, #108]	; (8031540 <ComputeCmac+0xf8>)
 80314d2:	9809      	ldr	r0, [sp, #36]	; 0x24
 80314d4:	f7f7 fc34 	bl	8028d40 <KMS_Sign>
 80314d8:	0006      	movs	r6, r0
    ( void )C_CloseSession( session );
 80314da:	9809      	ldr	r0, [sp, #36]	; 0x24
 80314dc:	f7f5 fffa 	bl	80274d4 <KMS_CloseSession>
    *cmac = GET_UINT32_LE( tag, 0 );
 80314e0:	4a18      	ldr	r2, [pc, #96]	; (8031544 <ComputeCmac+0xfc>)
 80314e2:	7813      	ldrb	r3, [r2, #0]
 80314e4:	7851      	ldrb	r1, [r2, #1]
 80314e6:	0209      	lsls	r1, r1, #8
 80314e8:	430b      	orrs	r3, r1
 80314ea:	7891      	ldrb	r1, [r2, #2]
 80314ec:	0409      	lsls	r1, r1, #16
 80314ee:	430b      	orrs	r3, r1
 80314f0:	78d2      	ldrb	r2, [r2, #3]
 80314f2:	0612      	lsls	r2, r2, #24
 80314f4:	4313      	orrs	r3, r2
 80314f6:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80314f8:	6013      	str	r3, [r2, #0]
    if( rv != CKR_OK )
 80314fa:	2e00      	cmp	r6, #0
 80314fc:	d0be      	beq.n	803147c <ComputeCmac+0x34>
        retval = SECURE_ELEMENT_ERROR;
 80314fe:	2406      	movs	r4, #6
 8031500:	e7bc      	b.n	803147c <ComputeCmac+0x34>
        rv = C_SignInit( session, &aes_cmac_mechanism, key_handle );
 8031502:	9a07      	ldr	r2, [sp, #28]
 8031504:	a904      	add	r1, sp, #16
 8031506:	9809      	ldr	r0, [sp, #36]	; 0x24
 8031508:	f7f7 fc08 	bl	8028d1c <KMS_SignInit>
 803150c:	0006      	movs	r6, r0
 803150e:	e7c4      	b.n	803149a <ComputeCmac+0x52>
            memcpy1( ( uint8_t * ) &input_align_combined_buf[0], ( uint8_t * ) buffer, size );
 8031510:	466b      	mov	r3, sp
 8031512:	899a      	ldrh	r2, [r3, #12]
 8031514:	0029      	movs	r1, r5
 8031516:	480a      	ldr	r0, [pc, #40]	; (8031540 <ComputeCmac+0xf8>)
 8031518:	f000 fdf3 	bl	8032102 <memcpy1>
 803151c:	e7cf      	b.n	80314be <ComputeCmac+0x76>
            rv = C_Sign( session, ( CK_BYTE_PTR )&input_align_combined_buf[0], size, &tag[0],
 803151e:	ab08      	add	r3, sp, #32
 8031520:	9300      	str	r3, [sp, #0]
 8031522:	4b08      	ldr	r3, [pc, #32]	; (8031544 <ComputeCmac+0xfc>)
 8031524:	9a03      	ldr	r2, [sp, #12]
 8031526:	4906      	ldr	r1, [pc, #24]	; (8031540 <ComputeCmac+0xf8>)
 8031528:	9809      	ldr	r0, [sp, #36]	; 0x24
 803152a:	f7f7 fc09 	bl	8028d40 <KMS_Sign>
 803152e:	0006      	movs	r6, r0
 8031530:	e7d3      	b.n	80314da <ComputeCmac+0x92>
        return SECURE_ELEMENT_ERROR_NPE;
 8031532:	2402      	movs	r4, #2
 8031534:	e7a2      	b.n	803147c <ComputeCmac+0x34>
 8031536:	2402      	movs	r4, #2
 8031538:	e7a0      	b.n	803147c <ComputeCmac+0x34>
 803153a:	46c0      	nop			; (mov r8, r8)
 803153c:	0000108a 	.word	0x0000108a
 8031540:	2000c32c 	.word	0x2000c32c
 8031544:	2000c55c 	.word	0x2000c55c

08031548 <SecureElementInit>:
/* Exported functions ---------------------------------------------------------*/
/*
 * API functions
 */
SecureElementStatus_t SecureElementInit( SecureElementNvmData_t *nvm )
{
 8031548:	b570      	push	{r4, r5, r6, lr}
 803154a:	b096      	sub	sp, #88	; 0x58
    if( nvm == NULL )
 803154c:	2800      	cmp	r0, #0
 803154e:	d05a      	beq.n	8031606 <SecureElementInit+0xbe>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    /* Initialize nvm pointer */
    SeNvm = nvm;
 8031550:	4b2e      	ldr	r3, [pc, #184]	; (803160c <SecureElementInit+0xc4>)
 8031552:	6018      	str	r0, [r3, #0]

#if (LORAWAN_KMS == 0)
    /* Initialize data */
    memcpy1( ( uint8_t * )SeNvm, ( uint8_t * )&seNvmInit, sizeof( seNvmInit ) );
#else /* LORAWAN_KMS == 1 */
    SeNvm->reserved = 0;
 8031554:	2200      	movs	r2, #0
 8031556:	6002      	str	r2, [r0, #0]
    CK_RV rv;
    CK_SESSION_HANDLE session;
    uint32_t ulCount;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;  /* Read ONLY session */
    CK_OBJECT_HANDLE hObject[NUM_OF_KEYS];
    CK_ULONG local_template_label[] = {GlobalTemplateLabel, 0UL};
 8031558:	ab06      	add	r3, sp, #24
 803155a:	492d      	ldr	r1, [pc, #180]	; (8031610 <SecureElementInit+0xc8>)
 803155c:	9106      	str	r1, [sp, #24]
 803155e:	9207      	str	r2, [sp, #28]
    CK_ATTRIBUTE key_template = {CKA_LABEL, ( CK_VOID_PTR )local_template_label, sizeof( local_template_label )};
 8031560:	3203      	adds	r2, #3
 8031562:	9203      	str	r2, [sp, #12]
 8031564:	9304      	str	r3, [sp, #16]
 8031566:	2308      	movs	r3, #8
 8031568:	9305      	str	r3, [sp, #20]

    /* Open session with KMS */
    rv = C_OpenSession( 0, session_flags, NULL, 0, &session );
 803156a:	ab15      	add	r3, sp, #84	; 0x54
 803156c:	9300      	str	r3, [sp, #0]
 803156e:	2300      	movs	r3, #0
 8031570:	2200      	movs	r2, #0
 8031572:	2104      	movs	r1, #4
 8031574:	2000      	movs	r0, #0
 8031576:	f7f5 ff6b 	bl	8027450 <KMS_OpenSession>
 803157a:	0006      	movs	r6, r0

    for( uint8_t itr = 0; itr < NUM_OF_KEYS; itr++ )
 803157c:	2400      	movs	r4, #0
 803157e:	e015      	b.n	80315ac <SecureElementInit+0x64>
        {
            ulCount = 0;
            /* Search from Template pattern */
            if( rv == CKR_OK )
            {
                rv = C_FindObjectsInit( session, &key_template, GET_NB_ATTRIBUTE( key_template ) );
 8031580:	2201      	movs	r2, #1
 8031582:	a903      	add	r1, sp, #12
 8031584:	9815      	ldr	r0, [sp, #84]	; 0x54
 8031586:	f7f5 fadf 	bl	8026b48 <KMS_FindObjectsInit>
 803158a:	0006      	movs	r6, r0
 803158c:	e01d      	b.n	80315ca <SecureElementInit+0x82>
            }

            /* Find all existing keys handle Template pattern */
            if( rv == CKR_OK )
            {
                rv = C_FindObjects( session, hObject, NUM_OF_KEYS, ( CK_ULONG * ) &ulCount );
 803158e:	ab14      	add	r3, sp, #80	; 0x50
 8031590:	220c      	movs	r2, #12
 8031592:	a908      	add	r1, sp, #32
 8031594:	9815      	ldr	r0, [sp, #84]	; 0x54
 8031596:	f7f5 fb3f 	bl	8026c18 <KMS_FindObjects>
 803159a:	0006      	movs	r6, r0
 803159c:	e017      	b.n	80315ce <SecureElementInit+0x86>
            }

            if( rv == CKR_OK )
            {
                rv = C_FindObjectsFinal( session );
 803159e:	9815      	ldr	r0, [sp, #84]	; 0x54
 80315a0:	f7f5 fb86 	bl	8026cb0 <KMS_FindObjectsFinal>
 80315a4:	0006      	movs	r6, r0
 80315a6:	e014      	b.n	80315d2 <SecureElementInit+0x8a>
    for( uint8_t itr = 0; itr < NUM_OF_KEYS; itr++ )
 80315a8:	3401      	adds	r4, #1
 80315aa:	b2e4      	uxtb	r4, r4
 80315ac:	2c0b      	cmp	r4, #11
 80315ae:	d820      	bhi.n	80315f2 <SecureElementInit+0xaa>
        if( SECURE_ELEMENT_SUCCESS == GetSpecificLabelByID( KeyList[itr].KeyID, &local_template_label[1] ) )
 80315b0:	0025      	movs	r5, r4
 80315b2:	00e3      	lsls	r3, r4, #3
 80315b4:	4a17      	ldr	r2, [pc, #92]	; (8031614 <SecureElementInit+0xcc>)
 80315b6:	5c98      	ldrb	r0, [r3, r2]
 80315b8:	a907      	add	r1, sp, #28
 80315ba:	f7ff ff25 	bl	8031408 <GetSpecificLabelByID>
 80315be:	2800      	cmp	r0, #0
 80315c0:	d1f2      	bne.n	80315a8 <SecureElementInit+0x60>
            ulCount = 0;
 80315c2:	2300      	movs	r3, #0
 80315c4:	9314      	str	r3, [sp, #80]	; 0x50
            if( rv == CKR_OK )
 80315c6:	2e00      	cmp	r6, #0
 80315c8:	d0da      	beq.n	8031580 <SecureElementInit+0x38>
            if( rv == CKR_OK )
 80315ca:	2e00      	cmp	r6, #0
 80315cc:	d0df      	beq.n	803158e <SecureElementInit+0x46>
            if( rv == CKR_OK )
 80315ce:	2e00      	cmp	r6, #0
 80315d0:	d0e5      	beq.n	803159e <SecureElementInit+0x56>
            }

            if( ( rv == CKR_OK ) && ( ulCount > 0 ) && ( ulCount <= NUM_OF_KEYS ) )
 80315d2:	2e00      	cmp	r6, #0
 80315d4:	d1e8      	bne.n	80315a8 <SecureElementInit+0x60>
 80315d6:	9b14      	ldr	r3, [sp, #80]	; 0x50
 80315d8:	2b00      	cmp	r3, #0
 80315da:	d0e5      	beq.n	80315a8 <SecureElementInit+0x60>
 80315dc:	2b0c      	cmp	r3, #12
 80315de:	d8e3      	bhi.n	80315a8 <SecureElementInit+0x60>
            {
                KeyList[itr].Object_Index = hObject[ulCount - 1];
 80315e0:	3b01      	subs	r3, #1
 80315e2:	009b      	lsls	r3, r3, #2
 80315e4:	aa08      	add	r2, sp, #32
 80315e6:	589a      	ldr	r2, [r3, r2]
 80315e8:	00ed      	lsls	r5, r5, #3
 80315ea:	4b0a      	ldr	r3, [pc, #40]	; (8031614 <SecureElementInit+0xcc>)
 80315ec:	195d      	adds	r5, r3, r5
 80315ee:	606a      	str	r2, [r5, #4]
 80315f0:	e7da      	b.n	80315a8 <SecureElementInit+0x60>
            }
        }
    }
    /* Close sessions */
    if( session > 0 )
 80315f2:	9815      	ldr	r0, [sp, #84]	; 0x54
 80315f4:	2800      	cmp	r0, #0
 80315f6:	d102      	bne.n	80315fe <SecureElementInit+0xb6>
        ( void )C_CloseSession( session );
    }

#endif /* LORAWAN_KMS */

    return SECURE_ELEMENT_SUCCESS;
 80315f8:	2000      	movs	r0, #0
}
 80315fa:	b016      	add	sp, #88	; 0x58
 80315fc:	bd70      	pop	{r4, r5, r6, pc}
        ( void )C_CloseSession( session );
 80315fe:	f7f5 ff69 	bl	80274d4 <KMS_CloseSession>
    return SECURE_ELEMENT_SUCCESS;
 8031602:	2000      	movs	r0, #0
 8031604:	e7f9      	b.n	80315fa <SecureElementInit+0xb2>
        return SECURE_ELEMENT_ERROR_NPE;
 8031606:	2002      	movs	r0, #2
 8031608:	e7f7      	b.n	80315fa <SecureElementInit+0xb2>
 803160a:	46c0      	nop			; (mov r8, r8)
 803160c:	2000c328 	.word	0x2000c328
 8031610:	444e524c 	.word	0x444e524c
 8031614:	2000b0d4 	.word	0x2000b0d4

08031618 <SecureElementGetKeyByID>:
#endif /* KEY_EXTRACTABLE */
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
}
#else /* LORAWAN_KMS == 1 */
SecureElementStatus_t SecureElementGetKeyByID( KeyIdentifier_t keyID, uint8_t *extractable_key )
{
 8031618:	b530      	push	{r4, r5, lr}
 803161a:	b089      	sub	sp, #36	; 0x24
 803161c:	000c      	movs	r4, r1
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;  /* Read ONLY session */
    CK_OBJECT_HANDLE key_handle = ( CK_OBJECT_HANDLE )( ~0UL );
 803161e:	2301      	movs	r3, #1
 8031620:	425b      	negs	r3, r3
 8031622:	9306      	str	r3, [sp, #24]
    CK_ULONG derive_key_template_class = CKO_SECRET_KEY;
 8031624:	3305      	adds	r3, #5
 8031626:	9305      	str	r3, [sp, #20]
    uint32_t size = SE_KEY_SIZE;

    if( extractable_key == NULL )
 8031628:	2900      	cmp	r1, #0
 803162a:	d029      	beq.n	8031680 <SecureElementGetKeyByID+0x68>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    if( keyID == DEV_JOIN_EUI_ADDR_KEY )
 803162c:	2802      	cmp	r0, #2
 803162e:	d01c      	beq.n	803166a <SecureElementGetKeyByID+0x52>
    uint32_t size = SE_KEY_SIZE;
 8031630:	2210      	movs	r2, #16
    {
        size = SE_NVM_EUI_SIZE;
    }
    CK_ATTRIBUTE key_attribute_template = {CKA_VALUE, ( CK_VOID_PTR ) &derive_key_template_class, size};
 8031632:	2311      	movs	r3, #17
 8031634:	9302      	str	r3, [sp, #8]
 8031636:	ab05      	add	r3, sp, #20
 8031638:	9303      	str	r3, [sp, #12]
 803163a:	9204      	str	r2, [sp, #16]

    if( GetKeyIndexByID( keyID, &key_handle ) == SECURE_ELEMENT_ERROR_INVALID_KEY_ID )
 803163c:	a906      	add	r1, sp, #24
 803163e:	f7ff fec9 	bl	80313d4 <GetKeyIndexByID>
 8031642:	2803      	cmp	r0, #3
 8031644:	d00f      	beq.n	8031666 <SecureElementGetKeyByID+0x4e>
    {
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
    }

    /* Open session with KMS */
    rv = C_OpenSession( 0, session_flags, NULL, 0, &session );
 8031646:	ab07      	add	r3, sp, #28
 8031648:	9300      	str	r3, [sp, #0]
 803164a:	2300      	movs	r3, #0
 803164c:	2200      	movs	r2, #0
 803164e:	2104      	movs	r1, #4
 8031650:	2000      	movs	r0, #0
 8031652:	f7f5 fefd 	bl	8027450 <KMS_OpenSession>
 8031656:	1e05      	subs	r5, r0, #0

    /* Get key to display */
    if( rv == CKR_OK )
 8031658:	d009      	beq.n	803166e <SecureElementGetKeyByID+0x56>
        key_attribute_template.pValue = extractable_key;
        rv = C_GetAttributeValue( session, key_handle, &key_attribute_template, 1UL );
    }

    /* Close sessions */
    ( void )C_CloseSession( session );
 803165a:	9807      	ldr	r0, [sp, #28]
 803165c:	f7f5 ff3a 	bl	80274d4 <KMS_CloseSession>

    if( rv != CKR_OK )
 8031660:	2d00      	cmp	r5, #0
 8031662:	d10f      	bne.n	8031684 <SecureElementGetKeyByID+0x6c>
    {
        return SECURE_ELEMENT_ERROR;
    }
    return SECURE_ELEMENT_SUCCESS;
 8031664:	2000      	movs	r0, #0
}
 8031666:	b009      	add	sp, #36	; 0x24
 8031668:	bd30      	pop	{r4, r5, pc}
        size = SE_NVM_EUI_SIZE;
 803166a:	2218      	movs	r2, #24
 803166c:	e7e1      	b.n	8031632 <SecureElementGetKeyByID+0x1a>
        key_attribute_template.pValue = extractable_key;
 803166e:	9403      	str	r4, [sp, #12]
        rv = C_GetAttributeValue( session, key_handle, &key_attribute_template, 1UL );
 8031670:	2301      	movs	r3, #1
 8031672:	aa02      	add	r2, sp, #8
 8031674:	9906      	ldr	r1, [sp, #24]
 8031676:	9807      	ldr	r0, [sp, #28]
 8031678:	f7f5 f9c6 	bl	8026a08 <KMS_GetAttributeValue>
 803167c:	0005      	movs	r5, r0
 803167e:	e7ec      	b.n	803165a <SecureElementGetKeyByID+0x42>
        return SECURE_ELEMENT_ERROR_NPE;
 8031680:	2002      	movs	r0, #2
 8031682:	e7f0      	b.n	8031666 <SecureElementGetKeyByID+0x4e>
        return SECURE_ELEMENT_ERROR;
 8031684:	2006      	movs	r0, #6
 8031686:	e7ee      	b.n	8031666 <SecureElementGetKeyByID+0x4e>

08031688 <PrintKey>:
{
 8031688:	b5f0      	push	{r4, r5, r6, r7, lr}
 803168a:	46de      	mov	lr, fp
 803168c:	4657      	mov	r7, sl
 803168e:	464e      	mov	r6, r9
 8031690:	4645      	mov	r5, r8
 8031692:	b5e0      	push	{r5, r6, r7, lr}
 8031694:	b09d      	sub	sp, #116	; 0x74
 8031696:	0004      	movs	r4, r0
    uint8_t extractable_key[SE_KEY_SIZE] = {0};
 8031698:	2300      	movs	r3, #0
 803169a:	9318      	str	r3, [sp, #96]	; 0x60
 803169c:	220c      	movs	r2, #12
 803169e:	2100      	movs	r1, #0
 80316a0:	a819      	add	r0, sp, #100	; 0x64
 80316a2:	f003 fa48 	bl	8034b36 <memset>
    if( SECURE_ELEMENT_SUCCESS == SecureElementGetKeyByID( keyID, ( uint8_t * )extractable_key ) )
 80316a6:	a918      	add	r1, sp, #96	; 0x60
 80316a8:	0020      	movs	r0, r4
 80316aa:	f7ff ffb5 	bl	8031618 <SecureElementGetKeyByID>
 80316ae:	2800      	cmp	r0, #0
 80316b0:	d047      	beq.n	8031742 <PrintKey+0xba>
}
 80316b2:	b01d      	add	sp, #116	; 0x74
 80316b4:	bcf0      	pop	{r4, r5, r6, r7}
 80316b6:	46bb      	mov	fp, r7
 80316b8:	46b2      	mov	sl, r6
 80316ba:	46a9      	mov	r9, r5
 80316bc:	46a0      	mov	r8, r4
 80316be:	bdf0      	pop	{r4, r5, r6, r7, pc}
                MW_LOG( TS_OFF, VLEVEL_M,
 80316c0:	aa18      	add	r2, sp, #96	; 0x60
 80316c2:	7811      	ldrb	r1, [r2, #0]
 80316c4:	9113      	str	r1, [sp, #76]	; 0x4c
 80316c6:	7850      	ldrb	r0, [r2, #1]
 80316c8:	9014      	str	r0, [sp, #80]	; 0x50
 80316ca:	7894      	ldrb	r4, [r2, #2]
 80316cc:	9415      	str	r4, [sp, #84]	; 0x54
 80316ce:	78d5      	ldrb	r5, [r2, #3]
 80316d0:	9516      	str	r5, [sp, #88]	; 0x58
 80316d2:	7911      	ldrb	r1, [r2, #4]
 80316d4:	7950      	ldrb	r0, [r2, #5]
 80316d6:	7994      	ldrb	r4, [r2, #6]
 80316d8:	79d5      	ldrb	r5, [r2, #7]
 80316da:	7a16      	ldrb	r6, [r2, #8]
 80316dc:	9617      	str	r6, [sp, #92]	; 0x5c
 80316de:	7a57      	ldrb	r7, [r2, #9]
 80316e0:	7a96      	ldrb	r6, [r2, #10]
 80316e2:	46b4      	mov	ip, r6
 80316e4:	7ad6      	ldrb	r6, [r2, #11]
 80316e6:	46b0      	mov	r8, r6
 80316e8:	7b16      	ldrb	r6, [r2, #12]
 80316ea:	46b1      	mov	r9, r6
 80316ec:	7b56      	ldrb	r6, [r2, #13]
 80316ee:	46b2      	mov	sl, r6
 80316f0:	7b96      	ldrb	r6, [r2, #14]
 80316f2:	7bd2      	ldrb	r2, [r2, #15]
 80316f4:	9210      	str	r2, [sp, #64]	; 0x40
 80316f6:	960f      	str	r6, [sp, #60]	; 0x3c
 80316f8:	4652      	mov	r2, sl
 80316fa:	920e      	str	r2, [sp, #56]	; 0x38
 80316fc:	464a      	mov	r2, r9
 80316fe:	920d      	str	r2, [sp, #52]	; 0x34
 8031700:	4642      	mov	r2, r8
 8031702:	920c      	str	r2, [sp, #48]	; 0x30
 8031704:	4662      	mov	r2, ip
 8031706:	920b      	str	r2, [sp, #44]	; 0x2c
 8031708:	970a      	str	r7, [sp, #40]	; 0x28
 803170a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 803170c:	9209      	str	r2, [sp, #36]	; 0x24
 803170e:	9508      	str	r5, [sp, #32]
 8031710:	9407      	str	r4, [sp, #28]
 8031712:	9006      	str	r0, [sp, #24]
 8031714:	9105      	str	r1, [sp, #20]
 8031716:	9d16      	ldr	r5, [sp, #88]	; 0x58
 8031718:	9504      	str	r5, [sp, #16]
 803171a:	9c15      	ldr	r4, [sp, #84]	; 0x54
 803171c:	9403      	str	r4, [sp, #12]
 803171e:	9814      	ldr	r0, [sp, #80]	; 0x50
 8031720:	9002      	str	r0, [sp, #8]
 8031722:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8031724:	9101      	str	r1, [sp, #4]
 8031726:	005a      	lsls	r2, r3, #1
 8031728:	18d3      	adds	r3, r2, r3
 803172a:	009b      	lsls	r3, r3, #2
 803172c:	4a0b      	ldr	r2, [pc, #44]	; (803175c <PrintKey+0xd4>)
 803172e:	18d3      	adds	r3, r2, r3
 8031730:	689b      	ldr	r3, [r3, #8]
 8031732:	9300      	str	r3, [sp, #0]
 8031734:	4b0a      	ldr	r3, [pc, #40]	; (8031760 <PrintKey+0xd8>)
 8031736:	2200      	movs	r2, #0
 8031738:	2100      	movs	r1, #0
 803173a:	2002      	movs	r0, #2
 803173c:	f002 fb98 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
                return;
 8031740:	e7b7      	b.n	80316b2 <PrintKey+0x2a>
        for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )
 8031742:	280b      	cmp	r0, #11
 8031744:	d8b5      	bhi.n	80316b2 <PrintKey+0x2a>
            if( KeyLabel[i].keyID == keyID )
 8031746:	0003      	movs	r3, r0
 8031748:	0042      	lsls	r2, r0, #1
 803174a:	1812      	adds	r2, r2, r0
 803174c:	0092      	lsls	r2, r2, #2
 803174e:	4903      	ldr	r1, [pc, #12]	; (803175c <PrintKey+0xd4>)
 8031750:	5c52      	ldrb	r2, [r2, r1]
 8031752:	42a2      	cmp	r2, r4
 8031754:	d0b4      	beq.n	80316c0 <PrintKey+0x38>
        for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )
 8031756:	3001      	adds	r0, #1
 8031758:	b2c0      	uxtb	r0, r0
 803175a:	e7f2      	b.n	8031742 <PrintKey+0xba>
 803175c:	08035bdc 	.word	0x08035bdc
 8031760:	08035a44 	.word	0x08035a44

08031764 <SecureElementDeleteDynamicKey>:

    return SECURE_ELEMENT_SUCCESS;
}

SecureElementStatus_t SecureElementDeleteDynamicKey( KeyIdentifier_t keyID, uint32_t *key_label )
{
 8031764:	b570      	push	{r4, r5, r6, lr}
 8031766:	b096      	sub	sp, #88	; 0x58
 8031768:	000d      	movs	r5, r1
#else /* LORAWAN_KMS == 1 */
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;    /* Read ONLY session */
    CK_OBJECT_HANDLE hObject[NUM_OF_KEYS];
    CK_ULONG local_template_label[] = {GlobalTemplateLabel, 0UL};
 803176a:	aa07      	add	r2, sp, #28
 803176c:	4b2c      	ldr	r3, [pc, #176]	; (8031820 <SecureElementDeleteDynamicKey+0xbc>)
 803176e:	9307      	str	r3, [sp, #28]
 8031770:	2300      	movs	r3, #0
 8031772:	9308      	str	r3, [sp, #32]
    CK_ATTRIBUTE dynamic_key_template =
 8031774:	2103      	movs	r1, #3
 8031776:	9104      	str	r1, [sp, #16]
 8031778:	9205      	str	r2, [sp, #20]
 803177a:	2208      	movs	r2, #8
 803177c:	9206      	str	r2, [sp, #24]
    {
        CKA_LABEL, ( CK_VOID_PTR )local_template_label, sizeof( local_template_label )
    };
    uint32_t ulCount = 0;
 803177e:	9303      	str	r3, [sp, #12]

    if( key_label == NULL )
 8031780:	2d00      	cmp	r5, #0
 8031782:	d046      	beq.n	8031812 <SecureElementDeleteDynamicKey+0xae>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    if( SECURE_ELEMENT_SUCCESS != GetSpecificLabelByID( keyID, &local_template_label[1] ) )
 8031784:	a908      	add	r1, sp, #32
 8031786:	f7ff fe3f 	bl	8031408 <GetSpecificLabelByID>
 803178a:	0004      	movs	r4, r0
 803178c:	1e06      	subs	r6, r0, #0
 803178e:	d142      	bne.n	8031816 <SecureElementDeleteDynamicKey+0xb2>
    {
        return SECURE_ELEMENT_ERROR;
    }
    *key_label = local_template_label[1];
 8031790:	9b08      	ldr	r3, [sp, #32]
 8031792:	602b      	str	r3, [r5, #0]

    /* Open session with KMS */
    rv = C_OpenSession( 0,    session_flags, NULL, 0, &session );
 8031794:	ab15      	add	r3, sp, #84	; 0x54
 8031796:	9300      	str	r3, [sp, #0]
 8031798:	2300      	movs	r3, #0
 803179a:	2200      	movs	r2, #0
 803179c:	2104      	movs	r1, #4
 803179e:	2000      	movs	r0, #0
 80317a0:	f7f5 fe56 	bl	8027450 <KMS_OpenSession>
 80317a4:	1e05      	subs	r5, r0, #0

    /* Search from Template pattern */
    if( rv == CKR_OK )
 80317a6:	d00e      	beq.n	80317c6 <SecureElementDeleteDynamicKey+0x62>
    {
        rv = C_FindObjectsInit( session, &dynamic_key_template, GET_NB_ATTRIBUTE( dynamic_key_template ) );
    }

    /* Find all existing keys handle Template pattern */
    if( rv == CKR_OK )
 80317a8:	2d00      	cmp	r5, #0
 80317aa:	d013      	beq.n	80317d4 <SecureElementDeleteDynamicKey+0x70>
    {
        rv = C_FindObjects( session, hObject, NUM_OF_KEYS, ( CK_ULONG * ) &ulCount );
    }

    if( rv == CKR_OK )
 80317ac:	2d00      	cmp	r5, #0
 80317ae:	d019      	beq.n	80317e4 <SecureElementDeleteDynamicKey+0x80>
    {
        rv = C_FindObjectsFinal( session );
    }

    if( ulCount <= NUM_OF_KEYS )
 80317b0:	9b03      	ldr	r3, [sp, #12]
 80317b2:	2b0c      	cmp	r3, #12
 80317b4:	d91d      	bls.n	80317f2 <SecureElementDeleteDynamicKey+0x8e>
            }
        }
    }

    /* Close sessions */
    if( session > 0 )
 80317b6:	9815      	ldr	r0, [sp, #84]	; 0x54
 80317b8:	2800      	cmp	r0, #0
 80317ba:	d127      	bne.n	803180c <SecureElementDeleteDynamicKey+0xa8>
    {
        ( void )C_CloseSession( session );
    }

    if( rv != CKR_OK )
 80317bc:	2d00      	cmp	r5, #0
 80317be:	d12c      	bne.n	803181a <SecureElementDeleteDynamicKey+0xb6>
    {
        return SECURE_ELEMENT_ERROR;
    }
    return SECURE_ELEMENT_SUCCESS;
#endif /* LORAWAN_KMS */
}
 80317c0:	0030      	movs	r0, r6
 80317c2:	b016      	add	sp, #88	; 0x58
 80317c4:	bd70      	pop	{r4, r5, r6, pc}
        rv = C_FindObjectsInit( session, &dynamic_key_template, GET_NB_ATTRIBUTE( dynamic_key_template ) );
 80317c6:	2201      	movs	r2, #1
 80317c8:	a904      	add	r1, sp, #16
 80317ca:	9815      	ldr	r0, [sp, #84]	; 0x54
 80317cc:	f7f5 f9bc 	bl	8026b48 <KMS_FindObjectsInit>
 80317d0:	0005      	movs	r5, r0
 80317d2:	e7e9      	b.n	80317a8 <SecureElementDeleteDynamicKey+0x44>
        rv = C_FindObjects( session, hObject, NUM_OF_KEYS, ( CK_ULONG * ) &ulCount );
 80317d4:	ab03      	add	r3, sp, #12
 80317d6:	220c      	movs	r2, #12
 80317d8:	a909      	add	r1, sp, #36	; 0x24
 80317da:	9815      	ldr	r0, [sp, #84]	; 0x54
 80317dc:	f7f5 fa1c 	bl	8026c18 <KMS_FindObjects>
 80317e0:	0005      	movs	r5, r0
 80317e2:	e7e3      	b.n	80317ac <SecureElementDeleteDynamicKey+0x48>
        rv = C_FindObjectsFinal( session );
 80317e4:	9815      	ldr	r0, [sp, #84]	; 0x54
 80317e6:	f7f5 fa63 	bl	8026cb0 <KMS_FindObjectsFinal>
 80317ea:	0005      	movs	r5, r0
 80317ec:	e7e0      	b.n	80317b0 <SecureElementDeleteDynamicKey+0x4c>
        for( uint8_t i = 0; i < ulCount; i++ )
 80317ee:	3401      	adds	r4, #1
 80317f0:	b2e4      	uxtb	r4, r4
 80317f2:	9b03      	ldr	r3, [sp, #12]
 80317f4:	429c      	cmp	r4, r3
 80317f6:	d2de      	bcs.n	80317b6 <SecureElementDeleteDynamicKey+0x52>
            if( rv == CKR_OK )
 80317f8:	2d00      	cmp	r5, #0
 80317fa:	d1f8      	bne.n	80317ee <SecureElementDeleteDynamicKey+0x8a>
                rv = C_DestroyObject( session, hObject[i] );
 80317fc:	00a3      	lsls	r3, r4, #2
 80317fe:	aa09      	add	r2, sp, #36	; 0x24
 8031800:	5899      	ldr	r1, [r3, r2]
 8031802:	9815      	ldr	r0, [sp, #84]	; 0x54
 8031804:	f7f5 f8c2 	bl	802698c <KMS_DestroyObject>
 8031808:	0005      	movs	r5, r0
 803180a:	e7f0      	b.n	80317ee <SecureElementDeleteDynamicKey+0x8a>
        ( void )C_CloseSession( session );
 803180c:	f7f5 fe62 	bl	80274d4 <KMS_CloseSession>
 8031810:	e7d4      	b.n	80317bc <SecureElementDeleteDynamicKey+0x58>
        return SECURE_ELEMENT_ERROR_NPE;
 8031812:	2602      	movs	r6, #2
 8031814:	e7d4      	b.n	80317c0 <SecureElementDeleteDynamicKey+0x5c>
        return SECURE_ELEMENT_ERROR;
 8031816:	2606      	movs	r6, #6
 8031818:	e7d2      	b.n	80317c0 <SecureElementDeleteDynamicKey+0x5c>
        return SECURE_ELEMENT_ERROR;
 803181a:	2606      	movs	r6, #6
 803181c:	e7d0      	b.n	80317c0 <SecureElementDeleteDynamicKey+0x5c>
 803181e:	46c0      	nop			; (mov r8, r8)
 8031820:	444e524c 	.word	0x444e524c

08031824 <SecureElementSetObjHandler>:

SecureElementStatus_t SecureElementSetObjHandler( KeyIdentifier_t keyID, uint32_t keyIndex )
{
 8031824:	b530      	push	{r4, r5, lr}
#if (LORAWAN_KMS == 0)
    return SECURE_ELEMENT_ERROR;
#else /* LORAWAN_KMS == 1 */
    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )
 8031826:	2300      	movs	r3, #0
 8031828:	2b0b      	cmp	r3, #11
 803182a:	d80c      	bhi.n	8031846 <SecureElementSetObjHandler+0x22>
    {
        if( KeyList[i].KeyID == keyID )
 803182c:	00da      	lsls	r2, r3, #3
 803182e:	4c07      	ldr	r4, [pc, #28]	; (803184c <SecureElementSetObjHandler+0x28>)
 8031830:	5d12      	ldrb	r2, [r2, r4]
 8031832:	4282      	cmp	r2, r0
 8031834:	d002      	beq.n	803183c <SecureElementSetObjHandler+0x18>
    for( uint8_t i = 0; i < NUM_OF_KEYS; i++ )
 8031836:	3301      	adds	r3, #1
 8031838:	b2db      	uxtb	r3, r3
 803183a:	e7f5      	b.n	8031828 <SecureElementSetObjHandler+0x4>
        {
            KeyList[i].Object_Index = ( CK_OBJECT_HANDLE ) keyIndex;
 803183c:	00dd      	lsls	r5, r3, #3
 803183e:	1965      	adds	r5, r4, r5
 8031840:	6069      	str	r1, [r5, #4]
            return SECURE_ELEMENT_SUCCESS;
 8031842:	2000      	movs	r0, #0
 8031844:	e000      	b.n	8031848 <SecureElementSetObjHandler+0x24>
        }
    }
    return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8031846:	2003      	movs	r0, #3
#endif /* LORAWAN_KMS */
}
 8031848:	bd30      	pop	{r4, r5, pc}
 803184a:	46c0      	nop			; (mov r8, r8)
 803184c:	2000b0d4 	.word	0x2000b0d4

08031850 <SecureElementSetID>:
    return retval;
#endif /* LORAWAN_KMS */
}

SecureElementStatus_t SecureElementSetID( SecureElementNvmDevJoinAddrKey_t *KMSKeyBlob )
{
 8031850:	b530      	push	{r4, r5, lr}
 8031852:	b09f      	sub	sp, #124	; 0x7c
    CK_RV rv;
    CK_SESSION_HANDLE session;
    KeyIdentifier_t keyID = DEV_JOIN_EUI_ADDR_KEY;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;  /* Read ONLY session */
    CK_OBJECT_HANDLE key_handle;
    CK_ULONG template_class = CKO_SECRET_KEY;
 8031854:	2304      	movs	r3, #4
 8031856:	931b      	str	r3, [sp, #108]	; 0x6c
    CK_ULONG template_type = CKK_AES;
 8031858:	331b      	adds	r3, #27
 803185a:	931a      	str	r3, [sp, #104]	; 0x68
    CK_ULONG template_true = CK_TRUE;
 803185c:	2101      	movs	r1, #1
 803185e:	9119      	str	r1, [sp, #100]	; 0x64
    uint8_t *buf = ( uint8_t * )KMSKeyBlob;
    uint32_t buf_ui32[] =
    {
        GET_UINT32_BE( buf, 0 ),
 8031860:	7803      	ldrb	r3, [r0, #0]
 8031862:	061b      	lsls	r3, r3, #24
 8031864:	7842      	ldrb	r2, [r0, #1]
 8031866:	0412      	lsls	r2, r2, #16
 8031868:	4313      	orrs	r3, r2
 803186a:	7882      	ldrb	r2, [r0, #2]
 803186c:	0212      	lsls	r2, r2, #8
 803186e:	4313      	orrs	r3, r2
 8031870:	78c2      	ldrb	r2, [r0, #3]
 8031872:	4313      	orrs	r3, r2
    uint32_t buf_ui32[] =
 8031874:	aa13      	add	r2, sp, #76	; 0x4c
 8031876:	9313      	str	r3, [sp, #76]	; 0x4c
        GET_UINT32_BE( buf, 4 ),
 8031878:	7903      	ldrb	r3, [r0, #4]
 803187a:	061b      	lsls	r3, r3, #24
 803187c:	7944      	ldrb	r4, [r0, #5]
 803187e:	0424      	lsls	r4, r4, #16
 8031880:	4323      	orrs	r3, r4
 8031882:	7984      	ldrb	r4, [r0, #6]
 8031884:	0224      	lsls	r4, r4, #8
 8031886:	4323      	orrs	r3, r4
 8031888:	79c4      	ldrb	r4, [r0, #7]
 803188a:	4323      	orrs	r3, r4
    uint32_t buf_ui32[] =
 803188c:	9314      	str	r3, [sp, #80]	; 0x50
        GET_UINT32_BE( buf, 8 ),
 803188e:	7a03      	ldrb	r3, [r0, #8]
 8031890:	061b      	lsls	r3, r3, #24
 8031892:	7a44      	ldrb	r4, [r0, #9]
 8031894:	0424      	lsls	r4, r4, #16
 8031896:	4323      	orrs	r3, r4
 8031898:	7a84      	ldrb	r4, [r0, #10]
 803189a:	0224      	lsls	r4, r4, #8
 803189c:	4323      	orrs	r3, r4
 803189e:	7ac4      	ldrb	r4, [r0, #11]
 80318a0:	4323      	orrs	r3, r4
    uint32_t buf_ui32[] =
 80318a2:	9315      	str	r3, [sp, #84]	; 0x54
        GET_UINT32_BE( buf, 12 ),
 80318a4:	7b03      	ldrb	r3, [r0, #12]
 80318a6:	061b      	lsls	r3, r3, #24
 80318a8:	7b44      	ldrb	r4, [r0, #13]
 80318aa:	0424      	lsls	r4, r4, #16
 80318ac:	4323      	orrs	r3, r4
 80318ae:	7b84      	ldrb	r4, [r0, #14]
 80318b0:	0224      	lsls	r4, r4, #8
 80318b2:	4323      	orrs	r3, r4
 80318b4:	7bc4      	ldrb	r4, [r0, #15]
 80318b6:	4323      	orrs	r3, r4
    uint32_t buf_ui32[] =
 80318b8:	9316      	str	r3, [sp, #88]	; 0x58
        GET_UINT32_BE( buf, 16 ),
 80318ba:	7c03      	ldrb	r3, [r0, #16]
 80318bc:	061b      	lsls	r3, r3, #24
 80318be:	7c44      	ldrb	r4, [r0, #17]
 80318c0:	0424      	lsls	r4, r4, #16
 80318c2:	4323      	orrs	r3, r4
 80318c4:	7c84      	ldrb	r4, [r0, #18]
 80318c6:	0224      	lsls	r4, r4, #8
 80318c8:	4323      	orrs	r3, r4
 80318ca:	7cc4      	ldrb	r4, [r0, #19]
 80318cc:	4323      	orrs	r3, r4
    uint32_t buf_ui32[] =
 80318ce:	9317      	str	r3, [sp, #92]	; 0x5c
        GET_UINT32_BE( buf, 20 ),
 80318d0:	7d03      	ldrb	r3, [r0, #20]
 80318d2:	061b      	lsls	r3, r3, #24
 80318d4:	7d44      	ldrb	r4, [r0, #21]
 80318d6:	0424      	lsls	r4, r4, #16
 80318d8:	4323      	orrs	r3, r4
 80318da:	7d84      	ldrb	r4, [r0, #22]
 80318dc:	0224      	lsls	r4, r4, #8
 80318de:	4323      	orrs	r3, r4
 80318e0:	7dc4      	ldrb	r4, [r0, #23]
 80318e2:	4323      	orrs	r3, r4
    uint32_t buf_ui32[] =
 80318e4:	9318      	str	r3, [sp, #96]	; 0x60
    };

    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 80318e6:	ab11      	add	r3, sp, #68	; 0x44
 80318e8:	4c2a      	ldr	r4, [pc, #168]	; (8031994 <SecureElementSetID+0x144>)
 80318ea:	9411      	str	r4, [sp, #68]	; 0x44
 80318ec:	2400      	movs	r4, #0
 80318ee:	9412      	str	r4, [sp, #72]	; 0x48
    CK_ATTRIBUTE attribute_template[] =
 80318f0:	9402      	str	r4, [sp, #8]
 80318f2:	ac1b      	add	r4, sp, #108	; 0x6c
 80318f4:	9403      	str	r4, [sp, #12]
 80318f6:	9104      	str	r1, [sp, #16]
 80318f8:	2480      	movs	r4, #128	; 0x80
 80318fa:	0064      	lsls	r4, r4, #1
 80318fc:	9405      	str	r4, [sp, #20]
 80318fe:	ac1a      	add	r4, sp, #104	; 0x68
 8031900:	9406      	str	r4, [sp, #24]
 8031902:	9107      	str	r1, [sp, #28]
 8031904:	2411      	movs	r4, #17
 8031906:	9408      	str	r4, [sp, #32]
 8031908:	9209      	str	r2, [sp, #36]	; 0x24
 803190a:	2218      	movs	r2, #24
 803190c:	920a      	str	r2, [sp, #40]	; 0x28
 803190e:	324b      	adds	r2, #75	; 0x4b
 8031910:	32ff      	adds	r2, #255	; 0xff
 8031912:	920b      	str	r2, [sp, #44]	; 0x2c
 8031914:	aa19      	add	r2, sp, #100	; 0x64
 8031916:	920c      	str	r2, [sp, #48]	; 0x30
 8031918:	910d      	str	r1, [sp, #52]	; 0x34
 803191a:	2203      	movs	r2, #3
 803191c:	920e      	str	r2, [sp, #56]	; 0x38
 803191e:	930f      	str	r3, [sp, #60]	; 0x3c
 8031920:	2308      	movs	r3, #8
 8031922:	9310      	str	r3, [sp, #64]	; 0x40
        { CKA_VALUE, ( CK_VOID_PTR ) buf_ui32,         sizeof( buf_ui32 )      },
        { CKA_EXTRACTABLE, ( CK_VOID_PTR ) &template_true,   sizeof( CK_BBOOL )      },
        { CKA_LABEL, ( CK_VOID_PTR ) specific_label,   sizeof( specific_label )},
    };

    if( KMSKeyBlob == NULL )
 8031924:	2800      	cmp	r0, #0
 8031926:	d02c      	beq.n	8031982 <SecureElementSetID+0x132>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    if( SECURE_ELEMENT_SUCCESS != GetKeyIndexByID( keyID, &key_handle ) )
 8031928:	a91c      	add	r1, sp, #112	; 0x70
 803192a:	2002      	movs	r0, #2
 803192c:	f7ff fd52 	bl	80313d4 <GetKeyIndexByID>
 8031930:	2800      	cmp	r0, #0
 8031932:	d128      	bne.n	8031986 <SecureElementSetID+0x136>
    {
        return SECURE_ELEMENT_ERROR;
    }

    if( SECURE_ELEMENT_SUCCESS != SecureElementDeleteDynamicKey( keyID, &specific_label[1] ) )
 8031934:	a912      	add	r1, sp, #72	; 0x48
 8031936:	3002      	adds	r0, #2
 8031938:	f7ff ff14 	bl	8031764 <SecureElementDeleteDynamicKey>
 803193c:	2800      	cmp	r0, #0
 803193e:	d126      	bne.n	803198e <SecureElementSetID+0x13e>
    {
        return SECURE_ELEMENT_ERROR;
    }

    /* Open session with KMS */
    rv = C_OpenSession( 0, session_flags, NULL, 0, &session );
 8031940:	ab1d      	add	r3, sp, #116	; 0x74
 8031942:	9300      	str	r3, [sp, #0]
 8031944:	2300      	movs	r3, #0
 8031946:	2200      	movs	r2, #0
 8031948:	2104      	movs	r1, #4
 803194a:	f7f5 fd81 	bl	8027450 <KMS_OpenSession>
 803194e:	1e05      	subs	r5, r0, #0

    /* Get key to display */
    if( rv == CKR_OK )
 8031950:	d009      	beq.n	8031966 <SecureElementSetID+0x116>
    {
        rv = C_CreateObject( session, attribute_template, GET_NB_ATTRIBUTE( attribute_template ),
                             &key_handle );
    }

    if( rv == CKR_OK )
 8031952:	2d00      	cmp	r5, #0
 8031954:	d00f      	beq.n	8031976 <SecureElementSetID+0x126>
    SecureElementStatus_t retval = SECURE_ELEMENT_ERROR;
 8031956:	2406      	movs	r4, #6
    {
        retval = SecureElementSetObjHandler( keyID, key_handle );
    }

    /* Close sessions */
    ( void )C_CloseSession( session );
 8031958:	981d      	ldr	r0, [sp, #116]	; 0x74
 803195a:	f7f5 fdbb 	bl	80274d4 <KMS_CloseSession>

    if( rv != CKR_OK )
 803195e:	2d00      	cmp	r5, #0
 8031960:	d012      	beq.n	8031988 <SecureElementSetID+0x138>
    {
        retval = SECURE_ELEMENT_ERROR;
 8031962:	2406      	movs	r4, #6
 8031964:	e010      	b.n	8031988 <SecureElementSetID+0x138>
        rv = C_CreateObject( session, attribute_template, GET_NB_ATTRIBUTE( attribute_template ),
 8031966:	ab1c      	add	r3, sp, #112	; 0x70
 8031968:	2205      	movs	r2, #5
 803196a:	a902      	add	r1, sp, #8
 803196c:	981d      	ldr	r0, [sp, #116]	; 0x74
 803196e:	f7f4 ffb1 	bl	80268d4 <KMS_CreateObject>
 8031972:	0005      	movs	r5, r0
 8031974:	e7ed      	b.n	8031952 <SecureElementSetID+0x102>
        retval = SecureElementSetObjHandler( keyID, key_handle );
 8031976:	991c      	ldr	r1, [sp, #112]	; 0x70
 8031978:	2002      	movs	r0, #2
 803197a:	f7ff ff53 	bl	8031824 <SecureElementSetObjHandler>
 803197e:	0004      	movs	r4, r0
 8031980:	e7ea      	b.n	8031958 <SecureElementSetID+0x108>
        return SECURE_ELEMENT_ERROR_NPE;
 8031982:	2402      	movs	r4, #2
 8031984:	e000      	b.n	8031988 <SecureElementSetID+0x138>
        return SECURE_ELEMENT_ERROR;
 8031986:	2406      	movs	r4, #6
    }
    return retval;
#endif /* LORAWAN_KMS */
}
 8031988:	0020      	movs	r0, r4
 803198a:	b01f      	add	sp, #124	; 0x7c
 803198c:	bd30      	pop	{r4, r5, pc}
        return SECURE_ELEMENT_ERROR;
 803198e:	2406      	movs	r4, #6
 8031990:	e7fa      	b.n	8031988 <SecureElementSetID+0x138>
 8031992:	46c0      	nop			; (mov r8, r8)
 8031994:	444e524c 	.word	0x444e524c

08031998 <SecureElementComputeAesCmac>:

SecureElementStatus_t SecureElementComputeAesCmac( uint8_t *micBxBuffer, uint8_t *buffer, uint32_t size,
                                                   KeyIdentifier_t keyID, uint32_t *cmac )
{
 8031998:	b510      	push	{r4, lr}
 803199a:	b082      	sub	sp, #8
    if( keyID >= MC_KE_KEY )
 803199c:	2b0b      	cmp	r3, #11
 803199e:	d805      	bhi.n	80319ac <SecureElementComputeAesCmac+0x14>
    {
        /* Never accept multicast key identifier for cmac computation */
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
    }

    return ComputeCmac( micBxBuffer, buffer, size, keyID, cmac );
 80319a0:	9c04      	ldr	r4, [sp, #16]
 80319a2:	9400      	str	r4, [sp, #0]
 80319a4:	f7ff fd50 	bl	8031448 <ComputeCmac>
}
 80319a8:	b002      	add	sp, #8
 80319aa:	bd10      	pop	{r4, pc}
        return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 80319ac:	2003      	movs	r0, #3
 80319ae:	e7fb      	b.n	80319a8 <SecureElementComputeAesCmac+0x10>

080319b0 <SecureElementVerifyAesCmac>:

SecureElementStatus_t SecureElementVerifyAesCmac( uint8_t *buffer, uint32_t size, uint32_t expectedCmac,
                                                  KeyIdentifier_t keyID )
{
 80319b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80319b2:	b08b      	sub	sp, #44	; 0x2c
 80319b4:	0005      	movs	r5, r0
 80319b6:	000e      	movs	r6, r1
 80319b8:	9203      	str	r2, [sp, #12]
 80319ba:	0018      	movs	r0, r3
    if( buffer == NULL )
 80319bc:	2d00      	cmp	r5, #0
 80319be:	d036      	beq.n	8031a2e <SecureElementVerifyAesCmac+0x7e>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    /* AES CMAC Authentication variables */
    CK_MECHANISM aes_cmac_mechanism = { CKM_AES_CMAC, ( CK_VOID_PTR )NULL, 0 };
 80319c0:	4b1c      	ldr	r3, [pc, #112]	; (8031a34 <SecureElementVerifyAesCmac+0x84>)
 80319c2:	9305      	str	r3, [sp, #20]
 80319c4:	2300      	movs	r3, #0
 80319c6:	9306      	str	r3, [sp, #24]
 80319c8:	9307      	str	r3, [sp, #28]

    retval = GetKeyIndexByID( keyID, &object_handle );
 80319ca:	a908      	add	r1, sp, #32
 80319cc:	f7ff fd02 	bl	80313d4 <GetKeyIndexByID>
 80319d0:	1e04      	subs	r4, r0, #0
    if( retval != SECURE_ELEMENT_SUCCESS )
 80319d2:	d002      	beq.n	80319da <SecureElementVerifyAesCmac+0x2a>
    }

#endif /* LORAWAN_KMS */

    return retval;
}
 80319d4:	0020      	movs	r0, r4
 80319d6:	b00b      	add	sp, #44	; 0x2c
 80319d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    rv = C_OpenSession( 0,    session_flags, NULL, 0, &session );
 80319da:	ab09      	add	r3, sp, #36	; 0x24
 80319dc:	9300      	str	r3, [sp, #0]
 80319de:	2300      	movs	r3, #0
 80319e0:	2200      	movs	r2, #0
 80319e2:	2104      	movs	r1, #4
 80319e4:	2000      	movs	r0, #0
 80319e6:	f7f5 fd33 	bl	8027450 <KMS_OpenSession>
 80319ea:	1e07      	subs	r7, r0, #0
    if( rv == CKR_OK )
 80319ec:	d008      	beq.n	8031a00 <SecureElementVerifyAesCmac+0x50>
    if( rv == CKR_OK )
 80319ee:	2f00      	cmp	r7, #0
 80319f0:	d00d      	beq.n	8031a0e <SecureElementVerifyAesCmac+0x5e>
    ( void )C_CloseSession( session );
 80319f2:	9809      	ldr	r0, [sp, #36]	; 0x24
 80319f4:	f7f5 fd6e 	bl	80274d4 <KMS_CloseSession>
    if( rv != CKR_OK )
 80319f8:	2f00      	cmp	r7, #0
 80319fa:	d0eb      	beq.n	80319d4 <SecureElementVerifyAesCmac+0x24>
        retval = SECURE_ELEMENT_ERROR;
 80319fc:	2406      	movs	r4, #6
 80319fe:	e7e9      	b.n	80319d4 <SecureElementVerifyAesCmac+0x24>
        rv = C_VerifyInit( session, &aes_cmac_mechanism, object_handle );
 8031a00:	9a08      	ldr	r2, [sp, #32]
 8031a02:	a905      	add	r1, sp, #20
 8031a04:	9809      	ldr	r0, [sp, #36]	; 0x24
 8031a06:	f7f7 fa31 	bl	8028e6c <KMS_VerifyInit>
 8031a0a:	0007      	movs	r7, r0
 8031a0c:	e7ef      	b.n	80319ee <SecureElementVerifyAesCmac+0x3e>
        memcpy1( input_align_combined_buf, buffer, size );
 8031a0e:	b2b2      	uxth	r2, r6
 8031a10:	4f09      	ldr	r7, [pc, #36]	; (8031a38 <SecureElementVerifyAesCmac+0x88>)
 8031a12:	0029      	movs	r1, r5
 8031a14:	0038      	movs	r0, r7
 8031a16:	f000 fb74 	bl	8032102 <memcpy1>
        rv = C_Verify( session, ( CK_BYTE_PTR )input_align_combined_buf, size, ( CK_BYTE_PTR )&expectedCmac, 4 );
 8031a1a:	2304      	movs	r3, #4
 8031a1c:	9300      	str	r3, [sp, #0]
 8031a1e:	ab03      	add	r3, sp, #12
 8031a20:	0032      	movs	r2, r6
 8031a22:	0039      	movs	r1, r7
 8031a24:	9809      	ldr	r0, [sp, #36]	; 0x24
 8031a26:	f7f7 fa33 	bl	8028e90 <KMS_Verify>
 8031a2a:	0007      	movs	r7, r0
 8031a2c:	e7e1      	b.n	80319f2 <SecureElementVerifyAesCmac+0x42>
        return SECURE_ELEMENT_ERROR_NPE;
 8031a2e:	2402      	movs	r4, #2
 8031a30:	e7d0      	b.n	80319d4 <SecureElementVerifyAesCmac+0x24>
 8031a32:	46c0      	nop			; (mov r8, r8)
 8031a34:	0000108a 	.word	0x0000108a
 8031a38:	2000c32c 	.word	0x2000c32c

08031a3c <SecureElementAesEncrypt>:

SecureElementStatus_t SecureElementAesEncrypt( uint8_t *buffer, uint32_t size, KeyIdentifier_t keyID,
                                               uint8_t *encBuffer )
{
 8031a3c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8031a3e:	46ce      	mov	lr, r9
 8031a40:	4647      	mov	r7, r8
 8031a42:	b580      	push	{r7, lr}
 8031a44:	b091      	sub	sp, #68	; 0x44
 8031a46:	0004      	movs	r4, r0
 8031a48:	000e      	movs	r6, r1
 8031a4a:	9203      	str	r2, [sp, #12]
 8031a4c:	001d      	movs	r5, r3
    if( ( buffer == NULL ) || ( encBuffer == NULL ) )
 8031a4e:	2800      	cmp	r0, #0
 8031a50:	d05b      	beq.n	8031b0a <SecureElementAesEncrypt+0xce>
 8031a52:	2b00      	cmp	r3, #0
 8031a54:	d05b      	beq.n	8031b0e <SecureElementAesEncrypt+0xd2>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    /* Check if the size is divisible by 16 */
    if( ( size % 16 ) != 0 )
 8031a56:	070b      	lsls	r3, r1, #28
 8031a58:	d15b      	bne.n	8031b12 <SecureElementAesEncrypt+0xd6>
    }
#else /* LORAWAN_KMS == 1 */
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;    /* Read ONLY session */
    uint32_t encrypted_length = 0;
 8031a5a:	2700      	movs	r7, #0
 8031a5c:	970e      	str	r7, [sp, #56]	; 0x38
    CK_OBJECT_HANDLE object_handle;
    uint8_t dummy_tag[SE_KEY_SIZE] = {0};
 8031a5e:	9709      	str	r7, [sp, #36]	; 0x24
 8031a60:	220c      	movs	r2, #12
 8031a62:	2100      	movs	r1, #0
 8031a64:	a80a      	add	r0, sp, #40	; 0x28
 8031a66:	f003 f866 	bl	8034b36 <memset>
    uint32_t dummy_tag_length = 0;
 8031a6a:	9708      	str	r7, [sp, #32]

    CK_MECHANISM aes_ecb_mechanism = { CKM_AES_ECB, ( CK_VOID_PTR * ) NULL, 0 };
 8031a6c:	4b2c      	ldr	r3, [pc, #176]	; (8031b20 <SecureElementAesEncrypt+0xe4>)
 8031a6e:	9305      	str	r3, [sp, #20]
 8031a70:	9706      	str	r7, [sp, #24]
 8031a72:	9707      	str	r7, [sp, #28]

    SecureElementStatus_t retval = GetKeyIndexByID( keyID, &object_handle );
 8031a74:	a90d      	add	r1, sp, #52	; 0x34
 8031a76:	9803      	ldr	r0, [sp, #12]
 8031a78:	f7ff fcac 	bl	80313d4 <GetKeyIndexByID>
 8031a7c:	1e07      	subs	r7, r0, #0
    if( retval != SECURE_ELEMENT_SUCCESS )
 8031a7e:	d149      	bne.n	8031b14 <SecureElementAesEncrypt+0xd8>
    {
        return retval;
    }

    /* Open session with KMS */
    rv = C_OpenSession( 0,    session_flags, NULL, 0, &session );
 8031a80:	ab0f      	add	r3, sp, #60	; 0x3c
 8031a82:	9300      	str	r3, [sp, #0]
 8031a84:	2300      	movs	r3, #0
 8031a86:	2200      	movs	r2, #0
 8031a88:	2104      	movs	r1, #4
 8031a8a:	2000      	movs	r0, #0
 8031a8c:	f7f5 fce0 	bl	8027450 <KMS_OpenSession>
 8031a90:	4680      	mov	r8, r0

    /* Configure session to encrypt message in AES ECB with settings included into the mechanism */
    if( rv == CKR_OK )
 8031a92:	2800      	cmp	r0, #0
 8031a94:	d00d      	beq.n	8031ab2 <SecureElementAesEncrypt+0x76>
    {
        rv = C_EncryptInit( session, &aes_ecb_mechanism, object_handle );
    }

    /* Encrypt clear message */
    if( rv == CKR_OK )
 8031a96:	4643      	mov	r3, r8
 8031a98:	2b00      	cmp	r3, #0
 8031a9a:	d011      	beq.n	8031ac0 <SecureElementAesEncrypt+0x84>
                              output_align, ( CK_ULONG_PTR )&encrypted_length );
        memcpy1( encBuffer, output_align, size );
    }

    /* In this case C_EncryptFinal is just called to Free the Alloc mem */
    if( rv == CKR_OK )
 8031a9c:	4643      	mov	r3, r8
 8031a9e:	2b00      	cmp	r3, #0
 8031aa0:	d02a      	beq.n	8031af8 <SecureElementAesEncrypt+0xbc>
        dummy_tag_length = sizeof( tag );
        rv = C_EncryptFinal( session, &dummy_tag[0], ( CK_ULONG_PTR )&dummy_tag_length );
    }

    /* Close session with KMS */
    ( void )C_CloseSession( session );
 8031aa2:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8031aa4:	f7f5 fd16 	bl	80274d4 <KMS_CloseSession>

    if( rv != CKR_OK )
 8031aa8:	4643      	mov	r3, r8
 8031aaa:	2b00      	cmp	r3, #0
 8031aac:	d032      	beq.n	8031b14 <SecureElementAesEncrypt+0xd8>
    {
        retval = SECURE_ELEMENT_ERROR;
 8031aae:	2706      	movs	r7, #6
 8031ab0:	e030      	b.n	8031b14 <SecureElementAesEncrypt+0xd8>
        rv = C_EncryptInit( session, &aes_ecb_mechanism, object_handle );
 8031ab2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8031ab4:	a905      	add	r1, sp, #20
 8031ab6:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8031ab8:	f7f5 fb24 	bl	8027104 <KMS_EncryptInit>
 8031abc:	4680      	mov	r8, r0
 8031abe:	e7ea      	b.n	8031a96 <SecureElementAesEncrypt+0x5a>
        memcpy1( input_align_combined_buf, buffer, size );
 8031ac0:	b2b3      	uxth	r3, r6
 8031ac2:	4699      	mov	r9, r3
 8031ac4:	4b17      	ldr	r3, [pc, #92]	; (8031b24 <SecureElementAesEncrypt+0xe8>)
 8031ac6:	4698      	mov	r8, r3
 8031ac8:	464a      	mov	r2, r9
 8031aca:	0021      	movs	r1, r4
 8031acc:	0018      	movs	r0, r3
 8031ace:	f000 fb18 	bl	8032102 <memcpy1>
        encrypted_length = sizeof( output_align );
 8031ad2:	2387      	movs	r3, #135	; 0x87
 8031ad4:	005b      	lsls	r3, r3, #1
 8031ad6:	930e      	str	r3, [sp, #56]	; 0x38
        rv = C_EncryptUpdate( session, ( CK_BYTE_PTR )input_align_combined_buf, size,
 8031ad8:	4c13      	ldr	r4, [pc, #76]	; (8031b28 <SecureElementAesEncrypt+0xec>)
 8031ada:	ab0e      	add	r3, sp, #56	; 0x38
 8031adc:	9300      	str	r3, [sp, #0]
 8031ade:	0023      	movs	r3, r4
 8031ae0:	0032      	movs	r2, r6
 8031ae2:	4641      	mov	r1, r8
 8031ae4:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8031ae6:	f7f5 fb13 	bl	8027110 <KMS_EncryptUpdate>
 8031aea:	4680      	mov	r8, r0
        memcpy1( encBuffer, output_align, size );
 8031aec:	464a      	mov	r2, r9
 8031aee:	0021      	movs	r1, r4
 8031af0:	0028      	movs	r0, r5
 8031af2:	f000 fb06 	bl	8032102 <memcpy1>
 8031af6:	e7d1      	b.n	8031a9c <SecureElementAesEncrypt+0x60>
        dummy_tag_length = sizeof( tag );
 8031af8:	3310      	adds	r3, #16
 8031afa:	9308      	str	r3, [sp, #32]
        rv = C_EncryptFinal( session, &dummy_tag[0], ( CK_ULONG_PTR )&dummy_tag_length );
 8031afc:	aa08      	add	r2, sp, #32
 8031afe:	a909      	add	r1, sp, #36	; 0x24
 8031b00:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8031b02:	f7f5 fbcd 	bl	80272a0 <KMS_EncryptFinal>
 8031b06:	4680      	mov	r8, r0
 8031b08:	e7cb      	b.n	8031aa2 <SecureElementAesEncrypt+0x66>
        return SECURE_ELEMENT_ERROR_NPE;
 8031b0a:	2702      	movs	r7, #2
 8031b0c:	e002      	b.n	8031b14 <SecureElementAesEncrypt+0xd8>
 8031b0e:	2702      	movs	r7, #2
 8031b10:	e000      	b.n	8031b14 <SecureElementAesEncrypt+0xd8>
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
 8031b12:	2705      	movs	r7, #5
    }
#endif /* LORAWAN_KMS */

    return retval;
}
 8031b14:	0038      	movs	r0, r7
 8031b16:	b011      	add	sp, #68	; 0x44
 8031b18:	bcc0      	pop	{r6, r7}
 8031b1a:	46b9      	mov	r9, r7
 8031b1c:	46b0      	mov	r8, r6
 8031b1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8031b20:	00001081 	.word	0x00001081
 8031b24:	2000c32c 	.word	0x2000c32c
 8031b28:	2000c44c 	.word	0x2000c44c

08031b2c <SecureElementSetKey>:
{
 8031b2c:	b530      	push	{r4, r5, lr}
 8031b2e:	b0a1      	sub	sp, #132	; 0x84
 8031b30:	0005      	movs	r5, r0
 8031b32:	1e0c      	subs	r4, r1, #0
    if( key == NULL )
 8031b34:	d100      	bne.n	8031b38 <SecureElementSetKey+0xc>
 8031b36:	e0bf      	b.n	8031cb8 <SecureElementSetKey+0x18c>
    CK_ULONG template_class = CKO_SECRET_KEY;
 8031b38:	2304      	movs	r3, #4
 8031b3a:	931d      	str	r3, [sp, #116]	; 0x74
    CK_ULONG template_type = CKK_AES;
 8031b3c:	331b      	adds	r3, #27
 8031b3e:	931c      	str	r3, [sp, #112]	; 0x70
    CK_ULONG template_true = CK_TRUE;
 8031b40:	2201      	movs	r2, #1
 8031b42:	921b      	str	r2, [sp, #108]	; 0x6c
        GET_UINT32_BE( key, 0 ),
 8031b44:	780b      	ldrb	r3, [r1, #0]
 8031b46:	061b      	lsls	r3, r3, #24
 8031b48:	7849      	ldrb	r1, [r1, #1]
 8031b4a:	0409      	lsls	r1, r1, #16
 8031b4c:	430b      	orrs	r3, r1
 8031b4e:	78a1      	ldrb	r1, [r4, #2]
 8031b50:	0209      	lsls	r1, r1, #8
 8031b52:	430b      	orrs	r3, r1
 8031b54:	78e1      	ldrb	r1, [r4, #3]
 8031b56:	430b      	orrs	r3, r1
    uint32_t key_ui32[] =
 8031b58:	a917      	add	r1, sp, #92	; 0x5c
 8031b5a:	9317      	str	r3, [sp, #92]	; 0x5c
        GET_UINT32_BE( key, 4 ),
 8031b5c:	7923      	ldrb	r3, [r4, #4]
 8031b5e:	061b      	lsls	r3, r3, #24
 8031b60:	7960      	ldrb	r0, [r4, #5]
 8031b62:	0400      	lsls	r0, r0, #16
 8031b64:	4303      	orrs	r3, r0
 8031b66:	79a0      	ldrb	r0, [r4, #6]
 8031b68:	0200      	lsls	r0, r0, #8
 8031b6a:	4303      	orrs	r3, r0
 8031b6c:	79e0      	ldrb	r0, [r4, #7]
 8031b6e:	4303      	orrs	r3, r0
    uint32_t key_ui32[] =
 8031b70:	9318      	str	r3, [sp, #96]	; 0x60
        GET_UINT32_BE( key, 8 ),
 8031b72:	7a23      	ldrb	r3, [r4, #8]
 8031b74:	061b      	lsls	r3, r3, #24
 8031b76:	7a60      	ldrb	r0, [r4, #9]
 8031b78:	0400      	lsls	r0, r0, #16
 8031b7a:	4303      	orrs	r3, r0
 8031b7c:	7aa0      	ldrb	r0, [r4, #10]
 8031b7e:	0200      	lsls	r0, r0, #8
 8031b80:	4303      	orrs	r3, r0
 8031b82:	7ae0      	ldrb	r0, [r4, #11]
 8031b84:	4303      	orrs	r3, r0
    uint32_t key_ui32[] =
 8031b86:	9319      	str	r3, [sp, #100]	; 0x64
        GET_UINT32_BE( key, 12 ),
 8031b88:	7b23      	ldrb	r3, [r4, #12]
 8031b8a:	061b      	lsls	r3, r3, #24
 8031b8c:	7b60      	ldrb	r0, [r4, #13]
 8031b8e:	0400      	lsls	r0, r0, #16
 8031b90:	4303      	orrs	r3, r0
 8031b92:	7ba0      	ldrb	r0, [r4, #14]
 8031b94:	0200      	lsls	r0, r0, #8
 8031b96:	4303      	orrs	r3, r0
 8031b98:	7be0      	ldrb	r0, [r4, #15]
 8031b9a:	4303      	orrs	r3, r0
    uint32_t key_ui32[] =
 8031b9c:	931a      	str	r3, [sp, #104]	; 0x68
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8031b9e:	ab15      	add	r3, sp, #84	; 0x54
 8031ba0:	4849      	ldr	r0, [pc, #292]	; (8031cc8 <SecureElementSetKey+0x19c>)
 8031ba2:	9015      	str	r0, [sp, #84]	; 0x54
 8031ba4:	2000      	movs	r0, #0
 8031ba6:	9016      	str	r0, [sp, #88]	; 0x58
    CK_ATTRIBUTE key_attribute_template[] =
 8031ba8:	9006      	str	r0, [sp, #24]
 8031baa:	a81d      	add	r0, sp, #116	; 0x74
 8031bac:	9007      	str	r0, [sp, #28]
 8031bae:	9208      	str	r2, [sp, #32]
 8031bb0:	2080      	movs	r0, #128	; 0x80
 8031bb2:	0040      	lsls	r0, r0, #1
 8031bb4:	9009      	str	r0, [sp, #36]	; 0x24
 8031bb6:	a81c      	add	r0, sp, #112	; 0x70
 8031bb8:	900a      	str	r0, [sp, #40]	; 0x28
 8031bba:	920b      	str	r2, [sp, #44]	; 0x2c
 8031bbc:	2011      	movs	r0, #17
 8031bbe:	900c      	str	r0, [sp, #48]	; 0x30
 8031bc0:	910d      	str	r1, [sp, #52]	; 0x34
 8031bc2:	2110      	movs	r1, #16
 8031bc4:	910e      	str	r1, [sp, #56]	; 0x38
 8031bc6:	3153      	adds	r1, #83	; 0x53
 8031bc8:	31ff      	adds	r1, #255	; 0xff
 8031bca:	910f      	str	r1, [sp, #60]	; 0x3c
 8031bcc:	a91b      	add	r1, sp, #108	; 0x6c
 8031bce:	9110      	str	r1, [sp, #64]	; 0x40
 8031bd0:	9211      	str	r2, [sp, #68]	; 0x44
 8031bd2:	3202      	adds	r2, #2
 8031bd4:	9212      	str	r2, [sp, #72]	; 0x48
 8031bd6:	9313      	str	r3, [sp, #76]	; 0x4c
 8031bd8:	2308      	movs	r3, #8
 8031bda:	9314      	str	r3, [sp, #80]	; 0x50
    if( keyID == MC_KEY_0 )
 8031bdc:	2d0d      	cmp	r5, #13
 8031bde:	d01e      	beq.n	8031c1e <SecureElementSetKey+0xf2>
    if( SECURE_ELEMENT_SUCCESS != GetKeyIndexByID( keyID, &key_handle ) )
 8031be0:	a91e      	add	r1, sp, #120	; 0x78
 8031be2:	0028      	movs	r0, r5
 8031be4:	f7ff fbf6 	bl	80313d4 <GetKeyIndexByID>
 8031be8:	2800      	cmp	r0, #0
 8031bea:	d167      	bne.n	8031cbc <SecureElementSetKey+0x190>
    if( SECURE_ELEMENT_SUCCESS != SecureElementDeleteDynamicKey( keyID, &specific_label[1] ) )
 8031bec:	a916      	add	r1, sp, #88	; 0x58
 8031bee:	0028      	movs	r0, r5
 8031bf0:	f7ff fdb8 	bl	8031764 <SecureElementDeleteDynamicKey>
 8031bf4:	2800      	cmp	r0, #0
 8031bf6:	d165      	bne.n	8031cc4 <SecureElementSetKey+0x198>
    rv = C_OpenSession( 0, session_flags, NULL, 0, &session );
 8031bf8:	ab1f      	add	r3, sp, #124	; 0x7c
 8031bfa:	9300      	str	r3, [sp, #0]
 8031bfc:	2300      	movs	r3, #0
 8031bfe:	2200      	movs	r2, #0
 8031c00:	2104      	movs	r1, #4
 8031c02:	f7f5 fc25 	bl	8027450 <KMS_OpenSession>
 8031c06:	1e04      	subs	r4, r0, #0
    if( rv == CKR_OK )
 8031c08:	d048      	beq.n	8031c9c <SecureElementSetKey+0x170>
    if( rv == CKR_OK )
 8031c0a:	2c00      	cmp	r4, #0
 8031c0c:	d04e      	beq.n	8031cac <SecureElementSetKey+0x180>
    SecureElementStatus_t retval = SECURE_ELEMENT_ERROR;
 8031c0e:	2506      	movs	r5, #6
    ( void )C_CloseSession( session );
 8031c10:	981f      	ldr	r0, [sp, #124]	; 0x7c
 8031c12:	f7f5 fc5f 	bl	80274d4 <KMS_CloseSession>
    if( rv != CKR_OK )
 8031c16:	2c00      	cmp	r4, #0
 8031c18:	d051      	beq.n	8031cbe <SecureElementSetKey+0x192>
        retval = SECURE_ELEMENT_ERROR;
 8031c1a:	2506      	movs	r5, #6
 8031c1c:	e04f      	b.n	8031cbe <SecureElementSetKey+0x192>
        uint8_t decryptedKey[SE_KEY_SIZE] = { 0 };
 8031c1e:	2300      	movs	r3, #0
 8031c20:	9302      	str	r3, [sp, #8]
 8031c22:	3209      	adds	r2, #9
 8031c24:	2100      	movs	r1, #0
 8031c26:	a803      	add	r0, sp, #12
 8031c28:	f002 ff85 	bl	8034b36 <memset>
        if( SECURE_ELEMENT_SUCCESS != SecureElementAesEncrypt( key, SE_KEY_SIZE, MC_KE_KEY, decryptedKey ) )
 8031c2c:	ab02      	add	r3, sp, #8
 8031c2e:	220c      	movs	r2, #12
 8031c30:	2110      	movs	r1, #16
 8031c32:	0020      	movs	r0, r4
 8031c34:	f7ff ff02 	bl	8031a3c <SecureElementAesEncrypt>
 8031c38:	2800      	cmp	r0, #0
 8031c3a:	d12d      	bne.n	8031c98 <SecureElementSetKey+0x16c>
        key_ui32[0] = GET_UINT32_BE( decryptedKey, 0 );
 8031c3c:	ab02      	add	r3, sp, #8
 8031c3e:	781a      	ldrb	r2, [r3, #0]
 8031c40:	0612      	lsls	r2, r2, #24
 8031c42:	7859      	ldrb	r1, [r3, #1]
 8031c44:	0409      	lsls	r1, r1, #16
 8031c46:	430a      	orrs	r2, r1
 8031c48:	7899      	ldrb	r1, [r3, #2]
 8031c4a:	0209      	lsls	r1, r1, #8
 8031c4c:	430a      	orrs	r2, r1
 8031c4e:	78d9      	ldrb	r1, [r3, #3]
 8031c50:	430a      	orrs	r2, r1
 8031c52:	9217      	str	r2, [sp, #92]	; 0x5c
        key_ui32[1] = GET_UINT32_BE( decryptedKey, 4 );
 8031c54:	791a      	ldrb	r2, [r3, #4]
 8031c56:	0612      	lsls	r2, r2, #24
 8031c58:	7959      	ldrb	r1, [r3, #5]
 8031c5a:	0409      	lsls	r1, r1, #16
 8031c5c:	430a      	orrs	r2, r1
 8031c5e:	7999      	ldrb	r1, [r3, #6]
 8031c60:	0209      	lsls	r1, r1, #8
 8031c62:	430a      	orrs	r2, r1
 8031c64:	79d9      	ldrb	r1, [r3, #7]
 8031c66:	430a      	orrs	r2, r1
 8031c68:	9218      	str	r2, [sp, #96]	; 0x60
        key_ui32[2] = GET_UINT32_BE( decryptedKey, 8 );
 8031c6a:	7a1a      	ldrb	r2, [r3, #8]
 8031c6c:	0612      	lsls	r2, r2, #24
 8031c6e:	7a59      	ldrb	r1, [r3, #9]
 8031c70:	0409      	lsls	r1, r1, #16
 8031c72:	430a      	orrs	r2, r1
 8031c74:	7a99      	ldrb	r1, [r3, #10]
 8031c76:	0209      	lsls	r1, r1, #8
 8031c78:	430a      	orrs	r2, r1
 8031c7a:	7ad9      	ldrb	r1, [r3, #11]
 8031c7c:	430a      	orrs	r2, r1
 8031c7e:	9219      	str	r2, [sp, #100]	; 0x64
        key_ui32[3] = GET_UINT32_BE( decryptedKey, 12 );
 8031c80:	7b1a      	ldrb	r2, [r3, #12]
 8031c82:	0612      	lsls	r2, r2, #24
 8031c84:	7b59      	ldrb	r1, [r3, #13]
 8031c86:	0409      	lsls	r1, r1, #16
 8031c88:	430a      	orrs	r2, r1
 8031c8a:	7b99      	ldrb	r1, [r3, #14]
 8031c8c:	0209      	lsls	r1, r1, #8
 8031c8e:	430a      	orrs	r2, r1
 8031c90:	7bdb      	ldrb	r3, [r3, #15]
 8031c92:	4313      	orrs	r3, r2
 8031c94:	931a      	str	r3, [sp, #104]	; 0x68
 8031c96:	e7a3      	b.n	8031be0 <SecureElementSetKey+0xb4>
            return SECURE_ELEMENT_ERROR;
 8031c98:	3d07      	subs	r5, #7
 8031c9a:	e010      	b.n	8031cbe <SecureElementSetKey+0x192>
        rv = C_CreateObject( session, key_attribute_template, GET_NB_ATTRIBUTE( key_attribute_template ),
 8031c9c:	ab1e      	add	r3, sp, #120	; 0x78
 8031c9e:	2205      	movs	r2, #5
 8031ca0:	a906      	add	r1, sp, #24
 8031ca2:	981f      	ldr	r0, [sp, #124]	; 0x7c
 8031ca4:	f7f4 fe16 	bl	80268d4 <KMS_CreateObject>
 8031ca8:	0004      	movs	r4, r0
 8031caa:	e7ae      	b.n	8031c0a <SecureElementSetKey+0xde>
        retval = SecureElementSetObjHandler( keyID, key_handle );
 8031cac:	991e      	ldr	r1, [sp, #120]	; 0x78
 8031cae:	0028      	movs	r0, r5
 8031cb0:	f7ff fdb8 	bl	8031824 <SecureElementSetObjHandler>
 8031cb4:	0005      	movs	r5, r0
 8031cb6:	e7ab      	b.n	8031c10 <SecureElementSetKey+0xe4>
        return SECURE_ELEMENT_ERROR_NPE;
 8031cb8:	2502      	movs	r5, #2
 8031cba:	e000      	b.n	8031cbe <SecureElementSetKey+0x192>
        return SECURE_ELEMENT_ERROR;
 8031cbc:	2506      	movs	r5, #6
}
 8031cbe:	0028      	movs	r0, r5
 8031cc0:	b021      	add	sp, #132	; 0x84
 8031cc2:	bd30      	pop	{r4, r5, pc}
        return SECURE_ELEMENT_ERROR;
 8031cc4:	2506      	movs	r5, #6
 8031cc6:	e7fa      	b.n	8031cbe <SecureElementSetKey+0x192>
 8031cc8:	444e524c 	.word	0x444e524c

08031ccc <SecureElementDeriveAndStoreKey>:

SecureElementStatus_t SecureElementDeriveAndStoreKey( uint8_t *input, KeyIdentifier_t rootKeyID,
                                                      KeyIdentifier_t targetKeyID )
{
 8031ccc:	b530      	push	{r4, r5, lr}
 8031cce:	b08f      	sub	sp, #60	; 0x3c
 8031cd0:	0003      	movs	r3, r0
 8031cd2:	0008      	movs	r0, r1
 8031cd4:	0014      	movs	r4, r2
    if( input == NULL )
 8031cd6:	2b00      	cmp	r3, #0
 8031cd8:	d048      	beq.n	8031d6c <SecureElementDeriveAndStoreKey+0xa0>
    }

    SecureElementStatus_t retval  = SECURE_ELEMENT_ERROR;

    /* In case of MC_KE_KEY, only McRootKey can be used as root key */
    if( targetKeyID == MC_KE_KEY )
 8031cda:	2a0c      	cmp	r2, #12
 8031cdc:	d101      	bne.n	8031ce2 <SecureElementDeriveAndStoreKey+0x16>
    {
        if( rootKeyID != MC_ROOT_KEY )
 8031cde:	290b      	cmp	r1, #11
 8031ce0:	d146      	bne.n	8031d70 <SecureElementDeriveAndStoreKey+0xa4>
#else /* LORAWAN_KMS == 1 */
    CK_RV rv;
    CK_SESSION_HANDLE session;
    CK_FLAGS session_flags = CKF_SERIAL_SESSION;    /* Read ONLY session */
    /* Key derivation */
    CK_MECHANISM            mech = {CKM_AES_ECB_ENCRYPT_DATA, input, SE_KEY_SIZE};
 8031ce2:	4a28      	ldr	r2, [pc, #160]	; (8031d84 <SecureElementDeriveAndStoreKey+0xb8>)
 8031ce4:	920a      	str	r2, [sp, #40]	; 0x28
 8031ce6:	930b      	str	r3, [sp, #44]	; 0x2c
 8031ce8:	2310      	movs	r3, #16
 8031cea:	930c      	str	r3, [sp, #48]	; 0x30
    CK_OBJECT_HANDLE  derived_object_handle;
    CK_OBJECT_HANDLE    rootkey_object_handle;
    uint32_t specific_label[] = {GlobalTemplateLabel, 0UL};
 8031cec:	ab06      	add	r3, sp, #24
 8031cee:	4a26      	ldr	r2, [pc, #152]	; (8031d88 <SecureElementDeriveAndStoreKey+0xbc>)
 8031cf0:	9206      	str	r2, [sp, #24]
 8031cf2:	2200      	movs	r2, #0
 8031cf4:	9207      	str	r2, [sp, #28]
    CK_ATTRIBUTE DeriveKey_template = {CKA_LABEL, ( CK_VOID_PTR )specific_label, sizeof( specific_label )};
 8031cf6:	3203      	adds	r2, #3
 8031cf8:	9203      	str	r2, [sp, #12]
 8031cfa:	9304      	str	r3, [sp, #16]
 8031cfc:	2308      	movs	r3, #8
 8031cfe:	9305      	str	r3, [sp, #20]

    /* Derive key */
    if( SECURE_ELEMENT_SUCCESS != GetKeyIndexByID( rootKeyID, &rootkey_object_handle ) )
 8031d00:	a908      	add	r1, sp, #32
 8031d02:	f7ff fb67 	bl	80313d4 <GetKeyIndexByID>
 8031d06:	2800      	cmp	r0, #0
 8031d08:	d134      	bne.n	8031d74 <SecureElementDeriveAndStoreKey+0xa8>
    {
        return SECURE_ELEMENT_ERROR;
    }

    if( SECURE_ELEMENT_SUCCESS != GetKeyIndexByID( targetKeyID, &derived_object_handle ) )
 8031d0a:	a909      	add	r1, sp, #36	; 0x24
 8031d0c:	0020      	movs	r0, r4
 8031d0e:	f7ff fb61 	bl	80313d4 <GetKeyIndexByID>
 8031d12:	2800      	cmp	r0, #0
 8031d14:	d132      	bne.n	8031d7c <SecureElementDeriveAndStoreKey+0xb0>
    {
        return SECURE_ELEMENT_ERROR;
    }

    if( SECURE_ELEMENT_SUCCESS != SecureElementDeleteDynamicKey( targetKeyID, &specific_label[1] ) )
 8031d16:	a907      	add	r1, sp, #28
 8031d18:	0020      	movs	r0, r4
 8031d1a:	f7ff fd23 	bl	8031764 <SecureElementDeleteDynamicKey>
 8031d1e:	2800      	cmp	r0, #0
 8031d20:	d12e      	bne.n	8031d80 <SecureElementDeriveAndStoreKey+0xb4>
    {
        return SECURE_ELEMENT_ERROR;
    }

    /* Open session with KMS */
    rv = C_OpenSession( 0,    session_flags, NULL, 0, &session );
 8031d22:	ab0d      	add	r3, sp, #52	; 0x34
 8031d24:	9300      	str	r3, [sp, #0]
 8031d26:	2300      	movs	r3, #0
 8031d28:	2200      	movs	r2, #0
 8031d2a:	2104      	movs	r1, #4
 8031d2c:	f7f5 fb90 	bl	8027450 <KMS_OpenSession>
 8031d30:	1e05      	subs	r5, r0, #0

    /* Derive key with pass phrase */
    if( rv == CKR_OK )
 8031d32:	d009      	beq.n	8031d48 <SecureElementDeriveAndStoreKey+0x7c>
    {
        rv = C_DeriveKey( session, &( mech ), rootkey_object_handle,
                          &DeriveKey_template, GET_NB_ATTRIBUTE( DeriveKey_template ), &derived_object_handle );
    }

    if( rv == CKR_OK )
 8031d34:	2d00      	cmp	r5, #0
 8031d36:	d013      	beq.n	8031d60 <SecureElementDeriveAndStoreKey+0x94>
    SecureElementStatus_t retval  = SECURE_ELEMENT_ERROR;
 8031d38:	2406      	movs	r4, #6
        /* Store Derived Index in table */
        retval = SecureElementSetObjHandler( targetKeyID, derived_object_handle );
    }

    /* Close session with KMS */
    ( void )C_CloseSession( session );
 8031d3a:	980d      	ldr	r0, [sp, #52]	; 0x34
 8031d3c:	f7f5 fbca 	bl	80274d4 <KMS_CloseSession>

    if( rv != CKR_OK )
 8031d40:	2d00      	cmp	r5, #0
 8031d42:	d018      	beq.n	8031d76 <SecureElementDeriveAndStoreKey+0xaa>
    {
        retval = SECURE_ELEMENT_ERROR;
 8031d44:	2406      	movs	r4, #6
 8031d46:	e016      	b.n	8031d76 <SecureElementDeriveAndStoreKey+0xaa>
        rv = C_DeriveKey( session, &( mech ), rootkey_object_handle,
 8031d48:	ab09      	add	r3, sp, #36	; 0x24
 8031d4a:	9301      	str	r3, [sp, #4]
 8031d4c:	2301      	movs	r3, #1
 8031d4e:	9300      	str	r3, [sp, #0]
 8031d50:	ab03      	add	r3, sp, #12
 8031d52:	9a08      	ldr	r2, [sp, #32]
 8031d54:	a90a      	add	r1, sp, #40	; 0x28
 8031d56:	980d      	ldr	r0, [sp, #52]	; 0x34
 8031d58:	f7f5 fbfc 	bl	8027554 <KMS_DeriveKey>
 8031d5c:	0005      	movs	r5, r0
 8031d5e:	e7e9      	b.n	8031d34 <SecureElementDeriveAndStoreKey+0x68>
        retval = SecureElementSetObjHandler( targetKeyID, derived_object_handle );
 8031d60:	9909      	ldr	r1, [sp, #36]	; 0x24
 8031d62:	0020      	movs	r0, r4
 8031d64:	f7ff fd5e 	bl	8031824 <SecureElementSetObjHandler>
 8031d68:	0004      	movs	r4, r0
 8031d6a:	e7e6      	b.n	8031d3a <SecureElementDeriveAndStoreKey+0x6e>
        return SECURE_ELEMENT_ERROR_NPE;
 8031d6c:	2402      	movs	r4, #2
 8031d6e:	e002      	b.n	8031d76 <SecureElementDeriveAndStoreKey+0xaa>
            return SECURE_ELEMENT_ERROR_INVALID_KEY_ID;
 8031d70:	2403      	movs	r4, #3
 8031d72:	e000      	b.n	8031d76 <SecureElementDeriveAndStoreKey+0xaa>
        return SECURE_ELEMENT_ERROR;
 8031d74:	2406      	movs	r4, #6
    }
    return retval;
#endif /* LORAWAN_KMS */
}
 8031d76:	0020      	movs	r0, r4
 8031d78:	b00f      	add	sp, #60	; 0x3c
 8031d7a:	bd30      	pop	{r4, r5, pc}
        return SECURE_ELEMENT_ERROR;
 8031d7c:	2406      	movs	r4, #6
 8031d7e:	e7fa      	b.n	8031d76 <SecureElementDeriveAndStoreKey+0xaa>
        return SECURE_ELEMENT_ERROR;
 8031d80:	2406      	movs	r4, #6
 8031d82:	e7f8      	b.n	8031d76 <SecureElementDeriveAndStoreKey+0xaa>
 8031d84:	00001104 	.word	0x00001104
 8031d88:	444e524c 	.word	0x444e524c

08031d8c <SecureElementProcessJoinAccept>:

SecureElementStatus_t SecureElementProcessJoinAccept( JoinReqIdentifier_t joinReqType, uint8_t *joinEui,
                                                      uint16_t devNonce, uint8_t *encJoinAccept,
                                                      uint8_t encJoinAcceptSize, uint8_t *decJoinAccept,
                                                      uint8_t *versionMinor )
{
 8031d8c:	b570      	push	{r4, r5, r6, lr}
 8031d8e:	001c      	movs	r4, r3
 8031d90:	ab04      	add	r3, sp, #16
 8031d92:	781e      	ldrb	r6, [r3, #0]
 8031d94:	9d05      	ldr	r5, [sp, #20]
    if( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) )
 8031d96:	2c00      	cmp	r4, #0
 8031d98:	d031      	beq.n	8031dfe <SecureElementProcessJoinAccept+0x72>
 8031d9a:	2d00      	cmp	r5, #0
 8031d9c:	d031      	beq.n	8031e02 <SecureElementProcessJoinAccept+0x76>
 8031d9e:	9b06      	ldr	r3, [sp, #24]
 8031da0:	2b00      	cmp	r3, #0
 8031da2:	d030      	beq.n	8031e06 <SecureElementProcessJoinAccept+0x7a>
    {
        return SECURE_ELEMENT_ERROR_NPE;
    }

    /* Check that frame size isn't bigger than a JoinAccept with CFList size */
    if( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE )
 8031da4:	2e21      	cmp	r6, #33	; 0x21
 8031da6:	d830      	bhi.n	8031e0a <SecureElementProcessJoinAccept+0x7e>
    {
        encKeyID = J_S_ENC_KEY;
    }
#endif /* LORAMAC_VERSION */

    memcpy1( decJoinAccept, encJoinAccept, encJoinAcceptSize );
 8031da8:	b2b2      	uxth	r2, r6
 8031daa:	0021      	movs	r1, r4
 8031dac:	0028      	movs	r0, r5
 8031dae:	f000 f9a8 	bl	8032102 <memcpy1>

    /* Decrypt JoinAccept, skip MHDR */
    if( SecureElementAesEncrypt( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE, encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE,
 8031db2:	1e71      	subs	r1, r6, #1
 8031db4:	1c6b      	adds	r3, r5, #1
 8031db6:	1c60      	adds	r0, r4, #1
 8031db8:	2201      	movs	r2, #1
 8031dba:	f7ff fe3f 	bl	8031a3c <SecureElementAesEncrypt>
 8031dbe:	2800      	cmp	r0, #0
 8031dc0:	d125      	bne.n	8031e0e <SecureElementProcessJoinAccept+0x82>
                                 encKeyID, decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS )
    {
        return SECURE_ELEMENT_FAIL_ENCRYPT;
    }

    *versionMinor = ( ( decJoinAccept[11] & 0x80 ) == 0x80 ) ? 1 : 0;
 8031dc2:	7ae9      	ldrb	r1, [r5, #11]
 8031dc4:	09c9      	lsrs	r1, r1, #7
 8031dc6:	9b06      	ldr	r3, [sp, #24]
 8031dc8:	7019      	strb	r1, [r3, #0]

    uint32_t mic = GET_UINT32_LE( decJoinAccept, encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE );
 8031dca:	19ab      	adds	r3, r5, r6
 8031dcc:	1f1a      	subs	r2, r3, #4
 8031dce:	7812      	ldrb	r2, [r2, #0]
 8031dd0:	1ed8      	subs	r0, r3, #3
 8031dd2:	7800      	ldrb	r0, [r0, #0]
 8031dd4:	0200      	lsls	r0, r0, #8
 8031dd6:	4302      	orrs	r2, r0
 8031dd8:	1e98      	subs	r0, r3, #2
 8031dda:	7800      	ldrb	r0, [r0, #0]
 8031ddc:	0400      	lsls	r0, r0, #16
 8031dde:	4302      	orrs	r2, r0
 8031de0:	3b01      	subs	r3, #1
 8031de2:	781b      	ldrb	r3, [r3, #0]
 8031de4:	061b      	lsls	r3, r3, #24
 8031de6:	431a      	orrs	r2, r3
     *        - LoRaWAN 1.0.x : micHeader = [MHDR(1)]
     *        - LoRaWAN 1.1.x : micHeader = [JoinReqType(1), JoinEUI(8), DevNonce(2), MHDR(1)]
     */

    /* Verify mic */
    if( *versionMinor == 0 )
 8031de8:	2900      	cmp	r1, #0
 8031dea:	d112      	bne.n	8031e12 <SecureElementProcessJoinAccept+0x86>
    {
        /* For LoRaWAN 1.0.x
         *   cmac = aes128_cmac(NwkKey, MHDR |  JoinNonce | NetID | DevAddr | DLSettings | RxDelay | CFList |
         *   CFListType)
         */
        if( SecureElementVerifyAesCmac( decJoinAccept, ( encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ), mic, NWK_KEY ) !=
 8031dec:	1f31      	subs	r1, r6, #4
 8031dee:	2301      	movs	r3, #1
 8031df0:	0028      	movs	r0, r5
 8031df2:	f7ff fddd 	bl	80319b0 <SecureElementVerifyAesCmac>
 8031df6:	2800      	cmp	r0, #0
 8031df8:	d008      	beq.n	8031e0c <SecureElementProcessJoinAccept+0x80>
            SECURE_ELEMENT_SUCCESS )
        {
            return SECURE_ELEMENT_FAIL_CMAC;
 8031dfa:	2001      	movs	r0, #1
 8031dfc:	e006      	b.n	8031e0c <SecureElementProcessJoinAccept+0x80>
        return SECURE_ELEMENT_ERROR_NPE;
 8031dfe:	2002      	movs	r0, #2
 8031e00:	e004      	b.n	8031e0c <SecureElementProcessJoinAccept+0x80>
 8031e02:	2002      	movs	r0, #2
 8031e04:	e002      	b.n	8031e0c <SecureElementProcessJoinAccept+0x80>
 8031e06:	2002      	movs	r0, #2
 8031e08:	e000      	b.n	8031e0c <SecureElementProcessJoinAccept+0x80>
        return SECURE_ELEMENT_ERROR_BUF_SIZE;
 8031e0a:	2005      	movs	r0, #5
    {
        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;
    }

    return SECURE_ELEMENT_SUCCESS;
}
 8031e0c:	bd70      	pop	{r4, r5, r6, pc}
        return SECURE_ELEMENT_FAIL_ENCRYPT;
 8031e0e:	2007      	movs	r0, #7
 8031e10:	e7fc      	b.n	8031e0c <SecureElementProcessJoinAccept+0x80>
        return SECURE_ELEMENT_ERROR_INVALID_LORAWAM_SPEC_VERSION;
 8031e12:	2004      	movs	r0, #4
 8031e14:	e7fa      	b.n	8031e0c <SecureElementProcessJoinAccept+0x80>

08031e16 <SecureElementSetDevEui>:
    return SECURE_ELEMENT_SUCCESS;
}
#endif /* LORAMAC_VERSION */

SecureElementStatus_t SecureElementSetDevEui( uint8_t *devEui )
{
 8031e16:	b530      	push	{r4, r5, lr}
 8031e18:	b087      	sub	sp, #28
 8031e1a:	1e05      	subs	r5, r0, #0
    if( devEui == NULL )
 8031e1c:	d019      	beq.n	8031e52 <SecureElementSetDevEui+0x3c>
#else
    SecureElementStatus_t status;
    SecureElementNvmDevJoinAddrKey_t KMSKeyBlob ALIGN( 8 );

    /* recover whole KMSKeyBlob handle */
    status = SecureElementGetKeyByID( DEV_JOIN_EUI_ADDR_KEY, ( uint8_t * )&KMSKeyBlob );
 8031e1e:	4669      	mov	r1, sp
 8031e20:	2002      	movs	r0, #2
 8031e22:	f7ff fbf9 	bl	8031618 <SecureElementGetKeyByID>
 8031e26:	1e04      	subs	r4, r0, #0
    if( ( status == SECURE_ELEMENT_SUCCESS ) && ( memcmp( KMSKeyBlob.DevEui, devEui, SE_EUI_SIZE ) != 0 ) )
 8031e28:	d106      	bne.n	8031e38 <SecureElementSetDevEui+0x22>
 8031e2a:	2208      	movs	r2, #8
 8031e2c:	0029      	movs	r1, r5
 8031e2e:	4668      	mov	r0, sp
 8031e30:	f002 fe6a 	bl	8034b08 <memcmp>
 8031e34:	2800      	cmp	r0, #0
 8031e36:	d102      	bne.n	8031e3e <SecureElementSetDevEui+0x28>
        memcpy1( KMSKeyBlob.DevEui, devEui, SE_EUI_SIZE );
        status = SecureElementSetID( &KMSKeyBlob );
    }
    return status;
#endif /* LORAWAN_KMS */
}
 8031e38:	0020      	movs	r0, r4
 8031e3a:	b007      	add	sp, #28
 8031e3c:	bd30      	pop	{r4, r5, pc}
        memcpy1( KMSKeyBlob.DevEui, devEui, SE_EUI_SIZE );
 8031e3e:	2208      	movs	r2, #8
 8031e40:	0029      	movs	r1, r5
 8031e42:	4668      	mov	r0, sp
 8031e44:	f000 f95d 	bl	8032102 <memcpy1>
        status = SecureElementSetID( &KMSKeyBlob );
 8031e48:	4668      	mov	r0, sp
 8031e4a:	f7ff fd01 	bl	8031850 <SecureElementSetID>
 8031e4e:	0004      	movs	r4, r0
 8031e50:	e7f2      	b.n	8031e38 <SecureElementSetDevEui+0x22>
        return SECURE_ELEMENT_ERROR_NPE;
 8031e52:	2402      	movs	r4, #2
 8031e54:	e7f0      	b.n	8031e38 <SecureElementSetDevEui+0x22>

08031e56 <SecureElementGetDevEui>:

SecureElementStatus_t SecureElementGetDevEui( uint8_t *devEui )
{
 8031e56:	b530      	push	{r4, r5, lr}
 8031e58:	b087      	sub	sp, #28
 8031e5a:	1e05      	subs	r5, r0, #0
    if( devEui == NULL )
 8031e5c:	d00e      	beq.n	8031e7c <SecureElementGetDevEui+0x26>
    return SECURE_ELEMENT_SUCCESS;
#else
    SecureElementStatus_t status;
    SecureElementNvmDevJoinAddrKey_t KMSKeyBlob ALIGN( 8 );

    status = SecureElementGetKeyByID( DEV_JOIN_EUI_ADDR_KEY, ( uint8_t * )&KMSKeyBlob );
 8031e5e:	4669      	mov	r1, sp
 8031e60:	2002      	movs	r0, #2
 8031e62:	f7ff fbd9 	bl	8031618 <SecureElementGetKeyByID>
 8031e66:	1e04      	subs	r4, r0, #0
    if( status == SECURE_ELEMENT_SUCCESS )
 8031e68:	d002      	beq.n	8031e70 <SecureElementGetDevEui+0x1a>
        /* get DevEui field in KMSKeyBlob handle */
        memcpy1( devEui, KMSKeyBlob.DevEui, SE_EUI_SIZE );
    }
    return status;
#endif /* LORAWAN_KMS */
}
 8031e6a:	0020      	movs	r0, r4
 8031e6c:	b007      	add	sp, #28
 8031e6e:	bd30      	pop	{r4, r5, pc}
        memcpy1( devEui, KMSKeyBlob.DevEui, SE_EUI_SIZE );
 8031e70:	2208      	movs	r2, #8
 8031e72:	4669      	mov	r1, sp
 8031e74:	0028      	movs	r0, r5
 8031e76:	f000 f944 	bl	8032102 <memcpy1>
 8031e7a:	e7f6      	b.n	8031e6a <SecureElementGetDevEui+0x14>
        return SECURE_ELEMENT_ERROR_NPE;
 8031e7c:	2402      	movs	r4, #2
 8031e7e:	e7f4      	b.n	8031e6a <SecureElementGetDevEui+0x14>

08031e80 <SecureElementSetJoinEui>:

SecureElementStatus_t SecureElementSetJoinEui( uint8_t *joinEui )
{
 8031e80:	b530      	push	{r4, r5, lr}
 8031e82:	b087      	sub	sp, #28
 8031e84:	1e05      	subs	r5, r0, #0
    if( joinEui == NULL )
 8031e86:	d019      	beq.n	8031ebc <SecureElementSetJoinEui+0x3c>
#else
    SecureElementStatus_t status;
    SecureElementNvmDevJoinAddrKey_t KMSKeyBlob ALIGN( 8 );

    /* recover whole KMSKeyBlob handle */
    status = SecureElementGetKeyByID( DEV_JOIN_EUI_ADDR_KEY, ( uint8_t * )&KMSKeyBlob );
 8031e88:	4669      	mov	r1, sp
 8031e8a:	2002      	movs	r0, #2
 8031e8c:	f7ff fbc4 	bl	8031618 <SecureElementGetKeyByID>
 8031e90:	1e04      	subs	r4, r0, #0
    if( ( status == SECURE_ELEMENT_SUCCESS ) && ( memcmp( KMSKeyBlob.JoinEui, joinEui, SE_EUI_SIZE ) != 0 ) )
 8031e92:	d106      	bne.n	8031ea2 <SecureElementSetJoinEui+0x22>
 8031e94:	2208      	movs	r2, #8
 8031e96:	0029      	movs	r1, r5
 8031e98:	a802      	add	r0, sp, #8
 8031e9a:	f002 fe35 	bl	8034b08 <memcmp>
 8031e9e:	2800      	cmp	r0, #0
 8031ea0:	d102      	bne.n	8031ea8 <SecureElementSetJoinEui+0x28>
        memcpy1( KMSKeyBlob.JoinEui, joinEui, SE_EUI_SIZE );
        status = SecureElementSetID( &KMSKeyBlob );
    }
    return status;
#endif /* LORAWAN_KMS */
}
 8031ea2:	0020      	movs	r0, r4
 8031ea4:	b007      	add	sp, #28
 8031ea6:	bd30      	pop	{r4, r5, pc}
        memcpy1( KMSKeyBlob.JoinEui, joinEui, SE_EUI_SIZE );
 8031ea8:	2208      	movs	r2, #8
 8031eaa:	0029      	movs	r1, r5
 8031eac:	a802      	add	r0, sp, #8
 8031eae:	f000 f928 	bl	8032102 <memcpy1>
        status = SecureElementSetID( &KMSKeyBlob );
 8031eb2:	4668      	mov	r0, sp
 8031eb4:	f7ff fccc 	bl	8031850 <SecureElementSetID>
 8031eb8:	0004      	movs	r4, r0
 8031eba:	e7f2      	b.n	8031ea2 <SecureElementSetJoinEui+0x22>
        return SECURE_ELEMENT_ERROR_NPE;
 8031ebc:	2402      	movs	r4, #2
 8031ebe:	e7f0      	b.n	8031ea2 <SecureElementSetJoinEui+0x22>

08031ec0 <SecureElementGetJoinEui>:

SecureElementStatus_t SecureElementGetJoinEui( uint8_t *joinEui )
{
 8031ec0:	b530      	push	{r4, r5, lr}
 8031ec2:	b087      	sub	sp, #28
 8031ec4:	1e05      	subs	r5, r0, #0
    if( joinEui == NULL )
 8031ec6:	d00e      	beq.n	8031ee6 <SecureElementGetJoinEui+0x26>
    return SECURE_ELEMENT_SUCCESS;
#else
    SecureElementStatus_t status;
    SecureElementNvmDevJoinAddrKey_t KMSKeyBlob ALIGN( 8 );

    status = SecureElementGetKeyByID( DEV_JOIN_EUI_ADDR_KEY, ( uint8_t * )&KMSKeyBlob );
 8031ec8:	4669      	mov	r1, sp
 8031eca:	2002      	movs	r0, #2
 8031ecc:	f7ff fba4 	bl	8031618 <SecureElementGetKeyByID>
 8031ed0:	1e04      	subs	r4, r0, #0
    if( status == SECURE_ELEMENT_SUCCESS )
 8031ed2:	d002      	beq.n	8031eda <SecureElementGetJoinEui+0x1a>
        /* get JoinEui field from KMSKeyBlob handle */
        memcpy1( joinEui, KMSKeyBlob.JoinEui, SE_EUI_SIZE );
    }
    return status;
#endif /* LORAWAN_KMS */
}
 8031ed4:	0020      	movs	r0, r4
 8031ed6:	b007      	add	sp, #28
 8031ed8:	bd30      	pop	{r4, r5, pc}
        memcpy1( joinEui, KMSKeyBlob.JoinEui, SE_EUI_SIZE );
 8031eda:	2208      	movs	r2, #8
 8031edc:	a902      	add	r1, sp, #8
 8031ede:	0028      	movs	r0, r5
 8031ee0:	f000 f90f 	bl	8032102 <memcpy1>
 8031ee4:	e7f6      	b.n	8031ed4 <SecureElementGetJoinEui+0x14>
        return SECURE_ELEMENT_ERROR_NPE;
 8031ee6:	2402      	movs	r4, #2
 8031ee8:	e7f4      	b.n	8031ed4 <SecureElementGetJoinEui+0x14>

08031eea <SecureElementSetDevAddr>:

SecureElementStatus_t SecureElementSetDevAddr( ActivationType_t mode, uint32_t devAddr )
{
 8031eea:	b530      	push	{r4, r5, lr}
 8031eec:	b087      	sub	sp, #28
 8031eee:	0004      	movs	r4, r0
 8031ef0:	000d      	movs	r5, r1
#else
    SecureElementStatus_t status;
    SecureElementNvmDevJoinAddrKey_t KMSKeyBlob ALIGN( 8 );

    /* recover whole KMSKeyBlob handle */
    status = SecureElementGetKeyByID( DEV_JOIN_EUI_ADDR_KEY, ( uint8_t * )&KMSKeyBlob );
 8031ef2:	4669      	mov	r1, sp
 8031ef4:	2002      	movs	r0, #2
 8031ef6:	f7ff fb8f 	bl	8031618 <SecureElementGetKeyByID>
    if( status == SECURE_ELEMENT_SUCCESS )
 8031efa:	2800      	cmp	r0, #0
 8031efc:	d104      	bne.n	8031f08 <SecureElementSetDevAddr+0x1e>
    {
        /* Recover DevAddrABP or DevAddrOTAA depending on mode */
        if( mode == ACTIVATION_TYPE_OTAA )
 8031efe:	2c02      	cmp	r4, #2
 8031f00:	d004      	beq.n	8031f0c <SecureElementSetDevAddr+0x22>
            }
        }
        else
        {
            /* ABP or Not yet joined: set devAddrABP */
            if( KMSKeyBlob.DevAddrABP != devAddr )
 8031f02:	9b05      	ldr	r3, [sp, #20]
 8031f04:	42ab      	cmp	r3, r5
 8031f06:	d109      	bne.n	8031f1c <SecureElementSetDevAddr+0x32>
        }
    }

    return status;
#endif /* LORAWAN_KMS */
}
 8031f08:	b007      	add	sp, #28
 8031f0a:	bd30      	pop	{r4, r5, pc}
            if( KMSKeyBlob.DevAddrOTAA != devAddr )
 8031f0c:	9b04      	ldr	r3, [sp, #16]
 8031f0e:	42ab      	cmp	r3, r5
 8031f10:	d0fa      	beq.n	8031f08 <SecureElementSetDevAddr+0x1e>
                KMSKeyBlob.DevAddrOTAA = devAddr;
 8031f12:	9504      	str	r5, [sp, #16]
                status = SecureElementSetID( &KMSKeyBlob );
 8031f14:	4668      	mov	r0, sp
 8031f16:	f7ff fc9b 	bl	8031850 <SecureElementSetID>
 8031f1a:	e7f5      	b.n	8031f08 <SecureElementSetDevAddr+0x1e>
                KMSKeyBlob.DevAddrABP = devAddr;
 8031f1c:	9505      	str	r5, [sp, #20]
                status = SecureElementSetID( &KMSKeyBlob );
 8031f1e:	4668      	mov	r0, sp
 8031f20:	f7ff fc96 	bl	8031850 <SecureElementSetID>
 8031f24:	e7f0      	b.n	8031f08 <SecureElementSetDevAddr+0x1e>

08031f26 <SecureElementGetDevAddr>:

SecureElementStatus_t SecureElementGetDevAddr( ActivationType_t mode, uint32_t *devAddr )
{
 8031f26:	b530      	push	{r4, r5, lr}
 8031f28:	b087      	sub	sp, #28
 8031f2a:	0005      	movs	r5, r0
 8031f2c:	1e0c      	subs	r4, r1, #0
    if( devAddr == NULL )
 8031f2e:	d00e      	beq.n	8031f4e <SecureElementGetDevAddr+0x28>
#else
    SecureElementStatus_t status;
    SecureElementNvmDevJoinAddrKey_t KMSKeyBlob ALIGN( 8 );

    /* recover whole KMSKeyBlob handle */
    status = SecureElementGetKeyByID( DEV_JOIN_EUI_ADDR_KEY, ( uint8_t * )&KMSKeyBlob );
 8031f30:	4669      	mov	r1, sp
 8031f32:	2002      	movs	r0, #2
 8031f34:	f7ff fb70 	bl	8031618 <SecureElementGetKeyByID>
    if( status == SECURE_ELEMENT_SUCCESS )
 8031f38:	2800      	cmp	r0, #0
 8031f3a:	d103      	bne.n	8031f44 <SecureElementGetDevAddr+0x1e>
    {
        /* Recover DevAddrABP or DevAddrOTAA depending on mode */
        if( mode == ACTIVATION_TYPE_OTAA )
 8031f3c:	2d02      	cmp	r5, #2
 8031f3e:	d003      	beq.n	8031f48 <SecureElementGetDevAddr+0x22>
        {
            *devAddr = KMSKeyBlob.DevAddrOTAA;
        }
        else
        {
            *devAddr = KMSKeyBlob.DevAddrABP;
 8031f40:	9b05      	ldr	r3, [sp, #20]
 8031f42:	6023      	str	r3, [r4, #0]
        }
    }

    return status;
#endif /* LORAWAN_KMS */
}
 8031f44:	b007      	add	sp, #28
 8031f46:	bd30      	pop	{r4, r5, pc}
            *devAddr = KMSKeyBlob.DevAddrOTAA;
 8031f48:	9b04      	ldr	r3, [sp, #16]
 8031f4a:	6023      	str	r3, [r4, #0]
 8031f4c:	e7fa      	b.n	8031f44 <SecureElementGetDevAddr+0x1e>
        return SECURE_ELEMENT_ERROR_NPE;
 8031f4e:	2002      	movs	r0, #2
 8031f50:	e7f8      	b.n	8031f44 <SecureElementGetDevAddr+0x1e>

08031f52 <SecureElementInitMcuID>:
{
 8031f52:	b530      	push	{r4, r5, lr}
 8031f54:	b085      	sub	sp, #20
 8031f56:	0005      	movs	r5, r0
 8031f58:	000c      	movs	r4, r1
    uint32_t devAddrABP = 0;
 8031f5a:	2300      	movs	r3, #0
 8031f5c:	9301      	str	r3, [sp, #4]
    SecureElementGetDevEui( devEui );
 8031f5e:	a802      	add	r0, sp, #8
 8031f60:	f7ff ff79 	bl	8031e56 <SecureElementGetDevEui>
    SecureElementGetDevAddr( ACTIVATION_TYPE_ABP, &devAddrABP );
 8031f64:	a901      	add	r1, sp, #4
 8031f66:	2001      	movs	r0, #1
 8031f68:	f7ff ffdd 	bl	8031f26 <SecureElementGetDevAddr>
    if( seGetUniqueId != NULL )
 8031f6c:	2d00      	cmp	r5, #0
 8031f6e:	d011      	beq.n	8031f94 <SecureElementInitMcuID+0x42>
        for( uint8_t index = 0; index < SE_EUI_SIZE; index++ )
 8031f70:	2300      	movs	r3, #0
 8031f72:	2b07      	cmp	r3, #7
 8031f74:	d806      	bhi.n	8031f84 <SecureElementInitMcuID+0x32>
            if( devEui[index] != 0 )
 8031f76:	aa02      	add	r2, sp, #8
 8031f78:	5cd2      	ldrb	r2, [r2, r3]
 8031f7a:	2a00      	cmp	r2, #0
 8031f7c:	d118      	bne.n	8031fb0 <SecureElementInitMcuID+0x5e>
        for( uint8_t index = 0; index < SE_EUI_SIZE; index++ )
 8031f7e:	3301      	adds	r3, #1
 8031f80:	b2db      	uxtb	r3, r3
 8031f82:	e7f6      	b.n	8031f72 <SecureElementInitMcuID+0x20>
        bool id_init = false;
 8031f84:	2300      	movs	r3, #0
        if( id_init == false )
 8031f86:	2b00      	cmp	r3, #0
 8031f88:	d104      	bne.n	8031f94 <SecureElementInitMcuID+0x42>
            seGetUniqueId( devEui );
 8031f8a:	a802      	add	r0, sp, #8
 8031f8c:	47a8      	blx	r5
            SecureElementSetDevEui( devEui );
 8031f8e:	a802      	add	r0, sp, #8
 8031f90:	f7ff ff41 	bl	8031e16 <SecureElementSetDevEui>
    if( ( seGetDevAddr != NULL ) && ( devAddrABP == 0 ) )
 8031f94:	2c00      	cmp	r4, #0
 8031f96:	d008      	beq.n	8031faa <SecureElementInitMcuID+0x58>
 8031f98:	9b01      	ldr	r3, [sp, #4]
 8031f9a:	2b00      	cmp	r3, #0
 8031f9c:	d105      	bne.n	8031faa <SecureElementInitMcuID+0x58>
        seGetDevAddr( &devAddrABP );
 8031f9e:	a801      	add	r0, sp, #4
 8031fa0:	47a0      	blx	r4
        SecureElementSetDevAddr( ACTIVATION_TYPE_ABP, devAddrABP );
 8031fa2:	9901      	ldr	r1, [sp, #4]
 8031fa4:	2001      	movs	r0, #1
 8031fa6:	f7ff ffa0 	bl	8031eea <SecureElementSetDevAddr>
}
 8031faa:	2000      	movs	r0, #0
 8031fac:	b005      	add	sp, #20
 8031fae:	bd30      	pop	{r4, r5, pc}
                id_init = true;
 8031fb0:	2301      	movs	r3, #1
 8031fb2:	e7e8      	b.n	8031f86 <SecureElementInitMcuID+0x34>

08031fb4 <PrintIds>:
{
 8031fb4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8031fb6:	46c6      	mov	lr, r8
 8031fb8:	b500      	push	{lr}
 8031fba:	b08e      	sub	sp, #56	; 0x38
 8031fbc:	4680      	mov	r8, r0
    uint32_t devAddr = 0;
 8031fbe:	2300      	movs	r3, #0
 8031fc0:	9309      	str	r3, [sp, #36]	; 0x24
    SecureElementGetDevEui( devEui );
 8031fc2:	ac0a      	add	r4, sp, #40	; 0x28
 8031fc4:	0020      	movs	r0, r4
 8031fc6:	f7ff ff46 	bl	8031e56 <SecureElementGetDevEui>
    MW_LOG( TS_OFF, VLEVEL_M, "###### DevEUI:      %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n", HEX8( devEui ) );
 8031fca:	7823      	ldrb	r3, [r4, #0]
 8031fcc:	7862      	ldrb	r2, [r4, #1]
 8031fce:	78a1      	ldrb	r1, [r4, #2]
 8031fd0:	78e0      	ldrb	r0, [r4, #3]
 8031fd2:	7926      	ldrb	r6, [r4, #4]
 8031fd4:	7967      	ldrb	r7, [r4, #5]
 8031fd6:	79a5      	ldrb	r5, [r4, #6]
 8031fd8:	79e4      	ldrb	r4, [r4, #7]
 8031fda:	9407      	str	r4, [sp, #28]
 8031fdc:	9506      	str	r5, [sp, #24]
 8031fde:	9705      	str	r7, [sp, #20]
 8031fe0:	9604      	str	r6, [sp, #16]
 8031fe2:	9003      	str	r0, [sp, #12]
 8031fe4:	9102      	str	r1, [sp, #8]
 8031fe6:	9201      	str	r2, [sp, #4]
 8031fe8:	9300      	str	r3, [sp, #0]
 8031fea:	4b1b      	ldr	r3, [pc, #108]	; (8032058 <PrintIds+0xa4>)
 8031fec:	2200      	movs	r2, #0
 8031fee:	2100      	movs	r1, #0
 8031ff0:	2002      	movs	r0, #2
 8031ff2:	f001 ff3d 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
    SecureElementGetJoinEui( joinEui );
 8031ff6:	ac0c      	add	r4, sp, #48	; 0x30
 8031ff8:	0020      	movs	r0, r4
 8031ffa:	f7ff ff61 	bl	8031ec0 <SecureElementGetJoinEui>
    MW_LOG( TS_OFF, VLEVEL_M, "###### AppEUI:      %02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\r\n", HEX8( joinEui ) );
 8031ffe:	7823      	ldrb	r3, [r4, #0]
 8032000:	7862      	ldrb	r2, [r4, #1]
 8032002:	78a1      	ldrb	r1, [r4, #2]
 8032004:	78e0      	ldrb	r0, [r4, #3]
 8032006:	7926      	ldrb	r6, [r4, #4]
 8032008:	7967      	ldrb	r7, [r4, #5]
 803200a:	79a5      	ldrb	r5, [r4, #6]
 803200c:	79e4      	ldrb	r4, [r4, #7]
 803200e:	9407      	str	r4, [sp, #28]
 8032010:	9506      	str	r5, [sp, #24]
 8032012:	9705      	str	r7, [sp, #20]
 8032014:	9604      	str	r6, [sp, #16]
 8032016:	9003      	str	r0, [sp, #12]
 8032018:	9102      	str	r1, [sp, #8]
 803201a:	9201      	str	r2, [sp, #4]
 803201c:	9300      	str	r3, [sp, #0]
 803201e:	4b0f      	ldr	r3, [pc, #60]	; (803205c <PrintIds+0xa8>)
 8032020:	2200      	movs	r2, #0
 8032022:	2100      	movs	r1, #0
 8032024:	2002      	movs	r0, #2
 8032026:	f001 ff23 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
    SecureElementGetDevAddr( mode, &devAddr );
 803202a:	ac09      	add	r4, sp, #36	; 0x24
 803202c:	0021      	movs	r1, r4
 803202e:	4640      	mov	r0, r8
 8032030:	f7ff ff79 	bl	8031f26 <SecureElementGetDevAddr>
    MW_LOG( TS_OFF, VLEVEL_M, "###### DevAddr:     %02X:%02X:%02X:%02X\r\n",
 8032034:	78e3      	ldrb	r3, [r4, #3]
 8032036:	78a2      	ldrb	r2, [r4, #2]
 8032038:	7861      	ldrb	r1, [r4, #1]
 803203a:	7820      	ldrb	r0, [r4, #0]
 803203c:	9003      	str	r0, [sp, #12]
 803203e:	9102      	str	r1, [sp, #8]
 8032040:	9201      	str	r2, [sp, #4]
 8032042:	9300      	str	r3, [sp, #0]
 8032044:	4b06      	ldr	r3, [pc, #24]	; (8032060 <PrintIds+0xac>)
 8032046:	2200      	movs	r2, #0
 8032048:	2100      	movs	r1, #0
 803204a:	2002      	movs	r0, #2
 803204c:	f001 ff10 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
}
 8032050:	b00e      	add	sp, #56	; 0x38
 8032052:	bc80      	pop	{r7}
 8032054:	46b8      	mov	r8, r7
 8032056:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8032058:	08035aa0 	.word	0x08035aa0
 803205c:	08035ae0 	.word	0x08035ae0
 8032060:	08035b20 	.word	0x08035b20

08032064 <SecureElementPrintKeys>:
{
 8032064:	b510      	push	{r4, lr}
    PrintKey( APP_KEY );
 8032066:	2000      	movs	r0, #0
 8032068:	f7ff fb0e 	bl	8031688 <PrintKey>
    PrintKey( NWK_KEY );
 803206c:	2001      	movs	r0, #1
 803206e:	f7ff fb0b 	bl	8031688 <PrintKey>
    PrintKey( APP_S_KEY );
 8032072:	2009      	movs	r0, #9
 8032074:	f7ff fb08 	bl	8031688 <PrintKey>
    PrintKey( NWK_S_KEY );
 8032078:	2008      	movs	r0, #8
 803207a:	f7ff fb05 	bl	8031688 <PrintKey>
    PrintIds( ACTIVATION_TYPE_NONE );
 803207e:	2000      	movs	r0, #0
 8032080:	f7ff ff98 	bl	8031fb4 <PrintIds>
}
 8032084:	2000      	movs	r0, #0
 8032086:	bd10      	pop	{r4, pc}

08032088 <SecureElementPrintSessionKeys>:
{
 8032088:	b510      	push	{r4, lr}
 803208a:	0004      	movs	r4, r0
    PrintKey( MC_ROOT_KEY );
 803208c:	200b      	movs	r0, #11
 803208e:	f7ff fafb 	bl	8031688 <PrintKey>
    PrintKey( MC_KE_KEY );
 8032092:	200c      	movs	r0, #12
 8032094:	f7ff faf8 	bl	8031688 <PrintKey>
    PrintKey( APP_S_KEY );
 8032098:	2009      	movs	r0, #9
 803209a:	f7ff faf5 	bl	8031688 <PrintKey>
    PrintKey( NWK_S_KEY );
 803209e:	2008      	movs	r0, #8
 80320a0:	f7ff faf2 	bl	8031688 <PrintKey>
    PrintKey( DATABLOCK_INT_KEY );
 80320a4:	200a      	movs	r0, #10
 80320a6:	f7ff faef 	bl	8031688 <PrintKey>
    PrintIds( mode );
 80320aa:	0020      	movs	r0, r4
 80320ac:	f7ff ff82 	bl	8031fb4 <PrintIds>
}
 80320b0:	2000      	movs	r0, #0
 80320b2:	bd10      	pop	{r4, pc}

080320b4 <rand1>:
static uint32_t next = 1;

static int32_t rand1( void );

static int32_t rand1( void )
{
 80320b4:	b510      	push	{r4, lr}
    return ( ( next = next * 1103515245L + 12345L ) % RAND_LOCAL_MAX );
 80320b6:	4b06      	ldr	r3, [pc, #24]	; (80320d0 <rand1+0x1c>)
 80320b8:	4806      	ldr	r0, [pc, #24]	; (80320d4 <rand1+0x20>)
 80320ba:	681a      	ldr	r2, [r3, #0]
 80320bc:	4350      	muls	r0, r2
 80320be:	4a06      	ldr	r2, [pc, #24]	; (80320d8 <rand1+0x24>)
 80320c0:	4694      	mov	ip, r2
 80320c2:	4460      	add	r0, ip
 80320c4:	6018      	str	r0, [r3, #0]
 80320c6:	4905      	ldr	r1, [pc, #20]	; (80320dc <rand1+0x28>)
 80320c8:	f7ee f8ac 	bl	8020224 <__aeabi_uidivmod>
 80320cc:	0008      	movs	r0, r1
}
 80320ce:	bd10      	pop	{r4, pc}
 80320d0:	2000b134 	.word	0x2000b134
 80320d4:	41c64e6d 	.word	0x41c64e6d
 80320d8:	00003039 	.word	0x00003039
 80320dc:	7fffffff 	.word	0x7fffffff

080320e0 <srand1>:

void srand1( uint32_t seed )
{
    next = seed;
 80320e0:	4b01      	ldr	r3, [pc, #4]	; (80320e8 <srand1+0x8>)
 80320e2:	6018      	str	r0, [r3, #0]
}
 80320e4:	4770      	bx	lr
 80320e6:	46c0      	nop			; (mov r8, r8)
 80320e8:	2000b134 	.word	0x2000b134

080320ec <randr>:
// Standard random functions redefinition end

int32_t randr( int32_t min, int32_t max )
{
 80320ec:	b570      	push	{r4, r5, r6, lr}
 80320ee:	0005      	movs	r5, r0
 80320f0:	000c      	movs	r4, r1
    return ( int32_t )rand1( ) % ( max - min + 1 ) + min;
 80320f2:	f7ff ffdf 	bl	80320b4 <rand1>
 80320f6:	1b61      	subs	r1, r4, r5
 80320f8:	3101      	adds	r1, #1
 80320fa:	f7ee f97d 	bl	80203f8 <__aeabi_idivmod>
 80320fe:	1948      	adds	r0, r1, r5
}
 8032100:	bd70      	pop	{r4, r5, r6, pc}

08032102 <memcpy1>:

void memcpy1( uint8_t *dst, const uint8_t *src, uint16_t size )
{
    while( size-- )
 8032102:	e004      	b.n	803210e <memcpy1+0xc>
    {
        *dst++ = *src++;
 8032104:	780a      	ldrb	r2, [r1, #0]
 8032106:	7002      	strb	r2, [r0, #0]
    while( size-- )
 8032108:	001a      	movs	r2, r3
        *dst++ = *src++;
 803210a:	3101      	adds	r1, #1
 803210c:	3001      	adds	r0, #1
    while( size-- )
 803210e:	1e53      	subs	r3, r2, #1
 8032110:	b29b      	uxth	r3, r3
 8032112:	2a00      	cmp	r2, #0
 8032114:	d1f6      	bne.n	8032104 <memcpy1+0x2>
    }
}
 8032116:	4770      	bx	lr

08032118 <memcpyr>:

void memcpyr( uint8_t *dst, const uint8_t *src, uint16_t size )
{
    dst = dst + ( size - 1 );
 8032118:	1e53      	subs	r3, r2, #1
 803211a:	18c0      	adds	r0, r0, r3
    while( size-- )
 803211c:	e004      	b.n	8032128 <memcpyr+0x10>
    {
        *dst-- = *src++;
 803211e:	780a      	ldrb	r2, [r1, #0]
 8032120:	7002      	strb	r2, [r0, #0]
    while( size-- )
 8032122:	001a      	movs	r2, r3
        *dst-- = *src++;
 8032124:	3101      	adds	r1, #1
 8032126:	3801      	subs	r0, #1
    while( size-- )
 8032128:	1e53      	subs	r3, r2, #1
 803212a:	b29b      	uxth	r3, r3
 803212c:	2a00      	cmp	r2, #0
 803212e:	d1f6      	bne.n	803211e <memcpyr+0x6>
    }
}
 8032130:	4770      	bx	lr

08032132 <memset1>:

void memset1( uint8_t *dst, uint8_t value, uint16_t size )
{
    while( size-- )
 8032132:	e002      	b.n	803213a <memset1+0x8>
    {
        *dst++ = value;
 8032134:	7001      	strb	r1, [r0, #0]
    while( size-- )
 8032136:	001a      	movs	r2, r3
        *dst++ = value;
 8032138:	3001      	adds	r0, #1
    while( size-- )
 803213a:	1e53      	subs	r3, r2, #1
 803213c:	b29b      	uxth	r3, r3
 803213e:	2a00      	cmp	r2, #0
 8032140:	d1f8      	bne.n	8032134 <memset1+0x2>
    }
}
 8032142:	4770      	bx	lr

08032144 <Crc32>:
        return '?';
    }
}

uint32_t Crc32( uint8_t *buffer, uint16_t length )
{
 8032144:	b570      	push	{r4, r5, r6, lr}
 8032146:	1e06      	subs	r6, r0, #0
    // CRC initial value
    uint32_t crc = 0xFFFFFFFF;

    if( buffer == NULL )
 8032148:	d018      	beq.n	803217c <Crc32+0x38>
    {
        return 0;
    }

    for( uint16_t i = 0; i < length; ++i )
 803214a:	2500      	movs	r5, #0
    uint32_t crc = 0xFFFFFFFF;
 803214c:	2301      	movs	r3, #1
 803214e:	425b      	negs	r3, r3
 8032150:	e00c      	b.n	803216c <Crc32+0x28>
    {
        crc ^= ( uint32_t )buffer[i];
        for( uint16_t i = 0; i < 8; i++ )
        {
            crc = ( crc >> 1 ) ^ ( reversedPolynom & ~( ( crc & 0x01 ) - 1 ) );
 8032152:	085c      	lsrs	r4, r3, #1
 8032154:	2001      	movs	r0, #1
 8032156:	4003      	ands	r3, r0
 8032158:	425b      	negs	r3, r3
 803215a:	4809      	ldr	r0, [pc, #36]	; (8032180 <Crc32+0x3c>)
 803215c:	4003      	ands	r3, r0
 803215e:	4063      	eors	r3, r4
        for( uint16_t i = 0; i < 8; i++ )
 8032160:	3201      	adds	r2, #1
 8032162:	b292      	uxth	r2, r2
 8032164:	2a07      	cmp	r2, #7
 8032166:	d9f4      	bls.n	8032152 <Crc32+0xe>
    for( uint16_t i = 0; i < length; ++i )
 8032168:	3501      	adds	r5, #1
 803216a:	b2ad      	uxth	r5, r5
 803216c:	428d      	cmp	r5, r1
 803216e:	d203      	bcs.n	8032178 <Crc32+0x34>
        crc ^= ( uint32_t )buffer[i];
 8032170:	5d72      	ldrb	r2, [r6, r5]
 8032172:	4053      	eors	r3, r2
        for( uint16_t i = 0; i < 8; i++ )
 8032174:	2200      	movs	r2, #0
 8032176:	e7f5      	b.n	8032164 <Crc32+0x20>
        }
    }

    return ~crc;
 8032178:	43d8      	mvns	r0, r3
}
 803217a:	bd70      	pop	{r4, r5, r6, pc}
        return 0;
 803217c:	2000      	movs	r0, #0
 803217e:	e7fc      	b.n	803217a <Crc32+0x36>
 8032180:	edb88320 	.word	0xedb88320

08032184 <RadioCheckRfFrequency>:
}

static bool RadioCheckRfFrequency( uint32_t frequency )
{
    return true;
}
 8032184:	2001      	movs	r0, #1
 8032186:	4770      	bx	lr

08032188 <RadioGetLoRaBandwidthInHz>:

static uint32_t RadioGetLoRaBandwidthInHz( RadioLoRaBandwidths_t bw )
{
    uint32_t bandwidthInHz = 0;

    switch( bw )
 8032188:	280a      	cmp	r0, #10
 803218a:	d803      	bhi.n	8032194 <RadioGetLoRaBandwidthInHz+0xc>
 803218c:	0080      	lsls	r0, r0, #2
 803218e:	4b0c      	ldr	r3, [pc, #48]	; (80321c0 <RadioGetLoRaBandwidthInHz+0x38>)
 8032190:	581b      	ldr	r3, [r3, r0]
 8032192:	469f      	mov	pc, r3
 8032194:	2000      	movs	r0, #0
 8032196:	e012      	b.n	80321be <RadioGetLoRaBandwidthInHz+0x36>
    {
    case LORA_BW_007:
        bandwidthInHz = 7812UL;
        break;
    case LORA_BW_010:
        bandwidthInHz = 10417UL;
 8032198:	480a      	ldr	r0, [pc, #40]	; (80321c4 <RadioGetLoRaBandwidthInHz+0x3c>)
        break;
 803219a:	e010      	b.n	80321be <RadioGetLoRaBandwidthInHz+0x36>
    case LORA_BW_015:
        bandwidthInHz = 15625UL;
 803219c:	480a      	ldr	r0, [pc, #40]	; (80321c8 <RadioGetLoRaBandwidthInHz+0x40>)
        break;
 803219e:	e00e      	b.n	80321be <RadioGetLoRaBandwidthInHz+0x36>
    case LORA_BW_020:
        bandwidthInHz = 20833UL;
 80321a0:	480a      	ldr	r0, [pc, #40]	; (80321cc <RadioGetLoRaBandwidthInHz+0x44>)
        break;
 80321a2:	e00c      	b.n	80321be <RadioGetLoRaBandwidthInHz+0x36>
    case LORA_BW_031:
        bandwidthInHz = 31250UL;
 80321a4:	480a      	ldr	r0, [pc, #40]	; (80321d0 <RadioGetLoRaBandwidthInHz+0x48>)
        break;
 80321a6:	e00a      	b.n	80321be <RadioGetLoRaBandwidthInHz+0x36>
    case LORA_BW_041:
        bandwidthInHz = 41667UL;
 80321a8:	480a      	ldr	r0, [pc, #40]	; (80321d4 <RadioGetLoRaBandwidthInHz+0x4c>)
        break;
 80321aa:	e008      	b.n	80321be <RadioGetLoRaBandwidthInHz+0x36>
    case LORA_BW_062:
        bandwidthInHz = 62500UL;
 80321ac:	480a      	ldr	r0, [pc, #40]	; (80321d8 <RadioGetLoRaBandwidthInHz+0x50>)
        break;
 80321ae:	e006      	b.n	80321be <RadioGetLoRaBandwidthInHz+0x36>
    case LORA_BW_125:
        bandwidthInHz = 125000UL;
 80321b0:	480a      	ldr	r0, [pc, #40]	; (80321dc <RadioGetLoRaBandwidthInHz+0x54>)
        break;
 80321b2:	e004      	b.n	80321be <RadioGetLoRaBandwidthInHz+0x36>
    case LORA_BW_250:
        bandwidthInHz = 250000UL;
 80321b4:	480a      	ldr	r0, [pc, #40]	; (80321e0 <RadioGetLoRaBandwidthInHz+0x58>)
        break;
 80321b6:	e002      	b.n	80321be <RadioGetLoRaBandwidthInHz+0x36>
    case LORA_BW_500:
        bandwidthInHz = 500000UL;
 80321b8:	480a      	ldr	r0, [pc, #40]	; (80321e4 <RadioGetLoRaBandwidthInHz+0x5c>)
        break;
 80321ba:	e000      	b.n	80321be <RadioGetLoRaBandwidthInHz+0x36>
        bandwidthInHz = 7812UL;
 80321bc:	480a      	ldr	r0, [pc, #40]	; (80321e8 <RadioGetLoRaBandwidthInHz+0x60>)
    }

    return bandwidthInHz;
}
 80321be:	4770      	bx	lr
 80321c0:	08035c6c 	.word	0x08035c6c
 80321c4:	000028b1 	.word	0x000028b1
 80321c8:	00003d09 	.word	0x00003d09
 80321cc:	00005161 	.word	0x00005161
 80321d0:	00007a12 	.word	0x00007a12
 80321d4:	0000a2c3 	.word	0x0000a2c3
 80321d8:	0000f424 	.word	0x0000f424
 80321dc:	0001e848 	.word	0x0001e848
 80321e0:	0003d090 	.word	0x0003d090
 80321e4:	0007a120 	.word	0x0007a120
 80321e8:	00001e84 	.word	0x00001e84

080321ec <RadioGetGfskTimeOnAirNumerator>:

static uint32_t RadioGetGfskTimeOnAirNumerator( uint32_t datarate, uint8_t coderate,
                                                uint16_t preambleLen, bool fixLen, uint8_t payloadLen,
                                                bool crcOn )
{
 80321ec:	b510      	push	{r4, lr}
 80321ee:	a902      	add	r1, sp, #8
 80321f0:	7809      	ldrb	r1, [r1, #0]
 80321f2:	a803      	add	r0, sp, #12
 80321f4:	7804      	ldrb	r4, [r0, #0]
    return ( preambleLen << 3 ) +
 80321f6:	00d2      	lsls	r2, r2, #3
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 80321f8:	2b00      	cmp	r3, #0
 80321fa:	d109      	bne.n	8032210 <RadioGetGfskTimeOnAirNumerator+0x24>
 80321fc:	2008      	movs	r0, #8
    return ( preambleLen << 3 ) +
 80321fe:	1810      	adds	r0, r2, r0
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 8032200:	3018      	adds	r0, #24
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 8032202:	2c00      	cmp	r4, #0
 8032204:	d006      	beq.n	8032214 <RadioGetGfskTimeOnAirNumerator+0x28>
 8032206:	2202      	movs	r2, #2
 8032208:	1889      	adds	r1, r1, r2
 803220a:	00c9      	lsls	r1, r1, #3
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 803220c:	1840      	adds	r0, r0, r1
}
 803220e:	bd10      	pop	{r4, pc}
           ( ( fixLen == false ) ? 8 : 0 ) + 24 +
 8032210:	2000      	movs	r0, #0
 8032212:	e7f4      	b.n	80321fe <RadioGetGfskTimeOnAirNumerator+0x12>
           ( ( payloadLen + ( ( crcOn == true ) ? 2 : 0 ) ) << 3 );
 8032214:	2200      	movs	r2, #0
 8032216:	e7f7      	b.n	8032208 <RadioGetGfskTimeOnAirNumerator+0x1c>

08032218 <RadioGetLoRaTimeOnAirNumerator>:

static uint32_t RadioGetLoRaTimeOnAirNumerator( uint32_t bandwidth,
                                                uint32_t datarate, uint8_t coderate,
                                                uint16_t preambleLen, bool fixLen, uint8_t payloadLen,
                                                bool crcOn )
{
 8032218:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803221a:	000d      	movs	r5, r1
 803221c:	001e      	movs	r6, r3
 803221e:	ab06      	add	r3, sp, #24
 8032220:	781b      	ldrb	r3, [r3, #0]
 8032222:	a907      	add	r1, sp, #28
 8032224:	780c      	ldrb	r4, [r1, #0]
 8032226:	a908      	add	r1, sp, #32
 8032228:	7809      	ldrb	r1, [r1, #0]
    int32_t crDenom           = coderate + 4;
 803222a:	1d17      	adds	r7, r2, #4
    bool    lowDatareOptimize = false;

    // Ensure that the preamble length is at least 12 symbols when using SF5 or SF6
    if( ( datarate == 5 ) || ( datarate == 6 ) )
 803222c:	1f6a      	subs	r2, r5, #5
 803222e:	2a01      	cmp	r2, #1
 8032230:	d92c      	bls.n	803228c <RadioGetLoRaTimeOnAirNumerator+0x74>
        {
            preambleLen = 12;
        }
    }

    if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8032232:	2800      	cmp	r0, #0
 8032234:	d103      	bne.n	803223e <RadioGetLoRaTimeOnAirNumerator+0x26>
 8032236:	002a      	movs	r2, r5
 8032238:	3a0b      	subs	r2, #11
 803223a:	2a01      	cmp	r2, #1
 803223c:	d92e      	bls.n	803229c <RadioGetLoRaTimeOnAirNumerator+0x84>
 803223e:	2801      	cmp	r0, #1
 8032240:	d028      	beq.n	8032294 <RadioGetLoRaTimeOnAirNumerator+0x7c>
    bool    lowDatareOptimize = false;
 8032242:	2200      	movs	r2, #0
    {
        lowDatareOptimize = true;
    }

    int32_t ceilDenominator;
    int32_t ceilNumerator = ( payloadLen << 3 ) +
 8032244:	00e0      	lsls	r0, r4, #3
                            ( crcOn ? 16 : 0 ) -
 8032246:	2900      	cmp	r1, #0
 8032248:	d02c      	beq.n	80322a4 <RadioGetLoRaTimeOnAirNumerator+0x8c>
 803224a:	2410      	movs	r4, #16
    int32_t ceilNumerator = ( payloadLen << 3 ) +
 803224c:	1900      	adds	r0, r0, r4
                            ( 4 * datarate ) +
 803224e:	00a9      	lsls	r1, r5, #2
                            ( crcOn ? 16 : 0 ) -
 8032250:	1a40      	subs	r0, r0, r1
                            ( fixLen ? 0 : 20 );
 8032252:	2b00      	cmp	r3, #0
 8032254:	d028      	beq.n	80322a8 <RadioGetLoRaTimeOnAirNumerator+0x90>
 8032256:	2300      	movs	r3, #0
                            ( 4 * datarate ) +
 8032258:	18c0      	adds	r0, r0, r3

    if( datarate <= 6 )
 803225a:	2d06      	cmp	r5, #6
 803225c:	d904      	bls.n	8032268 <RadioGetLoRaTimeOnAirNumerator+0x50>
    {
        ceilDenominator = 4 * datarate;
    }
    else
    {
        ceilNumerator += 8;
 803225e:	3008      	adds	r0, #8

        if( lowDatareOptimize == true )
 8032260:	2a00      	cmp	r2, #0
 8032262:	d001      	beq.n	8032268 <RadioGetLoRaTimeOnAirNumerator+0x50>
        {
            ceilDenominator = 4 * ( datarate - 2 );
 8032264:	1ea9      	subs	r1, r5, #2
 8032266:	0089      	lsls	r1, r1, #2
        {
            ceilDenominator = 4 * datarate;
        }
    }

    if( ceilNumerator < 0 )
 8032268:	2800      	cmp	r0, #0
 803226a:	db1f      	blt.n	80322ac <RadioGetLoRaTimeOnAirNumerator+0x94>
        ceilNumerator = 0;
    }

    // Perform integral ceil()
    int32_t intermediate =
        ( ( ceilNumerator + ceilDenominator - 1 ) / ceilDenominator ) * crDenom + preambleLen + 12;
 803226c:	1808      	adds	r0, r1, r0
 803226e:	3801      	subs	r0, #1
 8032270:	f7ed ffdc 	bl	802022c <__divsi3>
 8032274:	4347      	muls	r7, r0
 8032276:	19f6      	adds	r6, r6, r7
    int32_t intermediate =
 8032278:	0030      	movs	r0, r6
 803227a:	300c      	adds	r0, #12

    if( datarate <= 6 )
 803227c:	2d06      	cmp	r5, #6
 803227e:	d800      	bhi.n	8032282 <RadioGetLoRaTimeOnAirNumerator+0x6a>
    {
        intermediate += 2;
 8032280:	3002      	adds	r0, #2
    }

    return ( uint32_t )( ( 4 * intermediate + 1 ) * ( 1 << ( datarate - 2 ) ) );
 8032282:	0080      	lsls	r0, r0, #2
 8032284:	3001      	adds	r0, #1
 8032286:	3d02      	subs	r5, #2
 8032288:	40a8      	lsls	r0, r5
}
 803228a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if( preambleLen < 12 )
 803228c:	2e0b      	cmp	r6, #11
 803228e:	d8d0      	bhi.n	8032232 <RadioGetLoRaTimeOnAirNumerator+0x1a>
            preambleLen = 12;
 8032290:	260c      	movs	r6, #12
 8032292:	e7ce      	b.n	8032232 <RadioGetLoRaTimeOnAirNumerator+0x1a>
        ( ( bandwidth == 1 ) && ( datarate == 12 ) ) )
 8032294:	2d0c      	cmp	r5, #12
 8032296:	d003      	beq.n	80322a0 <RadioGetLoRaTimeOnAirNumerator+0x88>
    bool    lowDatareOptimize = false;
 8032298:	2200      	movs	r2, #0
 803229a:	e7d3      	b.n	8032244 <RadioGetLoRaTimeOnAirNumerator+0x2c>
        lowDatareOptimize = true;
 803229c:	2201      	movs	r2, #1
 803229e:	e7d1      	b.n	8032244 <RadioGetLoRaTimeOnAirNumerator+0x2c>
 80322a0:	2201      	movs	r2, #1
 80322a2:	e7cf      	b.n	8032244 <RadioGetLoRaTimeOnAirNumerator+0x2c>
                            ( crcOn ? 16 : 0 ) -
 80322a4:	2400      	movs	r4, #0
 80322a6:	e7d1      	b.n	803224c <RadioGetLoRaTimeOnAirNumerator+0x34>
                            ( fixLen ? 0 : 20 );
 80322a8:	2314      	movs	r3, #20
 80322aa:	e7d5      	b.n	8032258 <RadioGetLoRaTimeOnAirNumerator+0x40>
        ceilNumerator = 0;
 80322ac:	2000      	movs	r0, #0
 80322ae:	e7dd      	b.n	803226c <RadioGetLoRaTimeOnAirNumerator+0x54>

080322b0 <RadioTimeOnAir>:

static uint32_t RadioTimeOnAir( RadioModems_t modem, uint32_t bandwidth,
                                uint32_t datarate, uint8_t coderate,
                                uint16_t preambleLen, bool fixLen, uint8_t payloadLen,
                                bool crcOn )
{
 80322b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80322b2:	b085      	sub	sp, #20
 80322b4:	000d      	movs	r5, r1
 80322b6:	0016      	movs	r6, r2
 80322b8:	0019      	movs	r1, r3
 80322ba:	ab0a      	add	r3, sp, #40	; 0x28
 80322bc:	881a      	ldrh	r2, [r3, #0]
 80322be:	ab0b      	add	r3, sp, #44	; 0x2c
 80322c0:	781b      	ldrb	r3, [r3, #0]
 80322c2:	ac0c      	add	r4, sp, #48	; 0x30
 80322c4:	7827      	ldrb	r7, [r4, #0]
 80322c6:	ac0d      	add	r4, sp, #52	; 0x34
 80322c8:	7824      	ldrb	r4, [r4, #0]
    uint32_t numerator = 0;
    uint32_t denominator = 1;

    switch( modem )
 80322ca:	2800      	cmp	r0, #0
 80322cc:	d00a      	beq.n	80322e4 <RadioTimeOnAir+0x34>
 80322ce:	2801      	cmp	r0, #1
 80322d0:	d013      	beq.n	80322fa <RadioTimeOnAir+0x4a>
 80322d2:	2601      	movs	r6, #1
 80322d4:	2400      	movs	r4, #0
        break;
    default:
        break;
    }
    // Perform integral ceil()
    return DIVC( numerator, denominator );
 80322d6:	19a0      	adds	r0, r4, r6
 80322d8:	3801      	subs	r0, #1
 80322da:	0031      	movs	r1, r6
 80322dc:	f7ed ff1c 	bl	8020118 <__udivsi3>
}
 80322e0:	b005      	add	sp, #20
 80322e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
            numerator   = 1000U * RadioGetGfskTimeOnAirNumerator( datarate, coderate,
 80322e4:	9401      	str	r4, [sp, #4]
 80322e6:	9700      	str	r7, [sp, #0]
 80322e8:	0030      	movs	r0, r6
 80322ea:	f7ff ff7f 	bl	80321ec <RadioGetGfskTimeOnAirNumerator>
 80322ee:	0143      	lsls	r3, r0, #5
 80322f0:	1a1b      	subs	r3, r3, r0
 80322f2:	009c      	lsls	r4, r3, #2
 80322f4:	1824      	adds	r4, r4, r0
 80322f6:	00e4      	lsls	r4, r4, #3
        break;
 80322f8:	e7ed      	b.n	80322d6 <RadioTimeOnAir+0x26>
            numerator   = 1000U * RadioGetLoRaTimeOnAirNumerator( bandwidth, datarate,
 80322fa:	9402      	str	r4, [sp, #8]
 80322fc:	9701      	str	r7, [sp, #4]
 80322fe:	9300      	str	r3, [sp, #0]
 8032300:	0013      	movs	r3, r2
 8032302:	000a      	movs	r2, r1
 8032304:	0031      	movs	r1, r6
 8032306:	0028      	movs	r0, r5
 8032308:	f7ff ff86 	bl	8032218 <RadioGetLoRaTimeOnAirNumerator>
 803230c:	0143      	lsls	r3, r0, #5
 803230e:	1a1b      	subs	r3, r3, r0
 8032310:	009c      	lsls	r4, r3, #2
 8032312:	1824      	adds	r4, r4, r0
 8032314:	00e4      	lsls	r4, r4, #3
            denominator = RadioGetLoRaBandwidthInHz( Bandwidths[bandwidth] );
 8032316:	4b03      	ldr	r3, [pc, #12]	; (8032324 <RadioTimeOnAir+0x74>)
 8032318:	5d58      	ldrb	r0, [r3, r5]
 803231a:	f7ff ff35 	bl	8032188 <RadioGetLoRaBandwidthInHz>
 803231e:	0006      	movs	r6, r0
        break;
 8032320:	e7d9      	b.n	80322d6 <RadioTimeOnAir+0x26>
 8032322:	46c0      	nop			; (mov r8, r8)
 8032324:	08035d88 	.word	0x08035d88

08032328 <RadioOnTxTimeoutProcess>:
{
    RADIO_RX_TIMEOUT_PROCESS();
}

static void RadioOnTxTimeoutProcess( void )
{
 8032328:	b510      	push	{r4, lr}
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BRR, PinMask);
 803232a:	4b06      	ldr	r3, [pc, #24]	; (8032344 <RadioOnTxTimeoutProcess+0x1c>)
 803232c:	2280      	movs	r2, #128	; 0x80
 803232e:	0192      	lsls	r2, r2, #6
 8032330:	629a      	str	r2, [r3, #40]	; 0x28
    DBG_GPIO_RADIO_TX( RST );

    if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 8032332:	4b05      	ldr	r3, [pc, #20]	; (8032348 <RadioOnTxTimeoutProcess+0x20>)
 8032334:	681b      	ldr	r3, [r3, #0]
 8032336:	2b00      	cmp	r3, #0
 8032338:	d003      	beq.n	8032342 <RadioOnTxTimeoutProcess+0x1a>
 803233a:	685b      	ldr	r3, [r3, #4]
 803233c:	2b00      	cmp	r3, #0
 803233e:	d000      	beq.n	8032342 <RadioOnTxTimeoutProcess+0x1a>
    {
        RadioEvents->TxTimeout( );
 8032340:	4798      	blx	r3
    }
}
 8032342:	bd10      	pop	{r4, pc}
 8032344:	48000400 	.word	0x48000400
 8032348:	2000c66c 	.word	0x2000c66c

0803234c <RadioOnTxTimeoutIrq>:
{
 803234c:	b510      	push	{r4, lr}
    RADIO_TX_TIMEOUT_PROCESS();
 803234e:	f7ff ffeb 	bl	8032328 <RadioOnTxTimeoutProcess>
}
 8032352:	bd10      	pop	{r4, pc}

08032354 <RadioOnRxTimeoutProcess>:

static void RadioOnRxTimeoutProcess( void )
{
 8032354:	b510      	push	{r4, lr}
 8032356:	4b06      	ldr	r3, [pc, #24]	; (8032370 <RadioOnRxTimeoutProcess+0x1c>)
 8032358:	2280      	movs	r2, #128	; 0x80
 803235a:	0152      	lsls	r2, r2, #5
 803235c:	629a      	str	r2, [r3, #40]	; 0x28
    DBG_GPIO_RADIO_RX( RST );

    if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 803235e:	4b05      	ldr	r3, [pc, #20]	; (8032374 <RadioOnRxTimeoutProcess+0x20>)
 8032360:	681b      	ldr	r3, [r3, #0]
 8032362:	2b00      	cmp	r3, #0
 8032364:	d003      	beq.n	803236e <RadioOnRxTimeoutProcess+0x1a>
 8032366:	68db      	ldr	r3, [r3, #12]
 8032368:	2b00      	cmp	r3, #0
 803236a:	d000      	beq.n	803236e <RadioOnRxTimeoutProcess+0x1a>
    {
        RadioEvents->RxTimeout( );
 803236c:	4798      	blx	r3
    }
}
 803236e:	bd10      	pop	{r4, pc}
 8032370:	48000400 	.word	0x48000400
 8032374:	2000c66c 	.word	0x2000c66c

08032378 <RadioOnRxTimeoutIrq>:
{
 8032378:	b510      	push	{r4, lr}
    RADIO_RX_TIMEOUT_PROCESS();
 803237a:	f7ff ffeb 	bl	8032354 <RadioOnRxTimeoutProcess>
}
 803237e:	bd10      	pop	{r4, pc}

08032380 <RadioSetRxGenericConfig>:
    default:
        break;
    }
    return status;
#else /* RADIO_GENERIC_CONFIG_ENABLE == 1*/
    return -1;
 8032380:	2001      	movs	r0, #1
#endif /* RADIO_GENERIC_CONFIG_ENABLE == 0*/
}
 8032382:	4240      	negs	r0, r0
 8032384:	4770      	bx	lr

08032386 <RadioSetTxGenericConfig>:
    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect );
    SubgRf.TxTimeout = timeout;
    return 0;
#else /* RADIO_GENERIC_CONFIG_ENABLE == 1*/
    return -1;
 8032386:	2001      	movs	r0, #1
#endif /* RADIO_GENERIC_CONFIG_ENABLE == 0*/
}
 8032388:	4240      	negs	r0, r0
 803238a:	4770      	bx	lr

0803238c <RadioLrFhssSetCfg>:
        return status;
    }
    SubgRf.lr_fhss.is_lr_fhss_on = true;
#endif /* RADIO_LR_FHSS_IS_ON == 1 */
    return  status;
}
 803238c:	2001      	movs	r0, #1
 803238e:	4770      	bx	lr

08032390 <RadioLrFhssGetTimeOnAirInMs>:

    return RADIO_STATUS_OK;
#else
    return RADIO_STATUS_UNSUPPORTED_FEATURE;
#endif /* RADIO_LR_FHSS_IS_ON */
 8032390:	2001      	movs	r0, #1
 8032392:	4770      	bx	lr

08032394 <RadioWrite>:
{
 8032394:	b510      	push	{r4, lr}
    SUBGRF_WriteRegister( addr, data );
 8032396:	f000 fe53 	bl	8033040 <SUBGRF_WriteRegister>
}
 803239a:	bd10      	pop	{r4, pc}

0803239c <RadioTxCw>:
{
 803239c:	b510      	push	{r4, lr}
    uint8_t paselect = SUBGRF_SetRfTxPower( power );
 803239e:	f001 fba7 	bl	8033af0 <SUBGRF_SetRfTxPower>
 80323a2:	0004      	movs	r4, r0
    SUBGRF_WriteRegister(REG_DRV_CTRL, 0x7 << 1);
 80323a4:	210e      	movs	r1, #14
 80323a6:	4805      	ldr	r0, [pc, #20]	; (80323bc <RadioTxCw+0x20>)
 80323a8:	f000 fe4a 	bl	8033040 <SUBGRF_WriteRegister>
    SUBGRF_SetSwitch( paselect, RFSWITCH_TX );
 80323ac:	2101      	movs	r1, #1
 80323ae:	0020      	movs	r0, r4
 80323b0:	f001 fb8a 	bl	8033ac8 <SUBGRF_SetSwitch>
    SUBGRF_SetTxContinuousWave( );
 80323b4:	f001 f802 	bl	80333bc <SUBGRF_SetTxContinuousWave>
}
 80323b8:	bd10      	pop	{r4, pc}
 80323ba:	46c0      	nop			; (mov r8, r8)
 80323bc:	0000091f 	.word	0x0000091f

080323c0 <RadioTxPrbs>:
{
 80323c0:	b510      	push	{r4, lr}
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_TX );
 80323c2:	4a08      	ldr	r2, [pc, #32]	; (80323e4 <RadioTxPrbs+0x24>)
 80323c4:	2356      	movs	r3, #86	; 0x56
 80323c6:	5cd0      	ldrb	r0, [r2, r3]
 80323c8:	2101      	movs	r1, #1
 80323ca:	f001 fb7d 	bl	8033ac8 <SUBGRF_SetSwitch>
    Radio.Write( SUBGHZ_GPKTCTL1AR, 0x2d );  // sel mode prbs9 instead of preamble
 80323ce:	20d7      	movs	r0, #215	; 0xd7
 80323d0:	212d      	movs	r1, #45	; 0x2d
 80323d2:	00c0      	lsls	r0, r0, #3
 80323d4:	f7ff ffde 	bl	8032394 <RadioWrite>
    SUBGRF_SetTxInfinitePreamble( );
 80323d8:	f000 fff7 	bl	80333ca <SUBGRF_SetTxInfinitePreamble>
    SUBGRF_SetTx( 0x0fffff );
 80323dc:	4802      	ldr	r0, [pc, #8]	; (80323e8 <RadioTxPrbs+0x28>)
 80323de:	f000 ff45 	bl	803326c <SUBGRF_SetTx>
}
 80323e2:	bd10      	pop	{r4, pc}
 80323e4:	2000c688 	.word	0x2000c688
 80323e8:	000fffff 	.word	0x000fffff

080323ec <RadioSetRxDutyCycle>:
{
 80323ec:	b570      	push	{r4, r5, r6, lr}
 80323ee:	0004      	movs	r4, r0
 80323f0:	000d      	movs	r5, r1
    SubgRf.RxDcPreambleDetectTimeout = 2 * rxTime + sleepTime;
 80323f2:	0043      	lsls	r3, r0, #1
 80323f4:	185b      	adds	r3, r3, r1
 80323f6:	4e09      	ldr	r6, [pc, #36]	; (803241c <RadioSetRxDutyCycle+0x30>)
 80323f8:	65b3      	str	r3, [r6, #88]	; 0x58
    SUBGRF_SetDioIrqParams( IRQ_RADIO_ALL, IRQ_RADIO_ALL, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 80323fa:	4809      	ldr	r0, [pc, #36]	; (8032420 <RadioSetRxDutyCycle+0x34>)
 80323fc:	2300      	movs	r3, #0
 80323fe:	2200      	movs	r2, #0
 8032400:	0001      	movs	r1, r0
 8032402:	f001 f8a5 	bl	8033550 <SUBGRF_SetDioIrqParams>
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_RX );
 8032406:	2356      	movs	r3, #86	; 0x56
 8032408:	5cf0      	ldrb	r0, [r6, r3]
 803240a:	2100      	movs	r1, #0
 803240c:	f001 fb5c 	bl	8033ac8 <SUBGRF_SetSwitch>
    SUBGRF_SetRxDutyCycle( rxTime, sleepTime );
 8032410:	0029      	movs	r1, r5
 8032412:	0020      	movs	r0, r4
 8032414:	f000 ffac 	bl	8033370 <SUBGRF_SetRxDutyCycle>
}
 8032418:	bd70      	pop	{r4, r5, r6, pc}
 803241a:	46c0      	nop			; (mov r8, r8)
 803241c:	2000c688 	.word	0x2000c688
 8032420:	0000ffff 	.word	0x0000ffff

08032424 <RadioRxBoosted>:
{
 8032424:	b570      	push	{r4, r5, r6, lr}
 8032426:	0004      	movs	r4, r0
    if( 1UL == RFW_Is_Init() )
 8032428:	f001 fc3f 	bl	8033caa <RFW_Is_Init>
 803242c:	2801      	cmp	r0, #1
 803242e:	d01a      	beq.n	8032466 <RadioRxBoosted+0x42>
        SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 8032430:	4816      	ldr	r0, [pc, #88]	; (803248c <RadioRxBoosted+0x68>)
 8032432:	2300      	movs	r3, #0
 8032434:	2200      	movs	r2, #0
 8032436:	0001      	movs	r1, r0
 8032438:	f001 f88a 	bl	8033550 <SUBGRF_SetDioIrqParams>
    if( timeout != 0 )
 803243c:	2c00      	cmp	r4, #0
 803243e:	d115      	bne.n	803246c <RadioRxBoosted+0x48>
    SubgRf.RxDcPreambleDetectTimeout = 0;
 8032440:	4c13      	ldr	r4, [pc, #76]	; (8032490 <RadioRxBoosted+0x6c>)
 8032442:	2300      	movs	r3, #0
 8032444:	65a3      	str	r3, [r4, #88]	; 0x58
  WRITE_REG(GPIOx->BSRR, PinMask);
 8032446:	4b13      	ldr	r3, [pc, #76]	; (8032494 <RadioRxBoosted+0x70>)
 8032448:	2280      	movs	r2, #128	; 0x80
 803244a:	0152      	lsls	r2, r2, #5
 803244c:	619a      	str	r2, [r3, #24]
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_RX );
 803244e:	2356      	movs	r3, #86	; 0x56
 8032450:	5ce0      	ldrb	r0, [r4, r3]
 8032452:	2100      	movs	r1, #0
 8032454:	f001 fb38 	bl	8033ac8 <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 8032458:	7863      	ldrb	r3, [r4, #1]
 803245a:	2b00      	cmp	r3, #0
 803245c:	d00f      	beq.n	803247e <RadioRxBoosted+0x5a>
        SUBGRF_SetRxBoosted( 0xFFFFFF ); // Rx Continuous
 803245e:	480e      	ldr	r0, [pc, #56]	; (8032498 <RadioRxBoosted+0x74>)
 8032460:	f000 ff6c 	bl	803333c <SUBGRF_SetRxBoosted>
}
 8032464:	bd70      	pop	{r4, r5, r6, pc}
        RFW_ReceiveInit();
 8032466:	f001 fc28 	bl	8033cba <RFW_ReceiveInit>
 803246a:	e7e7      	b.n	803243c <RadioRxBoosted+0x18>
        TimerSetValue( &RxTimeoutTimer, timeout );
 803246c:	4d0b      	ldr	r5, [pc, #44]	; (803249c <RadioRxBoosted+0x78>)
 803246e:	0021      	movs	r1, r4
 8032470:	0028      	movs	r0, r5
 8032472:	f002 f937 	bl	80346e4 <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 8032476:	0028      	movs	r0, r5
 8032478:	f002 f8ee 	bl	8034658 <UTIL_TIMER_Start>
 803247c:	e7e0      	b.n	8032440 <RadioRxBoosted+0x1c>
        SUBGRF_SetRxBoosted( SubgRf.RxTimeout << 6 );
 803247e:	4b04      	ldr	r3, [pc, #16]	; (8032490 <RadioRxBoosted+0x6c>)
 8032480:	6898      	ldr	r0, [r3, #8]
 8032482:	0180      	lsls	r0, r0, #6
 8032484:	f000 ff5a 	bl	803333c <SUBGRF_SetRxBoosted>
}
 8032488:	e7ec      	b.n	8032464 <RadioRxBoosted+0x40>
 803248a:	46c0      	nop			; (mov r8, r8)
 803248c:	00000262 	.word	0x00000262
 8032490:	2000c688 	.word	0x2000c688
 8032494:	48000400 	.word	0x48000400
 8032498:	00ffffff 	.word	0x00ffffff
 803249c:	2000c670 	.word	0x2000c670

080324a0 <RadioStandby>:
{
 80324a0:	b510      	push	{r4, lr}
    SUBGRF_SetStandby( STDBY_RC );
 80324a2:	2000      	movs	r0, #0
 80324a4:	f000 feca 	bl	803323c <SUBGRF_SetStandby>
}
 80324a8:	bd10      	pop	{r4, pc}

080324aa <RadioRead>:
{
 80324aa:	b510      	push	{r4, lr}
    return SUBGRF_ReadRegister( addr );
 80324ac:	f000 fdd6 	bl	803305c <SUBGRF_ReadRegister>
}
 80324b0:	bd10      	pop	{r4, pc}

080324b2 <RadioGetStatus>:
{
 80324b2:	b510      	push	{r4, lr}
    switch( SUBGRF_GetOperatingMode( ) )
 80324b4:	f000 fdb8 	bl	8033028 <SUBGRF_GetOperatingMode>
 80324b8:	2805      	cmp	r0, #5
 80324ba:	d007      	beq.n	80324cc <RadioGetStatus+0x1a>
 80324bc:	2807      	cmp	r0, #7
 80324be:	d007      	beq.n	80324d0 <RadioGetStatus+0x1e>
 80324c0:	2804      	cmp	r0, #4
 80324c2:	d001      	beq.n	80324c8 <RadioGetStatus+0x16>
            return RF_IDLE;
 80324c4:	2000      	movs	r0, #0
}
 80324c6:	bd10      	pop	{r4, pc}
    switch( SUBGRF_GetOperatingMode( ) )
 80324c8:	3802      	subs	r0, #2
 80324ca:	e7fc      	b.n	80324c6 <RadioGetStatus+0x14>
            return RF_RX_RUNNING;
 80324cc:	2001      	movs	r0, #1
 80324ce:	e7fa      	b.n	80324c6 <RadioGetStatus+0x14>
            return RF_CAD;
 80324d0:	2003      	movs	r0, #3
 80324d2:	e7f8      	b.n	80324c6 <RadioGetStatus+0x14>

080324d4 <RadioIrqProcess>:
{
 80324d4:	b530      	push	{r4, r5, lr}
 80324d6:	b083      	sub	sp, #12
    uint8_t size = 0;
 80324d8:	2300      	movs	r3, #0
 80324da:	466a      	mov	r2, sp
 80324dc:	71d3      	strb	r3, [r2, #7]
    int32_t cfo = 0;
 80324de:	9300      	str	r3, [sp, #0]
    switch( SubgRf.RadioIrq )
 80324e0:	4aad      	ldr	r2, [pc, #692]	; (8032798 <RadioIrqProcess+0x2c4>)
 80324e2:	3354      	adds	r3, #84	; 0x54
 80324e4:	5ad3      	ldrh	r3, [r2, r3]
 80324e6:	2b20      	cmp	r3, #32
 80324e8:	d80a      	bhi.n	8032500 <RadioIrqProcess+0x2c>
 80324ea:	b21a      	sxth	r2, r3
 80324ec:	2a00      	cmp	r2, #0
 80324ee:	d100      	bne.n	80324f2 <RadioIrqProcess+0x1e>
 80324f0:	e11f      	b.n	8032732 <RadioIrqProcess+0x25e>
 80324f2:	2b20      	cmp	r3, #32
 80324f4:	d900      	bls.n	80324f8 <RadioIrqProcess+0x24>
 80324f6:	e11c      	b.n	8032732 <RadioIrqProcess+0x25e>
 80324f8:	009b      	lsls	r3, r3, #2
 80324fa:	4aa8      	ldr	r2, [pc, #672]	; (803279c <RadioIrqProcess+0x2c8>)
 80324fc:	58d3      	ldr	r3, [r2, r3]
 80324fe:	469f      	mov	pc, r3
 8032500:	2280      	movs	r2, #128	; 0x80
 8032502:	0052      	lsls	r2, r2, #1
 8032504:	4293      	cmp	r3, r2
 8032506:	d100      	bne.n	803250a <RadioIrqProcess+0x36>
 8032508:	e0b3      	b.n	8032672 <RadioIrqProcess+0x19e>
 803250a:	d929      	bls.n	8032560 <RadioIrqProcess+0x8c>
 803250c:	2280      	movs	r2, #128	; 0x80
 803250e:	0092      	lsls	r2, r2, #2
 8032510:	4293      	cmp	r3, r2
 8032512:	d000      	beq.n	8032516 <RadioIrqProcess+0x42>
 8032514:	e10d      	b.n	8032732 <RadioIrqProcess+0x25e>
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_RX_TX_TIMEOUT\r\n" );
 8032516:	4ba2      	ldr	r3, [pc, #648]	; (80327a0 <RadioIrqProcess+0x2cc>)
 8032518:	2201      	movs	r2, #1
 803251a:	2100      	movs	r1, #0
 803251c:	2002      	movs	r0, #2
 803251e:	f001 fca7 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
        if( SUBGRF_GetOperatingMode( ) == MODE_TX )
 8032522:	f000 fd81 	bl	8033028 <SUBGRF_GetOperatingMode>
 8032526:	2804      	cmp	r0, #4
 8032528:	d100      	bne.n	803252c <RadioIrqProcess+0x58>
 803252a:	e0af      	b.n	803268c <RadioIrqProcess+0x1b8>
        else if( SUBGRF_GetOperatingMode( ) == MODE_RX )
 803252c:	f000 fd7c 	bl	8033028 <SUBGRF_GetOperatingMode>
 8032530:	2805      	cmp	r0, #5
 8032532:	d000      	beq.n	8032536 <RadioIrqProcess+0x62>
 8032534:	e0fd      	b.n	8032732 <RadioIrqProcess+0x25e>
  WRITE_REG(GPIOx->BRR, PinMask);
 8032536:	4b9b      	ldr	r3, [pc, #620]	; (80327a4 <RadioIrqProcess+0x2d0>)
 8032538:	2280      	movs	r2, #128	; 0x80
 803253a:	0152      	lsls	r2, r2, #5
 803253c:	629a      	str	r2, [r3, #40]	; 0x28
            TimerStop( &RxTimeoutTimer );
 803253e:	489a      	ldr	r0, [pc, #616]	; (80327a8 <RadioIrqProcess+0x2d4>)
 8032540:	f002 f828 	bl	8034594 <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 8032544:	2000      	movs	r0, #0
 8032546:	f000 fe79 	bl	803323c <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 803254a:	4b98      	ldr	r3, [pc, #608]	; (80327ac <RadioIrqProcess+0x2d8>)
 803254c:	681b      	ldr	r3, [r3, #0]
 803254e:	2b00      	cmp	r3, #0
 8032550:	d100      	bne.n	8032554 <RadioIrqProcess+0x80>
 8032552:	e0ee      	b.n	8032732 <RadioIrqProcess+0x25e>
 8032554:	68db      	ldr	r3, [r3, #12]
 8032556:	2b00      	cmp	r3, #0
 8032558:	d100      	bne.n	803255c <RadioIrqProcess+0x88>
 803255a:	e0ea      	b.n	8032732 <RadioIrqProcess+0x25e>
                RadioEvents->RxTimeout( );
 803255c:	4798      	blx	r3
 803255e:	e0e8      	b.n	8032732 <RadioIrqProcess+0x25e>
    switch( SubgRf.RadioIrq )
 8032560:	2b40      	cmp	r3, #64	; 0x40
 8032562:	d100      	bne.n	8032566 <RadioIrqProcess+0x92>
 8032564:	e101      	b.n	803276a <RadioIrqProcess+0x296>
 8032566:	2b80      	cmp	r3, #128	; 0x80
 8032568:	d000      	beq.n	803256c <RadioIrqProcess+0x98>
 803256a:	e0e2      	b.n	8032732 <RadioIrqProcess+0x25e>
        SUBGRF_SetStandby( STDBY_RC );
 803256c:	2000      	movs	r0, #0
 803256e:	f000 fe65 	bl	803323c <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 8032572:	4b8e      	ldr	r3, [pc, #568]	; (80327ac <RadioIrqProcess+0x2d8>)
 8032574:	681b      	ldr	r3, [r3, #0]
 8032576:	2b00      	cmp	r3, #0
 8032578:	d100      	bne.n	803257c <RadioIrqProcess+0xa8>
 803257a:	e0da      	b.n	8032732 <RadioIrqProcess+0x25e>
 803257c:	699b      	ldr	r3, [r3, #24]
 803257e:	2b00      	cmp	r3, #0
 8032580:	d100      	bne.n	8032584 <RadioIrqProcess+0xb0>
 8032582:	e0d6      	b.n	8032732 <RadioIrqProcess+0x25e>
            RadioEvents->CadDone( false );
 8032584:	2000      	movs	r0, #0
 8032586:	4798      	blx	r3
 8032588:	e0d3      	b.n	8032732 <RadioIrqProcess+0x25e>
 803258a:	4b86      	ldr	r3, [pc, #536]	; (80327a4 <RadioIrqProcess+0x2d0>)
 803258c:	2280      	movs	r2, #128	; 0x80
 803258e:	0192      	lsls	r2, r2, #6
 8032590:	629a      	str	r2, [r3, #40]	; 0x28
        TimerStop( &TxTimeoutTimer );
 8032592:	4887      	ldr	r0, [pc, #540]	; (80327b0 <RadioIrqProcess+0x2dc>)
 8032594:	f001 fffe 	bl	8034594 <UTIL_TIMER_Stop>
        SUBGRF_SetStandby( STDBY_RC );
 8032598:	2000      	movs	r0, #0
 803259a:	f000 fe4f 	bl	803323c <SUBGRF_SetStandby>
        if( RFW_Is_LongPacketModeEnabled() == 1 )
 803259e:	f001 fb86 	bl	8033cae <RFW_Is_LongPacketModeEnabled>
 80325a2:	2801      	cmp	r0, #1
 80325a4:	d00a      	beq.n	80325bc <RadioIrqProcess+0xe8>
        if( ( RadioEvents != NULL ) && ( RadioEvents->TxDone != NULL ) )
 80325a6:	4b81      	ldr	r3, [pc, #516]	; (80327ac <RadioIrqProcess+0x2d8>)
 80325a8:	681b      	ldr	r3, [r3, #0]
 80325aa:	2b00      	cmp	r3, #0
 80325ac:	d100      	bne.n	80325b0 <RadioIrqProcess+0xdc>
 80325ae:	e0c0      	b.n	8032732 <RadioIrqProcess+0x25e>
 80325b0:	681b      	ldr	r3, [r3, #0]
 80325b2:	2b00      	cmp	r3, #0
 80325b4:	d100      	bne.n	80325b8 <RadioIrqProcess+0xe4>
 80325b6:	e0bc      	b.n	8032732 <RadioIrqProcess+0x25e>
            RadioEvents->TxDone( );
 80325b8:	4798      	blx	r3
 80325ba:	e0ba      	b.n	8032732 <RadioIrqProcess+0x25e>
            RFW_DeInit_TxLongPacket( );
 80325bc:	f001 fb80 	bl	8033cc0 <RFW_DeInit_TxLongPacket>
 80325c0:	e7f1      	b.n	80325a6 <RadioIrqProcess+0xd2>
 80325c2:	4b78      	ldr	r3, [pc, #480]	; (80327a4 <RadioIrqProcess+0x2d0>)
 80325c4:	2280      	movs	r2, #128	; 0x80
 80325c6:	0152      	lsls	r2, r2, #5
 80325c8:	629a      	str	r2, [r3, #40]	; 0x28
        TimerStop( &RxTimeoutTimer );
 80325ca:	4877      	ldr	r0, [pc, #476]	; (80327a8 <RadioIrqProcess+0x2d4>)
 80325cc:	f001 ffe2 	bl	8034594 <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 80325d0:	4b71      	ldr	r3, [pc, #452]	; (8032798 <RadioIrqProcess+0x2c4>)
 80325d2:	785b      	ldrb	r3, [r3, #1]
 80325d4:	2b00      	cmp	r3, #0
 80325d6:	d021      	beq.n	803261c <RadioIrqProcess+0x148>
        SUBGRF_GetPayload( RadioBuffer, &size, 255 );
 80325d8:	22ff      	movs	r2, #255	; 0xff
 80325da:	466b      	mov	r3, sp
 80325dc:	1dd9      	adds	r1, r3, #7
 80325de:	4875      	ldr	r0, [pc, #468]	; (80327b4 <RadioIrqProcess+0x2e0>)
 80325e0:	f001 fa1e 	bl	8033a20 <SUBGRF_GetPayload>
        SUBGRF_GetPacketStatus( &( SubgRf.PacketStatus ) );
 80325e4:	486c      	ldr	r0, [pc, #432]	; (8032798 <RadioIrqProcess+0x2c4>)
 80325e6:	3024      	adds	r0, #36	; 0x24
 80325e8:	f001 fa34 	bl	8033a54 <SUBGRF_GetPacketStatus>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxDone != NULL ) )
 80325ec:	4b6f      	ldr	r3, [pc, #444]	; (80327ac <RadioIrqProcess+0x2d8>)
 80325ee:	681b      	ldr	r3, [r3, #0]
 80325f0:	2b00      	cmp	r3, #0
 80325f2:	d100      	bne.n	80325f6 <RadioIrqProcess+0x122>
 80325f4:	e09d      	b.n	8032732 <RadioIrqProcess+0x25e>
 80325f6:	689c      	ldr	r4, [r3, #8]
 80325f8:	2c00      	cmp	r4, #0
 80325fa:	d100      	bne.n	80325fe <RadioIrqProcess+0x12a>
 80325fc:	e099      	b.n	8032732 <RadioIrqProcess+0x25e>
            switch( SubgRf.PacketStatus.packetType )
 80325fe:	4a66      	ldr	r2, [pc, #408]	; (8032798 <RadioIrqProcess+0x2c4>)
 8032600:	2324      	movs	r3, #36	; 0x24
 8032602:	5cd3      	ldrb	r3, [r2, r3]
 8032604:	2b01      	cmp	r3, #1
 8032606:	d11b      	bne.n	8032640 <RadioIrqProcess+0x16c>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.LoRa.RssiPkt,
 8032608:	3330      	adds	r3, #48	; 0x30
 803260a:	56d3      	ldrsb	r3, [r2, r3]
 803260c:	2130      	movs	r1, #48	; 0x30
 803260e:	5652      	ldrsb	r2, [r2, r1]
 8032610:	4669      	mov	r1, sp
 8032612:	3107      	adds	r1, #7
 8032614:	7809      	ldrb	r1, [r1, #0]
 8032616:	4867      	ldr	r0, [pc, #412]	; (80327b4 <RadioIrqProcess+0x2e0>)
 8032618:	47a0      	blx	r4
                break;
 803261a:	e08a      	b.n	8032732 <RadioIrqProcess+0x25e>
            SUBGRF_SetStandby( STDBY_RC );
 803261c:	2000      	movs	r0, #0
 803261e:	f000 fe0d 	bl	803323c <SUBGRF_SetStandby>
            SUBGRF_WriteRegister( SUBGHZ_RTCCTLR, 0x00 );
 8032622:	2100      	movs	r1, #0
 8032624:	4864      	ldr	r0, [pc, #400]	; (80327b8 <RadioIrqProcess+0x2e4>)
 8032626:	f000 fd0b 	bl	8033040 <SUBGRF_WriteRegister>
            SUBGRF_WriteRegister( SUBGHZ_EVENTMASKR, SUBGRF_ReadRegister( SUBGHZ_EVENTMASKR ) | ( 1 << 1 ) );
 803262a:	4c64      	ldr	r4, [pc, #400]	; (80327bc <RadioIrqProcess+0x2e8>)
 803262c:	0020      	movs	r0, r4
 803262e:	f000 fd15 	bl	803305c <SUBGRF_ReadRegister>
 8032632:	2102      	movs	r1, #2
 8032634:	4301      	orrs	r1, r0
 8032636:	b2c9      	uxtb	r1, r1
 8032638:	0020      	movs	r0, r4
 803263a:	f000 fd01 	bl	8033040 <SUBGRF_WriteRegister>
 803263e:	e7cb      	b.n	80325d8 <RadioIrqProcess+0x104>
                SUBGRF_GetCFO( SubgRf.ModulationParams.Params.Gfsk.BitRate, &cfo );
 8032640:	4c55      	ldr	r4, [pc, #340]	; (8032798 <RadioIrqProcess+0x2c4>)
 8032642:	4669      	mov	r1, sp
 8032644:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8032646:	f001 fae5 	bl	8033c14 <SUBGRF_GetCFO>
                RadioEvents->RxDone( RadioBuffer, size, SubgRf.PacketStatus.Params.Gfsk.RssiAvg, ( int8_t ) DIVR( cfo, 1000 ) );
 803264a:	4b58      	ldr	r3, [pc, #352]	; (80327ac <RadioIrqProcess+0x2d8>)
 803264c:	681b      	ldr	r3, [r3, #0]
 803264e:	689d      	ldr	r5, [r3, #8]
 8032650:	2329      	movs	r3, #41	; 0x29
 8032652:	56e4      	ldrsb	r4, [r4, r3]
 8032654:	9800      	ldr	r0, [sp, #0]
 8032656:	30f5      	adds	r0, #245	; 0xf5
 8032658:	30ff      	adds	r0, #255	; 0xff
 803265a:	21fa      	movs	r1, #250	; 0xfa
 803265c:	0089      	lsls	r1, r1, #2
 803265e:	f7ed fde5 	bl	802022c <__divsi3>
 8032662:	b243      	sxtb	r3, r0
 8032664:	b222      	sxth	r2, r4
 8032666:	4669      	mov	r1, sp
 8032668:	3107      	adds	r1, #7
 803266a:	7809      	ldrb	r1, [r1, #0]
 803266c:	4851      	ldr	r0, [pc, #324]	; (80327b4 <RadioIrqProcess+0x2e0>)
 803266e:	47a8      	blx	r5
                break;
 8032670:	e05f      	b.n	8032732 <RadioIrqProcess+0x25e>
        SUBGRF_SetStandby( STDBY_RC );
 8032672:	2000      	movs	r0, #0
 8032674:	f000 fde2 	bl	803323c <SUBGRF_SetStandby>
        if( ( RadioEvents != NULL ) && ( RadioEvents->CadDone != NULL ) )
 8032678:	4b4c      	ldr	r3, [pc, #304]	; (80327ac <RadioIrqProcess+0x2d8>)
 803267a:	681b      	ldr	r3, [r3, #0]
 803267c:	2b00      	cmp	r3, #0
 803267e:	d058      	beq.n	8032732 <RadioIrqProcess+0x25e>
 8032680:	699b      	ldr	r3, [r3, #24]
 8032682:	2b00      	cmp	r3, #0
 8032684:	d055      	beq.n	8032732 <RadioIrqProcess+0x25e>
            RadioEvents->CadDone( true );
 8032686:	2001      	movs	r0, #1
 8032688:	4798      	blx	r3
 803268a:	e052      	b.n	8032732 <RadioIrqProcess+0x25e>
 803268c:	4b45      	ldr	r3, [pc, #276]	; (80327a4 <RadioIrqProcess+0x2d0>)
 803268e:	2280      	movs	r2, #128	; 0x80
 8032690:	0192      	lsls	r2, r2, #6
 8032692:	629a      	str	r2, [r3, #40]	; 0x28
            TimerStop( &TxTimeoutTimer );
 8032694:	4846      	ldr	r0, [pc, #280]	; (80327b0 <RadioIrqProcess+0x2dc>)
 8032696:	f001 ff7d 	bl	8034594 <UTIL_TIMER_Stop>
            SUBGRF_SetStandby( STDBY_RC );
 803269a:	2000      	movs	r0, #0
 803269c:	f000 fdce 	bl	803323c <SUBGRF_SetStandby>
            if( ( RadioEvents != NULL ) && ( RadioEvents->TxTimeout != NULL ) )
 80326a0:	4b42      	ldr	r3, [pc, #264]	; (80327ac <RadioIrqProcess+0x2d8>)
 80326a2:	681b      	ldr	r3, [r3, #0]
 80326a4:	2b00      	cmp	r3, #0
 80326a6:	d044      	beq.n	8032732 <RadioIrqProcess+0x25e>
 80326a8:	685b      	ldr	r3, [r3, #4]
 80326aa:	2b00      	cmp	r3, #0
 80326ac:	d041      	beq.n	8032732 <RadioIrqProcess+0x25e>
                RadioEvents->TxTimeout( );
 80326ae:	4798      	blx	r3
 80326b0:	e03f      	b.n	8032732 <RadioIrqProcess+0x25e>
        MW_LOG( TS_ON, VLEVEL_M,  "PRE OK\r\n" );
 80326b2:	4b43      	ldr	r3, [pc, #268]	; (80327c0 <RadioIrqProcess+0x2ec>)
 80326b4:	2201      	movs	r2, #1
 80326b6:	2100      	movs	r1, #0
 80326b8:	2002      	movs	r0, #2
 80326ba:	f001 fbd9 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
        if( SubgRf.RxDcPreambleDetectTimeout != 0 )
 80326be:	4b36      	ldr	r3, [pc, #216]	; (8032798 <RadioIrqProcess+0x2c4>)
 80326c0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80326c2:	2b00      	cmp	r3, #0
 80326c4:	d035      	beq.n	8032732 <RadioIrqProcess+0x25e>
            Radio.Write( SUBGHZ_RTCPRDR2, ( SubgRf.RxDcPreambleDetectTimeout >> 16 ) & 0xFF ); /*Update Radio RTC Period MSB*/
 80326c6:	0c1b      	lsrs	r3, r3, #16
 80326c8:	b2d9      	uxtb	r1, r3
 80326ca:	483e      	ldr	r0, [pc, #248]	; (80327c4 <RadioIrqProcess+0x2f0>)
 80326cc:	f7ff fe62 	bl	8032394 <RadioWrite>
            Radio.Write( SUBGHZ_RTCPRDR1, ( SubgRf.RxDcPreambleDetectTimeout >> 8 ) & 0xFF ); /*Update Radio RTC Period MidByte*/
 80326d0:	4c31      	ldr	r4, [pc, #196]	; (8032798 <RadioIrqProcess+0x2c4>)
 80326d2:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80326d4:	0a19      	lsrs	r1, r3, #8
 80326d6:	b2c9      	uxtb	r1, r1
 80326d8:	483b      	ldr	r0, [pc, #236]	; (80327c8 <RadioIrqProcess+0x2f4>)
 80326da:	f7ff fe5b 	bl	8032394 <RadioWrite>
            Radio.Write( SUBGHZ_RTCPRDR0, ( SubgRf.RxDcPreambleDetectTimeout ) & 0xFF ); /*Update Radio RTC Period lsb*/
 80326de:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80326e0:	b2d9      	uxtb	r1, r3
 80326e2:	483a      	ldr	r0, [pc, #232]	; (80327cc <RadioIrqProcess+0x2f8>)
 80326e4:	f7ff fe56 	bl	8032394 <RadioWrite>
            Radio.Write( SUBGHZ_RTCCTLR, Radio.Read( SUBGHZ_RTCCTLR ) | 0x1 ); /*restart Radio RTC*/
 80326e8:	4d33      	ldr	r5, [pc, #204]	; (80327b8 <RadioIrqProcess+0x2e4>)
 80326ea:	0028      	movs	r0, r5
 80326ec:	f7ff fedd 	bl	80324aa <RadioRead>
 80326f0:	2101      	movs	r1, #1
 80326f2:	4301      	orrs	r1, r0
 80326f4:	b2c9      	uxtb	r1, r1
 80326f6:	0028      	movs	r0, r5
 80326f8:	f7ff fe4c 	bl	8032394 <RadioWrite>
            SubgRf.RxDcPreambleDetectTimeout = 0;
 80326fc:	2300      	movs	r3, #0
 80326fe:	65a3      	str	r3, [r4, #88]	; 0x58
            SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 8032700:	4833      	ldr	r0, [pc, #204]	; (80327d0 <RadioIrqProcess+0x2fc>)
 8032702:	2200      	movs	r2, #0
 8032704:	0001      	movs	r1, r0
 8032706:	f000 ff23 	bl	8033550 <SUBGRF_SetDioIrqParams>
 803270a:	e012      	b.n	8032732 <RadioIrqProcess+0x25e>
        MW_LOG( TS_ON, VLEVEL_M,  "SYNC OK\r\n" );
 803270c:	4b31      	ldr	r3, [pc, #196]	; (80327d4 <RadioIrqProcess+0x300>)
 803270e:	2201      	movs	r2, #1
 8032710:	2100      	movs	r1, #0
 8032712:	2002      	movs	r0, #2
 8032714:	f001 fbac 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
        if( 1UL == RFW_Is_Init( ) )
 8032718:	f001 fac7 	bl	8033caa <RFW_Is_Init>
 803271c:	2801      	cmp	r0, #1
 803271e:	d108      	bne.n	8032732 <RadioIrqProcess+0x25e>
            RFW_ReceivePayload( );
 8032720:	f001 facf 	bl	8033cc2 <RFW_ReceivePayload>
 8032724:	e005      	b.n	8032732 <RadioIrqProcess+0x25e>
        MW_LOG( TS_ON, VLEVEL_M,  "HDR OK\r\n" );
 8032726:	4b2c      	ldr	r3, [pc, #176]	; (80327d8 <RadioIrqProcess+0x304>)
 8032728:	2201      	movs	r2, #1
 803272a:	2100      	movs	r1, #0
 803272c:	2002      	movs	r0, #2
 803272e:	f001 fb9f 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
}
 8032732:	b003      	add	sp, #12
 8032734:	bd30      	pop	{r4, r5, pc}
        TimerStop( &RxTimeoutTimer );
 8032736:	481c      	ldr	r0, [pc, #112]	; (80327a8 <RadioIrqProcess+0x2d4>)
 8032738:	f001 ff2c 	bl	8034594 <UTIL_TIMER_Stop>
        if( SubgRf.RxContinuous == false )
 803273c:	4b16      	ldr	r3, [pc, #88]	; (8032798 <RadioIrqProcess+0x2c4>)
 803273e:	785b      	ldrb	r3, [r3, #1]
 8032740:	2b00      	cmp	r3, #0
 8032742:	d00e      	beq.n	8032762 <RadioIrqProcess+0x28e>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxTimeout != NULL ) )
 8032744:	4b19      	ldr	r3, [pc, #100]	; (80327ac <RadioIrqProcess+0x2d8>)
 8032746:	681b      	ldr	r3, [r3, #0]
 8032748:	2b00      	cmp	r3, #0
 803274a:	d0f2      	beq.n	8032732 <RadioIrqProcess+0x25e>
 803274c:	68db      	ldr	r3, [r3, #12]
 803274e:	2b00      	cmp	r3, #0
 8032750:	d0ef      	beq.n	8032732 <RadioIrqProcess+0x25e>
            RadioEvents->RxTimeout( );
 8032752:	4798      	blx	r3
            MW_LOG( TS_ON, VLEVEL_M,  "HDR KO\r\n" );
 8032754:	4b21      	ldr	r3, [pc, #132]	; (80327dc <RadioIrqProcess+0x308>)
 8032756:	2201      	movs	r2, #1
 8032758:	2100      	movs	r1, #0
 803275a:	2002      	movs	r0, #2
 803275c:	f001 fb88 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
 8032760:	e7e7      	b.n	8032732 <RadioIrqProcess+0x25e>
            SUBGRF_SetStandby( STDBY_RC );
 8032762:	2000      	movs	r0, #0
 8032764:	f000 fd6a 	bl	803323c <SUBGRF_SetStandby>
 8032768:	e7ec      	b.n	8032744 <RadioIrqProcess+0x270>
        MW_LOG( TS_ON, VLEVEL_M,  "IRQ_CRC_ERROR\r\n" );
 803276a:	4b1d      	ldr	r3, [pc, #116]	; (80327e0 <RadioIrqProcess+0x30c>)
 803276c:	2201      	movs	r2, #1
 803276e:	2100      	movs	r1, #0
 8032770:	2002      	movs	r0, #2
 8032772:	f001 fb7d 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
        if( SubgRf.RxContinuous == false )
 8032776:	4b08      	ldr	r3, [pc, #32]	; (8032798 <RadioIrqProcess+0x2c4>)
 8032778:	785b      	ldrb	r3, [r3, #1]
 803277a:	2b00      	cmp	r3, #0
 803277c:	d008      	beq.n	8032790 <RadioIrqProcess+0x2bc>
        if( ( RadioEvents != NULL ) && ( RadioEvents->RxError ) )
 803277e:	4b0b      	ldr	r3, [pc, #44]	; (80327ac <RadioIrqProcess+0x2d8>)
 8032780:	681b      	ldr	r3, [r3, #0]
 8032782:	2b00      	cmp	r3, #0
 8032784:	d0d5      	beq.n	8032732 <RadioIrqProcess+0x25e>
 8032786:	691b      	ldr	r3, [r3, #16]
 8032788:	2b00      	cmp	r3, #0
 803278a:	d0d2      	beq.n	8032732 <RadioIrqProcess+0x25e>
            RadioEvents->RxError( );
 803278c:	4798      	blx	r3
}
 803278e:	e7d0      	b.n	8032732 <RadioIrqProcess+0x25e>
            SUBGRF_SetStandby( STDBY_RC );
 8032790:	2000      	movs	r0, #0
 8032792:	f000 fd53 	bl	803323c <SUBGRF_SetStandby>
 8032796:	e7f2      	b.n	803277e <RadioIrqProcess+0x2aa>
 8032798:	2000c688 	.word	0x2000c688
 803279c:	08035cec 	.word	0x08035cec
 80327a0:	08035c98 	.word	0x08035c98
 80327a4:	48000400 	.word	0x48000400
 80327a8:	2000c670 	.word	0x2000c670
 80327ac:	2000c66c 	.word	0x2000c66c
 80327b0:	2000c6e4 	.word	0x2000c6e4
 80327b4:	2000c56c 	.word	0x2000c56c
 80327b8:	00000902 	.word	0x00000902
 80327bc:	00000944 	.word	0x00000944
 80327c0:	08035cac 	.word	0x08035cac
 80327c4:	00000903 	.word	0x00000903
 80327c8:	00000904 	.word	0x00000904
 80327cc:	00000905 	.word	0x00000905
 80327d0:	00000262 	.word	0x00000262
 80327d4:	08035cb8 	.word	0x08035cb8
 80327d8:	08035cc4 	.word	0x08035cc4
 80327dc:	08035cd0 	.word	0x08035cd0
 80327e0:	08035cdc 	.word	0x08035cdc

080327e4 <RadioOnDioIrq>:
{
 80327e4:	b510      	push	{r4, lr}
    SubgRf.RadioIrq = radioIrq;
 80327e6:	4a03      	ldr	r2, [pc, #12]	; (80327f4 <RadioOnDioIrq+0x10>)
 80327e8:	2354      	movs	r3, #84	; 0x54
 80327ea:	52d0      	strh	r0, [r2, r3]
    RADIO_IRQ_PROCESS();
 80327ec:	f7ff fe72 	bl	80324d4 <RadioIrqProcess>
}
 80327f0:	bd10      	pop	{r4, pc}
 80327f2:	46c0      	nop			; (mov r8, r8)
 80327f4:	2000c688 	.word	0x2000c688

080327f8 <RadioGetWakeupTime>:
{
 80327f8:	b510      	push	{r4, lr}
    return SUBGRF_GetRadioWakeUpTime() + RADIO_WAKEUP_TIME;
 80327fa:	f001 f991 	bl	8033b20 <SUBGRF_GetRadioWakeUpTime>
 80327fe:	3003      	adds	r0, #3
}
 8032800:	bd10      	pop	{r4, pc}
	...

08032804 <RadioSetMaxPayloadLength>:
{
 8032804:	b510      	push	{r4, lr}
    if( modem == MODEM_LORA )
 8032806:	2801      	cmp	r0, #1
 8032808:	d004      	beq.n	8032814 <RadioSetMaxPayloadLength+0x10>
        if( SubgRf.PacketParams.Params.Gfsk.HeaderType == RADIO_PACKET_VARIABLE_LENGTH )
 803280a:	4b0a      	ldr	r3, [pc, #40]	; (8032834 <RadioSetMaxPayloadLength+0x30>)
 803280c:	7d5b      	ldrb	r3, [r3, #21]
 803280e:	2b01      	cmp	r3, #1
 8032810:	d008      	beq.n	8032824 <RadioSetMaxPayloadLength+0x20>
}
 8032812:	bd10      	pop	{r4, pc}
        SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength = max;
 8032814:	4b08      	ldr	r3, [pc, #32]	; (8032838 <RadioSetMaxPayloadLength+0x34>)
 8032816:	7019      	strb	r1, [r3, #0]
 8032818:	4806      	ldr	r0, [pc, #24]	; (8032834 <RadioSetMaxPayloadLength+0x30>)
 803281a:	77c1      	strb	r1, [r0, #31]
        SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 803281c:	300e      	adds	r0, #14
 803281e:	f001 f843 	bl	80338a8 <SUBGRF_SetPacketParams>
 8032822:	e7f6      	b.n	8032812 <RadioSetMaxPayloadLength+0xe>
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength = max;
 8032824:	4b04      	ldr	r3, [pc, #16]	; (8032838 <RadioSetMaxPayloadLength+0x34>)
 8032826:	7019      	strb	r1, [r3, #0]
 8032828:	4802      	ldr	r0, [pc, #8]	; (8032834 <RadioSetMaxPayloadLength+0x30>)
 803282a:	7581      	strb	r1, [r0, #22]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 803282c:	300e      	adds	r0, #14
 803282e:	f001 f83b 	bl	80338a8 <SUBGRF_SetPacketParams>
}
 8032832:	e7ee      	b.n	8032812 <RadioSetMaxPayloadLength+0xe>
 8032834:	2000c688 	.word	0x2000c688
 8032838:	2000b138 	.word	0x2000b138

0803283c <RadioReadRegisters>:
{
 803283c:	b510      	push	{r4, lr}
    SUBGRF_ReadRegisters( addr, buffer, size );
 803283e:	f000 fc93 	bl	8033168 <SUBGRF_ReadRegisters>
}
 8032842:	bd10      	pop	{r4, pc}

08032844 <RadioWriteRegisters>:
{
 8032844:	b510      	push	{r4, lr}
    SUBGRF_WriteRegisters( addr, buffer, size );
 8032846:	f000 fc4d 	bl	80330e4 <SUBGRF_WriteRegisters>
}
 803284a:	bd10      	pop	{r4, pc}

0803284c <RadioRssi>:
{
 803284c:	b510      	push	{r4, lr}
    return SUBGRF_GetRssiInst( );
 803284e:	f001 f8b7 	bl	80339c0 <SUBGRF_GetRssiInst>
 8032852:	b200      	sxth	r0, r0
}
 8032854:	bd10      	pop	{r4, pc}
	...

08032858 <RadioSetTxContinuousWave>:
{
 8032858:	b570      	push	{r4, r5, r6, lr}
 803285a:	000d      	movs	r5, r1
    uint32_t timeout = ( uint32_t )time * 1000;
 803285c:	0153      	lsls	r3, r2, #5
 803285e:	1a9b      	subs	r3, r3, r2
 8032860:	009c      	lsls	r4, r3, #2
 8032862:	18a4      	adds	r4, r4, r2
 8032864:	00e4      	lsls	r4, r4, #3
    SUBGRF_SetRfFrequency( freq );
 8032866:	f000 fed9 	bl	803361c <SUBGRF_SetRfFrequency>
    antswitchpow = SUBGRF_SetRfTxPower( power );
 803286a:	0028      	movs	r0, r5
 803286c:	f001 f940 	bl	8033af0 <SUBGRF_SetRfTxPower>
 8032870:	0005      	movs	r5, r0
    SUBGRF_WriteRegister(REG_DRV_CTRL, 0x7 << 1);
 8032872:	210e      	movs	r1, #14
 8032874:	4808      	ldr	r0, [pc, #32]	; (8032898 <RadioSetTxContinuousWave+0x40>)
 8032876:	f000 fbe3 	bl	8033040 <SUBGRF_WriteRegister>
    SUBGRF_SetSwitch( antswitchpow, RFSWITCH_TX );
 803287a:	2101      	movs	r1, #1
 803287c:	0028      	movs	r0, r5
 803287e:	f001 f923 	bl	8033ac8 <SUBGRF_SetSwitch>
    SUBGRF_SetTxContinuousWave( );
 8032882:	f000 fd9b 	bl	80333bc <SUBGRF_SetTxContinuousWave>
    TimerSetValue( &TxTimeoutTimer, timeout );
 8032886:	4d05      	ldr	r5, [pc, #20]	; (803289c <RadioSetTxContinuousWave+0x44>)
 8032888:	0021      	movs	r1, r4
 803288a:	0028      	movs	r0, r5
 803288c:	f001 ff2a 	bl	80346e4 <UTIL_TIMER_SetPeriod>
    TimerStart( &TxTimeoutTimer );
 8032890:	0028      	movs	r0, r5
 8032892:	f001 fee1 	bl	8034658 <UTIL_TIMER_Start>
}
 8032896:	bd70      	pop	{r4, r5, r6, pc}
 8032898:	0000091f 	.word	0x0000091f
 803289c:	2000c6e4 	.word	0x2000c6e4

080328a0 <RadioSetChannel>:
{
 80328a0:	b510      	push	{r4, lr}
    SUBGRF_SetRfFrequency( freq );
 80328a2:	f000 febb 	bl	803361c <SUBGRF_SetRfFrequency>
}
 80328a6:	bd10      	pop	{r4, pc}

080328a8 <RadioStartCad>:
{
 80328a8:	b510      	push	{r4, lr}
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_RX );
 80328aa:	4a08      	ldr	r2, [pc, #32]	; (80328cc <RadioStartCad+0x24>)
 80328ac:	2356      	movs	r3, #86	; 0x56
 80328ae:	5cd0      	ldrb	r0, [r2, r3]
 80328b0:	2100      	movs	r1, #0
 80328b2:	f001 f909 	bl	8033ac8 <SUBGRF_SetSwitch>
    SUBGRF_SetDioIrqParams( IRQ_CAD_CLEAR | IRQ_CAD_DETECTED,
 80328b6:	20c0      	movs	r0, #192	; 0xc0
 80328b8:	0040      	lsls	r0, r0, #1
 80328ba:	2300      	movs	r3, #0
 80328bc:	2200      	movs	r2, #0
 80328be:	0001      	movs	r1, r0
 80328c0:	f000 fe46 	bl	8033550 <SUBGRF_SetDioIrqParams>
    SUBGRF_SetCad( );
 80328c4:	f000 fd6e 	bl	80333a4 <SUBGRF_SetCad>
}
 80328c8:	bd10      	pop	{r4, pc}
 80328ca:	46c0      	nop			; (mov r8, r8)
 80328cc:	2000c688 	.word	0x2000c688

080328d0 <RadioRx>:
{
 80328d0:	b570      	push	{r4, r5, r6, lr}
 80328d2:	0004      	movs	r4, r0
    if( 1UL == RFW_Is_Init( ) )
 80328d4:	f001 f9e9 	bl	8033caa <RFW_Is_Init>
 80328d8:	2801      	cmp	r0, #1
 80328da:	d01a      	beq.n	8032912 <RadioRx+0x42>
        SUBGRF_SetDioIrqParams( IRQ_RX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_CRC_ERROR | IRQ_HEADER_ERROR | IRQ_RX_DBG,
 80328dc:	4816      	ldr	r0, [pc, #88]	; (8032938 <RadioRx+0x68>)
 80328de:	2300      	movs	r3, #0
 80328e0:	2200      	movs	r2, #0
 80328e2:	0001      	movs	r1, r0
 80328e4:	f000 fe34 	bl	8033550 <SUBGRF_SetDioIrqParams>
    if( timeout != 0 )
 80328e8:	2c00      	cmp	r4, #0
 80328ea:	d115      	bne.n	8032918 <RadioRx+0x48>
    SubgRf.RxDcPreambleDetectTimeout = 0;
 80328ec:	4c13      	ldr	r4, [pc, #76]	; (803293c <RadioRx+0x6c>)
 80328ee:	2300      	movs	r3, #0
 80328f0:	65a3      	str	r3, [r4, #88]	; 0x58
  WRITE_REG(GPIOx->BSRR, PinMask);
 80328f2:	4b13      	ldr	r3, [pc, #76]	; (8032940 <RadioRx+0x70>)
 80328f4:	2280      	movs	r2, #128	; 0x80
 80328f6:	0152      	lsls	r2, r2, #5
 80328f8:	619a      	str	r2, [r3, #24]
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_RX );
 80328fa:	2356      	movs	r3, #86	; 0x56
 80328fc:	5ce0      	ldrb	r0, [r4, r3]
 80328fe:	2100      	movs	r1, #0
 8032900:	f001 f8e2 	bl	8033ac8 <SUBGRF_SetSwitch>
    if( SubgRf.RxContinuous == true )
 8032904:	7863      	ldrb	r3, [r4, #1]
 8032906:	2b00      	cmp	r3, #0
 8032908:	d00f      	beq.n	803292a <RadioRx+0x5a>
        SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 803290a:	480e      	ldr	r0, [pc, #56]	; (8032944 <RadioRx+0x74>)
 803290c:	f000 fcca 	bl	80332a4 <SUBGRF_SetRx>
}
 8032910:	bd70      	pop	{r4, r5, r6, pc}
        RFW_ReceiveInit( );
 8032912:	f001 f9d2 	bl	8033cba <RFW_ReceiveInit>
 8032916:	e7e7      	b.n	80328e8 <RadioRx+0x18>
        TimerSetValue( &RxTimeoutTimer, timeout );
 8032918:	4d0b      	ldr	r5, [pc, #44]	; (8032948 <RadioRx+0x78>)
 803291a:	0021      	movs	r1, r4
 803291c:	0028      	movs	r0, r5
 803291e:	f001 fee1 	bl	80346e4 <UTIL_TIMER_SetPeriod>
        TimerStart( &RxTimeoutTimer );
 8032922:	0028      	movs	r0, r5
 8032924:	f001 fe98 	bl	8034658 <UTIL_TIMER_Start>
 8032928:	e7e0      	b.n	80328ec <RadioRx+0x1c>
        SUBGRF_SetRx( SubgRf.RxTimeout << 6 );
 803292a:	4b04      	ldr	r3, [pc, #16]	; (803293c <RadioRx+0x6c>)
 803292c:	6898      	ldr	r0, [r3, #8]
 803292e:	0180      	lsls	r0, r0, #6
 8032930:	f000 fcb8 	bl	80332a4 <SUBGRF_SetRx>
}
 8032934:	e7ec      	b.n	8032910 <RadioRx+0x40>
 8032936:	46c0      	nop			; (mov r8, r8)
 8032938:	00000262 	.word	0x00000262
 803293c:	2000c688 	.word	0x2000c688
 8032940:	48000400 	.word	0x48000400
 8032944:	00ffffff 	.word	0x00ffffff
 8032948:	2000c670 	.word	0x2000c670

0803294c <RadioSleep>:
{
 803294c:	b510      	push	{r4, lr}
    SUBGRF_SetSleep( params );
 803294e:	2004      	movs	r0, #4
 8032950:	f000 fc52 	bl	80331f8 <SUBGRF_SetSleep>
    RADIO_DELAY_MS( 2 );
 8032954:	2002      	movs	r0, #2
 8032956:	f7ef f933 	bl	8021bc0 <HAL_Delay>
}
 803295a:	bd10      	pop	{r4, pc}

0803295c <RadioSend>:
{
 803295c:	b570      	push	{r4, r5, r6, lr}
 803295e:	b082      	sub	sp, #8
 8032960:	0005      	movs	r5, r0
 8032962:	000c      	movs	r4, r1
    SUBGRF_SetDioIrqParams( IRQ_TX_DONE | IRQ_RX_TX_TIMEOUT | IRQ_TX_DBG,
 8032964:	4843      	ldr	r0, [pc, #268]	; (8032a74 <RadioSend+0x118>)
 8032966:	2300      	movs	r3, #0
 8032968:	2200      	movs	r2, #0
 803296a:	0001      	movs	r1, r0
 803296c:	f000 fdf0 	bl	8033550 <SUBGRF_SetDioIrqParams>
 8032970:	4b41      	ldr	r3, [pc, #260]	; (8032a78 <RadioSend+0x11c>)
 8032972:	2280      	movs	r2, #128	; 0x80
 8032974:	0192      	lsls	r2, r2, #6
 8032976:	619a      	str	r2, [r3, #24]
    SUBGRF_SetSwitch( SubgRf.AntSwitchPaSelect, RFSWITCH_TX );
 8032978:	4e40      	ldr	r6, [pc, #256]	; (8032a7c <RadioSend+0x120>)
 803297a:	2356      	movs	r3, #86	; 0x56
 803297c:	5cf0      	ldrb	r0, [r6, r3]
 803297e:	2101      	movs	r1, #1
 8032980:	f001 f8a2 	bl	8033ac8 <SUBGRF_SetSwitch>
    if( ( SubgRf.Modem == MODEM_LORA ) && ( SubgRf.ModulationParams.Params.LoRa.Bandwidth == LORA_BW_500 ) )
 8032984:	7833      	ldrb	r3, [r6, #0]
 8032986:	2b01      	cmp	r3, #1
 8032988:	d104      	bne.n	8032994 <RadioSend+0x38>
 803298a:	4a3c      	ldr	r2, [pc, #240]	; (8032a7c <RadioSend+0x120>)
 803298c:	3350      	adds	r3, #80	; 0x50
 803298e:	5cd3      	ldrb	r3, [r2, r3]
 8032990:	2b06      	cmp	r3, #6
 8032992:	d028      	beq.n	80329e6 <RadioSend+0x8a>
        SUBGRF_WriteRegister( SUBGHZ_SDCFG0R, SUBGRF_ReadRegister( SUBGHZ_SDCFG0R ) | ( 1 << 2 ) );
 8032994:	4e3a      	ldr	r6, [pc, #232]	; (8032a80 <RadioSend+0x124>)
 8032996:	0030      	movs	r0, r6
 8032998:	f000 fb60 	bl	803305c <SUBGRF_ReadRegister>
 803299c:	2104      	movs	r1, #4
 803299e:	4301      	orrs	r1, r0
 80329a0:	b2c9      	uxtb	r1, r1
 80329a2:	0030      	movs	r0, r6
 80329a4:	f000 fb4c 	bl	8033040 <SUBGRF_WriteRegister>
        switch( SubgRf.Modem )
 80329a8:	4b34      	ldr	r3, [pc, #208]	; (8032a7c <RadioSend+0x120>)
 80329aa:	781b      	ldrb	r3, [r3, #0]
 80329ac:	2b02      	cmp	r3, #2
 80329ae:	d034      	beq.n	8032a1a <RadioSend+0xbe>
 80329b0:	d824      	bhi.n	80329fc <RadioSend+0xa0>
 80329b2:	2b00      	cmp	r3, #0
 80329b4:	d031      	beq.n	8032a1a <RadioSend+0xbe>
 80329b6:	2b01      	cmp	r3, #1
 80329b8:	d109      	bne.n	80329ce <RadioSend+0x72>
            SubgRf.PacketParams.Params.LoRa.PayloadLength = size;
 80329ba:	4830      	ldr	r0, [pc, #192]	; (8032a7c <RadioSend+0x120>)
 80329bc:	77c4      	strb	r4, [r0, #31]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 80329be:	300e      	adds	r0, #14
 80329c0:	f000 ff72 	bl	80338a8 <SUBGRF_SetPacketParams>
            SUBGRF_SendPayload( buffer, size, 0 );
 80329c4:	2200      	movs	r2, #0
 80329c6:	0021      	movs	r1, r4
 80329c8:	0028      	movs	r0, r5
 80329ca:	f000 fc63 	bl	8033294 <SUBGRF_SendPayload>
        TimerSetValue( &TxTimeoutTimer, SubgRf.TxTimeout );
 80329ce:	4b2b      	ldr	r3, [pc, #172]	; (8032a7c <RadioSend+0x120>)
 80329d0:	6859      	ldr	r1, [r3, #4]
 80329d2:	4c2c      	ldr	r4, [pc, #176]	; (8032a84 <RadioSend+0x128>)
 80329d4:	0020      	movs	r0, r4
 80329d6:	f001 fe85 	bl	80346e4 <UTIL_TIMER_SetPeriod>
        TimerStart( &TxTimeoutTimer );
 80329da:	0020      	movs	r0, r4
 80329dc:	f001 fe3c 	bl	8034658 <UTIL_TIMER_Start>
    return RADIO_STATUS_OK;
 80329e0:	2000      	movs	r0, #0
}
 80329e2:	b002      	add	sp, #8
 80329e4:	bd70      	pop	{r4, r5, r6, pc}
        SUBGRF_WriteRegister( SUBGHZ_SDCFG0R, SUBGRF_ReadRegister( SUBGHZ_SDCFG0R ) & ~( 1 << 2 ) );
 80329e6:	4e26      	ldr	r6, [pc, #152]	; (8032a80 <RadioSend+0x124>)
 80329e8:	0030      	movs	r0, r6
 80329ea:	f000 fb37 	bl	803305c <SUBGRF_ReadRegister>
 80329ee:	2304      	movs	r3, #4
 80329f0:	4398      	bics	r0, r3
 80329f2:	b2c1      	uxtb	r1, r0
 80329f4:	0030      	movs	r0, r6
 80329f6:	f000 fb23 	bl	8033040 <SUBGRF_WriteRegister>
 80329fa:	e7d5      	b.n	80329a8 <RadioSend+0x4c>
        switch( SubgRf.Modem )
 80329fc:	2b03      	cmp	r3, #3
 80329fe:	d1e6      	bne.n	80329ce <RadioSend+0x72>
            SubgRf.PacketParams.PacketType = PACKET_TYPE_BPSK;
 8032a00:	481e      	ldr	r0, [pc, #120]	; (8032a7c <RadioSend+0x120>)
 8032a02:	2302      	movs	r3, #2
 8032a04:	7383      	strb	r3, [r0, #14]
            SubgRf.PacketParams.Params.Bpsk.PayloadLength = size;
 8032a06:	7684      	strb	r4, [r0, #26]
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8032a08:	300e      	adds	r0, #14
 8032a0a:	f000 ff4d 	bl	80338a8 <SUBGRF_SetPacketParams>
            SUBGRF_SendPayload( buffer, size, 0 );
 8032a0e:	2200      	movs	r2, #0
 8032a10:	0021      	movs	r1, r4
 8032a12:	0028      	movs	r0, r5
 8032a14:	f000 fc3e 	bl	8033294 <SUBGRF_SendPayload>
            break;
 8032a18:	e7d9      	b.n	80329ce <RadioSend+0x72>
            if ( 1UL == RFW_Is_Init( ) )
 8032a1a:	f001 f946 	bl	8033caa <RFW_Is_Init>
 8032a1e:	2801      	cmp	r0, #1
 8032a20:	d00a      	beq.n	8032a38 <RadioSend+0xdc>
                SubgRf.PacketParams.Params.Gfsk.PayloadLength = size;
 8032a22:	4816      	ldr	r0, [pc, #88]	; (8032a7c <RadioSend+0x120>)
 8032a24:	7584      	strb	r4, [r0, #22]
                SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8032a26:	300e      	adds	r0, #14
 8032a28:	f000 ff3e 	bl	80338a8 <SUBGRF_SetPacketParams>
                SUBGRF_SendPayload( buffer, size, 0 );
 8032a2c:	2200      	movs	r2, #0
 8032a2e:	0021      	movs	r1, r4
 8032a30:	0028      	movs	r0, r5
 8032a32:	f000 fc2f 	bl	8033294 <SUBGRF_SendPayload>
 8032a36:	e7ca      	b.n	80329ce <RadioSend+0x72>
                if ( 0UL == RFW_TransmitInit( buffer,size, &outsize ) )
 8032a38:	466b      	mov	r3, sp
 8032a3a:	1dda      	adds	r2, r3, #7
 8032a3c:	0021      	movs	r1, r4
 8032a3e:	0028      	movs	r0, r5
 8032a40:	f001 f938 	bl	8033cb4 <RFW_TransmitInit>
 8032a44:	2800      	cmp	r0, #0
 8032a46:	d10d      	bne.n	8032a64 <RadioSend+0x108>
                    SubgRf.PacketParams.Params.Gfsk.PayloadLength = outsize;
 8032a48:	480c      	ldr	r0, [pc, #48]	; (8032a7c <RadioSend+0x120>)
 8032a4a:	466b      	mov	r3, sp
 8032a4c:	1ddc      	adds	r4, r3, #7
 8032a4e:	79db      	ldrb	r3, [r3, #7]
 8032a50:	7583      	strb	r3, [r0, #22]
                    SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8032a52:	300e      	adds	r0, #14
 8032a54:	f000 ff28 	bl	80338a8 <SUBGRF_SetPacketParams>
                    SUBGRF_SendPayload( buffer, outsize, 0 );
 8032a58:	7821      	ldrb	r1, [r4, #0]
 8032a5a:	2200      	movs	r2, #0
 8032a5c:	0028      	movs	r0, r5
 8032a5e:	f000 fc19 	bl	8033294 <SUBGRF_SendPayload>
 8032a62:	e7b4      	b.n	80329ce <RadioSend+0x72>
                    MW_LOG( TS_ON, VLEVEL_M, "RadioSend Oversize\r\n" );
 8032a64:	4b08      	ldr	r3, [pc, #32]	; (8032a88 <RadioSend+0x12c>)
 8032a66:	2201      	movs	r2, #1
 8032a68:	2100      	movs	r1, #0
 8032a6a:	2002      	movs	r0, #2
 8032a6c:	f001 fa00 	bl	8033e70 <UTIL_ADV_TRACE_COND_FSend>
                    return RADIO_STATUS_ERROR;
 8032a70:	2003      	movs	r0, #3
 8032a72:	e7b6      	b.n	80329e2 <RadioSend+0x86>
 8032a74:	00000201 	.word	0x00000201
 8032a78:	48000400 	.word	0x48000400
 8032a7c:	2000c688 	.word	0x2000c688
 8032a80:	00000889 	.word	0x00000889
 8032a84:	2000c6e4 	.word	0x2000c6e4
 8032a88:	08035d70 	.word	0x08035d70

08032a8c <RadioRandom>:
{
 8032a8c:	b510      	push	{r4, lr}
    SUBGRF_SetDioIrqParams( IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 8032a8e:	2300      	movs	r3, #0
 8032a90:	2200      	movs	r2, #0
 8032a92:	2100      	movs	r1, #0
 8032a94:	2000      	movs	r0, #0
 8032a96:	f000 fd5b 	bl	8033550 <SUBGRF_SetDioIrqParams>
    rnd = SUBGRF_GetRandom();
 8032a9a:	f000 fc17 	bl	80332cc <SUBGRF_GetRandom>
}
 8032a9e:	bd10      	pop	{r4, pc}

08032aa0 <RadioSetModem>:
{
 8032aa0:	b510      	push	{r4, lr}
 8032aa2:	0004      	movs	r4, r0
    SubgRf.Modem = modem;
 8032aa4:	4b15      	ldr	r3, [pc, #84]	; (8032afc <RadioSetModem+0x5c>)
 8032aa6:	7018      	strb	r0, [r3, #0]
    RFW_SetRadioModem( modem );
 8032aa8:	f001 f90c 	bl	8033cc4 <RFW_SetRadioModem>
    switch( modem )
 8032aac:	2c01      	cmp	r4, #1
 8032aae:	d011      	beq.n	8032ad4 <RadioSetModem+0x34>
 8032ab0:	2c03      	cmp	r4, #3
 8032ab2:	d01b      	beq.n	8032aec <RadioSetModem+0x4c>
 8032ab4:	2c00      	cmp	r4, #0
 8032ab6:	d006      	beq.n	8032ac6 <RadioSetModem+0x26>
        SUBGRF_SetPacketType( PACKET_TYPE_GMSK );
 8032ab8:	2003      	movs	r0, #3
 8032aba:	f000 fdd5 	bl	8033668 <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 8032abe:	4b0f      	ldr	r3, [pc, #60]	; (8032afc <RadioSetModem+0x5c>)
 8032ac0:	2200      	movs	r2, #0
 8032ac2:	735a      	strb	r2, [r3, #13]
}
 8032ac4:	bd10      	pop	{r4, pc}
        SUBGRF_SetPacketType( PACKET_TYPE_GFSK );
 8032ac6:	2000      	movs	r0, #0
 8032ac8:	f000 fdce 	bl	8033668 <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 8032acc:	4b0b      	ldr	r3, [pc, #44]	; (8032afc <RadioSetModem+0x5c>)
 8032ace:	2200      	movs	r2, #0
 8032ad0:	735a      	strb	r2, [r3, #13]
        break;
 8032ad2:	e7f7      	b.n	8032ac4 <RadioSetModem+0x24>
        SUBGRF_SetPacketType( PACKET_TYPE_LORA );
 8032ad4:	2001      	movs	r0, #1
 8032ad6:	f000 fdc7 	bl	8033668 <SUBGRF_SetPacketType>
        if( SubgRf.PublicNetwork.Current != SubgRf.PublicNetwork.Previous )
 8032ada:	4b08      	ldr	r3, [pc, #32]	; (8032afc <RadioSetModem+0x5c>)
 8032adc:	7b5a      	ldrb	r2, [r3, #13]
 8032ade:	7b18      	ldrb	r0, [r3, #12]
 8032ae0:	4282      	cmp	r2, r0
 8032ae2:	d0ef      	beq.n	8032ac4 <RadioSetModem+0x24>
            SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous;
 8032ae4:	7358      	strb	r0, [r3, #13]
            RadioSetPublicNetwork( SubgRf.PublicNetwork.Current );
 8032ae6:	f000 f80b 	bl	8032b00 <RadioSetPublicNetwork>
 8032aea:	e7eb      	b.n	8032ac4 <RadioSetModem+0x24>
        SUBGRF_SetPacketType( PACKET_TYPE_BPSK );
 8032aec:	2002      	movs	r0, #2
 8032aee:	f000 fdbb 	bl	8033668 <SUBGRF_SetPacketType>
        SubgRf.PublicNetwork.Current = false;
 8032af2:	4b02      	ldr	r3, [pc, #8]	; (8032afc <RadioSetModem+0x5c>)
 8032af4:	2200      	movs	r2, #0
 8032af6:	735a      	strb	r2, [r3, #13]
}
 8032af8:	e7e4      	b.n	8032ac4 <RadioSetModem+0x24>
 8032afa:	46c0      	nop			; (mov r8, r8)
 8032afc:	2000c688 	.word	0x2000c688

08032b00 <RadioSetPublicNetwork>:
{
 8032b00:	b510      	push	{r4, lr}
 8032b02:	0004      	movs	r4, r0
    SubgRf.PublicNetwork.Current = SubgRf.PublicNetwork.Previous = enable;
 8032b04:	4b0d      	ldr	r3, [pc, #52]	; (8032b3c <RadioSetPublicNetwork+0x3c>)
 8032b06:	7318      	strb	r0, [r3, #12]
 8032b08:	7358      	strb	r0, [r3, #13]
    RadioSetModem( MODEM_LORA );
 8032b0a:	2001      	movs	r0, #1
 8032b0c:	f7ff ffc8 	bl	8032aa0 <RadioSetModem>
    if( enable == true )
 8032b10:	2c00      	cmp	r4, #0
 8032b12:	d009      	beq.n	8032b28 <RadioSetPublicNetwork+0x28>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PUBLIC_SYNCWORD >> 8 ) & 0xFF );
 8032b14:	20e8      	movs	r0, #232	; 0xe8
 8032b16:	2134      	movs	r1, #52	; 0x34
 8032b18:	00c0      	lsls	r0, r0, #3
 8032b1a:	f000 fa91 	bl	8033040 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PUBLIC_SYNCWORD & 0xFF );
 8032b1e:	2144      	movs	r1, #68	; 0x44
 8032b20:	4807      	ldr	r0, [pc, #28]	; (8032b40 <RadioSetPublicNetwork+0x40>)
 8032b22:	f000 fa8d 	bl	8033040 <SUBGRF_WriteRegister>
}
 8032b26:	bd10      	pop	{r4, pc}
        SUBGRF_WriteRegister( REG_LR_SYNCWORD, ( LORA_MAC_PRIVATE_SYNCWORD >> 8 ) & 0xFF );
 8032b28:	20e8      	movs	r0, #232	; 0xe8
 8032b2a:	2114      	movs	r1, #20
 8032b2c:	00c0      	lsls	r0, r0, #3
 8032b2e:	f000 fa87 	bl	8033040 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_LR_SYNCWORD + 1, LORA_MAC_PRIVATE_SYNCWORD & 0xFF );
 8032b32:	2124      	movs	r1, #36	; 0x24
 8032b34:	4802      	ldr	r0, [pc, #8]	; (8032b40 <RadioSetPublicNetwork+0x40>)
 8032b36:	f000 fa83 	bl	8033040 <SUBGRF_WriteRegister>
}
 8032b3a:	e7f4      	b.n	8032b26 <RadioSetPublicNetwork+0x26>
 8032b3c:	2000c688 	.word	0x2000c688
 8032b40:	00000741 	.word	0x00000741

08032b44 <RadioSetTxConfig>:
{
 8032b44:	b5f0      	push	{r4, r5, r6, r7, lr}
 8032b46:	46de      	mov	lr, fp
 8032b48:	4657      	mov	r7, sl
 8032b4a:	464e      	mov	r6, r9
 8032b4c:	4645      	mov	r5, r8
 8032b4e:	b5e0      	push	{r5, r6, r7, lr}
 8032b50:	b085      	sub	sp, #20
 8032b52:	0004      	movs	r4, r0
 8032b54:	9100      	str	r1, [sp, #0]
 8032b56:	9201      	str	r2, [sp, #4]
 8032b58:	001d      	movs	r5, r3
 8032b5a:	ab0e      	add	r3, sp, #56	; 0x38
 8032b5c:	cb80      	ldmia	r3!, {r7}
 8032b5e:	781b      	ldrb	r3, [r3, #0]
 8032b60:	469b      	mov	fp, r3
 8032b62:	ab10      	add	r3, sp, #64	; 0x40
 8032b64:	881e      	ldrh	r6, [r3, #0]
 8032b66:	ab11      	add	r3, sp, #68	; 0x44
 8032b68:	781b      	ldrb	r3, [r3, #0]
 8032b6a:	4699      	mov	r9, r3
 8032b6c:	ab12      	add	r3, sp, #72	; 0x48
 8032b6e:	781b      	ldrb	r3, [r3, #0]
 8032b70:	4698      	mov	r8, r3
 8032b72:	ab15      	add	r3, sp, #84	; 0x54
 8032b74:	781b      	ldrb	r3, [r3, #0]
 8032b76:	469a      	mov	sl, r3
    RFW_DeInit();
 8032b78:	f001 f896 	bl	8033ca8 <RFW_DeInit>
    switch( modem )
 8032b7c:	2c00      	cmp	r4, #0
 8032b7e:	d017      	beq.n	8032bb0 <RadioSetTxConfig+0x6c>
 8032b80:	2c01      	cmp	r4, #1
 8032b82:	d059      	beq.n	8032c38 <RadioSetTxConfig+0xf4>
    SubgRf.AntSwitchPaSelect = SUBGRF_SetRfTxPower( power );
 8032b84:	9800      	ldr	r0, [sp, #0]
 8032b86:	f000 ffb3 	bl	8033af0 <SUBGRF_SetRfTxPower>
 8032b8a:	4c52      	ldr	r4, [pc, #328]	; (8032cd4 <RadioSetTxConfig+0x190>)
 8032b8c:	2556      	movs	r5, #86	; 0x56
 8032b8e:	5560      	strb	r0, [r4, r5]
    SUBGRF_WriteRegister(REG_DRV_CTRL, 0x7 << 1);
 8032b90:	210e      	movs	r1, #14
 8032b92:	4851      	ldr	r0, [pc, #324]	; (8032cd8 <RadioSetTxConfig+0x194>)
 8032b94:	f000 fa54 	bl	8033040 <SUBGRF_WriteRegister>
    RFW_SetAntSwitch( SubgRf.AntSwitchPaSelect );
 8032b98:	5d60      	ldrb	r0, [r4, r5]
 8032b9a:	f001 f88a 	bl	8033cb2 <RFW_SetAntSwitch>
    SubgRf.TxTimeout = timeout;
 8032b9e:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8032ba0:	6063      	str	r3, [r4, #4]
}
 8032ba2:	b005      	add	sp, #20
 8032ba4:	bcf0      	pop	{r4, r5, r6, r7}
 8032ba6:	46bb      	mov	fp, r7
 8032ba8:	46b2      	mov	sl, r6
 8032baa:	46a9      	mov	r9, r5
 8032bac:	46a0      	mov	r8, r4
 8032bae:	bdf0      	pop	{r4, r5, r6, r7, pc}
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8032bb0:	4c48      	ldr	r4, [pc, #288]	; (8032cd4 <RadioSetTxConfig+0x190>)
 8032bb2:	2300      	movs	r3, #0
 8032bb4:	469a      	mov	sl, r3
 8032bb6:	3338      	adds	r3, #56	; 0x38
 8032bb8:	4652      	mov	r2, sl
 8032bba:	54e2      	strb	r2, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8032bbc:	63e7      	str	r7, [r4, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8032bbe:	330c      	adds	r3, #12
 8032bc0:	320b      	adds	r2, #11
 8032bc2:	54e2      	strb	r2, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8032bc4:	0028      	movs	r0, r5
 8032bc6:	f001 f80d 	bl	8033be4 <SUBGRF_GetFskBandwidthRegValue>
 8032bca:	2345      	movs	r3, #69	; 0x45
 8032bcc:	54e0      	strb	r0, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.Fdev = fdev;
 8032bce:	9b01      	ldr	r3, [sp, #4]
 8032bd0:	6423      	str	r3, [r4, #64]	; 0x40
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8032bd2:	4653      	mov	r3, sl
 8032bd4:	73a3      	strb	r3, [r4, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8032bd6:	00f6      	lsls	r6, r6, #3
 8032bd8:	8226      	strh	r6, [r4, #16]
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 8032bda:	3304      	adds	r3, #4
 8032bdc:	74a3      	strb	r3, [r4, #18]
            SubgRf.PacketParams.Params.Gfsk.SyncWordLength = 3 << 3 ; // convert byte into bit
 8032bde:	3314      	adds	r3, #20
 8032be0:	74e3      	strb	r3, [r4, #19]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 8032be2:	4653      	mov	r3, sl
 8032be4:	7523      	strb	r3, [r4, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 8032be6:	2301      	movs	r3, #1
 8032be8:	464a      	mov	r2, r9
 8032bea:	405a      	eors	r2, r3
 8032bec:	7562      	strb	r2, [r4, #21]
            if( crcOn == true )
 8032bee:	4643      	mov	r3, r8
 8032bf0:	2b00      	cmp	r3, #0
 8032bf2:	d01d      	beq.n	8032c30 <RadioSetTxConfig+0xec>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_2_BYTES_CCIT;
 8032bf4:	4b37      	ldr	r3, [pc, #220]	; (8032cd4 <RadioSetTxConfig+0x190>)
 8032bf6:	22f2      	movs	r2, #242	; 0xf2
 8032bf8:	75da      	strb	r2, [r3, #23]
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 8032bfa:	4c36      	ldr	r4, [pc, #216]	; (8032cd4 <RadioSetTxConfig+0x190>)
 8032bfc:	2301      	movs	r3, #1
 8032bfe:	7623      	strb	r3, [r4, #24]
            RadioStandby( );
 8032c00:	f7ff fc4e 	bl	80324a0 <RadioStandby>
            RadioSetModem(  MODEM_FSK  );
 8032c04:	2000      	movs	r0, #0
 8032c06:	f7ff ff4b 	bl	8032aa0 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8032c0a:	0020      	movs	r0, r4
 8032c0c:	3038      	adds	r0, #56	; 0x38
 8032c0e:	f000 fdd3 	bl	80337b8 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8032c12:	0020      	movs	r0, r4
 8032c14:	300e      	adds	r0, #14
 8032c16:	f000 fe47 	bl	80338a8 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 8032c1a:	a802      	add	r0, sp, #8
 8032c1c:	4b2f      	ldr	r3, [pc, #188]	; (8032cdc <RadioSetTxConfig+0x198>)
 8032c1e:	0002      	movs	r2, r0
 8032c20:	cb12      	ldmia	r3!, {r1, r4}
 8032c22:	c212      	stmia	r2!, {r1, r4}
 8032c24:	f000 fa6e 	bl	8033104 <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 8032c28:	482d      	ldr	r0, [pc, #180]	; (8032ce0 <RadioSetTxConfig+0x19c>)
 8032c2a:	f000 fa3d 	bl	80330a8 <SUBGRF_SetWhiteningSeed>
            break;
 8032c2e:	e7a9      	b.n	8032b84 <RadioSetTxConfig+0x40>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8032c30:	4b28      	ldr	r3, [pc, #160]	; (8032cd4 <RadioSetTxConfig+0x190>)
 8032c32:	2201      	movs	r2, #1
 8032c34:	75da      	strb	r2, [r3, #23]
 8032c36:	e7e0      	b.n	8032bfa <RadioSetTxConfig+0xb6>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 8032c38:	4a26      	ldr	r2, [pc, #152]	; (8032cd4 <RadioSetTxConfig+0x190>)
 8032c3a:	2338      	movs	r3, #56	; 0x38
 8032c3c:	2101      	movs	r1, #1
 8032c3e:	54d1      	strb	r1, [r2, r3]
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t ) datarate;
 8032c40:	b2fb      	uxtb	r3, r7
 8032c42:	314f      	adds	r1, #79	; 0x4f
 8032c44:	5453      	strb	r3, [r2, r1]
            SubgRf.ModulationParams.Params.LoRa.Bandwidth =  Bandwidths[bandwidth];
 8032c46:	4927      	ldr	r1, [pc, #156]	; (8032ce4 <RadioSetTxConfig+0x1a0>)
 8032c48:	5d48      	ldrb	r0, [r1, r5]
 8032c4a:	2151      	movs	r1, #81	; 0x51
 8032c4c:	5450      	strb	r0, [r2, r1]
            SubgRf.ModulationParams.Params.LoRa.CodingRate= ( RadioLoRaCodingRates_t )coderate;
 8032c4e:	3101      	adds	r1, #1
 8032c50:	4658      	mov	r0, fp
 8032c52:	5450      	strb	r0, [r2, r1]
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8032c54:	2d00      	cmp	r5, #0
 8032c56:	d103      	bne.n	8032c60 <RadioSetTxConfig+0x11c>
 8032c58:	003a      	movs	r2, r7
 8032c5a:	3a0b      	subs	r2, #11
 8032c5c:	2a01      	cmp	r2, #1
 8032c5e:	d92a      	bls.n	8032cb6 <RadioSetTxConfig+0x172>
 8032c60:	2d01      	cmp	r5, #1
 8032c62:	d026      	beq.n	8032cb2 <RadioSetTxConfig+0x16e>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8032c64:	491b      	ldr	r1, [pc, #108]	; (8032cd4 <RadioSetTxConfig+0x190>)
 8032c66:	2253      	movs	r2, #83	; 0x53
 8032c68:	2000      	movs	r0, #0
 8032c6a:	5488      	strb	r0, [r1, r2]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8032c6c:	4a19      	ldr	r2, [pc, #100]	; (8032cd4 <RadioSetTxConfig+0x190>)
 8032c6e:	2101      	movs	r1, #1
 8032c70:	7391      	strb	r1, [r2, #14]
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 8032c72:	3b05      	subs	r3, #5
 8032c74:	b2db      	uxtb	r3, r3
 8032c76:	2b01      	cmp	r3, #1
 8032c78:	d922      	bls.n	8032cc0 <RadioSetTxConfig+0x17c>
                SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8032c7a:	4b16      	ldr	r3, [pc, #88]	; (8032cd4 <RadioSetTxConfig+0x190>)
 8032c7c:	839e      	strh	r6, [r3, #28]
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 8032c7e:	4c15      	ldr	r4, [pc, #84]	; (8032cd4 <RadioSetTxConfig+0x190>)
 8032c80:	464b      	mov	r3, r9
 8032c82:	77a3      	strb	r3, [r4, #30]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8032c84:	4b18      	ldr	r3, [pc, #96]	; (8032ce8 <RadioSetTxConfig+0x1a4>)
 8032c86:	781b      	ldrb	r3, [r3, #0]
 8032c88:	77e3      	strb	r3, [r4, #31]
            SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t )crcOn;
 8032c8a:	2320      	movs	r3, #32
 8032c8c:	4642      	mov	r2, r8
 8032c8e:	54e2      	strb	r2, [r4, r3]
            SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t )iqInverted;
 8032c90:	3301      	adds	r3, #1
 8032c92:	4652      	mov	r2, sl
 8032c94:	54e2      	strb	r2, [r4, r3]
            RadioStandby( );
 8032c96:	f7ff fc03 	bl	80324a0 <RadioStandby>
            RadioSetModem( MODEM_LORA );
 8032c9a:	2001      	movs	r0, #1
 8032c9c:	f7ff ff00 	bl	8032aa0 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8032ca0:	0020      	movs	r0, r4
 8032ca2:	3038      	adds	r0, #56	; 0x38
 8032ca4:	f000 fd88 	bl	80337b8 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8032ca8:	0020      	movs	r0, r4
 8032caa:	300e      	adds	r0, #14
 8032cac:	f000 fdfc 	bl	80338a8 <SUBGRF_SetPacketParams>
            break;
 8032cb0:	e768      	b.n	8032b84 <RadioSetTxConfig+0x40>
                ( ( bandwidth == 1 ) && ( datarate == 12 ) ) )
 8032cb2:	2f0c      	cmp	r7, #12
 8032cb4:	d1d6      	bne.n	8032c64 <RadioSetTxConfig+0x120>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x01;
 8032cb6:	4907      	ldr	r1, [pc, #28]	; (8032cd4 <RadioSetTxConfig+0x190>)
 8032cb8:	2253      	movs	r2, #83	; 0x53
 8032cba:	2001      	movs	r0, #1
 8032cbc:	5488      	strb	r0, [r1, r2]
 8032cbe:	e7d5      	b.n	8032c6c <RadioSetTxConfig+0x128>
                if( preambleLen < 12 )
 8032cc0:	2e0b      	cmp	r6, #11
 8032cc2:	d803      	bhi.n	8032ccc <RadioSetTxConfig+0x188>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = 12;
 8032cc4:	0013      	movs	r3, r2
 8032cc6:	220c      	movs	r2, #12
 8032cc8:	839a      	strh	r2, [r3, #28]
 8032cca:	e7d8      	b.n	8032c7e <RadioSetTxConfig+0x13a>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8032ccc:	4b01      	ldr	r3, [pc, #4]	; (8032cd4 <RadioSetTxConfig+0x190>)
 8032cce:	839e      	strh	r6, [r3, #28]
 8032cd0:	e7d5      	b.n	8032c7e <RadioSetTxConfig+0x13a>
 8032cd2:	46c0      	nop			; (mov r8, r8)
 8032cd4:	2000c688 	.word	0x2000c688
 8032cd8:	0000091f 	.word	0x0000091f
 8032cdc:	08034d10 	.word	0x08034d10
 8032ce0:	000001ff 	.word	0x000001ff
 8032ce4:	08035d88 	.word	0x08035d88
 8032ce8:	2000b138 	.word	0x2000b138

08032cec <RadioSetRxConfig>:
{
 8032cec:	b5f0      	push	{r4, r5, r6, r7, lr}
 8032cee:	46de      	mov	lr, fp
 8032cf0:	4657      	mov	r7, sl
 8032cf2:	464e      	mov	r6, r9
 8032cf4:	4645      	mov	r5, r8
 8032cf6:	b5e0      	push	{r5, r6, r7, lr}
 8032cf8:	b087      	sub	sp, #28
 8032cfa:	0004      	movs	r4, r0
 8032cfc:	4688      	mov	r8, r1
 8032cfe:	9201      	str	r2, [sp, #4]
 8032d00:	9302      	str	r3, [sp, #8]
 8032d02:	ab11      	add	r3, sp, #68	; 0x44
 8032d04:	881b      	ldrh	r3, [r3, #0]
 8032d06:	4699      	mov	r9, r3
 8032d08:	ab12      	add	r3, sp, #72	; 0x48
 8032d0a:	881e      	ldrh	r6, [r3, #0]
 8032d0c:	ab13      	add	r3, sp, #76	; 0x4c
 8032d0e:	781d      	ldrb	r5, [r3, #0]
 8032d10:	ab14      	add	r3, sp, #80	; 0x50
 8032d12:	781b      	ldrb	r3, [r3, #0]
 8032d14:	469b      	mov	fp, r3
 8032d16:	ab15      	add	r3, sp, #84	; 0x54
 8032d18:	781b      	ldrb	r3, [r3, #0]
 8032d1a:	469a      	mov	sl, r3
 8032d1c:	ab18      	add	r3, sp, #96	; 0x60
 8032d1e:	781b      	ldrb	r3, [r3, #0]
 8032d20:	9303      	str	r3, [sp, #12]
 8032d22:	ab19      	add	r3, sp, #100	; 0x64
 8032d24:	781f      	ldrb	r7, [r3, #0]
    SubgRf.RxContinuous = rxContinuous;
 8032d26:	4b73      	ldr	r3, [pc, #460]	; (8032ef4 <RadioSetRxConfig+0x208>)
 8032d28:	705f      	strb	r7, [r3, #1]
    RFW_DeInit();
 8032d2a:	f000 ffbd 	bl	8033ca8 <RFW_DeInit>
    if( rxContinuous == true )
 8032d2e:	2f00      	cmp	r7, #0
 8032d30:	d000      	beq.n	8032d34 <RadioSetRxConfig+0x48>
        symbTimeout = 0;
 8032d32:	2600      	movs	r6, #0
    if( fixLen == true )
 8032d34:	2d00      	cmp	r5, #0
 8032d36:	d00d      	beq.n	8032d54 <RadioSetRxConfig+0x68>
        MaxPayloadLength = payloadLen;
 8032d38:	4b6f      	ldr	r3, [pc, #444]	; (8032ef8 <RadioSetRxConfig+0x20c>)
 8032d3a:	465a      	mov	r2, fp
 8032d3c:	701a      	strb	r2, [r3, #0]
    switch( modem )
 8032d3e:	2c00      	cmp	r4, #0
 8032d40:	d00c      	beq.n	8032d5c <RadioSetRxConfig+0x70>
 8032d42:	2c01      	cmp	r4, #1
 8032d44:	d058      	beq.n	8032df8 <RadioSetRxConfig+0x10c>
}
 8032d46:	b007      	add	sp, #28
 8032d48:	bcf0      	pop	{r4, r5, r6, r7}
 8032d4a:	46bb      	mov	fp, r7
 8032d4c:	46b2      	mov	sl, r6
 8032d4e:	46a9      	mov	r9, r5
 8032d50:	46a0      	mov	r8, r4
 8032d52:	bdf0      	pop	{r4, r5, r6, r7, pc}
        MaxPayloadLength = 0xFF;
 8032d54:	4b68      	ldr	r3, [pc, #416]	; (8032ef8 <RadioSetRxConfig+0x20c>)
 8032d56:	22ff      	movs	r2, #255	; 0xff
 8032d58:	701a      	strb	r2, [r3, #0]
 8032d5a:	e7f0      	b.n	8032d3e <RadioSetRxConfig+0x52>
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 8032d5c:	2000      	movs	r0, #0
 8032d5e:	f000 fb3b 	bl	80333d8 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_GFSK;
 8032d62:	4c64      	ldr	r4, [pc, #400]	; (8032ef4 <RadioSetRxConfig+0x208>)
 8032d64:	2700      	movs	r7, #0
 8032d66:	2338      	movs	r3, #56	; 0x38
 8032d68:	54e7      	strb	r7, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.BitRate = datarate;
 8032d6a:	9b01      	ldr	r3, [sp, #4]
 8032d6c:	63e3      	str	r3, [r4, #60]	; 0x3c
            SubgRf.ModulationParams.Params.Gfsk.ModulationShaping = MOD_SHAPING_G_BT_1;
 8032d6e:	2344      	movs	r3, #68	; 0x44
 8032d70:	220b      	movs	r2, #11
 8032d72:	54e2      	strb	r2, [r4, r3]
            SubgRf.ModulationParams.Params.Gfsk.Bandwidth = SUBGRF_GetFskBandwidthRegValue( bandwidth );
 8032d74:	4640      	mov	r0, r8
 8032d76:	f000 ff35 	bl	8033be4 <SUBGRF_GetFskBandwidthRegValue>
 8032d7a:	2345      	movs	r3, #69	; 0x45
 8032d7c:	54e0      	strb	r0, [r4, r3]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_GFSK;
 8032d7e:	73a7      	strb	r7, [r4, #14]
            SubgRf.PacketParams.Params.Gfsk.PreambleLength = ( preambleLen << 3 ); // convert byte into bit
 8032d80:	464b      	mov	r3, r9
 8032d82:	00db      	lsls	r3, r3, #3
 8032d84:	8223      	strh	r3, [r4, #16]
            SubgRf.PacketParams.Params.Gfsk.PreambleMinDetect = RADIO_PREAMBLE_DETECTOR_08_BITS;
 8032d86:	2304      	movs	r3, #4
 8032d88:	74a3      	strb	r3, [r4, #18]
            SubgRf.PacketParams.Params.Gfsk.SyncWordLength = 3 << 3; // convert byte into bit
 8032d8a:	3314      	adds	r3, #20
 8032d8c:	74e3      	strb	r3, [r4, #19]
            SubgRf.PacketParams.Params.Gfsk.AddrComp = RADIO_ADDRESSCOMP_FILT_OFF;
 8032d8e:	7527      	strb	r7, [r4, #20]
            SubgRf.PacketParams.Params.Gfsk.HeaderType = ( fixLen == true ) ? RADIO_PACKET_FIXED_LENGTH : RADIO_PACKET_VARIABLE_LENGTH;
 8032d90:	2301      	movs	r3, #1
 8032d92:	406b      	eors	r3, r5
 8032d94:	7563      	strb	r3, [r4, #21]
            SubgRf.PacketParams.Params.Gfsk.PayloadLength = MaxPayloadLength;
 8032d96:	4b58      	ldr	r3, [pc, #352]	; (8032ef8 <RadioSetRxConfig+0x20c>)
 8032d98:	781b      	ldrb	r3, [r3, #0]
 8032d9a:	75a3      	strb	r3, [r4, #22]
            if( crcOn == true )
 8032d9c:	4653      	mov	r3, sl
 8032d9e:	2b00      	cmp	r3, #0
 8032da0:	d026      	beq.n	8032df0 <RadioSetRxConfig+0x104>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_2_BYTES_CCIT;
 8032da2:	4b54      	ldr	r3, [pc, #336]	; (8032ef4 <RadioSetRxConfig+0x208>)
 8032da4:	22f2      	movs	r2, #242	; 0xf2
 8032da6:	75da      	strb	r2, [r3, #23]
            SubgRf.PacketParams.Params.Gfsk.DcFree = RADIO_DC_FREEWHITENING;
 8032da8:	4c52      	ldr	r4, [pc, #328]	; (8032ef4 <RadioSetRxConfig+0x208>)
 8032daa:	2301      	movs	r3, #1
 8032dac:	7623      	strb	r3, [r4, #24]
            RadioStandby( );
 8032dae:	f7ff fb77 	bl	80324a0 <RadioStandby>
            RadioSetModem( MODEM_FSK );
 8032db2:	2000      	movs	r0, #0
 8032db4:	f7ff fe74 	bl	8032aa0 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8032db8:	0020      	movs	r0, r4
 8032dba:	3038      	adds	r0, #56	; 0x38
 8032dbc:	f000 fcfc 	bl	80337b8 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8032dc0:	0020      	movs	r0, r4
 8032dc2:	300e      	adds	r0, #14
 8032dc4:	f000 fd70 	bl	80338a8 <SUBGRF_SetPacketParams>
            SUBGRF_SetSyncWord( ( uint8_t[] ){ 0xC1, 0x94, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00 } );
 8032dc8:	a804      	add	r0, sp, #16
 8032dca:	4b4c      	ldr	r3, [pc, #304]	; (8032efc <RadioSetRxConfig+0x210>)
 8032dcc:	0002      	movs	r2, r0
 8032dce:	cb22      	ldmia	r3!, {r1, r5}
 8032dd0:	c222      	stmia	r2!, {r1, r5}
 8032dd2:	f000 f997 	bl	8033104 <SUBGRF_SetSyncWord>
            SUBGRF_SetWhiteningSeed( 0x01FF );
 8032dd6:	484a      	ldr	r0, [pc, #296]	; (8032f00 <RadioSetRxConfig+0x214>)
 8032dd8:	f000 f966 	bl	80330a8 <SUBGRF_SetWhiteningSeed>
            SubgRf.RxTimeout = ( uint32_t )(( symbTimeout * 8 * 1000 ) /datarate);
 8032ddc:	0170      	lsls	r0, r6, #5
 8032dde:	1b80      	subs	r0, r0, r6
 8032de0:	0080      	lsls	r0, r0, #2
 8032de2:	1980      	adds	r0, r0, r6
 8032de4:	0180      	lsls	r0, r0, #6
 8032de6:	9901      	ldr	r1, [sp, #4]
 8032de8:	f7ed f996 	bl	8020118 <__udivsi3>
 8032dec:	60a0      	str	r0, [r4, #8]
            break;
 8032dee:	e7aa      	b.n	8032d46 <RadioSetRxConfig+0x5a>
                SubgRf.PacketParams.Params.Gfsk.CrcLength = RADIO_CRC_OFF;
 8032df0:	4b40      	ldr	r3, [pc, #256]	; (8032ef4 <RadioSetRxConfig+0x208>)
 8032df2:	2201      	movs	r2, #1
 8032df4:	75da      	strb	r2, [r3, #23]
 8032df6:	e7d7      	b.n	8032da8 <RadioSetRxConfig+0xbc>
            SUBGRF_SetStopRxTimerOnPreambleDetect( false );
 8032df8:	2000      	movs	r0, #0
 8032dfa:	f000 faed 	bl	80333d8 <SUBGRF_SetStopRxTimerOnPreambleDetect>
            SubgRf.ModulationParams.PacketType = PACKET_TYPE_LORA;
 8032dfe:	4a3d      	ldr	r2, [pc, #244]	; (8032ef4 <RadioSetRxConfig+0x208>)
 8032e00:	2338      	movs	r3, #56	; 0x38
 8032e02:	2101      	movs	r1, #1
 8032e04:	54d1      	strb	r1, [r2, r3]
            SubgRf.ModulationParams.Params.LoRa.SpreadingFactor = ( RadioLoRaSpreadingFactors_t )datarate;
 8032e06:	9c01      	ldr	r4, [sp, #4]
 8032e08:	b2e3      	uxtb	r3, r4
 8032e0a:	314f      	adds	r1, #79	; 0x4f
 8032e0c:	5453      	strb	r3, [r2, r1]
            SubgRf.ModulationParams.Params.LoRa.Bandwidth = Bandwidths[bandwidth];
 8032e0e:	493d      	ldr	r1, [pc, #244]	; (8032f04 <RadioSetRxConfig+0x218>)
 8032e10:	4640      	mov	r0, r8
 8032e12:	5c08      	ldrb	r0, [r1, r0]
 8032e14:	2151      	movs	r1, #81	; 0x51
 8032e16:	5450      	strb	r0, [r2, r1]
            SubgRf.ModulationParams.Params.LoRa.CodingRate = ( RadioLoRaCodingRates_t )coderate;
 8032e18:	3101      	adds	r1, #1
 8032e1a:	9802      	ldr	r0, [sp, #8]
 8032e1c:	5450      	strb	r0, [r2, r1]
            if( ( ( bandwidth == 0 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
 8032e1e:	4642      	mov	r2, r8
 8032e20:	2a00      	cmp	r2, #0
 8032e22:	d103      	bne.n	8032e2c <RadioSetRxConfig+0x140>
 8032e24:	0022      	movs	r2, r4
 8032e26:	3a0b      	subs	r2, #11
 8032e28:	2a01      	cmp	r2, #1
 8032e2a:	d948      	bls.n	8032ebe <RadioSetRxConfig+0x1d2>
 8032e2c:	4642      	mov	r2, r8
 8032e2e:	2a01      	cmp	r2, #1
 8032e30:	d042      	beq.n	8032eb8 <RadioSetRxConfig+0x1cc>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x00;
 8032e32:	4930      	ldr	r1, [pc, #192]	; (8032ef4 <RadioSetRxConfig+0x208>)
 8032e34:	2253      	movs	r2, #83	; 0x53
 8032e36:	2000      	movs	r0, #0
 8032e38:	5488      	strb	r0, [r1, r2]
            SubgRf.PacketParams.PacketType = PACKET_TYPE_LORA;
 8032e3a:	4a2e      	ldr	r2, [pc, #184]	; (8032ef4 <RadioSetRxConfig+0x208>)
 8032e3c:	2101      	movs	r1, #1
 8032e3e:	7391      	strb	r1, [r2, #14]
            if( ( SubgRf.ModulationParams.Params.LoRa.SpreadingFactor == LORA_SF5 ) ||
 8032e40:	3b05      	subs	r3, #5
 8032e42:	b2db      	uxtb	r3, r3
 8032e44:	2b01      	cmp	r3, #1
 8032e46:	d93f      	bls.n	8032ec8 <RadioSetRxConfig+0x1dc>
                SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8032e48:	4b2a      	ldr	r3, [pc, #168]	; (8032ef4 <RadioSetRxConfig+0x208>)
 8032e4a:	464a      	mov	r2, r9
 8032e4c:	839a      	strh	r2, [r3, #28]
            SubgRf.PacketParams.Params.LoRa.HeaderType = ( RadioLoRaPacketLengthsMode_t )fixLen;
 8032e4e:	4c29      	ldr	r4, [pc, #164]	; (8032ef4 <RadioSetRxConfig+0x208>)
 8032e50:	77a5      	strb	r5, [r4, #30]
            SubgRf.PacketParams.Params.LoRa.PayloadLength = MaxPayloadLength;
 8032e52:	4b29      	ldr	r3, [pc, #164]	; (8032ef8 <RadioSetRxConfig+0x20c>)
 8032e54:	781b      	ldrb	r3, [r3, #0]
 8032e56:	77e3      	strb	r3, [r4, #31]
            SubgRf.PacketParams.Params.LoRa.CrcMode = ( RadioLoRaCrcModes_t )crcOn;
 8032e58:	2320      	movs	r3, #32
 8032e5a:	4652      	mov	r2, sl
 8032e5c:	54e2      	strb	r2, [r4, r3]
            SubgRf.PacketParams.Params.LoRa.InvertIQ = ( RadioLoRaIQModes_t )iqInverted;
 8032e5e:	2521      	movs	r5, #33	; 0x21
 8032e60:	9b03      	ldr	r3, [sp, #12]
 8032e62:	5563      	strb	r3, [r4, r5]
            RadioStandby( );
 8032e64:	f7ff fb1c 	bl	80324a0 <RadioStandby>
            RadioSetModem( MODEM_LORA );
 8032e68:	2001      	movs	r0, #1
 8032e6a:	f7ff fe19 	bl	8032aa0 <RadioSetModem>
            SUBGRF_SetModulationParams( &SubgRf.ModulationParams );
 8032e6e:	0020      	movs	r0, r4
 8032e70:	3038      	adds	r0, #56	; 0x38
 8032e72:	f000 fca1 	bl	80337b8 <SUBGRF_SetModulationParams>
            SUBGRF_SetPacketParams( &SubgRf.PacketParams );
 8032e76:	0020      	movs	r0, r4
 8032e78:	300e      	adds	r0, #14
 8032e7a:	f000 fd15 	bl	80338a8 <SUBGRF_SetPacketParams>
            SUBGRF_SetLoRaSymbNumTimeout( symbTimeout );
 8032e7e:	b2f0      	uxtb	r0, r6
 8032e80:	f000 fab6 	bl	80333f0 <SUBGRF_SetLoRaSymbNumTimeout>
            SUBGRF_WriteRegister(SUBGHZ_AGCCFG,SUBGRF_ReadRegister(SUBGHZ_AGCCFG)&0x1);
 8032e84:	4e20      	ldr	r6, [pc, #128]	; (8032f08 <RadioSetRxConfig+0x21c>)
 8032e86:	0030      	movs	r0, r6
 8032e88:	f000 f8e8 	bl	803305c <SUBGRF_ReadRegister>
 8032e8c:	2101      	movs	r1, #1
 8032e8e:	4001      	ands	r1, r0
 8032e90:	0030      	movs	r0, r6
 8032e92:	f000 f8d5 	bl	8033040 <SUBGRF_WriteRegister>
            if( SubgRf.PacketParams.Params.LoRa.InvertIQ == LORA_IQ_INVERTED )
 8032e96:	5d63      	ldrb	r3, [r4, r5]
 8032e98:	2b01      	cmp	r3, #1
 8032e9a:	d020      	beq.n	8032ede <RadioSetRxConfig+0x1f2>
                SUBGRF_WriteRegister( SUBGHZ_LIQPOLR, SUBGRF_ReadRegister( SUBGHZ_LIQPOLR ) | ( 1 << 2 ) );
 8032e9c:	4c1b      	ldr	r4, [pc, #108]	; (8032f0c <RadioSetRxConfig+0x220>)
 8032e9e:	0020      	movs	r0, r4
 8032ea0:	f000 f8dc 	bl	803305c <SUBGRF_ReadRegister>
 8032ea4:	2104      	movs	r1, #4
 8032ea6:	4301      	orrs	r1, r0
 8032ea8:	b2c9      	uxtb	r1, r1
 8032eaa:	0020      	movs	r0, r4
 8032eac:	f000 f8c8 	bl	8033040 <SUBGRF_WriteRegister>
            SubgRf.RxTimeout = 0xFFFF;
 8032eb0:	4b10      	ldr	r3, [pc, #64]	; (8032ef4 <RadioSetRxConfig+0x208>)
 8032eb2:	4a17      	ldr	r2, [pc, #92]	; (8032f10 <RadioSetRxConfig+0x224>)
 8032eb4:	609a      	str	r2, [r3, #8]
}
 8032eb6:	e746      	b.n	8032d46 <RadioSetRxConfig+0x5a>
                ( ( bandwidth == 1 ) && ( datarate == 12 ) ) )
 8032eb8:	9a01      	ldr	r2, [sp, #4]
 8032eba:	2a0c      	cmp	r2, #12
 8032ebc:	d1b9      	bne.n	8032e32 <RadioSetRxConfig+0x146>
                SubgRf.ModulationParams.Params.LoRa.LowDatarateOptimize = 0x01;
 8032ebe:	490d      	ldr	r1, [pc, #52]	; (8032ef4 <RadioSetRxConfig+0x208>)
 8032ec0:	2253      	movs	r2, #83	; 0x53
 8032ec2:	2001      	movs	r0, #1
 8032ec4:	5488      	strb	r0, [r1, r2]
 8032ec6:	e7b8      	b.n	8032e3a <RadioSetRxConfig+0x14e>
                if( preambleLen < 12 )
 8032ec8:	464b      	mov	r3, r9
 8032eca:	2b0b      	cmp	r3, #11
 8032ecc:	d803      	bhi.n	8032ed6 <RadioSetRxConfig+0x1ea>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = 12;
 8032ece:	0013      	movs	r3, r2
 8032ed0:	220c      	movs	r2, #12
 8032ed2:	839a      	strh	r2, [r3, #28]
 8032ed4:	e7bb      	b.n	8032e4e <RadioSetRxConfig+0x162>
                    SubgRf.PacketParams.Params.LoRa.PreambleLength = preambleLen;
 8032ed6:	4b07      	ldr	r3, [pc, #28]	; (8032ef4 <RadioSetRxConfig+0x208>)
 8032ed8:	464a      	mov	r2, r9
 8032eda:	839a      	strh	r2, [r3, #28]
 8032edc:	e7b7      	b.n	8032e4e <RadioSetRxConfig+0x162>
                SUBGRF_WriteRegister( SUBGHZ_LIQPOLR, SUBGRF_ReadRegister( SUBGHZ_LIQPOLR ) & ~( 1 << 2 ) );
 8032ede:	4c0b      	ldr	r4, [pc, #44]	; (8032f0c <RadioSetRxConfig+0x220>)
 8032ee0:	0020      	movs	r0, r4
 8032ee2:	f000 f8bb 	bl	803305c <SUBGRF_ReadRegister>
 8032ee6:	2304      	movs	r3, #4
 8032ee8:	4398      	bics	r0, r3
 8032eea:	b2c1      	uxtb	r1, r0
 8032eec:	0020      	movs	r0, r4
 8032eee:	f000 f8a7 	bl	8033040 <SUBGRF_WriteRegister>
 8032ef2:	e7dd      	b.n	8032eb0 <RadioSetRxConfig+0x1c4>
 8032ef4:	2000c688 	.word	0x2000c688
 8032ef8:	2000b138 	.word	0x2000b138
 8032efc:	08034d10 	.word	0x08034d10
 8032f00:	000001ff 	.word	0x000001ff
 8032f04:	08035d88 	.word	0x08035d88
 8032f08:	000008a3 	.word	0x000008a3
 8032f0c:	00000736 	.word	0x00000736
 8032f10:	0000ffff 	.word	0x0000ffff

08032f14 <RadioIsChannelFree>:
{
 8032f14:	b5f0      	push	{r4, r5, r6, r7, lr}
 8032f16:	b08b      	sub	sp, #44	; 0x2c
 8032f18:	0007      	movs	r7, r0
 8032f1a:	000c      	movs	r4, r1
 8032f1c:	0016      	movs	r6, r2
 8032f1e:	001d      	movs	r5, r3
    RadioStandby( );
 8032f20:	f7ff fabe 	bl	80324a0 <RadioStandby>
    RadioSetModem( MODEM_FSK );
 8032f24:	2000      	movs	r0, #0
 8032f26:	f7ff fdbb 	bl	8032aa0 <RadioSetModem>
    RadioSetChannel( freq );
 8032f2a:	0038      	movs	r0, r7
 8032f2c:	f7ff fcb8 	bl	80328a0 <RadioSetChannel>
    RadioSetRxConfig( MODEM_FSK, rxBandwidth, 600, 0, rxBandwidth, 3, 0, false,
 8032f30:	2296      	movs	r2, #150	; 0x96
 8032f32:	2301      	movs	r3, #1
 8032f34:	9309      	str	r3, [sp, #36]	; 0x24
 8032f36:	2300      	movs	r3, #0
 8032f38:	9308      	str	r3, [sp, #32]
 8032f3a:	9307      	str	r3, [sp, #28]
 8032f3c:	9306      	str	r3, [sp, #24]
 8032f3e:	9305      	str	r3, [sp, #20]
 8032f40:	9304      	str	r3, [sp, #16]
 8032f42:	9303      	str	r3, [sp, #12]
 8032f44:	9302      	str	r3, [sp, #8]
 8032f46:	3303      	adds	r3, #3
 8032f48:	9301      	str	r3, [sp, #4]
 8032f4a:	9400      	str	r4, [sp, #0]
 8032f4c:	2300      	movs	r3, #0
 8032f4e:	0092      	lsls	r2, r2, #2
 8032f50:	0021      	movs	r1, r4
 8032f52:	2000      	movs	r0, #0
 8032f54:	f7ff feca 	bl	8032cec <RadioSetRxConfig>
    RadioRx( 0 );
 8032f58:	2000      	movs	r0, #0
 8032f5a:	f7ff fcb9 	bl	80328d0 <RadioRx>
    RADIO_DELAY_MS( RadioGetWakeupTime( ) );
 8032f5e:	f7ff fc4b 	bl	80327f8 <RadioGetWakeupTime>
 8032f62:	f7ee fe2d 	bl	8021bc0 <HAL_Delay>
    carrierSenseTime = TimerGetCurrentTime( );
 8032f66:	f001 fad5 	bl	8034514 <UTIL_TIMER_GetCurrentTime>
 8032f6a:	0004      	movs	r4, r0
    while( TimerGetElapsedTime( carrierSenseTime ) < maxCarrierSenseTime )
 8032f6c:	0020      	movs	r0, r4
 8032f6e:	f001 fadb 	bl	8034528 <UTIL_TIMER_GetElapsedTime>
 8032f72:	42a8      	cmp	r0, r5
 8032f74:	d206      	bcs.n	8032f84 <RadioIsChannelFree+0x70>
        rssi = RadioRssi( MODEM_FSK );
 8032f76:	2000      	movs	r0, #0
 8032f78:	f7ff fc68 	bl	803284c <RadioRssi>
        if( rssi > rssiThresh )
 8032f7c:	42b0      	cmp	r0, r6
 8032f7e:	ddf5      	ble.n	8032f6c <RadioIsChannelFree+0x58>
            status = false;
 8032f80:	2400      	movs	r4, #0
 8032f82:	e000      	b.n	8032f86 <RadioIsChannelFree+0x72>
    bool status = true;
 8032f84:	2401      	movs	r4, #1
    RadioStandby( );
 8032f86:	f7ff fa8b 	bl	80324a0 <RadioStandby>
}
 8032f8a:	0020      	movs	r0, r4
 8032f8c:	b00b      	add	sp, #44	; 0x2c
 8032f8e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08032f90 <RadioInit>:
{
 8032f90:	b5f0      	push	{r4, r5, r6, r7, lr}
 8032f92:	b083      	sub	sp, #12
    RadioEvents = events;
 8032f94:	4b1c      	ldr	r3, [pc, #112]	; (8033008 <RadioInit+0x78>)
 8032f96:	6018      	str	r0, [r3, #0]
    SubgRf.RxContinuous = false;
 8032f98:	4d1c      	ldr	r5, [pc, #112]	; (803300c <RadioInit+0x7c>)
 8032f9a:	2400      	movs	r4, #0
 8032f9c:	706c      	strb	r4, [r5, #1]
    SubgRf.TxTimeout = 0;
 8032f9e:	606c      	str	r4, [r5, #4]
    SubgRf.RxTimeout = 0;
 8032fa0:	60ac      	str	r4, [r5, #8]
    SubgRf.RxDcPreambleDetectTimeout = 0;
 8032fa2:	65ac      	str	r4, [r5, #88]	; 0x58
    SUBGRF_Init( RadioOnDioIrq );
 8032fa4:	481a      	ldr	r0, [pc, #104]	; (8033010 <RadioInit+0x80>)
 8032fa6:	f000 fafb 	bl	80335a0 <SUBGRF_Init>
    SubgRf.PublicNetwork.Current = false;
 8032faa:	736c      	strb	r4, [r5, #13]
    SubgRf.PublicNetwork.Previous = false;
 8032fac:	732c      	strb	r4, [r5, #12]
    SUBGRF_SetRegulatorMode( );
 8032fae:	f000 fa3f 	bl	8033430 <SUBGRF_SetRegulatorMode>
    SUBGRF_SetBufferBaseAddress( 0x00, 0x00 );
 8032fb2:	2100      	movs	r1, #0
 8032fb4:	2000      	movs	r0, #0
 8032fb6:	f000 fce7 	bl	8033988 <SUBGRF_SetBufferBaseAddress>
    SUBGRF_SetTxParams( RFO_LP, 0, RADIO_RAMP_200_US );
 8032fba:	2204      	movs	r2, #4
 8032fbc:	2100      	movs	r1, #0
 8032fbe:	2001      	movs	r0, #1
 8032fc0:	f000 fb6c 	bl	803369c <SUBGRF_SetTxParams>
    SUBGRF_SetDioIrqParams( IRQ_RADIO_ALL, IRQ_RADIO_ALL, IRQ_RADIO_NONE, IRQ_RADIO_NONE );
 8032fc4:	4813      	ldr	r0, [pc, #76]	; (8033014 <RadioInit+0x84>)
 8032fc6:	2300      	movs	r3, #0
 8032fc8:	2200      	movs	r2, #0
 8032fca:	0001      	movs	r1, r0
 8032fcc:	f000 fac0 	bl	8033550 <SUBGRF_SetDioIrqParams>
    RadioSleep();
 8032fd0:	f7ff fcbc 	bl	803294c <RadioSleep>
    TimerInit( &TxTimeoutTimer, RadioOnTxTimeoutIrq );
 8032fd4:	2701      	movs	r7, #1
 8032fd6:	427f      	negs	r7, r7
 8032fd8:	4e0f      	ldr	r6, [pc, #60]	; (8033018 <RadioInit+0x88>)
 8032fda:	9400      	str	r4, [sp, #0]
 8032fdc:	4b0f      	ldr	r3, [pc, #60]	; (803301c <RadioInit+0x8c>)
 8032fde:	2200      	movs	r2, #0
 8032fe0:	0039      	movs	r1, r7
 8032fe2:	0030      	movs	r0, r6
 8032fe4:	f001 fa76 	bl	80344d4 <UTIL_TIMER_Create>
    TimerInit( &RxTimeoutTimer, RadioOnRxTimeoutIrq );
 8032fe8:	4d0d      	ldr	r5, [pc, #52]	; (8033020 <RadioInit+0x90>)
 8032fea:	9400      	str	r4, [sp, #0]
 8032fec:	4b0d      	ldr	r3, [pc, #52]	; (8033024 <RadioInit+0x94>)
 8032fee:	2200      	movs	r2, #0
 8032ff0:	0039      	movs	r1, r7
 8032ff2:	0028      	movs	r0, r5
 8032ff4:	f001 fa6e 	bl	80344d4 <UTIL_TIMER_Create>
    TimerStop( &TxTimeoutTimer );
 8032ff8:	0030      	movs	r0, r6
 8032ffa:	f001 facb 	bl	8034594 <UTIL_TIMER_Stop>
    TimerStop( &RxTimeoutTimer );
 8032ffe:	0028      	movs	r0, r5
 8033000:	f001 fac8 	bl	8034594 <UTIL_TIMER_Stop>
}
 8033004:	b003      	add	sp, #12
 8033006:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8033008:	2000c66c 	.word	0x2000c66c
 803300c:	2000c688 	.word	0x2000c688
 8033010:	080327e5 	.word	0x080327e5
 8033014:	0000ffff 	.word	0x0000ffff
 8033018:	2000c6e4 	.word	0x2000c6e4
 803301c:	0803234d 	.word	0x0803234d
 8033020:	2000c670 	.word	0x2000c670
 8033024:	08032379 	.word	0x08032379

08033028 <SUBGRF_GetOperatingMode>:
    OperatingMode = MODE_STDBY_RC;
}

RadioOperatingModes_t SUBGRF_GetOperatingMode( void )
{
    return OperatingMode;
 8033028:	4b01      	ldr	r3, [pc, #4]	; (8033030 <SUBGRF_GetOperatingMode+0x8>)
 803302a:	7818      	ldrb	r0, [r3, #0]
}
 803302c:	4770      	bx	lr
 803302e:	46c0      	nop			; (mov r8, r8)
 8033030:	2000c702 	.word	0x2000c702

08033034 <SUBGRF_GetPacketType>:
    SUBGRF_WriteCommand( RADIO_SET_PACKETTYPE, ( uint8_t* )&packetType, 1 );
}

RadioPacketTypes_t SUBGRF_GetPacketType( void )
{
    return PacketType;
 8033034:	4b01      	ldr	r3, [pc, #4]	; (803303c <SUBGRF_GetPacketType+0x8>)
 8033036:	7818      	ldrb	r0, [r3, #0]
}
 8033038:	4770      	bx	lr
 803303a:	46c0      	nop			; (mov r8, r8)
 803303c:	2000c703 	.word	0x2000c703

08033040 <SUBGRF_WriteRegister>:
    buf[1] = ( uint8_t )( ( uint16_t )irq & 0x00FF );
    SUBGRF_WriteCommand( RADIO_CLR_IRQSTATUS, buf, 2 );
}

void SUBGRF_WriteRegister( uint16_t addr, uint8_t data )
{
 8033040:	b500      	push	{lr}
 8033042:	b083      	sub	sp, #12
 8033044:	466b      	mov	r3, sp
 8033046:	1dda      	adds	r2, r3, #7
 8033048:	7011      	strb	r1, [r2, #0]
    HAL_SUBGHZ_WriteRegisters( &hsubghz, addr, (uint8_t*)&data, 1 );
 803304a:	2301      	movs	r3, #1
 803304c:	0001      	movs	r1, r0
 803304e:	4802      	ldr	r0, [pc, #8]	; (8033058 <SUBGRF_WriteRegister+0x18>)
 8033050:	f7f2 fa70 	bl	8025534 <HAL_SUBGHZ_WriteRegisters>
}
 8033054:	b003      	add	sp, #12
 8033056:	bd00      	pop	{pc}
 8033058:	2000b210 	.word	0x2000b210

0803305c <SUBGRF_ReadRegister>:

uint8_t SUBGRF_ReadRegister( uint16_t addr )
{
 803305c:	b510      	push	{r4, lr}
 803305e:	b082      	sub	sp, #8
 8033060:	0001      	movs	r1, r0
    uint8_t data;
    HAL_SUBGHZ_ReadRegisters( &hsubghz, addr, &data, 1 );
 8033062:	466b      	mov	r3, sp
 8033064:	1ddc      	adds	r4, r3, #7
 8033066:	2301      	movs	r3, #1
 8033068:	0022      	movs	r2, r4
 803306a:	4803      	ldr	r0, [pc, #12]	; (8033078 <SUBGRF_ReadRegister+0x1c>)
 803306c:	f7f2 fab4 	bl	80255d8 <HAL_SUBGHZ_ReadRegisters>
    return data;
 8033070:	7820      	ldrb	r0, [r4, #0]
}
 8033072:	b002      	add	sp, #8
 8033074:	bd10      	pop	{r4, pc}
 8033076:	46c0      	nop			; (mov r8, r8)
 8033078:	2000b210 	.word	0x2000b210

0803307c <Radio_SMPS_Set>:
{
    RadioOnDioIrqCb( IRQ_LR_FHSS_HOP );
}

static void Radio_SMPS_Set(uint8_t level)
{
 803307c:	b570      	push	{r4, r5, r6, lr}
 803307e:	0004      	movs	r4, r0
  if ( 1U == RBI_IsDCDC() )
 8033080:	f7ee ff2c 	bl	8021edc <RBI_IsDCDC>
 8033084:	2801      	cmp	r0, #1
 8033086:	d000      	beq.n	803308a <Radio_SMPS_Set+0xe>
    uint8_t modReg;
    modReg= SUBGRF_ReadRegister(SUBGHZ_SMPSC2R);
    modReg&= (~SMPS_DRV_MASK);
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
  }
}
 8033088:	bd70      	pop	{r4, r5, r6, pc}
    modReg= SUBGRF_ReadRegister(SUBGHZ_SMPSC2R);
 803308a:	4d06      	ldr	r5, [pc, #24]	; (80330a4 <Radio_SMPS_Set+0x28>)
 803308c:	0028      	movs	r0, r5
 803308e:	f7ff ffe5 	bl	803305c <SUBGRF_ReadRegister>
    modReg&= (~SMPS_DRV_MASK);
 8033092:	2306      	movs	r3, #6
 8033094:	4398      	bics	r0, r3
 8033096:	b2c1      	uxtb	r1, r0
    SUBGRF_WriteRegister(SUBGHZ_SMPSC2R, modReg | level);
 8033098:	4321      	orrs	r1, r4
 803309a:	0028      	movs	r0, r5
 803309c:	f7ff ffd0 	bl	8033040 <SUBGRF_WriteRegister>
}
 80330a0:	e7f2      	b.n	8033088 <Radio_SMPS_Set+0xc>
 80330a2:	46c0      	nop			; (mov r8, r8)
 80330a4:	00000923 	.word	0x00000923

080330a8 <SUBGRF_SetWhiteningSeed>:
{
 80330a8:	b570      	push	{r4, r5, r6, lr}
 80330aa:	0004      	movs	r4, r0
    switch( SUBGRF_GetPacketType( ) )
 80330ac:	f7ff ffc2 	bl	8033034 <SUBGRF_GetPacketType>
 80330b0:	2800      	cmp	r0, #0
 80330b2:	d000      	beq.n	80330b6 <SUBGRF_SetWhiteningSeed+0xe>
}
 80330b4:	bd70      	pop	{r4, r5, r6, pc}
            regValue = SUBGRF_ReadRegister( REG_LR_WHITSEEDBASEADDR_MSB ) & 0xFE;
 80330b6:	25d7      	movs	r5, #215	; 0xd7
 80330b8:	00ed      	lsls	r5, r5, #3
 80330ba:	0028      	movs	r0, r5
 80330bc:	f7ff ffce 	bl	803305c <SUBGRF_ReadRegister>
 80330c0:	2301      	movs	r3, #1
 80330c2:	4398      	bics	r0, r3
 80330c4:	b2c0      	uxtb	r0, r0
            regValue = ( ( seed >> 8 ) & 0x01 ) | regValue;
 80330c6:	0a23      	lsrs	r3, r4, #8
 80330c8:	2101      	movs	r1, #1
 80330ca:	4019      	ands	r1, r3
 80330cc:	4301      	orrs	r1, r0
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_MSB, regValue ); // only 1 bit.
 80330ce:	0028      	movs	r0, r5
 80330d0:	f7ff ffb6 	bl	8033040 <SUBGRF_WriteRegister>
            SUBGRF_WriteRegister( REG_LR_WHITSEEDBASEADDR_LSB, (uint8_t)seed );
 80330d4:	b2e1      	uxtb	r1, r4
 80330d6:	4802      	ldr	r0, [pc, #8]	; (80330e0 <SUBGRF_SetWhiteningSeed+0x38>)
 80330d8:	f7ff ffb2 	bl	8033040 <SUBGRF_WriteRegister>
}
 80330dc:	e7ea      	b.n	80330b4 <SUBGRF_SetWhiteningSeed+0xc>
 80330de:	46c0      	nop			; (mov r8, r8)
 80330e0:	000006b9 	.word	0x000006b9

080330e4 <SUBGRF_WriteRegisters>:
{
 80330e4:	b510      	push	{r4, lr}
 80330e6:	0013      	movs	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80330e8:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80330ec:	b672      	cpsid	i
    HAL_SUBGHZ_WriteRegisters( &hsubghz, address, buffer, size );
 80330ee:	000a      	movs	r2, r1
 80330f0:	0001      	movs	r1, r0
 80330f2:	4803      	ldr	r0, [pc, #12]	; (8033100 <SUBGRF_WriteRegisters+0x1c>)
 80330f4:	f7f2 fa1e 	bl	8025534 <HAL_SUBGHZ_WriteRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80330f8:	f384 8810 	msr	PRIMASK, r4
}
 80330fc:	bd10      	pop	{r4, pc}
 80330fe:	46c0      	nop			; (mov r8, r8)
 8033100:	2000b210 	.word	0x2000b210

08033104 <SUBGRF_SetSyncWord>:
{
 8033104:	b510      	push	{r4, lr}
 8033106:	0001      	movs	r1, r0
    SUBGRF_WriteRegisters( REG_LR_SYNCWORDBASEADDRESS, syncWord, 8 );
 8033108:	20d8      	movs	r0, #216	; 0xd8
 803310a:	2208      	movs	r2, #8
 803310c:	00c0      	lsls	r0, r0, #3
 803310e:	f7ff ffe9 	bl	80330e4 <SUBGRF_WriteRegisters>
}
 8033112:	2000      	movs	r0, #0
 8033114:	bd10      	pop	{r4, pc}
	...

08033118 <SUBGRF_SetCrcSeed>:
{
 8033118:	b500      	push	{lr}
 803311a:	b083      	sub	sp, #12
    buf[0] = ( uint8_t )( ( seed >> 8 ) & 0xFF );
 803311c:	0a02      	lsrs	r2, r0, #8
 803311e:	ab01      	add	r3, sp, #4
 8033120:	701a      	strb	r2, [r3, #0]
    buf[1] = ( uint8_t )( seed & 0xFF );
 8033122:	7058      	strb	r0, [r3, #1]
    switch( SUBGRF_GetPacketType( ) )
 8033124:	f7ff ff86 	bl	8033034 <SUBGRF_GetPacketType>
 8033128:	2800      	cmp	r0, #0
 803312a:	d001      	beq.n	8033130 <SUBGRF_SetCrcSeed+0x18>
}
 803312c:	b003      	add	sp, #12
 803312e:	bd00      	pop	{pc}
            SUBGRF_WriteRegisters( REG_LR_CRCSEEDBASEADDR, buf, 2 );
 8033130:	2202      	movs	r2, #2
 8033132:	a901      	add	r1, sp, #4
 8033134:	4801      	ldr	r0, [pc, #4]	; (803313c <SUBGRF_SetCrcSeed+0x24>)
 8033136:	f7ff ffd5 	bl	80330e4 <SUBGRF_WriteRegisters>
}
 803313a:	e7f7      	b.n	803312c <SUBGRF_SetCrcSeed+0x14>
 803313c:	000006bc 	.word	0x000006bc

08033140 <SUBGRF_SetCrcPolynomial>:
{
 8033140:	b500      	push	{lr}
 8033142:	b083      	sub	sp, #12
    buf[0] = ( uint8_t )( ( polynomial >> 8 ) & 0xFF );
 8033144:	0a02      	lsrs	r2, r0, #8
 8033146:	ab01      	add	r3, sp, #4
 8033148:	701a      	strb	r2, [r3, #0]
    buf[1] = ( uint8_t )( polynomial & 0xFF );
 803314a:	7058      	strb	r0, [r3, #1]
    switch( SUBGRF_GetPacketType( ) )
 803314c:	f7ff ff72 	bl	8033034 <SUBGRF_GetPacketType>
 8033150:	2800      	cmp	r0, #0
 8033152:	d001      	beq.n	8033158 <SUBGRF_SetCrcPolynomial+0x18>
}
 8033154:	b003      	add	sp, #12
 8033156:	bd00      	pop	{pc}
            SUBGRF_WriteRegisters( REG_LR_CRCPOLYBASEADDR, buf, 2 );
 8033158:	2202      	movs	r2, #2
 803315a:	a901      	add	r1, sp, #4
 803315c:	4801      	ldr	r0, [pc, #4]	; (8033164 <SUBGRF_SetCrcPolynomial+0x24>)
 803315e:	f7ff ffc1 	bl	80330e4 <SUBGRF_WriteRegisters>
}
 8033162:	e7f7      	b.n	8033154 <SUBGRF_SetCrcPolynomial+0x14>
 8033164:	000006be 	.word	0x000006be

08033168 <SUBGRF_ReadRegisters>:
{
 8033168:	b510      	push	{r4, lr}
 803316a:	0013      	movs	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803316c:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033170:	b672      	cpsid	i
    HAL_SUBGHZ_ReadRegisters( &hsubghz, address, buffer, size );
 8033172:	000a      	movs	r2, r1
 8033174:	0001      	movs	r1, r0
 8033176:	4803      	ldr	r0, [pc, #12]	; (8033184 <SUBGRF_ReadRegisters+0x1c>)
 8033178:	f7f2 fa2e 	bl	80255d8 <HAL_SUBGHZ_ReadRegisters>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803317c:	f384 8810 	msr	PRIMASK, r4
}
 8033180:	bd10      	pop	{r4, pc}
 8033182:	46c0      	nop			; (mov r8, r8)
 8033184:	2000b210 	.word	0x2000b210

08033188 <SUBGRF_WriteBuffer>:
{
 8033188:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803318a:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803318e:	b672      	cpsid	i
    HAL_SUBGHZ_WriteBuffer( &hsubghz, offset, buffer, size );
 8033190:	b293      	uxth	r3, r2
 8033192:	000a      	movs	r2, r1
 8033194:	0001      	movs	r1, r0
 8033196:	4803      	ldr	r0, [pc, #12]	; (80331a4 <SUBGRF_WriteBuffer+0x1c>)
 8033198:	f7f2 fb70 	bl	802587c <HAL_SUBGHZ_WriteBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803319c:	f384 8810 	msr	PRIMASK, r4
}
 80331a0:	bd10      	pop	{r4, pc}
 80331a2:	46c0      	nop			; (mov r8, r8)
 80331a4:	2000b210 	.word	0x2000b210

080331a8 <SUBGRF_SetPayload>:
{
 80331a8:	b510      	push	{r4, lr}
 80331aa:	000a      	movs	r2, r1
    SUBGRF_WriteBuffer( 0x00, payload, size );
 80331ac:	0001      	movs	r1, r0
 80331ae:	2000      	movs	r0, #0
 80331b0:	f7ff ffea 	bl	8033188 <SUBGRF_WriteBuffer>
}
 80331b4:	bd10      	pop	{r4, pc}
	...

080331b8 <SUBGRF_ReadBuffer>:
{
 80331b8:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80331ba:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80331be:	b672      	cpsid	i
    HAL_SUBGHZ_ReadBuffer( &hsubghz, offset, buffer, size );
 80331c0:	b293      	uxth	r3, r2
 80331c2:	000a      	movs	r2, r1
 80331c4:	0001      	movs	r1, r0
 80331c6:	4803      	ldr	r0, [pc, #12]	; (80331d4 <SUBGRF_ReadBuffer+0x1c>)
 80331c8:	f7f2 fba4 	bl	8025914 <HAL_SUBGHZ_ReadBuffer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80331cc:	f384 8810 	msr	PRIMASK, r4
}
 80331d0:	bd10      	pop	{r4, pc}
 80331d2:	46c0      	nop			; (mov r8, r8)
 80331d4:	2000b210 	.word	0x2000b210

080331d8 <SUBGRF_WriteCommand>:
{
 80331d8:	b510      	push	{r4, lr}
 80331da:	0013      	movs	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80331dc:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80331e0:	b672      	cpsid	i
    HAL_SUBGHZ_ExecSetCmd( &hsubghz, Command, pBuffer, Size );
 80331e2:	000a      	movs	r2, r1
 80331e4:	0001      	movs	r1, r0
 80331e6:	4803      	ldr	r0, [pc, #12]	; (80331f4 <SUBGRF_WriteCommand+0x1c>)
 80331e8:	f7f2 fa4a 	bl	8025680 <HAL_SUBGHZ_ExecSetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80331ec:	f384 8810 	msr	PRIMASK, r4
}
 80331f0:	bd10      	pop	{r4, pc}
 80331f2:	46c0      	nop			; (mov r8, r8)
 80331f4:	2000b210 	.word	0x2000b210

080331f8 <SUBGRF_SetSleep>:
{
 80331f8:	b510      	push	{r4, lr}
 80331fa:	b082      	sub	sp, #8
 80331fc:	1c04      	adds	r4, r0, #0
    RBI_ConfigRFSwitch(RBI_SWITCH_OFF);
 80331fe:	2000      	movs	r0, #0
 8033200:	f7ee fe60 	bl	8021ec4 <RBI_ConfigRFSwitch>
    Radio_SMPS_Set(SMPS_DRIVE_SETTING_DEFAULT);
 8033204:	2002      	movs	r0, #2
 8033206:	f7ff ff39 	bl	803307c <Radio_SMPS_Set>
    uint8_t value = ( ( ( uint8_t )sleepConfig.Fields.WarmStart << 2 ) |
 803320a:	0760      	lsls	r0, r4, #29
 803320c:	0fc0      	lsrs	r0, r0, #31
 803320e:	0080      	lsls	r0, r0, #2
                      ( ( uint8_t )sleepConfig.Fields.Reset << 1 ) |
 8033210:	07a3      	lsls	r3, r4, #30
 8033212:	0fdb      	lsrs	r3, r3, #31
 8033214:	005b      	lsls	r3, r3, #1
    uint8_t value = ( ( ( uint8_t )sleepConfig.Fields.WarmStart << 2 ) |
 8033216:	4318      	orrs	r0, r3
                      ( ( uint8_t )sleepConfig.Fields.WakeUpRTC ) );
 8033218:	07e4      	lsls	r4, r4, #31
 803321a:	0fe4      	lsrs	r4, r4, #31
 803321c:	b264      	sxtb	r4, r4
                      ( ( uint8_t )sleepConfig.Fields.Reset << 1 ) |
 803321e:	4304      	orrs	r4, r0
    uint8_t value = ( ( ( uint8_t )sleepConfig.Fields.WarmStart << 2 ) |
 8033220:	466b      	mov	r3, sp
 8033222:	1dd9      	adds	r1, r3, #7
 8033224:	700c      	strb	r4, [r1, #0]
    SUBGRF_WriteCommand( RADIO_SET_SLEEP, &value, 1 );
 8033226:	2201      	movs	r2, #1
 8033228:	2084      	movs	r0, #132	; 0x84
 803322a:	f7ff ffd5 	bl	80331d8 <SUBGRF_WriteCommand>
    OperatingMode = MODE_SLEEP;
 803322e:	4b02      	ldr	r3, [pc, #8]	; (8033238 <SUBGRF_SetSleep+0x40>)
 8033230:	2200      	movs	r2, #0
 8033232:	701a      	strb	r2, [r3, #0]
}
 8033234:	b002      	add	sp, #8
 8033236:	bd10      	pop	{r4, pc}
 8033238:	2000c702 	.word	0x2000c702

0803323c <SUBGRF_SetStandby>:
{
 803323c:	b500      	push	{lr}
 803323e:	b083      	sub	sp, #12
 8033240:	466b      	mov	r3, sp
 8033242:	71d8      	strb	r0, [r3, #7]
    SUBGRF_WriteCommand( RADIO_SET_STANDBY, ( uint8_t* )&standbyConfig, 1 );
 8033244:	2201      	movs	r2, #1
 8033246:	1dd9      	adds	r1, r3, #7
 8033248:	2080      	movs	r0, #128	; 0x80
 803324a:	f7ff ffc5 	bl	80331d8 <SUBGRF_WriteCommand>
    if( standbyConfig == STDBY_RC )
 803324e:	466b      	mov	r3, sp
 8033250:	79db      	ldrb	r3, [r3, #7]
 8033252:	2b00      	cmp	r3, #0
 8033254:	d104      	bne.n	8033260 <SUBGRF_SetStandby+0x24>
        OperatingMode = MODE_STDBY_RC;
 8033256:	4b04      	ldr	r3, [pc, #16]	; (8033268 <SUBGRF_SetStandby+0x2c>)
 8033258:	2201      	movs	r2, #1
 803325a:	701a      	strb	r2, [r3, #0]
}
 803325c:	b003      	add	sp, #12
 803325e:	bd00      	pop	{pc}
        OperatingMode = MODE_STDBY_XOSC;
 8033260:	4b01      	ldr	r3, [pc, #4]	; (8033268 <SUBGRF_SetStandby+0x2c>)
 8033262:	2202      	movs	r2, #2
 8033264:	701a      	strb	r2, [r3, #0]
}
 8033266:	e7f9      	b.n	803325c <SUBGRF_SetStandby+0x20>
 8033268:	2000c702 	.word	0x2000c702

0803326c <SUBGRF_SetTx>:
{
 803326c:	b500      	push	{lr}
 803326e:	b083      	sub	sp, #12
    OperatingMode = MODE_TX;
 8033270:	4b07      	ldr	r3, [pc, #28]	; (8033290 <SUBGRF_SetTx+0x24>)
 8033272:	2204      	movs	r2, #4
 8033274:	701a      	strb	r2, [r3, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 8033276:	0c03      	lsrs	r3, r0, #16
 8033278:	a901      	add	r1, sp, #4
 803327a:	700b      	strb	r3, [r1, #0]
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803327c:	0a03      	lsrs	r3, r0, #8
 803327e:	704b      	strb	r3, [r1, #1]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 8033280:	7088      	strb	r0, [r1, #2]
    SUBGRF_WriteCommand( RADIO_SET_TX, buf, 3 );
 8033282:	3a01      	subs	r2, #1
 8033284:	2083      	movs	r0, #131	; 0x83
 8033286:	f7ff ffa7 	bl	80331d8 <SUBGRF_WriteCommand>
}
 803328a:	b003      	add	sp, #12
 803328c:	bd00      	pop	{pc}
 803328e:	46c0      	nop			; (mov r8, r8)
 8033290:	2000c702 	.word	0x2000c702

08033294 <SUBGRF_SendPayload>:
{
 8033294:	b510      	push	{r4, lr}
 8033296:	0014      	movs	r4, r2
    SUBGRF_SetPayload( payload, size );
 8033298:	f7ff ff86 	bl	80331a8 <SUBGRF_SetPayload>
    SUBGRF_SetTx( timeout );
 803329c:	0020      	movs	r0, r4
 803329e:	f7ff ffe5 	bl	803326c <SUBGRF_SetTx>
}
 80332a2:	bd10      	pop	{r4, pc}

080332a4 <SUBGRF_SetRx>:
{
 80332a4:	b500      	push	{lr}
 80332a6:	b083      	sub	sp, #12
    OperatingMode = MODE_RX;
 80332a8:	4b07      	ldr	r3, [pc, #28]	; (80332c8 <SUBGRF_SetRx+0x24>)
 80332aa:	2205      	movs	r2, #5
 80332ac:	701a      	strb	r2, [r3, #0]
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 80332ae:	0c03      	lsrs	r3, r0, #16
 80332b0:	a901      	add	r1, sp, #4
 80332b2:	700b      	strb	r3, [r1, #0]
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 80332b4:	0a03      	lsrs	r3, r0, #8
 80332b6:	704b      	strb	r3, [r1, #1]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 80332b8:	7088      	strb	r0, [r1, #2]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 80332ba:	3a02      	subs	r2, #2
 80332bc:	2082      	movs	r0, #130	; 0x82
 80332be:	f7ff ff8b 	bl	80331d8 <SUBGRF_WriteCommand>
}
 80332c2:	b003      	add	sp, #12
 80332c4:	bd00      	pop	{pc}
 80332c6:	46c0      	nop			; (mov r8, r8)
 80332c8:	2000c702 	.word	0x2000c702

080332cc <SUBGRF_GetRandom>:
{
 80332cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80332ce:	b083      	sub	sp, #12
    uint32_t number = 0;
 80332d0:	2300      	movs	r3, #0
 80332d2:	9301      	str	r3, [sp, #4]
    regAnaLna = SUBGRF_ReadRegister( REG_ANA_LNA );
 80332d4:	4f15      	ldr	r7, [pc, #84]	; (803332c <SUBGRF_GetRandom+0x60>)
 80332d6:	0038      	movs	r0, r7
 80332d8:	f7ff fec0 	bl	803305c <SUBGRF_ReadRegister>
 80332dc:	0005      	movs	r5, r0
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna & ~( 1 << 0 ) );
 80332de:	2301      	movs	r3, #1
 80332e0:	0001      	movs	r1, r0
 80332e2:	4399      	bics	r1, r3
 80332e4:	b2c9      	uxtb	r1, r1
 80332e6:	0038      	movs	r0, r7
 80332e8:	f7ff feaa 	bl	8033040 <SUBGRF_WriteRegister>
    regAnaMixer = SUBGRF_ReadRegister( REG_ANA_MIXER );
 80332ec:	4e10      	ldr	r6, [pc, #64]	; (8033330 <SUBGRF_GetRandom+0x64>)
 80332ee:	0030      	movs	r0, r6
 80332f0:	f7ff feb4 	bl	803305c <SUBGRF_ReadRegister>
 80332f4:	0004      	movs	r4, r0
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer & ~( 1 << 7 ) );
 80332f6:	217f      	movs	r1, #127	; 0x7f
 80332f8:	4001      	ands	r1, r0
 80332fa:	0030      	movs	r0, r6
 80332fc:	f7ff fea0 	bl	8033040 <SUBGRF_WriteRegister>
    SUBGRF_SetRx( 0xFFFFFF ); // Rx Continuous
 8033300:	480c      	ldr	r0, [pc, #48]	; (8033334 <SUBGRF_GetRandom+0x68>)
 8033302:	f7ff ffcf 	bl	80332a4 <SUBGRF_SetRx>
    SUBGRF_ReadRegisters( RANDOM_NUMBER_GENERATORBASEADDR, ( uint8_t* )&number, 4 );
 8033306:	2204      	movs	r2, #4
 8033308:	a901      	add	r1, sp, #4
 803330a:	480b      	ldr	r0, [pc, #44]	; (8033338 <SUBGRF_GetRandom+0x6c>)
 803330c:	f7ff ff2c 	bl	8033168 <SUBGRF_ReadRegisters>
    SUBGRF_SetStandby( STDBY_RC );
 8033310:	2000      	movs	r0, #0
 8033312:	f7ff ff93 	bl	803323c <SUBGRF_SetStandby>
    SUBGRF_WriteRegister( REG_ANA_LNA, regAnaLna );
 8033316:	0029      	movs	r1, r5
 8033318:	0038      	movs	r0, r7
 803331a:	f7ff fe91 	bl	8033040 <SUBGRF_WriteRegister>
    SUBGRF_WriteRegister( REG_ANA_MIXER, regAnaMixer );
 803331e:	0021      	movs	r1, r4
 8033320:	0030      	movs	r0, r6
 8033322:	f7ff fe8d 	bl	8033040 <SUBGRF_WriteRegister>
}
 8033326:	9801      	ldr	r0, [sp, #4]
 8033328:	b003      	add	sp, #12
 803332a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 803332c:	000008e2 	.word	0x000008e2
 8033330:	000008e5 	.word	0x000008e5
 8033334:	00ffffff 	.word	0x00ffffff
 8033338:	00000819 	.word	0x00000819

0803333c <SUBGRF_SetRxBoosted>:
{
 803333c:	b510      	push	{r4, lr}
 803333e:	b082      	sub	sp, #8
 8033340:	0004      	movs	r4, r0
    OperatingMode = MODE_RX;
 8033342:	4b09      	ldr	r3, [pc, #36]	; (8033368 <SUBGRF_SetRxBoosted+0x2c>)
 8033344:	2205      	movs	r2, #5
 8033346:	701a      	strb	r2, [r3, #0]
    SUBGRF_WriteRegister( REG_RX_GAIN, 0x97 ); // max LNA gain, increase current by ~2mA for around ~3dB in sensitivity
 8033348:	2197      	movs	r1, #151	; 0x97
 803334a:	4808      	ldr	r0, [pc, #32]	; (803336c <SUBGRF_SetRxBoosted+0x30>)
 803334c:	f7ff fe78 	bl	8033040 <SUBGRF_WriteRegister>
    buf[0] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 8033350:	0c23      	lsrs	r3, r4, #16
 8033352:	a901      	add	r1, sp, #4
 8033354:	700b      	strb	r3, [r1, #0]
    buf[1] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 8033356:	0a23      	lsrs	r3, r4, #8
 8033358:	704b      	strb	r3, [r1, #1]
    buf[2] = ( uint8_t )( timeout & 0xFF );
 803335a:	708c      	strb	r4, [r1, #2]
    SUBGRF_WriteCommand( RADIO_SET_RX, buf, 3 );
 803335c:	2203      	movs	r2, #3
 803335e:	2082      	movs	r0, #130	; 0x82
 8033360:	f7ff ff3a 	bl	80331d8 <SUBGRF_WriteCommand>
}
 8033364:	b002      	add	sp, #8
 8033366:	bd10      	pop	{r4, pc}
 8033368:	2000c702 	.word	0x2000c702
 803336c:	000008ac 	.word	0x000008ac

08033370 <SUBGRF_SetRxDutyCycle>:
{
 8033370:	b500      	push	{lr}
 8033372:	b083      	sub	sp, #12
    buf[0] = ( uint8_t )( ( rxTime >> 16 ) & 0xFF );
 8033374:	0c03      	lsrs	r3, r0, #16
 8033376:	466a      	mov	r2, sp
 8033378:	7013      	strb	r3, [r2, #0]
    buf[1] = ( uint8_t )( ( rxTime >> 8 ) & 0xFF );
 803337a:	0a03      	lsrs	r3, r0, #8
 803337c:	7053      	strb	r3, [r2, #1]
    buf[2] = ( uint8_t )( rxTime & 0xFF );
 803337e:	7090      	strb	r0, [r2, #2]
    buf[3] = ( uint8_t )( ( sleepTime >> 16 ) & 0xFF );
 8033380:	0c0b      	lsrs	r3, r1, #16
 8033382:	70d3      	strb	r3, [r2, #3]
    buf[4] = ( uint8_t )( ( sleepTime >> 8 ) & 0xFF );
 8033384:	0a0b      	lsrs	r3, r1, #8
 8033386:	7113      	strb	r3, [r2, #4]
    buf[5] = ( uint8_t )( sleepTime & 0xFF );
 8033388:	7151      	strb	r1, [r2, #5]
    SUBGRF_WriteCommand( RADIO_SET_RXDUTYCYCLE, buf, 6 );
 803338a:	2206      	movs	r2, #6
 803338c:	4669      	mov	r1, sp
 803338e:	2094      	movs	r0, #148	; 0x94
 8033390:	f7ff ff22 	bl	80331d8 <SUBGRF_WriteCommand>
    OperatingMode = MODE_RX_DC;
 8033394:	4b02      	ldr	r3, [pc, #8]	; (80333a0 <SUBGRF_SetRxDutyCycle+0x30>)
 8033396:	2206      	movs	r2, #6
 8033398:	701a      	strb	r2, [r3, #0]
}
 803339a:	b003      	add	sp, #12
 803339c:	bd00      	pop	{pc}
 803339e:	46c0      	nop			; (mov r8, r8)
 80333a0:	2000c702 	.word	0x2000c702

080333a4 <SUBGRF_SetCad>:
{
 80333a4:	b510      	push	{r4, lr}
    SUBGRF_WriteCommand( RADIO_SET_CAD, 0, 0 );
 80333a6:	2200      	movs	r2, #0
 80333a8:	2100      	movs	r1, #0
 80333aa:	20c5      	movs	r0, #197	; 0xc5
 80333ac:	f7ff ff14 	bl	80331d8 <SUBGRF_WriteCommand>
    OperatingMode = MODE_CAD;
 80333b0:	4b01      	ldr	r3, [pc, #4]	; (80333b8 <SUBGRF_SetCad+0x14>)
 80333b2:	2207      	movs	r2, #7
 80333b4:	701a      	strb	r2, [r3, #0]
}
 80333b6:	bd10      	pop	{r4, pc}
 80333b8:	2000c702 	.word	0x2000c702

080333bc <SUBGRF_SetTxContinuousWave>:
{
 80333bc:	b510      	push	{r4, lr}
    SUBGRF_WriteCommand( RADIO_SET_TXCONTINUOUSWAVE, 0, 0 );
 80333be:	2200      	movs	r2, #0
 80333c0:	2100      	movs	r1, #0
 80333c2:	20d1      	movs	r0, #209	; 0xd1
 80333c4:	f7ff ff08 	bl	80331d8 <SUBGRF_WriteCommand>
}
 80333c8:	bd10      	pop	{r4, pc}

080333ca <SUBGRF_SetTxInfinitePreamble>:
{
 80333ca:	b510      	push	{r4, lr}
    SUBGRF_WriteCommand( RADIO_SET_TXCONTINUOUSPREAMBLE, 0, 0 );
 80333cc:	2200      	movs	r2, #0
 80333ce:	2100      	movs	r1, #0
 80333d0:	20d2      	movs	r0, #210	; 0xd2
 80333d2:	f7ff ff01 	bl	80331d8 <SUBGRF_WriteCommand>
}
 80333d6:	bd10      	pop	{r4, pc}

080333d8 <SUBGRF_SetStopRxTimerOnPreambleDetect>:
{
 80333d8:	b500      	push	{lr}
 80333da:	b083      	sub	sp, #12
 80333dc:	466b      	mov	r3, sp
 80333de:	1dd9      	adds	r1, r3, #7
 80333e0:	7008      	strb	r0, [r1, #0]
    SUBGRF_WriteCommand( RADIO_SET_STOPRXTIMERONPREAMBLE, ( uint8_t* )&enable, 1 );
 80333e2:	2201      	movs	r2, #1
 80333e4:	209f      	movs	r0, #159	; 0x9f
 80333e6:	f7ff fef7 	bl	80331d8 <SUBGRF_WriteCommand>
}
 80333ea:	b003      	add	sp, #12
 80333ec:	bd00      	pop	{pc}
	...

080333f0 <SUBGRF_SetLoRaSymbNumTimeout>:
{
 80333f0:	b500      	push	{lr}
 80333f2:	b083      	sub	sp, #12
 80333f4:	466b      	mov	r3, sp
 80333f6:	71d8      	strb	r0, [r3, #7]
    SUBGRF_WriteCommand( RADIO_SET_LORASYMBTIMEOUT, &symbNum, 1 );
 80333f8:	2201      	movs	r2, #1
 80333fa:	1dd9      	adds	r1, r3, #7
 80333fc:	20a0      	movs	r0, #160	; 0xa0
 80333fe:	f7ff feeb 	bl	80331d8 <SUBGRF_WriteCommand>
    if( symbNum >= 64 )
 8033402:	466b      	mov	r3, sp
 8033404:	79db      	ldrb	r3, [r3, #7]
 8033406:	2b3f      	cmp	r3, #63	; 0x3f
 8033408:	d90e      	bls.n	8033428 <SUBGRF_SetLoRaSymbNumTimeout+0x38>
        uint8_t mant = symbNum >> 1;
 803340a:	085b      	lsrs	r3, r3, #1
        uint8_t exp  = 0;
 803340c:	2100      	movs	r1, #0
        while( mant > 31 )
 803340e:	e002      	b.n	8033416 <SUBGRF_SetLoRaSymbNumTimeout+0x26>
            mant >>= 2;
 8033410:	089b      	lsrs	r3, r3, #2
            exp++;
 8033412:	3101      	adds	r1, #1
 8033414:	b2c9      	uxtb	r1, r1
        while( mant > 31 )
 8033416:	2b1f      	cmp	r3, #31
 8033418:	d8fa      	bhi.n	8033410 <SUBGRF_SetLoRaSymbNumTimeout+0x20>
        reg = exp + ( mant << 3 );
 803341a:	00db      	lsls	r3, r3, #3
 803341c:	b2db      	uxtb	r3, r3
 803341e:	1859      	adds	r1, r3, r1
 8033420:	b2c9      	uxtb	r1, r1
        SUBGRF_WriteRegister( REG_LR_SYNCH_TIMEOUT, reg );
 8033422:	4802      	ldr	r0, [pc, #8]	; (803342c <SUBGRF_SetLoRaSymbNumTimeout+0x3c>)
 8033424:	f7ff fe0c 	bl	8033040 <SUBGRF_WriteRegister>
}
 8033428:	b003      	add	sp, #12
 803342a:	bd00      	pop	{pc}
 803342c:	00000706 	.word	0x00000706

08033430 <SUBGRF_SetRegulatorMode>:
{
 8033430:	b500      	push	{lr}
 8033432:	b083      	sub	sp, #12
    if ( ( 1UL == RBI_IsDCDC() ) && ( 1UL == DCDC_ENABLE ) )
 8033434:	f7ee fd52 	bl	8021edc <RBI_IsDCDC>
 8033438:	2801      	cmp	r0, #1
 803343a:	d00a      	beq.n	8033452 <SUBGRF_SetRegulatorMode+0x22>
        mode = USE_LDO ;
 803343c:	466b      	mov	r3, sp
 803343e:	2200      	movs	r2, #0
 8033440:	71da      	strb	r2, [r3, #7]
    SUBGRF_WriteCommand( RADIO_SET_REGULATORMODE, ( uint8_t* )&mode, 1 );
 8033442:	2201      	movs	r2, #1
 8033444:	466b      	mov	r3, sp
 8033446:	1dd9      	adds	r1, r3, #7
 8033448:	2096      	movs	r0, #150	; 0x96
 803344a:	f7ff fec5 	bl	80331d8 <SUBGRF_WriteCommand>
}
 803344e:	b003      	add	sp, #12
 8033450:	bd00      	pop	{pc}
        mode = USE_DCDC ;
 8033452:	466b      	mov	r3, sp
 8033454:	2201      	movs	r2, #1
 8033456:	71da      	strb	r2, [r3, #7]
 8033458:	e7f3      	b.n	8033442 <SUBGRF_SetRegulatorMode+0x12>

0803345a <SUBGRF_Calibrate>:
{
 803345a:	b500      	push	{lr}
 803345c:	b083      	sub	sp, #12
 803345e:	1c03      	adds	r3, r0, #0
    uint8_t value = ( ( ( uint8_t )calibParam.Fields.ImgEnable << 6 ) |
 8033460:	0658      	lsls	r0, r3, #25
 8033462:	0fc0      	lsrs	r0, r0, #31
 8033464:	0180      	lsls	r0, r0, #6
                      ( ( uint8_t )calibParam.Fields.ADCBulkPEnable << 5 ) |
 8033466:	069a      	lsls	r2, r3, #26
 8033468:	0fd2      	lsrs	r2, r2, #31
 803346a:	0152      	lsls	r2, r2, #5
    uint8_t value = ( ( ( uint8_t )calibParam.Fields.ImgEnable << 6 ) |
 803346c:	4310      	orrs	r0, r2
                      ( ( uint8_t )calibParam.Fields.ADCBulkNEnable << 4 ) |
 803346e:	06da      	lsls	r2, r3, #27
 8033470:	0fd2      	lsrs	r2, r2, #31
 8033472:	0112      	lsls	r2, r2, #4
                      ( ( uint8_t )calibParam.Fields.ADCBulkPEnable << 5 ) |
 8033474:	4310      	orrs	r0, r2
                      ( ( uint8_t )calibParam.Fields.ADCPulseEnable << 3 ) |
 8033476:	071a      	lsls	r2, r3, #28
 8033478:	0fd2      	lsrs	r2, r2, #31
 803347a:	00d2      	lsls	r2, r2, #3
                      ( ( uint8_t )calibParam.Fields.ADCBulkNEnable << 4 ) |
 803347c:	4310      	orrs	r0, r2
                      ( ( uint8_t )calibParam.Fields.PLLEnable << 2 ) |
 803347e:	075a      	lsls	r2, r3, #29
 8033480:	0fd2      	lsrs	r2, r2, #31
 8033482:	0092      	lsls	r2, r2, #2
                      ( ( uint8_t )calibParam.Fields.ADCPulseEnable << 3 ) |
 8033484:	4310      	orrs	r0, r2
                      ( ( uint8_t )calibParam.Fields.RC13MEnable << 1 ) |
 8033486:	079a      	lsls	r2, r3, #30
 8033488:	0fd2      	lsrs	r2, r2, #31
 803348a:	0052      	lsls	r2, r2, #1
                      ( ( uint8_t )calibParam.Fields.PLLEnable << 2 ) |
 803348c:	4310      	orrs	r0, r2
                      ( ( uint8_t )calibParam.Fields.RC64KEnable ) );
 803348e:	07db      	lsls	r3, r3, #31
 8033490:	0fdb      	lsrs	r3, r3, #31
 8033492:	b25b      	sxtb	r3, r3
                      ( ( uint8_t )calibParam.Fields.RC13MEnable << 1 ) |
 8033494:	4318      	orrs	r0, r3
    uint8_t value = ( ( ( uint8_t )calibParam.Fields.ImgEnable << 6 ) |
 8033496:	466b      	mov	r3, sp
 8033498:	1dd9      	adds	r1, r3, #7
 803349a:	7008      	strb	r0, [r1, #0]
    SUBGRF_WriteCommand( RADIO_CALIBRATE, &value, 1 );
 803349c:	2201      	movs	r2, #1
 803349e:	2089      	movs	r0, #137	; 0x89
 80334a0:	f7ff fe9a 	bl	80331d8 <SUBGRF_WriteCommand>
}
 80334a4:	b003      	add	sp, #12
 80334a6:	bd00      	pop	{pc}

080334a8 <SUBGRF_CalibrateImage>:
{
 80334a8:	b500      	push	{lr}
 80334aa:	b083      	sub	sp, #12
    if( freq > 900000000 )
 80334ac:	4b1c      	ldr	r3, [pc, #112]	; (8033520 <SUBGRF_CalibrateImage+0x78>)
 80334ae:	4298      	cmp	r0, r3
 80334b0:	d90b      	bls.n	80334ca <SUBGRF_CalibrateImage+0x22>
        calFreq[0] = 0xE1;
 80334b2:	ab01      	add	r3, sp, #4
 80334b4:	22e1      	movs	r2, #225	; 0xe1
 80334b6:	701a      	strb	r2, [r3, #0]
        calFreq[1] = 0xE9;
 80334b8:	3208      	adds	r2, #8
 80334ba:	705a      	strb	r2, [r3, #1]
    SUBGRF_WriteCommand( RADIO_CALIBRATEIMAGE, calFreq, 2 );
 80334bc:	2202      	movs	r2, #2
 80334be:	a901      	add	r1, sp, #4
 80334c0:	2098      	movs	r0, #152	; 0x98
 80334c2:	f7ff fe89 	bl	80331d8 <SUBGRF_WriteCommand>
}
 80334c6:	b003      	add	sp, #12
 80334c8:	bd00      	pop	{pc}
    else if( freq > 850000000 )
 80334ca:	4b16      	ldr	r3, [pc, #88]	; (8033524 <SUBGRF_CalibrateImage+0x7c>)
 80334cc:	4298      	cmp	r0, r3
 80334ce:	d905      	bls.n	80334dc <SUBGRF_CalibrateImage+0x34>
        calFreq[0] = 0xD7;
 80334d0:	ab01      	add	r3, sp, #4
 80334d2:	22d7      	movs	r2, #215	; 0xd7
 80334d4:	701a      	strb	r2, [r3, #0]
        calFreq[1] = 0xDB;
 80334d6:	3204      	adds	r2, #4
 80334d8:	705a      	strb	r2, [r3, #1]
 80334da:	e7ef      	b.n	80334bc <SUBGRF_CalibrateImage+0x14>
    else if( freq > 770000000 )
 80334dc:	4b12      	ldr	r3, [pc, #72]	; (8033528 <SUBGRF_CalibrateImage+0x80>)
 80334de:	4298      	cmp	r0, r3
 80334e0:	d905      	bls.n	80334ee <SUBGRF_CalibrateImage+0x46>
        calFreq[0] = 0xC1;
 80334e2:	ab01      	add	r3, sp, #4
 80334e4:	22c1      	movs	r2, #193	; 0xc1
 80334e6:	701a      	strb	r2, [r3, #0]
        calFreq[1] = 0xC5;
 80334e8:	3204      	adds	r2, #4
 80334ea:	705a      	strb	r2, [r3, #1]
 80334ec:	e7e6      	b.n	80334bc <SUBGRF_CalibrateImage+0x14>
    else if( freq > 460000000 )
 80334ee:	4b0f      	ldr	r3, [pc, #60]	; (803352c <SUBGRF_CalibrateImage+0x84>)
 80334f0:	4298      	cmp	r0, r3
 80334f2:	d905      	bls.n	8033500 <SUBGRF_CalibrateImage+0x58>
        calFreq[0] = 0x75;
 80334f4:	ab01      	add	r3, sp, #4
 80334f6:	2275      	movs	r2, #117	; 0x75
 80334f8:	701a      	strb	r2, [r3, #0]
        calFreq[1] = 0x81;
 80334fa:	320c      	adds	r2, #12
 80334fc:	705a      	strb	r2, [r3, #1]
 80334fe:	e7dd      	b.n	80334bc <SUBGRF_CalibrateImage+0x14>
    else if( freq > 425000000 )
 8033500:	4b0b      	ldr	r3, [pc, #44]	; (8033530 <SUBGRF_CalibrateImage+0x88>)
 8033502:	4298      	cmp	r0, r3
 8033504:	d905      	bls.n	8033512 <SUBGRF_CalibrateImage+0x6a>
        calFreq[0] = 0x6B;
 8033506:	ab01      	add	r3, sp, #4
 8033508:	226b      	movs	r2, #107	; 0x6b
 803350a:	701a      	strb	r2, [r3, #0]
        calFreq[1] = 0x6F;
 803350c:	3204      	adds	r2, #4
 803350e:	705a      	strb	r2, [r3, #1]
 8033510:	e7d4      	b.n	80334bc <SUBGRF_CalibrateImage+0x14>
        calFreq[0] = 0x29;
 8033512:	ab01      	add	r3, sp, #4
 8033514:	2229      	movs	r2, #41	; 0x29
 8033516:	701a      	strb	r2, [r3, #0]
        calFreq[1] = 0x2B ;
 8033518:	3202      	adds	r2, #2
 803351a:	705a      	strb	r2, [r3, #1]
 803351c:	e7ce      	b.n	80334bc <SUBGRF_CalibrateImage+0x14>
 803351e:	46c0      	nop			; (mov r8, r8)
 8033520:	35a4e900 	.word	0x35a4e900
 8033524:	32a9f880 	.word	0x32a9f880
 8033528:	2de54480 	.word	0x2de54480
 803352c:	1b6b0b00 	.word	0x1b6b0b00
 8033530:	1954fc40 	.word	0x1954fc40

08033534 <SUBGRF_SetPaConfig>:
{
 8033534:	b510      	push	{r4, lr}
 8033536:	b082      	sub	sp, #8
    buf[0] = paDutyCycle;
 8033538:	ac01      	add	r4, sp, #4
 803353a:	7020      	strb	r0, [r4, #0]
    buf[1] = hpMax;
 803353c:	7061      	strb	r1, [r4, #1]
    buf[2] = deviceSel;
 803353e:	70a2      	strb	r2, [r4, #2]
    buf[3] = paLut;
 8033540:	70e3      	strb	r3, [r4, #3]
    SUBGRF_WriteCommand( RADIO_SET_PACONFIG, buf, 4 );
 8033542:	2204      	movs	r2, #4
 8033544:	0021      	movs	r1, r4
 8033546:	2095      	movs	r0, #149	; 0x95
 8033548:	f7ff fe46 	bl	80331d8 <SUBGRF_WriteCommand>
}
 803354c:	b002      	add	sp, #8
 803354e:	bd10      	pop	{r4, pc}

08033550 <SUBGRF_SetDioIrqParams>:
{
 8033550:	b530      	push	{r4, r5, lr}
 8033552:	b083      	sub	sp, #12
    buf[0] = ( uint8_t )( ( irqMask >> 8 ) & 0x00FF );
 8033554:	0a04      	lsrs	r4, r0, #8
 8033556:	466d      	mov	r5, sp
 8033558:	702c      	strb	r4, [r5, #0]
    buf[1] = ( uint8_t )( irqMask & 0x00FF );
 803355a:	7068      	strb	r0, [r5, #1]
    buf[2] = ( uint8_t )( ( dio1Mask >> 8 ) & 0x00FF );
 803355c:	0a08      	lsrs	r0, r1, #8
 803355e:	70a8      	strb	r0, [r5, #2]
    buf[3] = ( uint8_t )( dio1Mask & 0x00FF );
 8033560:	70e9      	strb	r1, [r5, #3]
    buf[4] = ( uint8_t )( ( dio2Mask >> 8 ) & 0x00FF );
 8033562:	0a11      	lsrs	r1, r2, #8
 8033564:	7129      	strb	r1, [r5, #4]
    buf[5] = ( uint8_t )( dio2Mask & 0x00FF );
 8033566:	4669      	mov	r1, sp
 8033568:	716a      	strb	r2, [r5, #5]
    buf[6] = ( uint8_t )( ( dio3Mask >> 8 ) & 0x00FF );
 803356a:	0a1a      	lsrs	r2, r3, #8
 803356c:	71aa      	strb	r2, [r5, #6]
    buf[7] = ( uint8_t )( dio3Mask & 0x00FF );
 803356e:	71eb      	strb	r3, [r5, #7]
    SUBGRF_WriteCommand( RADIO_CFG_DIOIRQ, buf, 8 );
 8033570:	2208      	movs	r2, #8
 8033572:	2008      	movs	r0, #8
 8033574:	f7ff fe30 	bl	80331d8 <SUBGRF_WriteCommand>
}
 8033578:	b003      	add	sp, #12
 803357a:	bd30      	pop	{r4, r5, pc}

0803357c <SUBGRF_SetTcxoMode>:
{
 803357c:	b500      	push	{lr}
 803357e:	b083      	sub	sp, #12
 8033580:	000b      	movs	r3, r1
    buf[0] = tcxoVoltage & 0x07;
 8033582:	2207      	movs	r2, #7
 8033584:	4010      	ands	r0, r2
 8033586:	a901      	add	r1, sp, #4
 8033588:	7008      	strb	r0, [r1, #0]
    buf[1] = ( uint8_t )( ( timeout >> 16 ) & 0xFF );
 803358a:	0c1a      	lsrs	r2, r3, #16
 803358c:	704a      	strb	r2, [r1, #1]
    buf[2] = ( uint8_t )( ( timeout >> 8 ) & 0xFF );
 803358e:	0a1a      	lsrs	r2, r3, #8
 8033590:	708a      	strb	r2, [r1, #2]
    buf[3] = ( uint8_t )( timeout & 0xFF );
 8033592:	70cb      	strb	r3, [r1, #3]
    SUBGRF_WriteCommand( RADIO_SET_TCXOMODE, buf, 4 );
 8033594:	2204      	movs	r2, #4
 8033596:	2097      	movs	r0, #151	; 0x97
 8033598:	f7ff fe1e 	bl	80331d8 <SUBGRF_WriteCommand>
}
 803359c:	b003      	add	sp, #12
 803359e:	bd00      	pop	{pc}

080335a0 <SUBGRF_Init>:
{
 80335a0:	b510      	push	{r4, lr}
    if ( dioIrq != NULL)
 80335a2:	2800      	cmp	r0, #0
 80335a4:	d001      	beq.n	80335aa <SUBGRF_Init+0xa>
        RadioOnDioIrqCb = dioIrq;
 80335a6:	4b17      	ldr	r3, [pc, #92]	; (8033604 <SUBGRF_Init+0x64>)
 80335a8:	6018      	str	r0, [r3, #0]
    RADIO_INIT();
 80335aa:	f7ee f9ed 	bl	8021988 <MX_SUBGHZ_Init>
    Radio_SMPS_Set(SMPS_DRIVE_SETTING_DEFAULT);
 80335ae:	2002      	movs	r0, #2
 80335b0:	f7ff fd64 	bl	803307c <Radio_SMPS_Set>
    ImageCalibrated = false;
 80335b4:	4b14      	ldr	r3, [pc, #80]	; (8033608 <SUBGRF_Init+0x68>)
 80335b6:	2200      	movs	r2, #0
 80335b8:	701a      	strb	r2, [r3, #0]
    SUBGRF_SetStandby( STDBY_RC );
 80335ba:	2000      	movs	r0, #0
 80335bc:	f7ff fe3e 	bl	803323c <SUBGRF_SetStandby>
    if (1U == RBI_IsTCXO() )
 80335c0:	f7ee fc88 	bl	8021ed4 <RBI_IsTCXO>
 80335c4:	2801      	cmp	r0, #1
 80335c6:	d011      	beq.n	80335ec <SUBGRF_Init+0x4c>
        SUBGRF_WriteRegister( REG_XTA_TRIM, XTAL_DEFAULT_CAP_VALUE );
 80335c8:	2120      	movs	r1, #32
 80335ca:	4810      	ldr	r0, [pc, #64]	; (803360c <SUBGRF_Init+0x6c>)
 80335cc:	f7ff fd38 	bl	8033040 <SUBGRF_WriteRegister>
        SUBGRF_WriteRegister( REG_XTB_TRIM, XTAL_DEFAULT_CAP_VALUE );
 80335d0:	2120      	movs	r1, #32
 80335d2:	480f      	ldr	r0, [pc, #60]	; (8033610 <SUBGRF_Init+0x70>)
 80335d4:	f7ff fd34 	bl	8033040 <SUBGRF_WriteRegister>
    SUBGRF_WriteRegister(REG_DRV_CTRL, 0x7 << 1);
 80335d8:	210e      	movs	r1, #14
 80335da:	480e      	ldr	r0, [pc, #56]	; (8033614 <SUBGRF_Init+0x74>)
 80335dc:	f7ff fd30 	bl	8033040 <SUBGRF_WriteRegister>
    RBI_Init();
 80335e0:	f7ee fc6c 	bl	8021ebc <RBI_Init>
    OperatingMode = MODE_STDBY_RC;
 80335e4:	4b0c      	ldr	r3, [pc, #48]	; (8033618 <SUBGRF_Init+0x78>)
 80335e6:	2201      	movs	r2, #1
 80335e8:	701a      	strb	r2, [r3, #0]
}
 80335ea:	bd10      	pop	{r4, pc}
        SUBGRF_SetTcxoMode( TCXO_CTRL_VOLTAGE, RF_WAKEUP_TIME << 6 );// 100 ms
 80335ec:	2140      	movs	r1, #64	; 0x40
 80335ee:	f7ff ffc5 	bl	803357c <SUBGRF_SetTcxoMode>
        SUBGRF_WriteRegister( REG_XTA_TRIM, 0x00 );
 80335f2:	2100      	movs	r1, #0
 80335f4:	4805      	ldr	r0, [pc, #20]	; (803360c <SUBGRF_Init+0x6c>)
 80335f6:	f7ff fd23 	bl	8033040 <SUBGRF_WriteRegister>
        SUBGRF_Calibrate( calibParam );
 80335fa:	207f      	movs	r0, #127	; 0x7f
 80335fc:	f7ff ff2d 	bl	803345a <SUBGRF_Calibrate>
 8033600:	e7ea      	b.n	80335d8 <SUBGRF_Init+0x38>
 8033602:	46c0      	nop			; (mov r8, r8)
 8033604:	2000c704 	.word	0x2000c704
 8033608:	2000c700 	.word	0x2000c700
 803360c:	00000911 	.word	0x00000911
 8033610:	00000912 	.word	0x00000912
 8033614:	0000091f 	.word	0x0000091f
 8033618:	2000c702 	.word	0x2000c702

0803361c <SUBGRF_SetRfFrequency>:
{
 803361c:	b510      	push	{r4, lr}
 803361e:	b082      	sub	sp, #8
 8033620:	0004      	movs	r4, r0
    if( ImageCalibrated == false )
 8033622:	4b0f      	ldr	r3, [pc, #60]	; (8033660 <SUBGRF_SetRfFrequency+0x44>)
 8033624:	781b      	ldrb	r3, [r3, #0]
 8033626:	2b00      	cmp	r3, #0
 8033628:	d013      	beq.n	8033652 <SUBGRF_SetRfFrequency+0x36>
    SX_FREQ_TO_CHANNEL(chan, frequency);
 803362a:	09e1      	lsrs	r1, r4, #7
 803362c:	0660      	lsls	r0, r4, #25
 803362e:	4a0d      	ldr	r2, [pc, #52]	; (8033664 <SUBGRF_SetRfFrequency+0x48>)
 8033630:	2300      	movs	r3, #0
 8033632:	f7ec ff25 	bl	8020480 <__aeabi_uldivmod>
    buf[0] = ( uint8_t )( ( chan >> 24 ) & 0xFF );
 8033636:	0e03      	lsrs	r3, r0, #24
 8033638:	a901      	add	r1, sp, #4
 803363a:	700b      	strb	r3, [r1, #0]
    buf[1] = ( uint8_t )( ( chan >> 16 ) & 0xFF );
 803363c:	0c03      	lsrs	r3, r0, #16
 803363e:	704b      	strb	r3, [r1, #1]
    buf[2] = ( uint8_t )( ( chan >> 8 ) & 0xFF );
 8033640:	0a03      	lsrs	r3, r0, #8
 8033642:	708b      	strb	r3, [r1, #2]
    buf[3] = ( uint8_t )( chan & 0xFF );
 8033644:	70c8      	strb	r0, [r1, #3]
    SUBGRF_WriteCommand( RADIO_SET_RFFREQUENCY, buf, 4 );
 8033646:	2204      	movs	r2, #4
 8033648:	2086      	movs	r0, #134	; 0x86
 803364a:	f7ff fdc5 	bl	80331d8 <SUBGRF_WriteCommand>
}
 803364e:	b002      	add	sp, #8
 8033650:	bd10      	pop	{r4, pc}
        SUBGRF_CalibrateImage( frequency );
 8033652:	f7ff ff29 	bl	80334a8 <SUBGRF_CalibrateImage>
        ImageCalibrated = true;
 8033656:	4b02      	ldr	r3, [pc, #8]	; (8033660 <SUBGRF_SetRfFrequency+0x44>)
 8033658:	2201      	movs	r2, #1
 803365a:	701a      	strb	r2, [r3, #0]
 803365c:	e7e5      	b.n	803362a <SUBGRF_SetRfFrequency+0xe>
 803365e:	46c0      	nop			; (mov r8, r8)
 8033660:	2000c700 	.word	0x2000c700
 8033664:	01e84800 	.word	0x01e84800

08033668 <SUBGRF_SetPacketType>:
{
 8033668:	b500      	push	{lr}
 803366a:	b083      	sub	sp, #12
 803366c:	466b      	mov	r3, sp
 803366e:	71d8      	strb	r0, [r3, #7]
    PacketType = packetType;
 8033670:	b2c3      	uxtb	r3, r0
 8033672:	4a08      	ldr	r2, [pc, #32]	; (8033694 <SUBGRF_SetPacketType+0x2c>)
 8033674:	7013      	strb	r3, [r2, #0]
    if( packetType == PACKET_TYPE_GFSK )
 8033676:	2b00      	cmp	r3, #0
 8033678:	d007      	beq.n	803368a <SUBGRF_SetPacketType+0x22>
    SUBGRF_WriteCommand( RADIO_SET_PACKETTYPE, ( uint8_t* )&packetType, 1 );
 803367a:	2201      	movs	r2, #1
 803367c:	466b      	mov	r3, sp
 803367e:	1dd9      	adds	r1, r3, #7
 8033680:	208a      	movs	r0, #138	; 0x8a
 8033682:	f7ff fda9 	bl	80331d8 <SUBGRF_WriteCommand>
}
 8033686:	b003      	add	sp, #12
 8033688:	bd00      	pop	{pc}
        SUBGRF_WriteRegister( REG_BIT_SYNC, 0x00 );
 803368a:	2100      	movs	r1, #0
 803368c:	4802      	ldr	r0, [pc, #8]	; (8033698 <SUBGRF_SetPacketType+0x30>)
 803368e:	f7ff fcd7 	bl	8033040 <SUBGRF_WriteRegister>
 8033692:	e7f2      	b.n	803367a <SUBGRF_SetPacketType+0x12>
 8033694:	2000c703 	.word	0x2000c703
 8033698:	000006ac 	.word	0x000006ac

0803369c <SUBGRF_SetTxParams>:
{
 803369c:	b570      	push	{r4, r5, r6, lr}
 803369e:	b082      	sub	sp, #8
 80336a0:	000c      	movs	r4, r1
 80336a2:	0016      	movs	r6, r2
    if (paSelect == RFO_LP)
 80336a4:	2801      	cmp	r0, #1
 80336a6:	d032      	beq.n	803370e <SUBGRF_SetTxParams+0x72>
        SUBGRF_WriteRegister(REG_TX_CLAMP, SUBGRF_ReadRegister(REG_TX_CLAMP) | (0x0F << 1));
 80336a8:	4d41      	ldr	r5, [pc, #260]	; (80337b0 <SUBGRF_SetTxParams+0x114>)
 80336aa:	0028      	movs	r0, r5
 80336ac:	f7ff fcd6 	bl	803305c <SUBGRF_ReadRegister>
 80336b0:	211e      	movs	r1, #30
 80336b2:	4301      	orrs	r1, r0
 80336b4:	b2c9      	uxtb	r1, r1
 80336b6:	0028      	movs	r0, r5
 80336b8:	f7ff fcc2 	bl	8033040 <SUBGRF_WriteRegister>
        max_power = RBI_GetRFOMaxPowerConfig(RBI_RFO_HP_MAXPOWER);
 80336bc:	2001      	movs	r0, #1
 80336be:	f7ee fc11 	bl	8021ee4 <RBI_GetRFOMaxPowerConfig>
 80336c2:	0005      	movs	r5, r0
        if (power > max_power)
 80336c4:	4284      	cmp	r4, r0
 80336c6:	dd00      	ble.n	80336ca <SUBGRF_SetTxParams+0x2e>
            power = max_power;
 80336c8:	b244      	sxtb	r4, r0
        if (max_power == 20)
 80336ca:	2d14      	cmp	r5, #20
 80336cc:	d051      	beq.n	8033772 <SUBGRF_SetTxParams+0xd6>
        else if (max_power == 17)
 80336ce:	2d11      	cmp	r5, #17
 80336d0:	d059      	beq.n	8033786 <SUBGRF_SetTxParams+0xea>
        else if (max_power == 14)
 80336d2:	2d0e      	cmp	r5, #14
 80336d4:	d061      	beq.n	803379a <SUBGRF_SetTxParams+0xfe>
            SUBGRF_SetPaConfig(0x04, 0x07, 0x00, 0x01);
 80336d6:	2301      	movs	r3, #1
 80336d8:	2200      	movs	r2, #0
 80336da:	2107      	movs	r1, #7
 80336dc:	2004      	movs	r0, #4
 80336de:	f7ff ff29 	bl	8033534 <SUBGRF_SetPaConfig>
            power = 0x16 - (max_power - power);
 80336e2:	1b64      	subs	r4, r4, r5
 80336e4:	3416      	adds	r4, #22
 80336e6:	b264      	sxtb	r4, r4
        if (power < -9)
 80336e8:	0023      	movs	r3, r4
 80336ea:	3309      	adds	r3, #9
 80336ec:	da01      	bge.n	80336f2 <SUBGRF_SetTxParams+0x56>
            power = -9;
 80336ee:	2409      	movs	r4, #9
 80336f0:	4264      	negs	r4, r4
        SUBGRF_WriteRegister(REG_OCP, 0x38);   /*current max 160mA for the whole device*/
 80336f2:	2138      	movs	r1, #56	; 0x38
 80336f4:	482f      	ldr	r0, [pc, #188]	; (80337b4 <SUBGRF_SetTxParams+0x118>)
 80336f6:	f7ff fca3 	bl	8033040 <SUBGRF_WriteRegister>
    buf[0] = power;
 80336fa:	466b      	mov	r3, sp
 80336fc:	711c      	strb	r4, [r3, #4]
    buf[1] = (uint8_t)rampTime;
 80336fe:	715e      	strb	r6, [r3, #5]
    SUBGRF_WriteCommand(RADIO_SET_TXPARAMS, buf, 2);
 8033700:	2202      	movs	r2, #2
 8033702:	a901      	add	r1, sp, #4
 8033704:	208e      	movs	r0, #142	; 0x8e
 8033706:	f7ff fd67 	bl	80331d8 <SUBGRF_WriteCommand>
}
 803370a:	b002      	add	sp, #8
 803370c:	bd70      	pop	{r4, r5, r6, pc}
        max_power = RBI_GetRFOMaxPowerConfig(RBI_RFO_LP_MAXPOWER);
 803370e:	2000      	movs	r0, #0
 8033710:	f7ee fbe8 	bl	8021ee4 <RBI_GetRFOMaxPowerConfig>
 8033714:	0005      	movs	r5, r0
        if (power >  max_power)
 8033716:	4284      	cmp	r4, r0
 8033718:	dd00      	ble.n	803371c <SUBGRF_SetTxParams+0x80>
          power = max_power;
 803371a:	b244      	sxtb	r4, r0
        if (max_power == 14)
 803371c:	2d0e      	cmp	r5, #14
 803371e:	d014      	beq.n	803374a <SUBGRF_SetTxParams+0xae>
        else if (max_power == 10)
 8033720:	2d0a      	cmp	r5, #10
 8033722:	d01c      	beq.n	803375e <SUBGRF_SetTxParams+0xc2>
            SUBGRF_SetPaConfig(0x07, 0x00, 0x01, 0x01);
 8033724:	2301      	movs	r3, #1
 8033726:	2201      	movs	r2, #1
 8033728:	2100      	movs	r1, #0
 803372a:	2007      	movs	r0, #7
 803372c:	f7ff ff02 	bl	8033534 <SUBGRF_SetPaConfig>
            power = 0x0E - (max_power - power);
 8033730:	1b64      	subs	r4, r4, r5
 8033732:	340e      	adds	r4, #14
 8033734:	b264      	sxtb	r4, r4
        if (power < -17)
 8033736:	0023      	movs	r3, r4
 8033738:	3311      	adds	r3, #17
 803373a:	da01      	bge.n	8033740 <SUBGRF_SetTxParams+0xa4>
            power = -17;
 803373c:	2411      	movs	r4, #17
 803373e:	4264      	negs	r4, r4
        SUBGRF_WriteRegister(REG_OCP, 0x18);   /* current max is 80 mA for the whole device*/
 8033740:	2118      	movs	r1, #24
 8033742:	481c      	ldr	r0, [pc, #112]	; (80337b4 <SUBGRF_SetTxParams+0x118>)
 8033744:	f7ff fc7c 	bl	8033040 <SUBGRF_WriteRegister>
 8033748:	e7d7      	b.n	80336fa <SUBGRF_SetTxParams+0x5e>
            SUBGRF_SetPaConfig(0x04, 0x00, 0x01, 0x01);
 803374a:	2301      	movs	r3, #1
 803374c:	2201      	movs	r2, #1
 803374e:	2100      	movs	r1, #0
 8033750:	2004      	movs	r0, #4
 8033752:	f7ff feef 	bl	8033534 <SUBGRF_SetPaConfig>
            power = 0x0E - (max_power - power);
 8033756:	1b64      	subs	r4, r4, r5
 8033758:	340e      	adds	r4, #14
 803375a:	b264      	sxtb	r4, r4
 803375c:	e7eb      	b.n	8033736 <SUBGRF_SetTxParams+0x9a>
            SUBGRF_SetPaConfig(0x01, 0x00, 0x01, 0x01);
 803375e:	2301      	movs	r3, #1
 8033760:	2201      	movs	r2, #1
 8033762:	2100      	movs	r1, #0
 8033764:	2001      	movs	r0, #1
 8033766:	f7ff fee5 	bl	8033534 <SUBGRF_SetPaConfig>
            power = 0x0D - (max_power - power);
 803376a:	1b64      	subs	r4, r4, r5
 803376c:	340d      	adds	r4, #13
 803376e:	b264      	sxtb	r4, r4
 8033770:	e7e1      	b.n	8033736 <SUBGRF_SetTxParams+0x9a>
            SUBGRF_SetPaConfig(0x03, 0x05, 0x00, 0x01);
 8033772:	2301      	movs	r3, #1
 8033774:	2200      	movs	r2, #0
 8033776:	2105      	movs	r1, #5
 8033778:	2003      	movs	r0, #3
 803377a:	f7ff fedb 	bl	8033534 <SUBGRF_SetPaConfig>
            power = 0x16 - (max_power - power);
 803377e:	1b64      	subs	r4, r4, r5
 8033780:	3416      	adds	r4, #22
 8033782:	b264      	sxtb	r4, r4
 8033784:	e7b0      	b.n	80336e8 <SUBGRF_SetTxParams+0x4c>
            SUBGRF_SetPaConfig(0x02, 0x03, 0x00, 0x01);
 8033786:	2301      	movs	r3, #1
 8033788:	2200      	movs	r2, #0
 803378a:	2103      	movs	r1, #3
 803378c:	2002      	movs	r0, #2
 803378e:	f7ff fed1 	bl	8033534 <SUBGRF_SetPaConfig>
            power = 0x16 - (max_power - power);
 8033792:	1b64      	subs	r4, r4, r5
 8033794:	3416      	adds	r4, #22
 8033796:	b264      	sxtb	r4, r4
 8033798:	e7a6      	b.n	80336e8 <SUBGRF_SetTxParams+0x4c>
            SUBGRF_SetPaConfig(0x02, 0x02, 0x00, 0x01);
 803379a:	2301      	movs	r3, #1
 803379c:	2200      	movs	r2, #0
 803379e:	2102      	movs	r1, #2
 80337a0:	2002      	movs	r0, #2
 80337a2:	f7ff fec7 	bl	8033534 <SUBGRF_SetPaConfig>
            power = 0x0E - (max_power - power);
 80337a6:	1b64      	subs	r4, r4, r5
 80337a8:	340e      	adds	r4, #14
 80337aa:	b264      	sxtb	r4, r4
 80337ac:	e79c      	b.n	80336e8 <SUBGRF_SetTxParams+0x4c>
 80337ae:	46c0      	nop			; (mov r8, r8)
 80337b0:	000008d8 	.word	0x000008d8
 80337b4:	000008e7 	.word	0x000008e7

080337b8 <SUBGRF_SetModulationParams>:
{
 80337b8:	b510      	push	{r4, lr}
 80337ba:	b082      	sub	sp, #8
 80337bc:	0004      	movs	r4, r0
    uint8_t buf[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 80337be:	466a      	mov	r2, sp
 80337c0:	4b35      	ldr	r3, [pc, #212]	; (8033898 <SUBGRF_SetModulationParams+0xe0>)
 80337c2:	cb03      	ldmia	r3!, {r0, r1}
 80337c4:	c203      	stmia	r2!, {r0, r1}
    if( PacketType != modulationParams->PacketType )
 80337c6:	7820      	ldrb	r0, [r4, #0]
 80337c8:	4b34      	ldr	r3, [pc, #208]	; (803389c <SUBGRF_SetModulationParams+0xe4>)
 80337ca:	781b      	ldrb	r3, [r3, #0]
 80337cc:	4298      	cmp	r0, r3
 80337ce:	d116      	bne.n	80337fe <SUBGRF_SetModulationParams+0x46>
    switch( modulationParams->PacketType )
 80337d0:	7823      	ldrb	r3, [r4, #0]
 80337d2:	2b02      	cmp	r3, #2
 80337d4:	d04e      	beq.n	8033874 <SUBGRF_SetModulationParams+0xbc>
 80337d6:	d815      	bhi.n	8033804 <SUBGRF_SetModulationParams+0x4c>
 80337d8:	2b00      	cmp	r3, #0
 80337da:	d029      	beq.n	8033830 <SUBGRF_SetModulationParams+0x78>
 80337dc:	2b01      	cmp	r3, #1
 80337de:	d147      	bne.n	8033870 <SUBGRF_SetModulationParams+0xb8>
        buf[0] = modulationParams->Params.LoRa.SpreadingFactor;
 80337e0:	7e23      	ldrb	r3, [r4, #24]
 80337e2:	466a      	mov	r2, sp
 80337e4:	7013      	strb	r3, [r2, #0]
        buf[1] = modulationParams->Params.LoRa.Bandwidth;
 80337e6:	7e63      	ldrb	r3, [r4, #25]
 80337e8:	7053      	strb	r3, [r2, #1]
        buf[2] = modulationParams->Params.LoRa.CodingRate;
 80337ea:	7ea3      	ldrb	r3, [r4, #26]
 80337ec:	7093      	strb	r3, [r2, #2]
        buf[3] = modulationParams->Params.LoRa.LowDatarateOptimize;
 80337ee:	7ee3      	ldrb	r3, [r4, #27]
 80337f0:	70d3      	strb	r3, [r2, #3]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 80337f2:	2204      	movs	r2, #4
 80337f4:	4669      	mov	r1, sp
 80337f6:	208b      	movs	r0, #139	; 0x8b
 80337f8:	f7ff fcee 	bl	80331d8 <SUBGRF_WriteCommand>
        break;
 80337fc:	e038      	b.n	8033870 <SUBGRF_SetModulationParams+0xb8>
        SUBGRF_SetPacketType( modulationParams->PacketType );
 80337fe:	f7ff ff33 	bl	8033668 <SUBGRF_SetPacketType>
 8033802:	e7e5      	b.n	80337d0 <SUBGRF_SetModulationParams+0x18>
    switch( modulationParams->PacketType )
 8033804:	2b03      	cmp	r3, #3
 8033806:	d133      	bne.n	8033870 <SUBGRF_SetModulationParams+0xb8>
        tempVal = ( uint32_t )(( 32 *XTAL_FREQ) / modulationParams->Params.Gfsk.BitRate );
 8033808:	6861      	ldr	r1, [r4, #4]
 803380a:	4825      	ldr	r0, [pc, #148]	; (80338a0 <SUBGRF_SetModulationParams+0xe8>)
 803380c:	f7ec fc84 	bl	8020118 <__udivsi3>
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 8033810:	0c03      	lsrs	r3, r0, #16
 8033812:	466a      	mov	r2, sp
 8033814:	7013      	strb	r3, [r2, #0]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 8033816:	0a03      	lsrs	r3, r0, #8
 8033818:	7053      	strb	r3, [r2, #1]
        buf[2] = tempVal & 0xFF;
 803381a:	7090      	strb	r0, [r2, #2]
        buf[3] = modulationParams->Params.Gfsk.ModulationShaping;
 803381c:	7b23      	ldrb	r3, [r4, #12]
 803381e:	70d3      	strb	r3, [r2, #3]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 8033820:	7b63      	ldrb	r3, [r4, #13]
 8033822:	7113      	strb	r3, [r2, #4]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 8033824:	2205      	movs	r2, #5
 8033826:	4669      	mov	r1, sp
 8033828:	208b      	movs	r0, #139	; 0x8b
 803382a:	f7ff fcd5 	bl	80331d8 <SUBGRF_WriteCommand>
}
 803382e:	e01f      	b.n	8033870 <SUBGRF_SetModulationParams+0xb8>
        tempVal = ( uint32_t )(( 32 * XTAL_FREQ ) / modulationParams->Params.Gfsk.BitRate );
 8033830:	6861      	ldr	r1, [r4, #4]
 8033832:	481b      	ldr	r0, [pc, #108]	; (80338a0 <SUBGRF_SetModulationParams+0xe8>)
 8033834:	f7ec fc70 	bl	8020118 <__udivsi3>
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 8033838:	0c03      	lsrs	r3, r0, #16
 803383a:	466a      	mov	r2, sp
 803383c:	7013      	strb	r3, [r2, #0]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 803383e:	0a03      	lsrs	r3, r0, #8
 8033840:	7053      	strb	r3, [r2, #1]
        buf[2] = tempVal & 0xFF;
 8033842:	7090      	strb	r0, [r2, #2]
        buf[3] = modulationParams->Params.Gfsk.ModulationShaping;
 8033844:	7b23      	ldrb	r3, [r4, #12]
 8033846:	70d3      	strb	r3, [r2, #3]
        buf[4] = modulationParams->Params.Gfsk.Bandwidth;
 8033848:	7b63      	ldrb	r3, [r4, #13]
 803384a:	7113      	strb	r3, [r2, #4]
        SX_FREQ_TO_CHANNEL(tempVal, modulationParams->Params.Gfsk.Fdev);
 803384c:	68a0      	ldr	r0, [r4, #8]
 803384e:	09c1      	lsrs	r1, r0, #7
 8033850:	0640      	lsls	r0, r0, #25
 8033852:	4a14      	ldr	r2, [pc, #80]	; (80338a4 <SUBGRF_SetModulationParams+0xec>)
 8033854:	2300      	movs	r3, #0
 8033856:	f7ec fe13 	bl	8020480 <__aeabi_uldivmod>
        buf[5] = ( tempVal >> 16 ) & 0xFF;
 803385a:	0c03      	lsrs	r3, r0, #16
 803385c:	466a      	mov	r2, sp
 803385e:	7153      	strb	r3, [r2, #5]
        buf[6] = ( tempVal >> 8 ) & 0xFF;
 8033860:	0a03      	lsrs	r3, r0, #8
 8033862:	7193      	strb	r3, [r2, #6]
        buf[7] = ( tempVal& 0xFF );
 8033864:	71d0      	strb	r0, [r2, #7]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 8033866:	2208      	movs	r2, #8
 8033868:	4669      	mov	r1, sp
 803386a:	208b      	movs	r0, #139	; 0x8b
 803386c:	f7ff fcb4 	bl	80331d8 <SUBGRF_WriteCommand>
}
 8033870:	b002      	add	sp, #8
 8033872:	bd10      	pop	{r4, pc}
        tempVal = ( uint32_t ) (( 32 * XTAL_FREQ) / modulationParams->Params.Bpsk.BitRate );
 8033874:	6921      	ldr	r1, [r4, #16]
 8033876:	480a      	ldr	r0, [pc, #40]	; (80338a0 <SUBGRF_SetModulationParams+0xe8>)
 8033878:	f7ec fc4e 	bl	8020118 <__udivsi3>
        buf[0] = ( tempVal >> 16 ) & 0xFF;
 803387c:	0c03      	lsrs	r3, r0, #16
 803387e:	466a      	mov	r2, sp
 8033880:	7013      	strb	r3, [r2, #0]
        buf[1] = ( tempVal >> 8 ) & 0xFF;
 8033882:	0a03      	lsrs	r3, r0, #8
 8033884:	7053      	strb	r3, [r2, #1]
        buf[2] = tempVal & 0xFF;
 8033886:	7090      	strb	r0, [r2, #2]
        buf[3] = modulationParams->Params.Bpsk.ModulationShaping;
 8033888:	7d23      	ldrb	r3, [r4, #20]
 803388a:	70d3      	strb	r3, [r2, #3]
        SUBGRF_WriteCommand( RADIO_SET_MODULATIONPARAMS, buf, n );
 803388c:	2204      	movs	r2, #4
 803388e:	4669      	mov	r1, sp
 8033890:	208b      	movs	r0, #139	; 0x8b
 8033892:	f7ff fca1 	bl	80331d8 <SUBGRF_WriteCommand>
        break;
 8033896:	e7eb      	b.n	8033870 <SUBGRF_SetModulationParams+0xb8>
 8033898:	08034d18 	.word	0x08034d18
 803389c:	2000c703 	.word	0x2000c703
 80338a0:	3d090000 	.word	0x3d090000
 80338a4:	01e84800 	.word	0x01e84800

080338a8 <SUBGRF_SetPacketParams>:
{
 80338a8:	b510      	push	{r4, lr}
 80338aa:	b084      	sub	sp, #16
 80338ac:	0004      	movs	r4, r0
    uint8_t buf[9] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
 80338ae:	aa01      	add	r2, sp, #4
 80338b0:	4b2e      	ldr	r3, [pc, #184]	; (803396c <SUBGRF_SetPacketParams+0xc4>)
 80338b2:	3308      	adds	r3, #8
 80338b4:	cb03      	ldmia	r3!, {r0, r1}
 80338b6:	c203      	stmia	r2!, {r0, r1}
 80338b8:	781b      	ldrb	r3, [r3, #0]
 80338ba:	7013      	strb	r3, [r2, #0]
    if( PacketType != packetParams->PacketType )
 80338bc:	7820      	ldrb	r0, [r4, #0]
 80338be:	4b2c      	ldr	r3, [pc, #176]	; (8033970 <SUBGRF_SetPacketParams+0xc8>)
 80338c0:	781b      	ldrb	r3, [r3, #0]
 80338c2:	4298      	cmp	r0, r3
 80338c4:	d118      	bne.n	80338f8 <SUBGRF_SetPacketParams+0x50>
    switch( packetParams->PacketType )
 80338c6:	7823      	ldrb	r3, [r4, #0]
 80338c8:	2b02      	cmp	r3, #2
 80338ca:	d049      	beq.n	8033960 <SUBGRF_SetPacketParams+0xb8>
 80338cc:	d817      	bhi.n	80338fe <SUBGRF_SetPacketParams+0x56>
 80338ce:	2b00      	cmp	r3, #0
 80338d0:	d017      	beq.n	8033902 <SUBGRF_SetPacketParams+0x5a>
 80338d2:	2b01      	cmp	r3, #1
 80338d4:	d132      	bne.n	803393c <SUBGRF_SetPacketParams+0x94>
        buf[0] = ( packetParams->Params.LoRa.PreambleLength >> 8 ) & 0xFF;
 80338d6:	89e2      	ldrh	r2, [r4, #14]
 80338d8:	ab01      	add	r3, sp, #4
 80338da:	0a11      	lsrs	r1, r2, #8
 80338dc:	7019      	strb	r1, [r3, #0]
        buf[1] = packetParams->Params.LoRa.PreambleLength;
 80338de:	705a      	strb	r2, [r3, #1]
        buf[2] = LoRaHeaderType = packetParams->Params.LoRa.HeaderType;
 80338e0:	7c22      	ldrb	r2, [r4, #16]
 80338e2:	4924      	ldr	r1, [pc, #144]	; (8033974 <SUBGRF_SetPacketParams+0xcc>)
 80338e4:	700a      	strb	r2, [r1, #0]
 80338e6:	709a      	strb	r2, [r3, #2]
        buf[3] = packetParams->Params.LoRa.PayloadLength;
 80338e8:	7c62      	ldrb	r2, [r4, #17]
 80338ea:	70da      	strb	r2, [r3, #3]
        buf[4] = packetParams->Params.LoRa.CrcMode;
 80338ec:	7ca2      	ldrb	r2, [r4, #18]
 80338ee:	711a      	strb	r2, [r3, #4]
        buf[5] = packetParams->Params.LoRa.InvertIQ;
 80338f0:	7ce2      	ldrb	r2, [r4, #19]
 80338f2:	715a      	strb	r2, [r3, #5]
        n = 6;
 80338f4:	2206      	movs	r2, #6
        break;
 80338f6:	e01c      	b.n	8033932 <SUBGRF_SetPacketParams+0x8a>
        SUBGRF_SetPacketType( packetParams->PacketType );
 80338f8:	f7ff feb6 	bl	8033668 <SUBGRF_SetPacketType>
 80338fc:	e7e3      	b.n	80338c6 <SUBGRF_SetPacketParams+0x1e>
    switch( packetParams->PacketType )
 80338fe:	2b03      	cmp	r3, #3
 8033900:	d11c      	bne.n	803393c <SUBGRF_SetPacketParams+0x94>
        if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_IBM )
 8033902:	7a62      	ldrb	r2, [r4, #9]
 8033904:	2af1      	cmp	r2, #241	; 0xf1
 8033906:	d01b      	beq.n	8033940 <SUBGRF_SetPacketParams+0x98>
        else if( packetParams->Params.Gfsk.CrcLength == RADIO_CRC_2_BYTES_CCIT )
 8033908:	2af2      	cmp	r2, #242	; 0xf2
 803390a:	d021      	beq.n	8033950 <SUBGRF_SetPacketParams+0xa8>
        buf[0] = ( packetParams->Params.Gfsk.PreambleLength >> 8 ) & 0xFF;
 803390c:	8861      	ldrh	r1, [r4, #2]
 803390e:	ab01      	add	r3, sp, #4
 8033910:	0a08      	lsrs	r0, r1, #8
 8033912:	7018      	strb	r0, [r3, #0]
        buf[1] = packetParams->Params.Gfsk.PreambleLength;
 8033914:	7059      	strb	r1, [r3, #1]
        buf[2] = packetParams->Params.Gfsk.PreambleMinDetect;
 8033916:	7921      	ldrb	r1, [r4, #4]
 8033918:	7099      	strb	r1, [r3, #2]
        buf[3] = ( packetParams->Params.Gfsk.SyncWordLength /*<< 3*/ ); // convert from byte to bit
 803391a:	7961      	ldrb	r1, [r4, #5]
 803391c:	70d9      	strb	r1, [r3, #3]
        buf[4] = packetParams->Params.Gfsk.AddrComp;
 803391e:	79a1      	ldrb	r1, [r4, #6]
 8033920:	7119      	strb	r1, [r3, #4]
        buf[5] = packetParams->Params.Gfsk.HeaderType;
 8033922:	79e1      	ldrb	r1, [r4, #7]
 8033924:	7159      	strb	r1, [r3, #5]
        buf[6] = packetParams->Params.Gfsk.PayloadLength;
 8033926:	7a21      	ldrb	r1, [r4, #8]
 8033928:	7199      	strb	r1, [r3, #6]
        buf[7] = crcVal;
 803392a:	71da      	strb	r2, [r3, #7]
        buf[8] = packetParams->Params.Gfsk.DcFree;
 803392c:	7aa2      	ldrb	r2, [r4, #10]
 803392e:	721a      	strb	r2, [r3, #8]
        n = 9;
 8033930:	2209      	movs	r2, #9
    SUBGRF_WriteCommand( RADIO_SET_PACKETPARAMS, buf, n );
 8033932:	b292      	uxth	r2, r2
 8033934:	a901      	add	r1, sp, #4
 8033936:	208c      	movs	r0, #140	; 0x8c
 8033938:	f7ff fc4e 	bl	80331d8 <SUBGRF_WriteCommand>
}
 803393c:	b004      	add	sp, #16
 803393e:	bd10      	pop	{r4, pc}
            SUBGRF_SetCrcSeed( CRC_IBM_SEED );
 8033940:	480d      	ldr	r0, [pc, #52]	; (8033978 <SUBGRF_SetPacketParams+0xd0>)
 8033942:	f7ff fbe9 	bl	8033118 <SUBGRF_SetCrcSeed>
            SUBGRF_SetCrcPolynomial( CRC_POLYNOMIAL_IBM );
 8033946:	480d      	ldr	r0, [pc, #52]	; (803397c <SUBGRF_SetPacketParams+0xd4>)
 8033948:	f7ff fbfa 	bl	8033140 <SUBGRF_SetCrcPolynomial>
            crcVal = RADIO_CRC_2_BYTES;
 803394c:	2202      	movs	r2, #2
 803394e:	e7dd      	b.n	803390c <SUBGRF_SetPacketParams+0x64>
            SUBGRF_SetCrcSeed( CRC_CCITT_SEED );
 8033950:	480b      	ldr	r0, [pc, #44]	; (8033980 <SUBGRF_SetPacketParams+0xd8>)
 8033952:	f7ff fbe1 	bl	8033118 <SUBGRF_SetCrcSeed>
            SUBGRF_SetCrcPolynomial( CRC_POLYNOMIAL_CCITT );
 8033956:	480b      	ldr	r0, [pc, #44]	; (8033984 <SUBGRF_SetPacketParams+0xdc>)
 8033958:	f7ff fbf2 	bl	8033140 <SUBGRF_SetCrcPolynomial>
            crcVal = RADIO_CRC_2_BYTES_INV;
 803395c:	2206      	movs	r2, #6
 803395e:	e7d5      	b.n	803390c <SUBGRF_SetPacketParams+0x64>
        buf[0] = packetParams->Params.Bpsk.PayloadLength;
 8033960:	7b22      	ldrb	r2, [r4, #12]
 8033962:	ab01      	add	r3, sp, #4
 8033964:	701a      	strb	r2, [r3, #0]
        n = 1;
 8033966:	2201      	movs	r2, #1
        break;
 8033968:	e7e3      	b.n	8033932 <SUBGRF_SetPacketParams+0x8a>
 803396a:	46c0      	nop			; (mov r8, r8)
 803396c:	08034d18 	.word	0x08034d18
 8033970:	2000c703 	.word	0x2000c703
 8033974:	2000c701 	.word	0x2000c701
 8033978:	0000ffff 	.word	0x0000ffff
 803397c:	00008005 	.word	0x00008005
 8033980:	00001d0f 	.word	0x00001d0f
 8033984:	00001021 	.word	0x00001021

08033988 <SUBGRF_SetBufferBaseAddress>:
{
 8033988:	b500      	push	{lr}
 803398a:	b083      	sub	sp, #12
    buf[0] = txBaseAddress;
 803398c:	466b      	mov	r3, sp
 803398e:	7118      	strb	r0, [r3, #4]
    buf[1] = rxBaseAddress;
 8033990:	7159      	strb	r1, [r3, #5]
    SUBGRF_WriteCommand( RADIO_SET_BUFFERBASEADDRESS, buf, 2 );
 8033992:	2202      	movs	r2, #2
 8033994:	a901      	add	r1, sp, #4
 8033996:	208f      	movs	r0, #143	; 0x8f
 8033998:	f7ff fc1e 	bl	80331d8 <SUBGRF_WriteCommand>
}
 803399c:	b003      	add	sp, #12
 803399e:	bd00      	pop	{pc}

080339a0 <SUBGRF_ReadCommand>:
{
 80339a0:	b510      	push	{r4, lr}
 80339a2:	0013      	movs	r3, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80339a4:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80339a8:	b672      	cpsid	i
    HAL_SUBGHZ_ExecGetCmd( &hsubghz, Command, pBuffer, Size );
 80339aa:	000a      	movs	r2, r1
 80339ac:	0001      	movs	r1, r0
 80339ae:	4803      	ldr	r0, [pc, #12]	; (80339bc <SUBGRF_ReadCommand+0x1c>)
 80339b0:	f7f1 febe 	bl	8025730 <HAL_SUBGHZ_ExecGetCmd>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80339b4:	f384 8810 	msr	PRIMASK, r4
}
 80339b8:	bd10      	pop	{r4, pc}
 80339ba:	46c0      	nop			; (mov r8, r8)
 80339bc:	2000b210 	.word	0x2000b210

080339c0 <SUBGRF_GetRssiInst>:
{
 80339c0:	b510      	push	{r4, lr}
 80339c2:	b082      	sub	sp, #8
    SUBGRF_ReadCommand( RADIO_GET_RSSIINST, buf, 1 );
 80339c4:	ac01      	add	r4, sp, #4
 80339c6:	2201      	movs	r2, #1
 80339c8:	0021      	movs	r1, r4
 80339ca:	2015      	movs	r0, #21
 80339cc:	f7ff ffe8 	bl	80339a0 <SUBGRF_ReadCommand>
    rssi = -buf[0] >> 1;
 80339d0:	7820      	ldrb	r0, [r4, #0]
 80339d2:	4240      	negs	r0, r0
 80339d4:	1040      	asrs	r0, r0, #1
}
 80339d6:	b002      	add	sp, #8
 80339d8:	bd10      	pop	{r4, pc}
	...

080339dc <SUBGRF_GetRxBufferStatus>:
{
 80339dc:	b530      	push	{r4, r5, lr}
 80339de:	b083      	sub	sp, #12
 80339e0:	0005      	movs	r5, r0
 80339e2:	000c      	movs	r4, r1
    SUBGRF_ReadCommand( RADIO_GET_RXBUFFERSTATUS, status, 2 );
 80339e4:	2202      	movs	r2, #2
 80339e6:	a901      	add	r1, sp, #4
 80339e8:	2013      	movs	r0, #19
 80339ea:	f7ff ffd9 	bl	80339a0 <SUBGRF_ReadCommand>
    if( ( SUBGRF_GetPacketType( ) == PACKET_TYPE_LORA ) && ( LoRaHeaderType == LORA_PACKET_FIXED_LENGTH ) )
 80339ee:	f7ff fb21 	bl	8033034 <SUBGRF_GetPacketType>
 80339f2:	2801      	cmp	r0, #1
 80339f4:	d007      	beq.n	8033a06 <SUBGRF_GetRxBufferStatus+0x2a>
        *payloadLength = status[0];
 80339f6:	ab01      	add	r3, sp, #4
 80339f8:	781b      	ldrb	r3, [r3, #0]
 80339fa:	702b      	strb	r3, [r5, #0]
    *rxStartBufferPointer = status[1];
 80339fc:	ab01      	add	r3, sp, #4
 80339fe:	785b      	ldrb	r3, [r3, #1]
 8033a00:	7023      	strb	r3, [r4, #0]
}
 8033a02:	b003      	add	sp, #12
 8033a04:	bd30      	pop	{r4, r5, pc}
    if( ( SUBGRF_GetPacketType( ) == PACKET_TYPE_LORA ) && ( LoRaHeaderType == LORA_PACKET_FIXED_LENGTH ) )
 8033a06:	4b04      	ldr	r3, [pc, #16]	; (8033a18 <SUBGRF_GetRxBufferStatus+0x3c>)
 8033a08:	781b      	ldrb	r3, [r3, #0]
 8033a0a:	2b01      	cmp	r3, #1
 8033a0c:	d1f3      	bne.n	80339f6 <SUBGRF_GetRxBufferStatus+0x1a>
        *payloadLength = SUBGRF_ReadRegister( REG_LR_PAYLOADLENGTH );
 8033a0e:	4803      	ldr	r0, [pc, #12]	; (8033a1c <SUBGRF_GetRxBufferStatus+0x40>)
 8033a10:	f7ff fb24 	bl	803305c <SUBGRF_ReadRegister>
 8033a14:	7028      	strb	r0, [r5, #0]
 8033a16:	e7f1      	b.n	80339fc <SUBGRF_GetRxBufferStatus+0x20>
 8033a18:	2000c701 	.word	0x2000c701
 8033a1c:	00000702 	.word	0x00000702

08033a20 <SUBGRF_GetPayload>:
{
 8033a20:	b570      	push	{r4, r5, r6, lr}
 8033a22:	b082      	sub	sp, #8
 8033a24:	0006      	movs	r6, r0
 8033a26:	000c      	movs	r4, r1
 8033a28:	0015      	movs	r5, r2
    uint8_t offset = 0;
 8033a2a:	466b      	mov	r3, sp
 8033a2c:	1dd9      	adds	r1, r3, #7
 8033a2e:	2300      	movs	r3, #0
 8033a30:	700b      	strb	r3, [r1, #0]
    SUBGRF_GetRxBufferStatus( size, &offset );
 8033a32:	0020      	movs	r0, r4
 8033a34:	f7ff ffd2 	bl	80339dc <SUBGRF_GetRxBufferStatus>
    if( *size > maxSize )
 8033a38:	7822      	ldrb	r2, [r4, #0]
 8033a3a:	42aa      	cmp	r2, r5
 8033a3c:	d902      	bls.n	8033a44 <SUBGRF_GetPayload+0x24>
        return 1;
 8033a3e:	2001      	movs	r0, #1
}
 8033a40:	b002      	add	sp, #8
 8033a42:	bd70      	pop	{r4, r5, r6, pc}
    SUBGRF_ReadBuffer( offset, buffer, *size );
 8033a44:	466b      	mov	r3, sp
 8033a46:	79d8      	ldrb	r0, [r3, #7]
 8033a48:	0031      	movs	r1, r6
 8033a4a:	f7ff fbb5 	bl	80331b8 <SUBGRF_ReadBuffer>
    return 0;
 8033a4e:	2000      	movs	r0, #0
 8033a50:	e7f6      	b.n	8033a40 <SUBGRF_GetPayload+0x20>
	...

08033a54 <SUBGRF_GetPacketStatus>:
{
 8033a54:	b510      	push	{r4, lr}
 8033a56:	b082      	sub	sp, #8
 8033a58:	0004      	movs	r4, r0
    SUBGRF_ReadCommand( RADIO_GET_PACKETSTATUS, status, 3 );
 8033a5a:	2203      	movs	r2, #3
 8033a5c:	a901      	add	r1, sp, #4
 8033a5e:	2014      	movs	r0, #20
 8033a60:	f7ff ff9e 	bl	80339a0 <SUBGRF_ReadCommand>
    pktStatus->packetType = SUBGRF_GetPacketType( );
 8033a64:	f7ff fae6 	bl	8033034 <SUBGRF_GetPacketType>
 8033a68:	7020      	strb	r0, [r4, #0]
    switch( pktStatus->packetType )
 8033a6a:	2800      	cmp	r0, #0
 8033a6c:	d009      	beq.n	8033a82 <SUBGRF_GetPacketStatus+0x2e>
 8033a6e:	2801      	cmp	r0, #1
 8033a70:	d016      	beq.n	8033aa0 <SUBGRF_GetPacketStatus+0x4c>
            RADIO_MEMSET8( pktStatus, 0, sizeof( PacketStatus_t ) );
 8033a72:	2214      	movs	r2, #20
 8033a74:	2100      	movs	r1, #0
 8033a76:	0020      	movs	r0, r4
 8033a78:	f000 fb1d 	bl	80340b6 <UTIL_MEM_set_8>
            pktStatus->packetType = PACKET_TYPE_NONE;
 8033a7c:	230f      	movs	r3, #15
 8033a7e:	7023      	strb	r3, [r4, #0]
}
 8033a80:	e00c      	b.n	8033a9c <SUBGRF_GetPacketStatus+0x48>
            pktStatus->Params.Gfsk.RxStatus = status[0];
 8033a82:	aa01      	add	r2, sp, #4
 8033a84:	7813      	ldrb	r3, [r2, #0]
 8033a86:	7123      	strb	r3, [r4, #4]
            pktStatus->Params.Gfsk.RssiSync = -status[1] >> 1;
 8033a88:	7853      	ldrb	r3, [r2, #1]
 8033a8a:	425b      	negs	r3, r3
 8033a8c:	105b      	asrs	r3, r3, #1
 8033a8e:	71a3      	strb	r3, [r4, #6]
            pktStatus->Params.Gfsk.RssiAvg = -status[2] >> 1;
 8033a90:	7893      	ldrb	r3, [r2, #2]
 8033a92:	425b      	negs	r3, r3
 8033a94:	105b      	asrs	r3, r3, #1
 8033a96:	7163      	strb	r3, [r4, #5]
            pktStatus->Params.Gfsk.FreqError = 0;
 8033a98:	2300      	movs	r3, #0
 8033a9a:	60a3      	str	r3, [r4, #8]
}
 8033a9c:	b002      	add	sp, #8
 8033a9e:	bd10      	pop	{r4, pc}
            pktStatus->Params.LoRa.RssiPkt = -status[0] >> 1;
 8033aa0:	aa01      	add	r2, sp, #4
 8033aa2:	7813      	ldrb	r3, [r2, #0]
 8033aa4:	425b      	negs	r3, r3
 8033aa6:	105b      	asrs	r3, r3, #1
 8033aa8:	7323      	strb	r3, [r4, #12]
            pktStatus->Params.LoRa.SnrPkt = ( ( ( int8_t )status[1] ) + 2 ) >> 2;
 8033aaa:	2301      	movs	r3, #1
 8033aac:	56d3      	ldrsb	r3, [r2, r3]
 8033aae:	3302      	adds	r3, #2
 8033ab0:	109b      	asrs	r3, r3, #2
 8033ab2:	7363      	strb	r3, [r4, #13]
            pktStatus->Params.LoRa.SignalRssiPkt = -status[2] >> 1;
 8033ab4:	7893      	ldrb	r3, [r2, #2]
 8033ab6:	425b      	negs	r3, r3
 8033ab8:	105b      	asrs	r3, r3, #1
 8033aba:	73a3      	strb	r3, [r4, #14]
            pktStatus->Params.LoRa.FreqError = FrequencyError;
 8033abc:	4b01      	ldr	r3, [pc, #4]	; (8033ac4 <SUBGRF_GetPacketStatus+0x70>)
 8033abe:	681b      	ldr	r3, [r3, #0]
 8033ac0:	6123      	str	r3, [r4, #16]
            break;
 8033ac2:	e7eb      	b.n	8033a9c <SUBGRF_GetPacketStatus+0x48>
 8033ac4:	2000c6fc 	.word	0x2000c6fc

08033ac8 <SUBGRF_SetSwitch>:
{
 8033ac8:	b510      	push	{r4, lr}
 8033aca:	0004      	movs	r4, r0
 8033acc:	0008      	movs	r0, r1
    if (rxtx == RFSWITCH_TX)
 8033ace:	2901      	cmp	r1, #1
 8033ad0:	d003      	beq.n	8033ada <SUBGRF_SetSwitch+0x12>
    RBI_Switch_TypeDef state = RBI_SWITCH_RX;
 8033ad2:	2001      	movs	r0, #1
    RBI_ConfigRFSwitch(state);
 8033ad4:	f7ee f9f6 	bl	8021ec4 <RBI_ConfigRFSwitch>
}
 8033ad8:	bd10      	pop	{r4, pc}
        if (paSelect == RFO_LP)
 8033ada:	2c01      	cmp	r4, #1
 8033adc:	d003      	beq.n	8033ae6 <SUBGRF_SetSwitch+0x1e>
        if (paSelect == RFO_HP)
 8033ade:	2c02      	cmp	r4, #2
 8033ae0:	d1f8      	bne.n	8033ad4 <SUBGRF_SetSwitch+0xc>
            state = RBI_SWITCH_RFO_HP;
 8033ae2:	2003      	movs	r0, #3
 8033ae4:	e7f6      	b.n	8033ad4 <SUBGRF_SetSwitch+0xc>
            Radio_SMPS_Set(SMPS_DRIVE_SETTING_MAX);
 8033ae6:	3003      	adds	r0, #3
 8033ae8:	f7ff fac8 	bl	803307c <Radio_SMPS_Set>
            state = RBI_SWITCH_RFO_LP;
 8033aec:	2002      	movs	r0, #2
 8033aee:	e7f6      	b.n	8033ade <SUBGRF_SetSwitch+0x16>

08033af0 <SUBGRF_SetRfTxPower>:
{
 8033af0:	b570      	push	{r4, r5, r6, lr}
 8033af2:	0004      	movs	r4, r0
    int32_t TxConfig = RBI_GetTxConfig();
 8033af4:	f7ee f9ea 	bl	8021ecc <RBI_GetTxConfig>
    switch (TxConfig)
 8033af8:	2800      	cmp	r0, #0
 8033afa:	d009      	beq.n	8033b10 <SUBGRF_SetRfTxPower+0x20>
 8033afc:	2802      	cmp	r0, #2
 8033afe:	d10d      	bne.n	8033b1c <SUBGRF_SetRfTxPower+0x2c>
            paSelect = RFO_HP;
 8033b00:	2502      	movs	r5, #2
    SUBGRF_SetTxParams( paSelect, power, RADIO_RAMP_40_US );
 8033b02:	2202      	movs	r2, #2
 8033b04:	0021      	movs	r1, r4
 8033b06:	0028      	movs	r0, r5
 8033b08:	f7ff fdc8 	bl	803369c <SUBGRF_SetTxParams>
}
 8033b0c:	0028      	movs	r0, r5
 8033b0e:	bd70      	pop	{r4, r5, r6, pc}
            if (power > 15)
 8033b10:	2c0f      	cmp	r4, #15
 8033b12:	dc01      	bgt.n	8033b18 <SUBGRF_SetRfTxPower+0x28>
                paSelect = RFO_LP;
 8033b14:	2501      	movs	r5, #1
 8033b16:	e7f4      	b.n	8033b02 <SUBGRF_SetRfTxPower+0x12>
                paSelect = RFO_HP;
 8033b18:	2502      	movs	r5, #2
 8033b1a:	e7f2      	b.n	8033b02 <SUBGRF_SetRfTxPower+0x12>
    switch (TxConfig)
 8033b1c:	2501      	movs	r5, #1
 8033b1e:	e7f0      	b.n	8033b02 <SUBGRF_SetRfTxPower+0x12>

08033b20 <SUBGRF_GetRadioWakeUpTime>:
}
 8033b20:	2001      	movs	r0, #1
 8033b22:	4770      	bx	lr

08033b24 <HAL_SUBGHZ_TxCpltCallback>:
{
 8033b24:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_TX_DONE );
 8033b26:	4b02      	ldr	r3, [pc, #8]	; (8033b30 <HAL_SUBGHZ_TxCpltCallback+0xc>)
 8033b28:	681b      	ldr	r3, [r3, #0]
 8033b2a:	2001      	movs	r0, #1
 8033b2c:	4798      	blx	r3
}
 8033b2e:	bd10      	pop	{r4, pc}
 8033b30:	2000c704 	.word	0x2000c704

08033b34 <HAL_SUBGHZ_RxCpltCallback>:
{
 8033b34:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_RX_DONE );
 8033b36:	4b02      	ldr	r3, [pc, #8]	; (8033b40 <HAL_SUBGHZ_RxCpltCallback+0xc>)
 8033b38:	681b      	ldr	r3, [r3, #0]
 8033b3a:	2002      	movs	r0, #2
 8033b3c:	4798      	blx	r3
}
 8033b3e:	bd10      	pop	{r4, pc}
 8033b40:	2000c704 	.word	0x2000c704

08033b44 <HAL_SUBGHZ_CRCErrorCallback>:
{
 8033b44:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_CRC_ERROR);
 8033b46:	4b02      	ldr	r3, [pc, #8]	; (8033b50 <HAL_SUBGHZ_CRCErrorCallback+0xc>)
 8033b48:	681b      	ldr	r3, [r3, #0]
 8033b4a:	2040      	movs	r0, #64	; 0x40
 8033b4c:	4798      	blx	r3
}
 8033b4e:	bd10      	pop	{r4, pc}
 8033b50:	2000c704 	.word	0x2000c704

08033b54 <HAL_SUBGHZ_CADStatusCallback>:
{
 8033b54:	b510      	push	{r4, lr}
    switch (cadstatus)
 8033b56:	2900      	cmp	r1, #0
 8033b58:	d002      	beq.n	8033b60 <HAL_SUBGHZ_CADStatusCallback+0xc>
 8033b5a:	2901      	cmp	r1, #1
 8033b5c:	d005      	beq.n	8033b6a <HAL_SUBGHZ_CADStatusCallback+0x16>
}
 8033b5e:	bd10      	pop	{r4, pc}
            RadioOnDioIrqCb( IRQ_CAD_CLEAR);
 8033b60:	4b05      	ldr	r3, [pc, #20]	; (8033b78 <HAL_SUBGHZ_CADStatusCallback+0x24>)
 8033b62:	681b      	ldr	r3, [r3, #0]
 8033b64:	2080      	movs	r0, #128	; 0x80
 8033b66:	4798      	blx	r3
            break;
 8033b68:	e7f9      	b.n	8033b5e <HAL_SUBGHZ_CADStatusCallback+0xa>
            RadioOnDioIrqCb( IRQ_CAD_DETECTED);
 8033b6a:	2080      	movs	r0, #128	; 0x80
 8033b6c:	4b02      	ldr	r3, [pc, #8]	; (8033b78 <HAL_SUBGHZ_CADStatusCallback+0x24>)
 8033b6e:	681b      	ldr	r3, [r3, #0]
 8033b70:	0040      	lsls	r0, r0, #1
 8033b72:	4798      	blx	r3
}
 8033b74:	e7f3      	b.n	8033b5e <HAL_SUBGHZ_CADStatusCallback+0xa>
 8033b76:	46c0      	nop			; (mov r8, r8)
 8033b78:	2000c704 	.word	0x2000c704

08033b7c <HAL_SUBGHZ_RxTxTimeoutCallback>:
{
 8033b7c:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_RX_TX_TIMEOUT );
 8033b7e:	2080      	movs	r0, #128	; 0x80
 8033b80:	4b02      	ldr	r3, [pc, #8]	; (8033b8c <HAL_SUBGHZ_RxTxTimeoutCallback+0x10>)
 8033b82:	681b      	ldr	r3, [r3, #0]
 8033b84:	0080      	lsls	r0, r0, #2
 8033b86:	4798      	blx	r3
}
 8033b88:	bd10      	pop	{r4, pc}
 8033b8a:	46c0      	nop			; (mov r8, r8)
 8033b8c:	2000c704 	.word	0x2000c704

08033b90 <HAL_SUBGHZ_HeaderErrorCallback>:
{
 8033b90:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_HEADER_ERROR );
 8033b92:	4b02      	ldr	r3, [pc, #8]	; (8033b9c <HAL_SUBGHZ_HeaderErrorCallback+0xc>)
 8033b94:	681b      	ldr	r3, [r3, #0]
 8033b96:	2020      	movs	r0, #32
 8033b98:	4798      	blx	r3
}
 8033b9a:	bd10      	pop	{r4, pc}
 8033b9c:	2000c704 	.word	0x2000c704

08033ba0 <HAL_SUBGHZ_PreambleDetectedCallback>:
{
 8033ba0:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_PREAMBLE_DETECTED );
 8033ba2:	4b02      	ldr	r3, [pc, #8]	; (8033bac <HAL_SUBGHZ_PreambleDetectedCallback+0xc>)
 8033ba4:	681b      	ldr	r3, [r3, #0]
 8033ba6:	2004      	movs	r0, #4
 8033ba8:	4798      	blx	r3
}
 8033baa:	bd10      	pop	{r4, pc}
 8033bac:	2000c704 	.word	0x2000c704

08033bb0 <HAL_SUBGHZ_SyncWordValidCallback>:
{
 8033bb0:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_SYNCWORD_VALID );
 8033bb2:	4b02      	ldr	r3, [pc, #8]	; (8033bbc <HAL_SUBGHZ_SyncWordValidCallback+0xc>)
 8033bb4:	681b      	ldr	r3, [r3, #0]
 8033bb6:	2008      	movs	r0, #8
 8033bb8:	4798      	blx	r3
}
 8033bba:	bd10      	pop	{r4, pc}
 8033bbc:	2000c704 	.word	0x2000c704

08033bc0 <HAL_SUBGHZ_HeaderValidCallback>:
{
 8033bc0:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_HEADER_VALID );
 8033bc2:	4b02      	ldr	r3, [pc, #8]	; (8033bcc <HAL_SUBGHZ_HeaderValidCallback+0xc>)
 8033bc4:	681b      	ldr	r3, [r3, #0]
 8033bc6:	2010      	movs	r0, #16
 8033bc8:	4798      	blx	r3
}
 8033bca:	bd10      	pop	{r4, pc}
 8033bcc:	2000c704 	.word	0x2000c704

08033bd0 <HAL_SUBGHZ_LrFhssHopCallback>:
{
 8033bd0:	b510      	push	{r4, lr}
    RadioOnDioIrqCb( IRQ_LR_FHSS_HOP );
 8033bd2:	2080      	movs	r0, #128	; 0x80
 8033bd4:	4b02      	ldr	r3, [pc, #8]	; (8033be0 <HAL_SUBGHZ_LrFhssHopCallback+0x10>)
 8033bd6:	681b      	ldr	r3, [r3, #0]
 8033bd8:	01c0      	lsls	r0, r0, #7
 8033bda:	4798      	blx	r3
}
 8033bdc:	bd10      	pop	{r4, pc}
 8033bde:	46c0      	nop			; (mov r8, r8)
 8033be0:	2000c704 	.word	0x2000c704

08033be4 <SUBGRF_GetFskBandwidthRegValue>:

uint8_t SUBGRF_GetFskBandwidthRegValue( uint32_t bandwidth )
{
 8033be4:	b510      	push	{r4, lr}
    uint8_t i;

    if( bandwidth == 0 )
 8033be6:	2800      	cmp	r0, #0
 8033be8:	d00f      	beq.n	8033c0a <SUBGRF_GetFskBandwidthRegValue+0x26>
    {
        return( 0x1F );
    }

    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ); i++ )
 8033bea:	2300      	movs	r3, #0
 8033bec:	2b15      	cmp	r3, #21
 8033bee:	d80b      	bhi.n	8033c08 <SUBGRF_GetFskBandwidthRegValue+0x24>
    {
        if ( bandwidth < FskBandwidths[i].bandwidth )
 8033bf0:	00da      	lsls	r2, r3, #3
 8033bf2:	4907      	ldr	r1, [pc, #28]	; (8033c10 <SUBGRF_GetFskBandwidthRegValue+0x2c>)
 8033bf4:	5852      	ldr	r2, [r2, r1]
 8033bf6:	4282      	cmp	r2, r0
 8033bf8:	d802      	bhi.n	8033c00 <SUBGRF_GetFskBandwidthRegValue+0x1c>
    for( i = 0; i < ( sizeof( FskBandwidths ) / sizeof( FskBandwidth_t ) ); i++ )
 8033bfa:	3301      	adds	r3, #1
 8033bfc:	b2db      	uxtb	r3, r3
 8033bfe:	e7f5      	b.n	8033bec <SUBGRF_GetFskBandwidthRegValue+0x8>
        {
            return FskBandwidths[i].RegValue;
 8033c00:	00dc      	lsls	r4, r3, #3
 8033c02:	190c      	adds	r4, r1, r4
 8033c04:	7920      	ldrb	r0, [r4, #4]
        }
    }
    // ERROR: Value not found
    while( 1 );
}
 8033c06:	bd10      	pop	{r4, pc}
    while( 1 );
 8033c08:	e7fe      	b.n	8033c08 <SUBGRF_GetFskBandwidthRegValue+0x24>
        return( 0x1F );
 8033c0a:	201f      	movs	r0, #31
 8033c0c:	e7fb      	b.n	8033c06 <SUBGRF_GetFskBandwidthRegValue+0x22>
 8033c0e:	46c0      	nop			; (mov r8, r8)
 8033c10:	08035e18 	.word	0x08035e18

08033c14 <SUBGRF_GetCFO>:
void SUBGRF_GetCFO( uint32_t bitRate, int32_t *cfo)
{
 8033c14:	b570      	push	{r4, r5, r6, lr}
 8033c16:	b082      	sub	sp, #8
 8033c18:	0006      	movs	r6, r0
 8033c1a:	000c      	movs	r4, r1
  uint8_t BwMant[] = {4, 8, 10, 12};
 8033c1c:	4b1a      	ldr	r3, [pc, #104]	; (8033c88 <SUBGRF_GetCFO+0x74>)
 8033c1e:	9301      	str	r3, [sp, #4]
  /* read demod bandwidth: mant bit4:3, exp bits 2:0 */
  uint8_t reg = (SUBGRF_ReadRegister( SUBGHZ_BWSELR ));
 8033c20:	481a      	ldr	r0, [pc, #104]	; (8033c8c <SUBGRF_GetCFO+0x78>)
 8033c22:	f7ff fa1b 	bl	803305c <SUBGRF_ReadRegister>
  uint8_t bandwidth_mant = BwMant[( reg >> 3 ) & 0x3];
 8033c26:	08c3      	lsrs	r3, r0, #3
 8033c28:	2203      	movs	r2, #3
 8033c2a:	4013      	ands	r3, r2
 8033c2c:	aa01      	add	r2, sp, #4
 8033c2e:	5cd1      	ldrb	r1, [r2, r3]
  uint8_t bandwidth_exp = reg & 0x7;
 8033c30:	2307      	movs	r3, #7
 8033c32:	4003      	ands	r3, r0
  uint32_t cf_fs = XTAL_FREQ / ( bandwidth_mant * ( 1 << ( bandwidth_exp + 1 )));
 8033c34:	3301      	adds	r3, #1
 8033c36:	4099      	lsls	r1, r3
 8033c38:	4815      	ldr	r0, [pc, #84]	; (8033c90 <SUBGRF_GetCFO+0x7c>)
 8033c3a:	f7ec fa6d 	bl	8020118 <__udivsi3>
 8033c3e:	0005      	movs	r5, r0
  uint32_t cf_osr = cf_fs / bitRate;
 8033c40:	0031      	movs	r1, r6
 8033c42:	f7ec fa69 	bl	8020118 <__udivsi3>
 8033c46:	0003      	movs	r3, r0
  uint8_t interp = 1;
  /* calculate demod interpolation factor */
  if (cf_osr * interp < 8)
 8033c48:	2807      	cmp	r0, #7
 8033c4a:	d91b      	bls.n	8033c84 <SUBGRF_GetCFO+0x70>
  uint8_t interp = 1;
 8033c4c:	2601      	movs	r6, #1
  {
    interp = 2;
  }
  if (cf_osr * interp < 4)
 8033c4e:	4373      	muls	r3, r6
 8033c50:	2b03      	cmp	r3, #3
 8033c52:	d800      	bhi.n	8033c56 <SUBGRF_GetCFO+0x42>
  {
    interp = 4;
 8033c54:	2604      	movs	r6, #4
  }
  /* calculate demod sampling frequency */
  uint32_t fs = cf_fs* interp;
 8033c56:	436e      	muls	r6, r5
  /* get the cfo registers */
  int32_t cfo_bin = ( SUBGRF_ReadRegister( SUBGHZ_GCFORH ) & 0xF ) << 8;
 8033c58:	20d6      	movs	r0, #214	; 0xd6
 8033c5a:	00c0      	lsls	r0, r0, #3
 8033c5c:	f7ff f9fe 	bl	803305c <SUBGRF_ReadRegister>
 8033c60:	0200      	lsls	r0, r0, #8
 8033c62:	25f0      	movs	r5, #240	; 0xf0
 8033c64:	012d      	lsls	r5, r5, #4
 8033c66:	4005      	ands	r5, r0
  cfo_bin |= SUBGRF_ReadRegister( SUBGHZ_GCFORL );
 8033c68:	480a      	ldr	r0, [pc, #40]	; (8033c94 <SUBGRF_GetCFO+0x80>)
 8033c6a:	f7ff f9f7 	bl	803305c <SUBGRF_ReadRegister>
 8033c6e:	4305      	orrs	r5, r0
  /* negate if 12 bits sign bit is 1 */
  if (( cfo_bin & 0x800 ) == 0x800 )
 8033c70:	052b      	lsls	r3, r5, #20
 8033c72:	d501      	bpl.n	8033c78 <SUBGRF_GetCFO+0x64>
  {
    cfo_bin |= 0xFFFFF000;
 8033c74:	4a08      	ldr	r2, [pc, #32]	; (8033c98 <SUBGRF_GetCFO+0x84>)
 8033c76:	4315      	orrs	r5, r2
  }
  /* calculate cfo in Hz */
  /* shift by 5 first to not saturate, cfo_bin on 12bits */
  *cfo = ((int32_t)( cfo_bin * ( fs >> 5 ))) >> ( 12 - 5 );
 8033c78:	0970      	lsrs	r0, r6, #5
 8033c7a:	4368      	muls	r0, r5
 8033c7c:	11c0      	asrs	r0, r0, #7
 8033c7e:	6020      	str	r0, [r4, #0]
}
 8033c80:	b002      	add	sp, #8
 8033c82:	bd70      	pop	{r4, r5, r6, pc}
    interp = 2;
 8033c84:	2602      	movs	r6, #2
 8033c86:	e7e2      	b.n	8033c4e <SUBGRF_GetCFO+0x3a>
 8033c88:	0c0a0804 	.word	0x0c0a0804
 8033c8c:	00000807 	.word	0x00000807
 8033c90:	01e84800 	.word	0x01e84800
 8033c94:	000006b1 	.word	0x000006b1
 8033c98:	fffff000 	.word	0xfffff000

08033c9c <RFW_TransmitLongPacket>:
        }
    }
#else
    status = -1;
#endif /* RFW_LONGPACKET_ENABLE == 1 */
    return status;
 8033c9c:	2001      	movs	r0, #1
}
 8033c9e:	4240      	negs	r0, r0
 8033ca0:	4770      	bx	lr

08033ca2 <RFW_ReceiveLongPacket>:
        }
    }
#else
    status = -1;
#endif /* RFW_LONGPACKET_ENABLE == 1 */
    return status;
 8033ca2:	2001      	movs	r0, #1
}
 8033ca4:	4240      	negs	r0, r0
 8033ca6:	4770      	bx	lr

08033ca8 <RFW_DeInit>:
void RFW_DeInit( void )
{
#if (RFW_ENABLE == 1 )
    RFWPacket.Init.Enable = 0; /*Disable the RFWPacket decoding*/
#endif /* RFW_ENABLE == 1 */
}
 8033ca8:	4770      	bx	lr

08033caa <RFW_Is_Init>:
#if (RFW_ENABLE == 1 )
    return RFWPacket.Init.Enable;
#else
    return 0;
#endif /* RFW_ENABLE == 1 */
}
 8033caa:	2000      	movs	r0, #0
 8033cac:	4770      	bx	lr

08033cae <RFW_Is_LongPacketModeEnabled>:
#if (RFW_ENABLE == 1 )
    return RFWPacket.LongPacketModeEnable;
#else
    return 0;
#endif /* RFW_ENABLE == 1 */
}
 8033cae:	2000      	movs	r0, #0
 8033cb0:	4770      	bx	lr

08033cb2 <RFW_SetAntSwitch>:
void RFW_SetAntSwitch( uint8_t AntSwitch )
{
#if (RFW_ENABLE == 1 )
    RFWPacket.AntSwitchPaSelect = AntSwitch;
#endif /* RFW_ENABLE == 1 */
}
 8033cb2:	4770      	bx	lr

08033cb4 <RFW_TransmitInit>:
        RFWPacket.LongPacketModeEnable = 0;

        status = 0;
    }
#endif /* RFW_ENABLE == 1 */
    return status;
 8033cb4:	2001      	movs	r0, #1
}
 8033cb6:	4240      	negs	r0, r0
 8033cb8:	4770      	bx	lr

08033cba <RFW_ReceiveInit>:
    RFWPacket.RxPayloadOffset = 0;

    RFWPacket.LongPacketModeEnable = 0;
    return 0;
#else
    return -1;
 8033cba:	2001      	movs	r0, #1
#endif /* RFW_ENABLE == 1 */
}
 8033cbc:	4240      	negs	r0, r0
 8033cbe:	4770      	bx	lr

08033cc0 <RFW_DeInit_TxLongPacket>:
    /*long packet WA*/
    uint8_t reg = SUBGRF_ReadRegister( SUBGHZ_GPKTCTL1AR );
    SUBGRF_WriteRegister( SUBGHZ_GPKTCTL1AR, reg & ~0x02 ); /* clear infinite_sequence bit */
    SUBGRF_WriteRegister( SUBGHZ_GRTXPLDLEN, 0xFF ); /* RxTxPldLen: reset to 0xFF */
#endif /* RFW_LONGPACKET_ENABLE == 1 */
}
 8033cc0:	4770      	bx	lr

08033cc2 <RFW_ReceivePayload>:
        /*timeout*/
        SUBGRF_SetStandby( STDBY_RC );
        RFWPacket.Init.RadioEvents->RxTimeout( );
    }
#endif /* RFW_ENABLE == 1 */
}
 8033cc2:	4770      	bx	lr

08033cc4 <RFW_SetRadioModem>:
void RFW_SetRadioModem( RadioModems_t Modem )
{
#if (RFW_ENABLE == 1 )
    RFWPacket.Init.Modem = Modem;
#endif /* RFW_ENABLE == 1 */
}
 8033cc4:	4770      	bx	lr
	...

08033cc8 <TRACE_AllocateBufer>:
 * @param  Size to allocate within fifo
 * @param  Pos position within the fifo
 * @retval write position inside the buffer is -1 no space available.
 */
static int16_t TRACE_AllocateBufer(uint16_t Size, uint16_t *Pos)
{
 8033cc8:	b530      	push	{r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033cca:	f3ef 8c10 	mrs	ip, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033cce:	b672      	cpsid	i
  uint16_t freesize;
  int16_t ret = -1;

  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();

  if(ADV_TRACE_Ctx.TraceWrPtr == ADV_TRACE_Ctx.TraceRdPtr)
 8033cd0:	4b1b      	ldr	r3, [pc, #108]	; (8033d40 <TRACE_AllocateBufer+0x78>)
 8033cd2:	8a5c      	ldrh	r4, [r3, #18]
 8033cd4:	8a1a      	ldrh	r2, [r3, #16]
 8033cd6:	4294      	cmp	r4, r2
 8033cd8:	d010      	beq.n	8033cfc <TRACE_AllocateBufer+0x34>
#endif
  }
  else
  {
#ifdef UTIL_ADV_TRACE_UNCHUNK_MODE
    if (ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 8033cda:	d91f      	bls.n	8033d1c <TRACE_AllocateBufer+0x54>
    {
      freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 8033cdc:	2380      	movs	r3, #128	; 0x80
 8033cde:	00db      	lsls	r3, r3, #3
 8033ce0:	1b1b      	subs	r3, r3, r4
 8033ce2:	b29b      	uxth	r3, r3
      if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size)) 
 8033ce4:	4283      	cmp	r3, r0
 8033ce6:	d81b      	bhi.n	8033d20 <TRACE_AllocateBufer+0x58>
 8033ce8:	4282      	cmp	r2, r0
 8033cea:	d919      	bls.n	8033d20 <TRACE_AllocateBufer+0x58>
      {
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_DETECTED;
 8033cec:	4b14      	ldr	r3, [pc, #80]	; (8033d40 <TRACE_AllocateBufer+0x78>)
 8033cee:	2501      	movs	r5, #1
 8033cf0:	709d      	strb	r5, [r3, #2]
        ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 8033cf2:	801c      	strh	r4, [r3, #0]
        freesize = ADV_TRACE_Ctx.TraceRdPtr;
        ADV_TRACE_Ctx.TraceWrPtr = 0;
 8033cf4:	2400      	movs	r4, #0
 8033cf6:	825c      	strh	r4, [r3, #18]
        freesize = ADV_TRACE_Ctx.TraceRdPtr;
 8033cf8:	0013      	movs	r3, r2
 8033cfa:	e011      	b.n	8033d20 <TRACE_AllocateBufer+0x58>
    freesize = (uint16_t)(UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceWrPtr);
 8033cfc:	2380      	movs	r3, #128	; 0x80
 8033cfe:	00db      	lsls	r3, r3, #3
 8033d00:	1b1b      	subs	r3, r3, r4
 8033d02:	b29b      	uxth	r3, r3
    if((Size >= freesize) && (ADV_TRACE_Ctx.TraceRdPtr > Size))
 8033d04:	4298      	cmp	r0, r3
 8033d06:	d30b      	bcc.n	8033d20 <TRACE_AllocateBufer+0x58>
 8033d08:	4282      	cmp	r2, r0
 8033d0a:	d909      	bls.n	8033d20 <TRACE_AllocateBufer+0x58>
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_DETECTED;
 8033d0c:	4b0c      	ldr	r3, [pc, #48]	; (8033d40 <TRACE_AllocateBufer+0x78>)
 8033d0e:	2501      	movs	r5, #1
 8033d10:	709d      	strb	r5, [r3, #2]
      ADV_TRACE_Ctx.unchunk_enabled = ADV_TRACE_Ctx.TraceWrPtr;
 8033d12:	801c      	strh	r4, [r3, #0]
      ADV_TRACE_Ctx.TraceWrPtr = 0;
 8033d14:	2400      	movs	r4, #0
 8033d16:	825c      	strh	r4, [r3, #18]
      freesize = ADV_TRACE_Ctx.TraceRdPtr;
 8033d18:	0013      	movs	r3, r2
 8033d1a:	e001      	b.n	8033d20 <TRACE_AllocateBufer+0x58>
      }
    }
    else
    {
      freesize = (uint16_t)(ADV_TRACE_Ctx.TraceRdPtr - ADV_TRACE_Ctx.TraceWrPtr);
 8033d1c:	1b13      	subs	r3, r2, r4
 8033d1e:	b29b      	uxth	r3, r3
      freesize = ADV_TRACE_Ctx.TraceRdPtr - ADV_TRACE_Ctx.TraceWrPtr;
    }
#endif
  }

  if(freesize > Size)
 8033d20:	4283      	cmp	r3, r0
 8033d22:	d90a      	bls.n	8033d3a <TRACE_AllocateBufer+0x72>
  {
    *Pos = ADV_TRACE_Ctx.TraceWrPtr;
 8033d24:	4a06      	ldr	r2, [pc, #24]	; (8033d40 <TRACE_AllocateBufer+0x78>)
 8033d26:	8a53      	ldrh	r3, [r2, #18]
 8033d28:	800b      	strh	r3, [r1, #0]
    ADV_TRACE_Ctx.TraceWrPtr = (ADV_TRACE_Ctx.TraceWrPtr + Size) % UTIL_ADV_TRACE_FIFO_SIZE;
 8033d2a:	181b      	adds	r3, r3, r0
 8033d2c:	059b      	lsls	r3, r3, #22
 8033d2e:	0d9b      	lsrs	r3, r3, #22
 8033d30:	8253      	strh	r3, [r2, #18]
    ret = 0;
 8033d32:	2000      	movs	r0, #0
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033d34:	f38c 8810 	msr	PRIMASK, ip
  }
#endif

  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
  return ret;
}
 8033d38:	bd30      	pop	{r4, r5, pc}
  int16_t ret = -1;
 8033d3a:	2001      	movs	r0, #1
 8033d3c:	4240      	negs	r0, r0
 8033d3e:	e7f9      	b.n	8033d34 <TRACE_AllocateBufer+0x6c>
 8033d40:	2000c708 	.word	0x2000c708

08033d44 <TRACE_Lock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033d44:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033d48:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_Lock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock++;
 8033d4a:	4a03      	ldr	r2, [pc, #12]	; (8033d58 <TRACE_Lock+0x14>)
 8033d4c:	8ad3      	ldrh	r3, [r2, #22]
 8033d4e:	3301      	adds	r3, #1
 8033d50:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033d52:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 8033d56:	4770      	bx	lr
 8033d58:	2000c708 	.word	0x2000c708

08033d5c <TRACE_UnLock>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033d5c:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033d60:	b672      	cpsid	i
 * @retval None.
 */
static void TRACE_UnLock(void)
{
  UTIL_ADV_TRACE_ENTER_CRITICAL_SECTION();
  ADV_TRACE_Ctx.TraceLock--;
 8033d62:	4a03      	ldr	r2, [pc, #12]	; (8033d70 <TRACE_UnLock+0x14>)
 8033d64:	8ad3      	ldrh	r3, [r2, #22]
 8033d66:	3b01      	subs	r3, #1
 8033d68:	82d3      	strh	r3, [r2, #22]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033d6a:	f381 8810 	msr	PRIMASK, r1
  UTIL_ADV_TRACE_EXIT_CRITICAL_SECTION();
}
 8033d6e:	4770      	bx	lr
 8033d70:	2000c708 	.word	0x2000c708

08033d74 <TRACE_IsLocked>:
 * @brief  UnLock the trace buffer.
 * @retval None.
 */
static uint32_t TRACE_IsLocked(void)
{
  return (ADV_TRACE_Ctx.TraceLock == 0u? 0u: 1u);
 8033d74:	4b02      	ldr	r3, [pc, #8]	; (8033d80 <TRACE_IsLocked+0xc>)
 8033d76:	8ad8      	ldrh	r0, [r3, #22]
 8033d78:	1e43      	subs	r3, r0, #1
 8033d7a:	4198      	sbcs	r0, r3
}
 8033d7c:	4770      	bx	lr
 8033d7e:	46c0      	nop			; (mov r8, r8)
 8033d80:	2000c708 	.word	0x2000c708

08033d84 <UTIL_ADV_TRACE_Init>:
{
 8033d84:	b510      	push	{r4, lr}
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Ctx, 0x0, sizeof(ADV_TRACE_Context));
 8033d86:	2218      	movs	r2, #24
 8033d88:	2100      	movs	r1, #0
 8033d8a:	4807      	ldr	r0, [pc, #28]	; (8033da8 <UTIL_ADV_TRACE_Init+0x24>)
 8033d8c:	f000 f993 	bl	80340b6 <UTIL_MEM_set_8>
  (void)UTIL_ADV_TRACE_MEMSET8(&ADV_TRACE_Buffer, 0x0, sizeof(ADV_TRACE_Buffer));
 8033d90:	2280      	movs	r2, #128	; 0x80
 8033d92:	00d2      	lsls	r2, r2, #3
 8033d94:	2100      	movs	r1, #0
 8033d96:	4805      	ldr	r0, [pc, #20]	; (8033dac <UTIL_ADV_TRACE_Init+0x28>)
 8033d98:	f000 f98d 	bl	80340b6 <UTIL_MEM_set_8>
  return UTIL_TraceDriver.Init(TRACE_TxCpltCallback);
 8033d9c:	4b04      	ldr	r3, [pc, #16]	; (8033db0 <UTIL_ADV_TRACE_Init+0x2c>)
 8033d9e:	681b      	ldr	r3, [r3, #0]
 8033da0:	4804      	ldr	r0, [pc, #16]	; (8033db4 <UTIL_ADV_TRACE_Init+0x30>)
 8033da2:	4798      	blx	r3
}
 8033da4:	bd10      	pop	{r4, pc}
 8033da6:	46c0      	nop			; (mov r8, r8)
 8033da8:	2000c708 	.word	0x2000c708
 8033dac:	200092a0 	.word	0x200092a0
 8033db0:	08034f40 	.word	0x08034f40
 8033db4:	08033f39 	.word	0x08033f39

08033db8 <UTIL_ADV_TRACE_RegisterTimeStampFunction>:
  ADV_TRACE_Ctx.timestamp_func = *cb;
 8033db8:	4b01      	ldr	r3, [pc, #4]	; (8033dc0 <UTIL_ADV_TRACE_RegisterTimeStampFunction+0x8>)
 8033dba:	6058      	str	r0, [r3, #4]
}
 8033dbc:	4770      	bx	lr
 8033dbe:	46c0      	nop			; (mov r8, r8)
 8033dc0:	2000c708 	.word	0x2000c708

08033dc4 <UTIL_ADV_TRACE_SetVerboseLevel>:
  ADV_TRACE_Ctx.CurrentVerboseLevel = Level;
 8033dc4:	4b01      	ldr	r3, [pc, #4]	; (8033dcc <UTIL_ADV_TRACE_SetVerboseLevel+0x8>)
 8033dc6:	7218      	strb	r0, [r3, #8]
}
 8033dc8:	4770      	bx	lr
 8033dca:	46c0      	nop			; (mov r8, r8)
 8033dcc:	2000c708 	.word	0x2000c708

08033dd0 <TRACE_Send>:
{
 8033dd0:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033dd2:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033dd6:	b672      	cpsid	i
  if(TRACE_IsLocked() == 0u)
 8033dd8:	f7ff ffcc 	bl	8033d74 <TRACE_IsLocked>
 8033ddc:	2800      	cmp	r0, #0
 8033dde:	d003      	beq.n	8033de8 <TRACE_Send+0x18>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033de0:	f384 8810 	msr	PRIMASK, r4
  UTIL_ADV_TRACE_Status_t ret = UTIL_ADV_TRACE_OK;
 8033de4:	2000      	movs	r0, #0
}
 8033de6:	bd70      	pop	{r4, r5, r6, pc}
    TRACE_Lock();
 8033de8:	f7ff ffac 	bl	8033d44 <TRACE_Lock>
    if(ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr)
 8033dec:	4b1d      	ldr	r3, [pc, #116]	; (8033e64 <TRACE_Send+0x94>)
 8033dee:	8a1a      	ldrh	r2, [r3, #16]
 8033df0:	8a5b      	ldrh	r3, [r3, #18]
 8033df2:	429a      	cmp	r2, r3
 8033df4:	d030      	beq.n	8033e58 <TRACE_Send+0x88>
      if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 8033df6:	491b      	ldr	r1, [pc, #108]	; (8033e64 <TRACE_Send+0x94>)
 8033df8:	7889      	ldrb	r1, [r1, #2]
 8033dfa:	2901      	cmp	r1, #1
 8033dfc:	d018      	beq.n	8033e30 <TRACE_Send+0x60>
      if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 8033dfe:	4a19      	ldr	r2, [pc, #100]	; (8033e64 <TRACE_Send+0x94>)
 8033e00:	7892      	ldrb	r2, [r2, #2]
 8033e02:	2a00      	cmp	r2, #0
 8033e04:	d106      	bne.n	8033e14 <TRACE_Send+0x44>
        if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 8033e06:	4a17      	ldr	r2, [pc, #92]	; (8033e64 <TRACE_Send+0x94>)
 8033e08:	8a12      	ldrh	r2, [r2, #16]
 8033e0a:	4293      	cmp	r3, r2
 8033e0c:	d91e      	bls.n	8033e4c <TRACE_Send+0x7c>
          ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 8033e0e:	1a9b      	subs	r3, r3, r2
 8033e10:	4a14      	ldr	r2, [pc, #80]	; (8033e64 <TRACE_Send+0x94>)
 8033e12:	8293      	strh	r3, [r2, #20]
      ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 8033e14:	4e13      	ldr	r6, [pc, #76]	; (8033e64 <TRACE_Send+0x94>)
 8033e16:	8a35      	ldrh	r5, [r6, #16]
 8033e18:	4b13      	ldr	r3, [pc, #76]	; (8033e68 <TRACE_Send+0x98>)
 8033e1a:	18ed      	adds	r5, r5, r3
 8033e1c:	f384 8810 	msr	PRIMASK, r4
      UTIL_ADV_TRACE_PreSendHook();
 8033e20:	f7ed feb4 	bl	8021b8c <UTIL_ADV_TRACE_PreSendHook>
      ret = UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 8033e24:	4b11      	ldr	r3, [pc, #68]	; (8033e6c <TRACE_Send+0x9c>)
 8033e26:	68db      	ldr	r3, [r3, #12]
 8033e28:	8ab1      	ldrh	r1, [r6, #20]
 8033e2a:	0028      	movs	r0, r5
 8033e2c:	4798      	blx	r3
 8033e2e:	e7da      	b.n	8033de6 <TRACE_Send+0x16>
        ADV_TRACE_Ctx.TraceSentSize = (uint16_t) (ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr);
 8033e30:	480c      	ldr	r0, [pc, #48]	; (8033e64 <TRACE_Send+0x94>)
 8033e32:	8801      	ldrh	r1, [r0, #0]
 8033e34:	1a8a      	subs	r2, r1, r2
 8033e36:	b292      	uxth	r2, r2
 8033e38:	8282      	strh	r2, [r0, #20]
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 8033e3a:	2102      	movs	r1, #2
 8033e3c:	7081      	strb	r1, [r0, #2]
        ADV_TRACE_Ctx.unchunk_enabled = 0;
 8033e3e:	2100      	movs	r1, #0
 8033e40:	8001      	strh	r1, [r0, #0]
        if(0u == ADV_TRACE_Ctx.TraceSentSize)
 8033e42:	2a00      	cmp	r2, #0
 8033e44:	d1db      	bne.n	8033dfe <TRACE_Send+0x2e>
          ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 8033e46:	7081      	strb	r1, [r0, #2]
          ADV_TRACE_Ctx.TraceRdPtr = 0;
 8033e48:	8201      	strh	r1, [r0, #16]
 8033e4a:	e7d8      	b.n	8033dfe <TRACE_Send+0x2e>
          ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 8033e4c:	2380      	movs	r3, #128	; 0x80
 8033e4e:	00db      	lsls	r3, r3, #3
 8033e50:	1a9b      	subs	r3, r3, r2
 8033e52:	4a04      	ldr	r2, [pc, #16]	; (8033e64 <TRACE_Send+0x94>)
 8033e54:	8293      	strh	r3, [r2, #20]
 8033e56:	e7dd      	b.n	8033e14 <TRACE_Send+0x44>
      TRACE_UnLock();
 8033e58:	f7ff ff80 	bl	8033d5c <TRACE_UnLock>
 8033e5c:	f384 8810 	msr	PRIMASK, r4
  UTIL_ADV_TRACE_Status_t ret = UTIL_ADV_TRACE_OK;
 8033e60:	2000      	movs	r0, #0
}
 8033e62:	e7c0      	b.n	8033de6 <TRACE_Send+0x16>
 8033e64:	2000c708 	.word	0x2000c708
 8033e68:	200092a0 	.word	0x200092a0
 8033e6c:	08034f40 	.word	0x08034f40

08033e70 <UTIL_ADV_TRACE_COND_FSend>:
{
 8033e70:	b408      	push	{r3}
 8033e72:	b510      	push	{r4, lr}
 8033e74:	b087      	sub	sp, #28
  uint16_t timestamp_size = 0u;
 8033e76:	466b      	mov	r3, sp
 8033e78:	2400      	movs	r4, #0
 8033e7a:	805c      	strh	r4, [r3, #2]
  if(!(ADV_TRACE_Ctx.CurrentVerboseLevel >= VerboseLevel))
 8033e7c:	4b2b      	ldr	r3, [pc, #172]	; (8033f2c <UTIL_ADV_TRACE_COND_FSend+0xbc>)
 8033e7e:	7a1b      	ldrb	r3, [r3, #8]
 8033e80:	4283      	cmp	r3, r0
 8033e82:	d34c      	bcc.n	8033f1e <UTIL_ADV_TRACE_COND_FSend+0xae>
  if((Region & ADV_TRACE_Ctx.RegionMask) != Region)
 8033e84:	4b29      	ldr	r3, [pc, #164]	; (8033f2c <UTIL_ADV_TRACE_COND_FSend+0xbc>)
 8033e86:	68db      	ldr	r3, [r3, #12]
 8033e88:	400b      	ands	r3, r1
 8033e8a:	428b      	cmp	r3, r1
 8033e8c:	d14a      	bne.n	8033f24 <UTIL_ADV_TRACE_COND_FSend+0xb4>
  if((ADV_TRACE_Ctx.timestamp_func != NULL) && (TimeStampState != 0u))
 8033e8e:	4b27      	ldr	r3, [pc, #156]	; (8033f2c <UTIL_ADV_TRACE_COND_FSend+0xbc>)
 8033e90:	685b      	ldr	r3, [r3, #4]
 8033e92:	2b00      	cmp	r3, #0
 8033e94:	d005      	beq.n	8033ea2 <UTIL_ADV_TRACE_COND_FSend+0x32>
 8033e96:	2a00      	cmp	r2, #0
 8033e98:	d003      	beq.n	8033ea2 <UTIL_ADV_TRACE_COND_FSend+0x32>
    ADV_TRACE_Ctx.timestamp_func(buf,&timestamp_size);
 8033e9a:	466a      	mov	r2, sp
 8033e9c:	1c91      	adds	r1, r2, #2
 8033e9e:	a801      	add	r0, sp, #4
 8033ea0:	4798      	blx	r3
  va_start( vaArgs, strFormat);
 8033ea2:	ab0a      	add	r3, sp, #40	; 0x28
 8033ea4:	9305      	str	r3, [sp, #20]
  buff_size =(uint16_t)UTIL_ADV_TRACE_VSNPRINTF((char *)sztmp,UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 8033ea6:	2180      	movs	r1, #128	; 0x80
 8033ea8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8033eaa:	0089      	lsls	r1, r1, #2
 8033eac:	4820      	ldr	r0, [pc, #128]	; (8033f30 <UTIL_ADV_TRACE_COND_FSend+0xc0>)
 8033eae:	f000 fd43 	bl	8034938 <tiny_vsnprintf_like>
 8033eb2:	b284      	uxth	r4, r0
  TRACE_Lock();
 8033eb4:	f7ff ff46 	bl	8033d44 <TRACE_Lock>
  if (TRACE_AllocateBufer((buff_size+timestamp_size),&writepos) != -1)
 8033eb8:	466b      	mov	r3, sp
 8033eba:	8858      	ldrh	r0, [r3, #2]
 8033ebc:	1820      	adds	r0, r4, r0
 8033ebe:	b280      	uxth	r0, r0
 8033ec0:	4669      	mov	r1, sp
 8033ec2:	f7ff ff01 	bl	8033cc8 <TRACE_AllocateBufer>
 8033ec6:	1c43      	adds	r3, r0, #1
 8033ec8:	d024      	beq.n	8033f14 <UTIL_ADV_TRACE_COND_FSend+0xa4>
    for (idx = 0u; idx < timestamp_size; idx++)
 8033eca:	2300      	movs	r3, #0
 8033ecc:	e00a      	b.n	8033ee4 <UTIL_ADV_TRACE_COND_FSend+0x74>
      ADV_TRACE_Buffer[writepos] = buf[idx];
 8033ece:	466a      	mov	r2, sp
 8033ed0:	8812      	ldrh	r2, [r2, #0]
 8033ed2:	a901      	add	r1, sp, #4
 8033ed4:	5cc8      	ldrb	r0, [r1, r3]
 8033ed6:	4917      	ldr	r1, [pc, #92]	; (8033f34 <UTIL_ADV_TRACE_COND_FSend+0xc4>)
 8033ed8:	5488      	strb	r0, [r1, r2]
      writepos = writepos + 1u;
 8033eda:	3201      	adds	r2, #1
 8033edc:	4669      	mov	r1, sp
 8033ede:	800a      	strh	r2, [r1, #0]
    for (idx = 0u; idx < timestamp_size; idx++)
 8033ee0:	3301      	adds	r3, #1
 8033ee2:	b29b      	uxth	r3, r3
 8033ee4:	466a      	mov	r2, sp
 8033ee6:	3202      	adds	r2, #2
 8033ee8:	8812      	ldrh	r2, [r2, #0]
 8033eea:	429a      	cmp	r2, r3
 8033eec:	d8ef      	bhi.n	8033ece <UTIL_ADV_TRACE_COND_FSend+0x5e>
    (void)UTIL_ADV_TRACE_VSNPRINTF((char *)(&ADV_TRACE_Buffer[writepos]), UTIL_ADV_TRACE_TMP_BUF_SIZE, strFormat, vaArgs);
 8033eee:	466b      	mov	r3, sp
 8033ef0:	8818      	ldrh	r0, [r3, #0]
 8033ef2:	4b10      	ldr	r3, [pc, #64]	; (8033f34 <UTIL_ADV_TRACE_COND_FSend+0xc4>)
 8033ef4:	18c0      	adds	r0, r0, r3
 8033ef6:	2180      	movs	r1, #128	; 0x80
 8033ef8:	9b05      	ldr	r3, [sp, #20]
 8033efa:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8033efc:	0089      	lsls	r1, r1, #2
 8033efe:	f000 fd1b 	bl	8034938 <tiny_vsnprintf_like>
    TRACE_UnLock();
 8033f02:	f7ff ff2b 	bl	8033d5c <TRACE_UnLock>
    return TRACE_Send();
 8033f06:	f7ff ff63 	bl	8033dd0 <TRACE_Send>
}
 8033f0a:	b007      	add	sp, #28
 8033f0c:	bc10      	pop	{r4}
 8033f0e:	bc08      	pop	{r3}
 8033f10:	b001      	add	sp, #4
 8033f12:	4718      	bx	r3
  TRACE_UnLock();
 8033f14:	f7ff ff22 	bl	8033d5c <TRACE_UnLock>
  return UTIL_ADV_TRACE_MEM_FULL;
 8033f18:	2003      	movs	r0, #3
 8033f1a:	4240      	negs	r0, r0
 8033f1c:	e7f5      	b.n	8033f0a <UTIL_ADV_TRACE_COND_FSend+0x9a>
    return UTIL_ADV_TRACE_GIVEUP;
 8033f1e:	2005      	movs	r0, #5
 8033f20:	4240      	negs	r0, r0
 8033f22:	e7f2      	b.n	8033f0a <UTIL_ADV_TRACE_COND_FSend+0x9a>
    return UTIL_ADV_TRACE_REGIONMASKED;
 8033f24:	2006      	movs	r0, #6
 8033f26:	4240      	negs	r0, r0
 8033f28:	e7ef      	b.n	8033f0a <UTIL_ADV_TRACE_COND_FSend+0x9a>
 8033f2a:	46c0      	nop			; (mov r8, r8)
 8033f2c:	2000c708 	.word	0x2000c708
 8033f30:	2000c720 	.word	0x2000c720
 8033f34:	200092a0 	.word	0x200092a0

08033f38 <TRACE_TxCpltCallback>:
{
 8033f38:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033f3a:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8033f3e:	b672      	cpsid	i
  if(TRACE_UNCHUNK_TRANSFER == ADV_TRACE_Ctx.unchunk_status)
 8033f40:	4b26      	ldr	r3, [pc, #152]	; (8033fdc <TRACE_TxCpltCallback+0xa4>)
 8033f42:	789b      	ldrb	r3, [r3, #2]
 8033f44:	2b02      	cmp	r3, #2
 8033f46:	d016      	beq.n	8033f76 <TRACE_TxCpltCallback+0x3e>
    ADV_TRACE_Ctx.TraceRdPtr = (ADV_TRACE_Ctx.TraceRdPtr + ADV_TRACE_Ctx.TraceSentSize) % UTIL_ADV_TRACE_FIFO_SIZE;
 8033f48:	4a24      	ldr	r2, [pc, #144]	; (8033fdc <TRACE_TxCpltCallback+0xa4>)
 8033f4a:	8a13      	ldrh	r3, [r2, #16]
 8033f4c:	8a90      	ldrh	r0, [r2, #20]
 8033f4e:	181b      	adds	r3, r3, r0
 8033f50:	059b      	lsls	r3, r3, #22
 8033f52:	0d9b      	lsrs	r3, r3, #22
 8033f54:	8213      	strh	r3, [r2, #16]
  if((ADV_TRACE_Ctx.TraceRdPtr != ADV_TRACE_Ctx.TraceWrPtr) && (1u == ADV_TRACE_Ctx.TraceLock))
 8033f56:	4b21      	ldr	r3, [pc, #132]	; (8033fdc <TRACE_TxCpltCallback+0xa4>)
 8033f58:	8a1a      	ldrh	r2, [r3, #16]
 8033f5a:	8a5b      	ldrh	r3, [r3, #18]
 8033f5c:	429a      	cmp	r2, r3
 8033f5e:	d003      	beq.n	8033f68 <TRACE_TxCpltCallback+0x30>
 8033f60:	481e      	ldr	r0, [pc, #120]	; (8033fdc <TRACE_TxCpltCallback+0xa4>)
 8033f62:	8ac0      	ldrh	r0, [r0, #22]
 8033f64:	2801      	cmp	r0, #1
 8033f66:	d00b      	beq.n	8033f80 <TRACE_TxCpltCallback+0x48>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8033f68:	f381 8810 	msr	PRIMASK, r1
    UTIL_ADV_TRACE_PostSendHook();
 8033f6c:	f7ed fe14 	bl	8021b98 <UTIL_ADV_TRACE_PostSendHook>
    TRACE_UnLock();
 8033f70:	f7ff fef4 	bl	8033d5c <TRACE_UnLock>
}
 8033f74:	bd10      	pop	{r4, pc}
    ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 8033f76:	4b19      	ldr	r3, [pc, #100]	; (8033fdc <TRACE_TxCpltCallback+0xa4>)
 8033f78:	2200      	movs	r2, #0
 8033f7a:	709a      	strb	r2, [r3, #2]
    ADV_TRACE_Ctx.TraceRdPtr = 0;
 8033f7c:	821a      	strh	r2, [r3, #16]
    UTIL_ADV_TRACE_DEBUG("\nTRACE_TxCpltCallback::unchunk complete\n");
 8033f7e:	e7ea      	b.n	8033f56 <TRACE_TxCpltCallback+0x1e>
    if(TRACE_UNCHUNK_DETECTED == ADV_TRACE_Ctx.unchunk_status)
 8033f80:	4816      	ldr	r0, [pc, #88]	; (8033fdc <TRACE_TxCpltCallback+0xa4>)
 8033f82:	7880      	ldrb	r0, [r0, #2]
 8033f84:	2801      	cmp	r0, #1
 8033f86:	d015      	beq.n	8033fb4 <TRACE_TxCpltCallback+0x7c>
    if(TRACE_UNCHUNK_NONE == ADV_TRACE_Ctx.unchunk_status)
 8033f88:	4a14      	ldr	r2, [pc, #80]	; (8033fdc <TRACE_TxCpltCallback+0xa4>)
 8033f8a:	7892      	ldrb	r2, [r2, #2]
 8033f8c:	2a00      	cmp	r2, #0
 8033f8e:	d106      	bne.n	8033f9e <TRACE_TxCpltCallback+0x66>
      if(ADV_TRACE_Ctx.TraceWrPtr > ADV_TRACE_Ctx.TraceRdPtr)
 8033f90:	4a12      	ldr	r2, [pc, #72]	; (8033fdc <TRACE_TxCpltCallback+0xa4>)
 8033f92:	8a12      	ldrh	r2, [r2, #16]
 8033f94:	4293      	cmp	r3, r2
 8033f96:	d91b      	bls.n	8033fd0 <TRACE_TxCpltCallback+0x98>
        ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.TraceWrPtr - ADV_TRACE_Ctx.TraceRdPtr;
 8033f98:	1a9b      	subs	r3, r3, r2
 8033f9a:	4a10      	ldr	r2, [pc, #64]	; (8033fdc <TRACE_TxCpltCallback+0xa4>)
 8033f9c:	8293      	strh	r3, [r2, #20]
    ptr = &ADV_TRACE_Buffer[ADV_TRACE_Ctx.TraceRdPtr];
 8033f9e:	4b0f      	ldr	r3, [pc, #60]	; (8033fdc <TRACE_TxCpltCallback+0xa4>)
 8033fa0:	8a18      	ldrh	r0, [r3, #16]
 8033fa2:	4a0f      	ldr	r2, [pc, #60]	; (8033fe0 <TRACE_TxCpltCallback+0xa8>)
 8033fa4:	1880      	adds	r0, r0, r2
 8033fa6:	f381 8810 	msr	PRIMASK, r1
    UTIL_TraceDriver.Send(ptr, ADV_TRACE_Ctx.TraceSentSize);
 8033faa:	4a0e      	ldr	r2, [pc, #56]	; (8033fe4 <TRACE_TxCpltCallback+0xac>)
 8033fac:	68d2      	ldr	r2, [r2, #12]
 8033fae:	8a99      	ldrh	r1, [r3, #20]
 8033fb0:	4790      	blx	r2
 8033fb2:	e7df      	b.n	8033f74 <TRACE_TxCpltCallback+0x3c>
      ADV_TRACE_Ctx.TraceSentSize = ADV_TRACE_Ctx.unchunk_enabled - ADV_TRACE_Ctx.TraceRdPtr;
 8033fb4:	4c09      	ldr	r4, [pc, #36]	; (8033fdc <TRACE_TxCpltCallback+0xa4>)
 8033fb6:	8820      	ldrh	r0, [r4, #0]
 8033fb8:	1a82      	subs	r2, r0, r2
 8033fba:	b292      	uxth	r2, r2
 8033fbc:	82a2      	strh	r2, [r4, #20]
      ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_TRANSFER;
 8033fbe:	2002      	movs	r0, #2
 8033fc0:	70a0      	strb	r0, [r4, #2]
      ADV_TRACE_Ctx.unchunk_enabled = 0;
 8033fc2:	2000      	movs	r0, #0
 8033fc4:	8020      	strh	r0, [r4, #0]
      if(0u == ADV_TRACE_Ctx.TraceSentSize)
 8033fc6:	2a00      	cmp	r2, #0
 8033fc8:	d1de      	bne.n	8033f88 <TRACE_TxCpltCallback+0x50>
        ADV_TRACE_Ctx.unchunk_status = TRACE_UNCHUNK_NONE;
 8033fca:	70a0      	strb	r0, [r4, #2]
        ADV_TRACE_Ctx.TraceRdPtr = 0;
 8033fcc:	8220      	strh	r0, [r4, #16]
 8033fce:	e7db      	b.n	8033f88 <TRACE_TxCpltCallback+0x50>
        ADV_TRACE_Ctx.TraceSentSize = UTIL_ADV_TRACE_FIFO_SIZE - ADV_TRACE_Ctx.TraceRdPtr;
 8033fd0:	2380      	movs	r3, #128	; 0x80
 8033fd2:	00db      	lsls	r3, r3, #3
 8033fd4:	1a9b      	subs	r3, r3, r2
 8033fd6:	4a01      	ldr	r2, [pc, #4]	; (8033fdc <TRACE_TxCpltCallback+0xa4>)
 8033fd8:	8293      	strh	r3, [r2, #20]
 8033fda:	e7e0      	b.n	8033f9e <TRACE_TxCpltCallback+0x66>
 8033fdc:	2000c708 	.word	0x2000c708
 8033fe0:	200092a0 	.word	0x200092a0
 8033fe4:	08034f40 	.word	0x08034f40

08033fe8 <UTIL_LPM_Init>:
/** @addtogroup TINY_LPM_Exported_function
  * @{
  */
void UTIL_LPM_Init( void )
{
  StopModeDisable = UTIL_LPM_NO_BIT_SET;
 8033fe8:	2300      	movs	r3, #0
 8033fea:	4a02      	ldr	r2, [pc, #8]	; (8033ff4 <UTIL_LPM_Init+0xc>)
 8033fec:	6013      	str	r3, [r2, #0]
  OffModeDisable = UTIL_LPM_NO_BIT_SET;
 8033fee:	4a02      	ldr	r2, [pc, #8]	; (8033ff8 <UTIL_LPM_Init+0x10>)
 8033ff0:	6013      	str	r3, [r2, #0]
  UTIL_LPM_INIT_CRITICAL_SECTION( );
}
 8033ff2:	4770      	bx	lr
 8033ff4:	2000c924 	.word	0x2000c924
 8033ff8:	2000c920 	.word	0x2000c920

08033ffc <UTIL_LPM_SetStopMode>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8033ffc:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8034000:	b672      	cpsid	i

void UTIL_LPM_SetStopMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch( state )
 8034002:	2900      	cmp	r1, #0
 8034004:	d008      	beq.n	8034018 <UTIL_LPM_SetStopMode+0x1c>
 8034006:	2901      	cmp	r1, #1
 8034008:	d103      	bne.n	8034012 <UTIL_LPM_SetStopMode+0x16>
  {
  case UTIL_LPM_DISABLE:
    {
      StopModeDisable |= lpm_id_bm;
 803400a:	4a06      	ldr	r2, [pc, #24]	; (8034024 <UTIL_LPM_SetStopMode+0x28>)
 803400c:	6811      	ldr	r1, [r2, #0]
 803400e:	4308      	orrs	r0, r1
 8034010:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8034012:	f383 8810 	msr	PRIMASK, r3
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 8034016:	4770      	bx	lr
      StopModeDisable &= ( ~lpm_id_bm );
 8034018:	4902      	ldr	r1, [pc, #8]	; (8034024 <UTIL_LPM_SetStopMode+0x28>)
 803401a:	680a      	ldr	r2, [r1, #0]
 803401c:	4382      	bics	r2, r0
 803401e:	600a      	str	r2, [r1, #0]
      break;
 8034020:	e7f7      	b.n	8034012 <UTIL_LPM_SetStopMode+0x16>
 8034022:	46c0      	nop			; (mov r8, r8)
 8034024:	2000c924 	.word	0x2000c924

08034028 <UTIL_LPM_SetOffMode>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8034028:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803402c:	b672      	cpsid	i

void UTIL_LPM_SetOffMode( UTIL_LPM_bm_t lpm_id_bm, UTIL_LPM_State_t state )
{
  UTIL_LPM_ENTER_CRITICAL_SECTION( );
  
  switch(state)
 803402e:	2900      	cmp	r1, #0
 8034030:	d008      	beq.n	8034044 <UTIL_LPM_SetOffMode+0x1c>
 8034032:	2901      	cmp	r1, #1
 8034034:	d103      	bne.n	803403e <UTIL_LPM_SetOffMode+0x16>
  {
  case UTIL_LPM_DISABLE:
    {
      OffModeDisable |= lpm_id_bm;
 8034036:	4a06      	ldr	r2, [pc, #24]	; (8034050 <UTIL_LPM_SetOffMode+0x28>)
 8034038:	6811      	ldr	r1, [r2, #0]
 803403a:	4308      	orrs	r0, r1
 803403c:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803403e:	f383 8810 	msr	PRIMASK, r3
      break;
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION( );
}
 8034042:	4770      	bx	lr
      OffModeDisable &= ( ~lpm_id_bm );
 8034044:	4902      	ldr	r1, [pc, #8]	; (8034050 <UTIL_LPM_SetOffMode+0x28>)
 8034046:	680a      	ldr	r2, [r1, #0]
 8034048:	4382      	bics	r2, r0
 803404a:	600a      	str	r2, [r1, #0]
      break;
 803404c:	e7f7      	b.n	803403e <UTIL_LPM_SetOffMode+0x16>
 803404e:	46c0      	nop			; (mov r8, r8)
 8034050:	2000c920 	.word	0x2000c920

08034054 <UTIL_LPM_EnterLowPower>:

  return mode_selected;
}

void UTIL_LPM_EnterLowPower( void )
{
 8034054:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8034056:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803405a:	b672      	cpsid	i
  UTIL_LPM_ENTER_CRITICAL_SECTION_ELP( );

  if( StopModeDisable != UTIL_LPM_NO_BIT_SET )
 803405c:	4b0d      	ldr	r3, [pc, #52]	; (8034094 <UTIL_LPM_EnterLowPower+0x40>)
 803405e:	681b      	ldr	r3, [r3, #0]
 8034060:	2b00      	cmp	r3, #0
 8034062:	d007      	beq.n	8034074 <UTIL_LPM_EnterLowPower+0x20>
  {
    /**
     * At least one user disallows Stop Mode
     * SLEEP mode is required
     */
      UTIL_PowerDriver.EnterSleepMode( );
 8034064:	4d0c      	ldr	r5, [pc, #48]	; (8034098 <UTIL_LPM_EnterLowPower+0x44>)
 8034066:	682b      	ldr	r3, [r5, #0]
 8034068:	4798      	blx	r3
      UTIL_PowerDriver.ExitSleepMode( );
 803406a:	686b      	ldr	r3, [r5, #4]
 803406c:	4798      	blx	r3
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803406e:	f384 8810 	msr	PRIMASK, r4
      UTIL_PowerDriver.ExitOffMode( );
    }
  }
  
  UTIL_LPM_EXIT_CRITICAL_SECTION_ELP( );
}
 8034072:	bd70      	pop	{r4, r5, r6, pc}
    if( OffModeDisable != UTIL_LPM_NO_BIT_SET )
 8034074:	4b09      	ldr	r3, [pc, #36]	; (803409c <UTIL_LPM_EnterLowPower+0x48>)
 8034076:	681b      	ldr	r3, [r3, #0]
 8034078:	2b00      	cmp	r3, #0
 803407a:	d005      	beq.n	8034088 <UTIL_LPM_EnterLowPower+0x34>
        UTIL_PowerDriver.EnterStopMode( );
 803407c:	4d06      	ldr	r5, [pc, #24]	; (8034098 <UTIL_LPM_EnterLowPower+0x44>)
 803407e:	68ab      	ldr	r3, [r5, #8]
 8034080:	4798      	blx	r3
        UTIL_PowerDriver.ExitStopMode( );
 8034082:	68eb      	ldr	r3, [r5, #12]
 8034084:	4798      	blx	r3
 8034086:	e7f2      	b.n	803406e <UTIL_LPM_EnterLowPower+0x1a>
      UTIL_PowerDriver.EnterOffMode( );
 8034088:	4d03      	ldr	r5, [pc, #12]	; (8034098 <UTIL_LPM_EnterLowPower+0x44>)
 803408a:	692b      	ldr	r3, [r5, #16]
 803408c:	4798      	blx	r3
      UTIL_PowerDriver.ExitOffMode( );
 803408e:	696b      	ldr	r3, [r5, #20]
 8034090:	4798      	blx	r3
 8034092:	e7ec      	b.n	803406e <UTIL_LPM_EnterLowPower+0x1a>
 8034094:	2000c924 	.word	0x2000c924
 8034098:	08034d2c 	.word	0x08034d2c
 803409c:	2000c920 	.word	0x2000c920

080340a0 <UTIL_MEM_cpy_8>:
void UTIL_MEM_cpy_8( void *dst, const void *src, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  uint8_t* src8= (uint8_t *) src;

  while( size-- )
 80340a0:	e004      	b.n	80340ac <UTIL_MEM_cpy_8+0xc>
    {
        *dst8++ = *src8++;
 80340a2:	780a      	ldrb	r2, [r1, #0]
 80340a4:	7002      	strb	r2, [r0, #0]
 80340a6:	3101      	adds	r1, #1
 80340a8:	3001      	adds	r0, #1
  while( size-- )
 80340aa:	001a      	movs	r2, r3
 80340ac:	1e53      	subs	r3, r2, #1
 80340ae:	b29b      	uxth	r3, r3
 80340b0:	2a00      	cmp	r2, #0
 80340b2:	d1f6      	bne.n	80340a2 <UTIL_MEM_cpy_8+0x2>
    }
}
 80340b4:	4770      	bx	lr

080340b6 <UTIL_MEM_set_8>:
}

void UTIL_MEM_set_8( void *dst, uint8_t value, uint16_t size )
{
  uint8_t* dst8= (uint8_t *) dst;
  while( size-- )
 80340b6:	e002      	b.n	80340be <UTIL_MEM_set_8+0x8>
  {
    *dst8++ = value;
 80340b8:	7001      	strb	r1, [r0, #0]
 80340ba:	3001      	adds	r0, #1
  while( size-- )
 80340bc:	001a      	movs	r2, r3
 80340be:	1e53      	subs	r3, r2, #1
 80340c0:	b29b      	uxth	r3, r3
 80340c2:	2a00      	cmp	r2, #0
 80340c4:	d1f8      	bne.n	80340b8 <UTIL_MEM_set_8+0x2>
  }
}
 80340c6:	4770      	bx	lr

080340c8 <UTIL_SEQ_SetTask>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80340c8:	f3ef 8c10 	mrs	ip, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80340cc:	b672      	cpsid	i

void UTIL_SEQ_SetTask( UTIL_SEQ_bm_t TaskId_bm , uint32_t Task_Prio )
{
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );

  TaskSet |= TaskId_bm;
 80340ce:	4a06      	ldr	r2, [pc, #24]	; (80340e8 <UTIL_SEQ_SetTask+0x20>)
 80340d0:	6813      	ldr	r3, [r2, #0]
 80340d2:	4303      	orrs	r3, r0
 80340d4:	6013      	str	r3, [r2, #0]
  TaskPrio[Task_Prio].priority |= TaskId_bm;
 80340d6:	4a05      	ldr	r2, [pc, #20]	; (80340ec <UTIL_SEQ_SetTask+0x24>)
 80340d8:	00c9      	lsls	r1, r1, #3
 80340da:	588b      	ldr	r3, [r1, r2]
 80340dc:	4318      	orrs	r0, r3
 80340de:	5088      	str	r0, [r1, r2]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80340e0:	f38c 8810 	msr	PRIMASK, ip

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
}
 80340e4:	4770      	bx	lr
 80340e6:	46c0      	nop			; (mov r8, r8)
 80340e8:	2000c958 	.word	0x2000c958
 80340ec:	2000c950 	.word	0x2000c950

080340f0 <UTIL_SEQ_SetEvt>:

  return;
}

void UTIL_SEQ_SetEvt( UTIL_SEQ_bm_t EvtId_bm )
{
 80340f0:	0003      	movs	r3, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80340f2:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80340f6:	b672      	cpsid	i
  UTIL_SEQ_ENTER_CRITICAL_SECTION( );

  EvtSet |= EvtId_bm;
 80340f8:	4a03      	ldr	r2, [pc, #12]	; (8034108 <UTIL_SEQ_SetEvt+0x18>)
 80340fa:	6810      	ldr	r0, [r2, #0]
 80340fc:	4318      	orrs	r0, r3
 80340fe:	6010      	str	r0, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8034100:	f381 8810 	msr	PRIMASK, r1

  UTIL_SEQ_EXIT_CRITICAL_SECTION( );

  return;
}
 8034104:	4770      	bx	lr
 8034106:	46c0      	nop			; (mov r8, r8)
 8034108:	2000c92c 	.word	0x2000c92c

0803410c <UTIL_SEQ_PreIdle>:
{
  /*
   * Unless specified by the application, there is nothing to be done
   */
  return;
}
 803410c:	4770      	bx	lr

0803410e <UTIL_SEQ_PostIdle>:
{
  /*
   * Unless specified by the application, there is nothing to be done
   */
  return;
}
 803410e:	4770      	bx	lr

08034110 <SEQ_BitPosition>:
uint8_t SEQ_BitPosition(uint32_t Value)
{
uint8_t n = 0U;
uint32_t lvalue = Value;

  if ((lvalue & 0xFFFF0000U) == 0U)  { n  = 16U; lvalue <<= 16U;  }
 8034110:	0c03      	lsrs	r3, r0, #16
 8034112:	d114      	bne.n	803413e <SEQ_BitPosition+0x2e>
 8034114:	0400      	lsls	r0, r0, #16
 8034116:	3310      	adds	r3, #16
  if ((lvalue & 0xFF000000U) == 0U)  { n +=  8U; lvalue <<=  8U;  }
 8034118:	0e02      	lsrs	r2, r0, #24
 803411a:	d102      	bne.n	8034122 <SEQ_BitPosition+0x12>
 803411c:	3308      	adds	r3, #8
 803411e:	b2db      	uxtb	r3, r3
 8034120:	0200      	lsls	r0, r0, #8
  if ((lvalue & 0xF0000000U) == 0U)  { n +=  4U; lvalue <<=  4U;  }
 8034122:	0f02      	lsrs	r2, r0, #28
 8034124:	d102      	bne.n	803412c <SEQ_BitPosition+0x1c>
 8034126:	3304      	adds	r3, #4
 8034128:	b2db      	uxtb	r3, r3
 803412a:	0100      	lsls	r0, r0, #4

  n += SEQ_clz_table_4bit[lvalue >> (32-4)];
 803412c:	0f00      	lsrs	r0, r0, #28
 803412e:	4a05      	ldr	r2, [pc, #20]	; (8034144 <SEQ_BitPosition+0x34>)
 8034130:	5c10      	ldrb	r0, [r2, r0]
 8034132:	18c3      	adds	r3, r0, r3
 8034134:	b2db      	uxtb	r3, r3

  return (uint8_t)(31U-n);
 8034136:	201f      	movs	r0, #31
 8034138:	1ac0      	subs	r0, r0, r3
 803413a:	b2c0      	uxtb	r0, r0
}
 803413c:	4770      	bx	lr
uint8_t n = 0U;
 803413e:	2300      	movs	r3, #0
 8034140:	e7ea      	b.n	8034118 <SEQ_BitPosition+0x8>
 8034142:	46c0      	nop			; (mov r8, r8)
 8034144:	08035ec8 	.word	0x08035ec8

08034148 <UTIL_SEQ_Run>:
{
 8034148:	b570      	push	{r4, r5, r6, lr}
  super_mask_backup = SuperMask;
 803414a:	4b41      	ldr	r3, [pc, #260]	; (8034250 <UTIL_SEQ_Run+0x108>)
 803414c:	681c      	ldr	r4, [r3, #0]
  SuperMask &= Mask_bm;
 803414e:	4020      	ands	r0, r4
 8034150:	6018      	str	r0, [r3, #0]
  local_taskset = TaskSet;
 8034152:	4b40      	ldr	r3, [pc, #256]	; (8034254 <UTIL_SEQ_Run+0x10c>)
 8034154:	681b      	ldr	r3, [r3, #0]
  local_evtset = EvtSet;
 8034156:	4a40      	ldr	r2, [pc, #256]	; (8034258 <UTIL_SEQ_Run+0x110>)
 8034158:	6816      	ldr	r6, [r2, #0]
  local_taskmask = TaskMask;
 803415a:	4a40      	ldr	r2, [pc, #256]	; (803425c <UTIL_SEQ_Run+0x114>)
 803415c:	6812      	ldr	r2, [r2, #0]
  local_evtwaited =  EvtWaited;
 803415e:	4940      	ldr	r1, [pc, #256]	; (8034260 <UTIL_SEQ_Run+0x118>)
 8034160:	6808      	ldr	r0, [r1, #0]
  while(((local_taskset & local_taskmask & SuperMask) != 0U) && ((local_evtset & local_evtwaited)==0U))
 8034162:	e02d      	b.n	80341c0 <UTIL_SEQ_Run+0x78>
      counter++;
 8034164:	3501      	adds	r5, #1
 8034166:	e034      	b.n	80341d2 <UTIL_SEQ_Run+0x8a>
    CurrentTaskIdx = (SEQ_BitPosition(current_task_set & TaskPrio[counter].round_robin));
 8034168:	00ed      	lsls	r5, r5, #3
 803416a:	4b3e      	ldr	r3, [pc, #248]	; (8034264 <UTIL_SEQ_Run+0x11c>)
 803416c:	195d      	adds	r5, r3, r5
 803416e:	686b      	ldr	r3, [r5, #4]
 8034170:	4018      	ands	r0, r3
 8034172:	f7ff ffcd 	bl	8034110 <SEQ_BitPosition>
 8034176:	493c      	ldr	r1, [pc, #240]	; (8034268 <UTIL_SEQ_Run+0x120>)
 8034178:	6008      	str	r0, [r1, #0]
    TaskPrio[counter].round_robin &= ~(1U << CurrentTaskIdx);
 803417a:	686a      	ldr	r2, [r5, #4]
 803417c:	2301      	movs	r3, #1
 803417e:	001e      	movs	r6, r3
 8034180:	4086      	lsls	r6, r0
 8034182:	43b2      	bics	r2, r6
 8034184:	606a      	str	r2, [r5, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8034186:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803418a:	b672      	cpsid	i
    TaskSet &= ~(1U << CurrentTaskIdx);
 803418c:	680a      	ldr	r2, [r1, #0]
 803418e:	4093      	lsls	r3, r2
 8034190:	43de      	mvns	r6, r3
 8034192:	4930      	ldr	r1, [pc, #192]	; (8034254 <UTIL_SEQ_Run+0x10c>)
 8034194:	680a      	ldr	r2, [r1, #0]
 8034196:	439a      	bics	r2, r3
 8034198:	600a      	str	r2, [r1, #0]
    for (counter = UTIL_SEQ_CONF_PRIO_NBR; counter != 0U; counter--)
 803419a:	2301      	movs	r3, #1
 803419c:	2b00      	cmp	r3, #0
 803419e:	d12d      	bne.n	80341fc <UTIL_SEQ_Run+0xb4>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80341a0:	f385 8810 	msr	PRIMASK, r5
    TaskCb[CurrentTaskIdx]( );
 80341a4:	4b30      	ldr	r3, [pc, #192]	; (8034268 <UTIL_SEQ_Run+0x120>)
 80341a6:	681b      	ldr	r3, [r3, #0]
 80341a8:	009b      	lsls	r3, r3, #2
 80341aa:	4a30      	ldr	r2, [pc, #192]	; (803426c <UTIL_SEQ_Run+0x124>)
 80341ac:	589b      	ldr	r3, [r3, r2]
 80341ae:	4798      	blx	r3
    local_taskset = TaskSet;
 80341b0:	4b28      	ldr	r3, [pc, #160]	; (8034254 <UTIL_SEQ_Run+0x10c>)
 80341b2:	681b      	ldr	r3, [r3, #0]
    local_evtset = EvtSet;
 80341b4:	4a28      	ldr	r2, [pc, #160]	; (8034258 <UTIL_SEQ_Run+0x110>)
 80341b6:	6816      	ldr	r6, [r2, #0]
    local_taskmask = TaskMask;
 80341b8:	4a28      	ldr	r2, [pc, #160]	; (803425c <UTIL_SEQ_Run+0x114>)
 80341ba:	6812      	ldr	r2, [r2, #0]
    local_evtwaited = EvtWaited;
 80341bc:	4928      	ldr	r1, [pc, #160]	; (8034260 <UTIL_SEQ_Run+0x118>)
 80341be:	6808      	ldr	r0, [r1, #0]
  while(((local_taskset & local_taskmask & SuperMask) != 0U) && ((local_evtset & local_evtwaited)==0U))
 80341c0:	4013      	ands	r3, r2
 80341c2:	4923      	ldr	r1, [pc, #140]	; (8034250 <UTIL_SEQ_Run+0x108>)
 80341c4:	6809      	ldr	r1, [r1, #0]
 80341c6:	4219      	tst	r1, r3
 80341c8:	d01f      	beq.n	803420a <UTIL_SEQ_Run+0xc2>
 80341ca:	0005      	movs	r5, r0
 80341cc:	4035      	ands	r5, r6
 80341ce:	4230      	tst	r0, r6
 80341d0:	d11b      	bne.n	803420a <UTIL_SEQ_Run+0xc2>
    while((TaskPrio[counter].priority & local_taskmask & SuperMask)== 0U)
 80341d2:	00eb      	lsls	r3, r5, #3
 80341d4:	4823      	ldr	r0, [pc, #140]	; (8034264 <UTIL_SEQ_Run+0x11c>)
 80341d6:	581b      	ldr	r3, [r3, r0]
 80341d8:	4013      	ands	r3, r2
 80341da:	4219      	tst	r1, r3
 80341dc:	d0c2      	beq.n	8034164 <UTIL_SEQ_Run+0x1c>
    current_task_set = TaskPrio[counter].priority & local_taskmask & SuperMask;
 80341de:	0003      	movs	r3, r0
 80341e0:	00ee      	lsls	r6, r5, #3
 80341e2:	5830      	ldr	r0, [r6, r0]
 80341e4:	4010      	ands	r0, r2
 80341e6:	4008      	ands	r0, r1
    if ((TaskPrio[counter].round_robin & current_task_set) == 0U)
 80341e8:	199b      	adds	r3, r3, r6
 80341ea:	685b      	ldr	r3, [r3, #4]
 80341ec:	4218      	tst	r0, r3
 80341ee:	d1bb      	bne.n	8034168 <UTIL_SEQ_Run+0x20>
      TaskPrio[counter].round_robin = UTIL_SEQ_ALL_BIT_SET;
 80341f0:	4b1c      	ldr	r3, [pc, #112]	; (8034264 <UTIL_SEQ_Run+0x11c>)
 80341f2:	199b      	adds	r3, r3, r6
 80341f4:	2201      	movs	r2, #1
 80341f6:	4252      	negs	r2, r2
 80341f8:	605a      	str	r2, [r3, #4]
 80341fa:	e7b5      	b.n	8034168 <UTIL_SEQ_Run+0x20>
      TaskPrio[counter - 1U].priority &= ~(1U << CurrentTaskIdx);
 80341fc:	3b01      	subs	r3, #1
 80341fe:	4919      	ldr	r1, [pc, #100]	; (8034264 <UTIL_SEQ_Run+0x11c>)
 8034200:	00d8      	lsls	r0, r3, #3
 8034202:	5842      	ldr	r2, [r0, r1]
 8034204:	4032      	ands	r2, r6
 8034206:	5042      	str	r2, [r0, r1]
    for (counter = UTIL_SEQ_CONF_PRIO_NBR; counter != 0U; counter--)
 8034208:	e7c8      	b.n	803419c <UTIL_SEQ_Run+0x54>
  CurrentTaskIdx = UTIL_SEQ_NOTASKRUNNING;
 803420a:	4b17      	ldr	r3, [pc, #92]	; (8034268 <UTIL_SEQ_Run+0x120>)
 803420c:	2201      	movs	r2, #1
 803420e:	4252      	negs	r2, r2
 8034210:	601a      	str	r2, [r3, #0]
  UTIL_SEQ_PreIdle( );
 8034212:	f7ff ff7b 	bl	803410c <UTIL_SEQ_PreIdle>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8034216:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803421a:	b672      	cpsid	i
  local_taskset = TaskSet;
 803421c:	4b0d      	ldr	r3, [pc, #52]	; (8034254 <UTIL_SEQ_Run+0x10c>)
 803421e:	681a      	ldr	r2, [r3, #0]
  local_evtset = EvtSet;
 8034220:	4b0d      	ldr	r3, [pc, #52]	; (8034258 <UTIL_SEQ_Run+0x110>)
 8034222:	6819      	ldr	r1, [r3, #0]
  local_taskmask = TaskMask;
 8034224:	4b0d      	ldr	r3, [pc, #52]	; (803425c <UTIL_SEQ_Run+0x114>)
 8034226:	681b      	ldr	r3, [r3, #0]
  if ((local_taskset & local_taskmask & SuperMask) == 0U)
 8034228:	4013      	ands	r3, r2
 803422a:	4a09      	ldr	r2, [pc, #36]	; (8034250 <UTIL_SEQ_Run+0x108>)
 803422c:	6812      	ldr	r2, [r2, #0]
 803422e:	421a      	tst	r2, r3
 8034230:	d103      	bne.n	803423a <UTIL_SEQ_Run+0xf2>
    if ((local_evtset & EvtWaited)== 0U)
 8034232:	4b0b      	ldr	r3, [pc, #44]	; (8034260 <UTIL_SEQ_Run+0x118>)
 8034234:	681b      	ldr	r3, [r3, #0]
 8034236:	4219      	tst	r1, r3
 8034238:	d006      	beq.n	8034248 <UTIL_SEQ_Run+0x100>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 803423a:	f385 8810 	msr	PRIMASK, r5
  UTIL_SEQ_PostIdle( );
 803423e:	f7ff ff66 	bl	803410e <UTIL_SEQ_PostIdle>
  SuperMask = super_mask_backup;
 8034242:	4b03      	ldr	r3, [pc, #12]	; (8034250 <UTIL_SEQ_Run+0x108>)
 8034244:	601c      	str	r4, [r3, #0]
}
 8034246:	bd70      	pop	{r4, r5, r6, pc}
      UTIL_SEQ_Idle( );
 8034248:	f7ed fc51 	bl	8021aee <UTIL_SEQ_Idle>
 803424c:	e7f5      	b.n	803423a <UTIL_SEQ_Run+0xf2>
 803424e:	46c0      	nop			; (mov r8, r8)
 8034250:	2000b13c 	.word	0x2000b13c
 8034254:	2000c958 	.word	0x2000c958
 8034258:	2000c92c 	.word	0x2000c92c
 803425c:	2000b140 	.word	0x2000b140
 8034260:	2000c930 	.word	0x2000c930
 8034264:	2000c950 	.word	0x2000c950
 8034268:	2000c928 	.word	0x2000c928
 803426c:	2000c934 	.word	0x2000c934

08034270 <UTIL_SEQ_WaitEvt>:
{
 8034270:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8034272:	0004      	movs	r4, r0
  current_task_idx = CurrentTaskIdx;
 8034274:	4b10      	ldr	r3, [pc, #64]	; (80342b8 <UTIL_SEQ_WaitEvt+0x48>)
 8034276:	681e      	ldr	r6, [r3, #0]
  if(UTIL_SEQ_NOTASKRUNNING == CurrentTaskIdx)
 8034278:	1c73      	adds	r3, r6, #1
 803427a:	d005      	beq.n	8034288 <UTIL_SEQ_WaitEvt+0x18>
    wait_task_idx = (uint32_t)1u << CurrentTaskIdx;
 803427c:	2501      	movs	r5, #1
 803427e:	40b5      	lsls	r5, r6
  event_waited_id_backup = EvtWaited;
 8034280:	4b0e      	ldr	r3, [pc, #56]	; (80342bc <UTIL_SEQ_WaitEvt+0x4c>)
 8034282:	681f      	ldr	r7, [r3, #0]
  EvtWaited = EvtId_bm;
 8034284:	601c      	str	r4, [r3, #0]
  while ((EvtSet & EvtId_bm) == 0U)
 8034286:	e005      	b.n	8034294 <UTIL_SEQ_WaitEvt+0x24>
    wait_task_idx = 0u;
 8034288:	2500      	movs	r5, #0
 803428a:	e7f9      	b.n	8034280 <UTIL_SEQ_WaitEvt+0x10>
    UTIL_SEQ_EvtIdle(wait_task_idx, EvtId_bm);
 803428c:	0021      	movs	r1, r4
 803428e:	0028      	movs	r0, r5
 8034290:	f7ed fc28 	bl	8021ae4 <UTIL_SEQ_EvtIdle>
  while ((EvtSet & EvtId_bm) == 0U)
 8034294:	4b0a      	ldr	r3, [pc, #40]	; (80342c0 <UTIL_SEQ_WaitEvt+0x50>)
 8034296:	681b      	ldr	r3, [r3, #0]
 8034298:	421c      	tst	r4, r3
 803429a:	d0f7      	beq.n	803428c <UTIL_SEQ_WaitEvt+0x1c>
  CurrentTaskIdx = current_task_idx;
 803429c:	4b06      	ldr	r3, [pc, #24]	; (80342b8 <UTIL_SEQ_WaitEvt+0x48>)
 803429e:	601e      	str	r6, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80342a0:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80342a4:	b672      	cpsid	i
  EvtSet &= (~EvtId_bm);
 80342a6:	4a06      	ldr	r2, [pc, #24]	; (80342c0 <UTIL_SEQ_WaitEvt+0x50>)
 80342a8:	6813      	ldr	r3, [r2, #0]
 80342aa:	43a3      	bics	r3, r4
 80342ac:	6013      	str	r3, [r2, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80342ae:	f381 8810 	msr	PRIMASK, r1
  EvtWaited = event_waited_id_backup;
 80342b2:	4b02      	ldr	r3, [pc, #8]	; (80342bc <UTIL_SEQ_WaitEvt+0x4c>)
 80342b4:	601f      	str	r7, [r3, #0]
}
 80342b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80342b8:	2000c928 	.word	0x2000c928
 80342bc:	2000c930 	.word	0x2000c930
 80342c0:	2000c92c 	.word	0x2000c92c

080342c4 <UTIL_SEQ_RegTask>:
{
 80342c4:	b570      	push	{r4, r5, r6, lr}
 80342c6:	0014      	movs	r4, r2
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80342c8:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80342cc:	b672      	cpsid	i
  TaskCb[SEQ_BitPosition(TaskId_bm)] = Task;
 80342ce:	f7ff ff1f 	bl	8034110 <SEQ_BitPosition>
 80342d2:	0080      	lsls	r0, r0, #2
 80342d4:	4b02      	ldr	r3, [pc, #8]	; (80342e0 <UTIL_SEQ_RegTask+0x1c>)
 80342d6:	50c4      	str	r4, [r0, r3]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80342d8:	f385 8810 	msr	PRIMASK, r5
}
 80342dc:	bd70      	pop	{r4, r5, r6, pc}
 80342de:	46c0      	nop			; (mov r8, r8)
 80342e0:	2000c934 	.word	0x2000c934

080342e4 <SysTimeAdd>:
  * @addtogroup SYSTIME_exported_function
  *  @{
  */

SysTime_t SysTimeAdd( SysTime_t a, SysTime_t b )
{
 80342e4:	b082      	sub	sp, #8
 80342e6:	b510      	push	{r4, lr}
 80342e8:	b082      	sub	sp, #8
 80342ea:	9100      	str	r1, [sp, #0]
 80342ec:	9201      	str	r2, [sp, #4]
 80342ee:	9305      	str	r3, [sp, #20]
  SysTime_t c =  { .Seconds = 0, .SubSeconds = 0 };
 80342f0:	2300      	movs	r3, #0
 80342f2:	6003      	str	r3, [r0, #0]
 80342f4:	8083      	strh	r3, [r0, #4]

  c.Seconds = a.Seconds + b.Seconds;
 80342f6:	000a      	movs	r2, r1
 80342f8:	9b05      	ldr	r3, [sp, #20]
 80342fa:	469c      	mov	ip, r3
 80342fc:	4462      	add	r2, ip
 80342fe:	6002      	str	r2, [r0, #0]
  c.SubSeconds = a.SubSeconds + b.SubSeconds;
 8034300:	466b      	mov	r3, sp
 8034302:	889b      	ldrh	r3, [r3, #4]
 8034304:	a905      	add	r1, sp, #20
 8034306:	8889      	ldrh	r1, [r1, #4]
 8034308:	185b      	adds	r3, r3, r1
 803430a:	b299      	uxth	r1, r3
 803430c:	b21b      	sxth	r3, r3
 803430e:	8083      	strh	r3, [r0, #4]
  if( c.SubSeconds >= 1000 )
 8034310:	24fa      	movs	r4, #250	; 0xfa
 8034312:	00a4      	lsls	r4, r4, #2
 8034314:	42a3      	cmp	r3, r4
 8034316:	db05      	blt.n	8034324 <SysTimeAdd+0x40>
  {
    c.Seconds++;
 8034318:	3201      	adds	r2, #1
 803431a:	6002      	str	r2, [r0, #0]
    c.SubSeconds -= 1000;
 803431c:	4b04      	ldr	r3, [pc, #16]	; (8034330 <SysTimeAdd+0x4c>)
 803431e:	469c      	mov	ip, r3
 8034320:	4461      	add	r1, ip
 8034322:	8081      	strh	r1, [r0, #4]
  }
  return c;
}
 8034324:	b002      	add	sp, #8
 8034326:	bc10      	pop	{r4}
 8034328:	bc08      	pop	{r3}
 803432a:	b002      	add	sp, #8
 803432c:	4718      	bx	r3
 803432e:	46c0      	nop			; (mov r8, r8)
 8034330:	fffffc18 	.word	0xfffffc18

08034334 <SysTimeSub>:

SysTime_t SysTimeSub( SysTime_t a, SysTime_t b )
{
 8034334:	b082      	sub	sp, #8
 8034336:	b082      	sub	sp, #8
 8034338:	9100      	str	r1, [sp, #0]
 803433a:	9201      	str	r2, [sp, #4]
 803433c:	9303      	str	r3, [sp, #12]
  SysTime_t c = { .Seconds = 0, .SubSeconds = 0 };
 803433e:	2300      	movs	r3, #0
 8034340:	6003      	str	r3, [r0, #0]
 8034342:	8083      	strh	r3, [r0, #4]

  c.Seconds = a.Seconds - b.Seconds;
 8034344:	9a03      	ldr	r2, [sp, #12]
 8034346:	1a8a      	subs	r2, r1, r2
 8034348:	6002      	str	r2, [r0, #0]
  c.SubSeconds = a.SubSeconds - b.SubSeconds;
 803434a:	466b      	mov	r3, sp
 803434c:	889b      	ldrh	r3, [r3, #4]
 803434e:	a903      	add	r1, sp, #12
 8034350:	8889      	ldrh	r1, [r1, #4]
 8034352:	1a5b      	subs	r3, r3, r1
 8034354:	b299      	uxth	r1, r3
 8034356:	b21b      	sxth	r3, r3
 8034358:	8083      	strh	r3, [r0, #4]
  if( c.SubSeconds < 0 )
 803435a:	2b00      	cmp	r3, #0
 803435c:	db02      	blt.n	8034364 <SysTimeSub+0x30>
  {
    c.Seconds--;
    c.SubSeconds += 1000;
  }
  return c;
}
 803435e:	b002      	add	sp, #8
 8034360:	b002      	add	sp, #8
 8034362:	4770      	bx	lr
    c.Seconds--;
 8034364:	3a01      	subs	r2, #1
 8034366:	6002      	str	r2, [r0, #0]
    c.SubSeconds += 1000;
 8034368:	23fa      	movs	r3, #250	; 0xfa
 803436a:	009b      	lsls	r3, r3, #2
 803436c:	469c      	mov	ip, r3
 803436e:	4461      	add	r1, ip
 8034370:	8081      	strh	r1, [r0, #4]
  return c;
 8034372:	e7f4      	b.n	803435e <SysTimeSub+0x2a>

08034374 <SysTimeSet>:

void SysTimeSet( SysTime_t sysTime )
{
 8034374:	b570      	push	{r4, r5, r6, lr}
 8034376:	b088      	sub	sp, #32
 8034378:	9002      	str	r0, [sp, #8]
 803437a:	9103      	str	r1, [sp, #12]
  SysTime_t DeltaTime;

  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 803437c:	ae04      	add	r6, sp, #16
 803437e:	2300      	movs	r3, #0
 8034380:	9304      	str	r3, [sp, #16]
 8034382:	80b3      	strh	r3, [r6, #4]

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 8034384:	4c0b      	ldr	r4, [pc, #44]	; (80343b4 <SysTimeSet+0x40>)
 8034386:	a805      	add	r0, sp, #20
 8034388:	6923      	ldr	r3, [r4, #16]
 803438a:	4798      	blx	r3
 803438c:	0003      	movs	r3, r0
 803438e:	9004      	str	r0, [sp, #16]

  // sysTime is UNIX epoch
  DeltaTime = SysTimeSub( sysTime, calendarTime );
 8034390:	ad06      	add	r5, sp, #24
 8034392:	9a05      	ldr	r2, [sp, #20]
 8034394:	9200      	str	r2, [sp, #0]
 8034396:	9902      	ldr	r1, [sp, #8]
 8034398:	9a03      	ldr	r2, [sp, #12]
 803439a:	0028      	movs	r0, r5
 803439c:	f7ff ffca 	bl	8034334 <SysTimeSub>

  UTIL_SYSTIMDriver.BKUPWrite_Seconds( DeltaTime.Seconds );
 80343a0:	9806      	ldr	r0, [sp, #24]
 80343a2:	6823      	ldr	r3, [r4, #0]
 80343a4:	4798      	blx	r3
  UTIL_SYSTIMDriver.BKUPWrite_SubSeconds( ( uint32_t ) DeltaTime.SubSeconds );
 80343a6:	68a3      	ldr	r3, [r4, #8]
 80343a8:	2204      	movs	r2, #4
 80343aa:	5ea8      	ldrsh	r0, [r5, r2]
 80343ac:	4798      	blx	r3
}
 80343ae:	b008      	add	sp, #32
 80343b0:	bd70      	pop	{r4, r5, r6, pc}
 80343b2:	46c0      	nop			; (mov r8, r8)
 80343b4:	08034d78 	.word	0x08034d78

080343b8 <SysTimeGet>:

SysTime_t SysTimeGet( void )
{
 80343b8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80343ba:	b087      	sub	sp, #28
 80343bc:	0004      	movs	r4, r0
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 80343be:	af04      	add	r7, sp, #16
 80343c0:	2300      	movs	r3, #0
 80343c2:	9304      	str	r3, [sp, #16]
 80343c4:	80bb      	strh	r3, [r7, #4]
  SysTime_t sysTime = { .Seconds = 0, .SubSeconds = 0 };
 80343c6:	6003      	str	r3, [r0, #0]
 80343c8:	8083      	strh	r3, [r0, #4]
  SysTime_t DeltaTime;

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 80343ca:	4d0b      	ldr	r5, [pc, #44]	; (80343f8 <SysTimeGet+0x40>)
 80343cc:	a805      	add	r0, sp, #20
 80343ce:	692b      	ldr	r3, [r5, #16]
 80343d0:	4798      	blx	r3
 80343d2:	9004      	str	r0, [sp, #16]

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 80343d4:	68eb      	ldr	r3, [r5, #12]
 80343d6:	4798      	blx	r3
 80343d8:	ae02      	add	r6, sp, #8
 80343da:	80b0      	strh	r0, [r6, #4]
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 80343dc:	686b      	ldr	r3, [r5, #4]
 80343de:	4798      	blx	r3
 80343e0:	0001      	movs	r1, r0
 80343e2:	9002      	str	r0, [sp, #8]

  sysTime = SysTimeAdd( DeltaTime, calendarTime );
 80343e4:	9b05      	ldr	r3, [sp, #20]
 80343e6:	9300      	str	r3, [sp, #0]
 80343e8:	9b04      	ldr	r3, [sp, #16]
 80343ea:	9a03      	ldr	r2, [sp, #12]
 80343ec:	0020      	movs	r0, r4
 80343ee:	f7ff ff79 	bl	80342e4 <SysTimeAdd>

  return sysTime;
}
 80343f2:	0020      	movs	r0, r4
 80343f4:	b007      	add	sp, #28
 80343f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80343f8:	08034d78 	.word	0x08034d78

080343fc <SysTimeGetMcuTime>:


SysTime_t SysTimeGetMcuTime( void )
{
 80343fc:	b530      	push	{r4, r5, lr}
 80343fe:	b083      	sub	sp, #12
 8034400:	0004      	movs	r4, r0
  SysTime_t calendarTime = { .Seconds = 0, .SubSeconds = 0 };
 8034402:	466d      	mov	r5, sp
 8034404:	2300      	movs	r3, #0
 8034406:	9300      	str	r3, [sp, #0]
 8034408:	80ab      	strh	r3, [r5, #4]

  calendarTime.Seconds = UTIL_SYSTIMDriver.GetCalendarTime( ( uint16_t* )&calendarTime.SubSeconds );
 803440a:	4b05      	ldr	r3, [pc, #20]	; (8034420 <SysTimeGetMcuTime+0x24>)
 803440c:	691b      	ldr	r3, [r3, #16]
 803440e:	a801      	add	r0, sp, #4
 8034410:	4798      	blx	r3
 8034412:	9000      	str	r0, [sp, #0]

  return calendarTime;
 8034414:	0023      	movs	r3, r4
 8034416:	cd06      	ldmia	r5!, {r1, r2}
 8034418:	c306      	stmia	r3!, {r1, r2}
}
 803441a:	0020      	movs	r0, r4
 803441c:	b003      	add	sp, #12
 803441e:	bd30      	pop	{r4, r5, pc}
 8034420:	08034d78 	.word	0x08034d78

08034424 <SysTimeToMs>:

uint32_t SysTimeToMs( SysTime_t sysTime )
{
 8034424:	b530      	push	{r4, r5, lr}
 8034426:	b089      	sub	sp, #36	; 0x24
 8034428:	9002      	str	r0, [sp, #8]
 803442a:	9103      	str	r1, [sp, #12]
  SysTime_t DeltaTime;
  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 803442c:	4c0d      	ldr	r4, [pc, #52]	; (8034464 <SysTimeToMs+0x40>)
 803442e:	68e3      	ldr	r3, [r4, #12]
 8034430:	4798      	blx	r3
 8034432:	ad06      	add	r5, sp, #24
 8034434:	80a8      	strh	r0, [r5, #4]
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 8034436:	6863      	ldr	r3, [r4, #4]
 8034438:	4798      	blx	r3
 803443a:	0003      	movs	r3, r0
 803443c:	9006      	str	r0, [sp, #24]

  SysTime_t calendarTime = SysTimeSub( sysTime, DeltaTime );
 803443e:	ac04      	add	r4, sp, #16
 8034440:	9a07      	ldr	r2, [sp, #28]
 8034442:	9200      	str	r2, [sp, #0]
 8034444:	9902      	ldr	r1, [sp, #8]
 8034446:	9a03      	ldr	r2, [sp, #12]
 8034448:	0020      	movs	r0, r4
 803444a:	f7ff ff73 	bl	8034334 <SysTimeSub>
  return calendarTime.Seconds * 1000 + calendarTime.SubSeconds;
 803444e:	9b04      	ldr	r3, [sp, #16]
 8034450:	0158      	lsls	r0, r3, #5
 8034452:	1ac0      	subs	r0, r0, r3
 8034454:	0080      	lsls	r0, r0, #2
 8034456:	18c0      	adds	r0, r0, r3
 8034458:	00c0      	lsls	r0, r0, #3
 803445a:	2204      	movs	r2, #4
 803445c:	5ea3      	ldrsh	r3, [r4, r2]
 803445e:	18c0      	adds	r0, r0, r3
}
 8034460:	b009      	add	sp, #36	; 0x24
 8034462:	bd30      	pop	{r4, r5, pc}
 8034464:	08034d78 	.word	0x08034d78

08034468 <SysTimeFromMs>:

SysTime_t SysTimeFromMs( uint32_t timeMs )
{
 8034468:	b5f0      	push	{r4, r5, r6, r7, lr}
 803446a:	b087      	sub	sp, #28
 803446c:	0005      	movs	r5, r0
 803446e:	000c      	movs	r4, r1
  uint32_t seconds = timeMs / 1000;
 8034470:	21fa      	movs	r1, #250	; 0xfa
 8034472:	0089      	lsls	r1, r1, #2
 8034474:	0020      	movs	r0, r4
 8034476:	f7eb fe4f 	bl	8020118 <__udivsi3>
  SysTime_t sysTime = { .Seconds = seconds, .SubSeconds =  timeMs - seconds * 1000 };
 803447a:	ae04      	add	r6, sp, #16
 803447c:	9004      	str	r0, [sp, #16]
 803447e:	21fa      	movs	r1, #250	; 0xfa
 8034480:	0089      	lsls	r1, r1, #2
 8034482:	4348      	muls	r0, r1
 8034484:	1a24      	subs	r4, r4, r0
 8034486:	80b4      	strh	r4, [r6, #4]
  SysTime_t DeltaTime = { 0 };
 8034488:	ac02      	add	r4, sp, #8
 803448a:	2208      	movs	r2, #8
 803448c:	2100      	movs	r1, #0
 803448e:	0020      	movs	r0, r4
 8034490:	f000 fb51 	bl	8034b36 <memset>

  DeltaTime.SubSeconds = (int16_t)UTIL_SYSTIMDriver.BKUPRead_SubSeconds();
 8034494:	4f08      	ldr	r7, [pc, #32]	; (80344b8 <SysTimeFromMs+0x50>)
 8034496:	68fb      	ldr	r3, [r7, #12]
 8034498:	4798      	blx	r3
 803449a:	80a0      	strh	r0, [r4, #4]
  DeltaTime.Seconds = UTIL_SYSTIMDriver.BKUPRead_Seconds();
 803449c:	687b      	ldr	r3, [r7, #4]
 803449e:	4798      	blx	r3
 80344a0:	0003      	movs	r3, r0
 80344a2:	9002      	str	r0, [sp, #8]
  return SysTimeAdd( sysTime, DeltaTime );
 80344a4:	9a03      	ldr	r2, [sp, #12]
 80344a6:	9200      	str	r2, [sp, #0]
 80344a8:	9904      	ldr	r1, [sp, #16]
 80344aa:	9a05      	ldr	r2, [sp, #20]
 80344ac:	0028      	movs	r0, r5
 80344ae:	f7ff ff19 	bl	80342e4 <SysTimeAdd>
}
 80344b2:	0028      	movs	r0, r5
 80344b4:	b007      	add	sp, #28
 80344b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80344b8:	08034d78 	.word	0x08034d78

080344bc <UTIL_TIMER_Init>:
  * @addtogroup TIMER_SERVER_exported_function
  *  @{
  */

UTIL_TIMER_Status_t UTIL_TIMER_Init(void)
{
 80344bc:	b510      	push	{r4, lr}
  UTIL_TIMER_INIT_CRITICAL_SECTION();
  TimerListHead = NULL;
 80344be:	4b03      	ldr	r3, [pc, #12]	; (80344cc <UTIL_TIMER_Init+0x10>)
 80344c0:	2200      	movs	r2, #0
 80344c2:	601a      	str	r2, [r3, #0]
  return UTIL_TimerDriver.InitTimer();
 80344c4:	4b02      	ldr	r3, [pc, #8]	; (80344d0 <UTIL_TIMER_Init+0x14>)
 80344c6:	681b      	ldr	r3, [r3, #0]
 80344c8:	4798      	blx	r3
}
 80344ca:	bd10      	pop	{r4, pc}
 80344cc:	2000c95c 	.word	0x2000c95c
 80344d0:	08034d8c 	.word	0x08034d8c

080344d4 <UTIL_TIMER_Create>:
{
  return UTIL_TimerDriver.DeInitTimer();
}

UTIL_TIMER_Status_t UTIL_TIMER_Create( UTIL_TIMER_Object_t *TimerObject, uint32_t PeriodValue, UTIL_TIMER_Mode_t Mode, void ( *Callback )( void *), void *Argument)
{
 80344d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80344d6:	0004      	movs	r4, r0
 80344d8:	0008      	movs	r0, r1
 80344da:	0016      	movs	r6, r2
 80344dc:	001d      	movs	r5, r3
  if((TimerObject != NULL) && (Callback != NULL))
 80344de:	2c00      	cmp	r4, #0
 80344e0:	d011      	beq.n	8034506 <UTIL_TIMER_Create+0x32>
 80344e2:	2b00      	cmp	r3, #0
 80344e4:	d011      	beq.n	803450a <UTIL_TIMER_Create+0x36>
  {
    TimerObject->Timestamp = 0U;
 80344e6:	2700      	movs	r7, #0
 80344e8:	6027      	str	r7, [r4, #0]
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(PeriodValue);
 80344ea:	4b09      	ldr	r3, [pc, #36]	; (8034510 <UTIL_TIMER_Create+0x3c>)
 80344ec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80344ee:	4798      	blx	r3
 80344f0:	6060      	str	r0, [r4, #4]
    TimerObject->IsPending = 0U;
 80344f2:	7227      	strb	r7, [r4, #8]
    TimerObject->IsRunning = 0U;
 80344f4:	7267      	strb	r7, [r4, #9]
    TimerObject->IsReloadStopped = 0U;
 80344f6:	72a7      	strb	r7, [r4, #10]
    TimerObject->Callback = Callback;
 80344f8:	60e5      	str	r5, [r4, #12]
    TimerObject->argument = Argument;
 80344fa:	9b06      	ldr	r3, [sp, #24]
 80344fc:	6123      	str	r3, [r4, #16]
    TimerObject->Mode = Mode;
 80344fe:	72e6      	strb	r6, [r4, #11]
    TimerObject->Next = NULL;
 8034500:	6167      	str	r7, [r4, #20]
    return UTIL_TIMER_OK;
 8034502:	2000      	movs	r0, #0
  }
  else
  {
    return UTIL_TIMER_INVALID_PARAM;
  }
}
 8034504:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return UTIL_TIMER_INVALID_PARAM;
 8034506:	2001      	movs	r0, #1
 8034508:	e7fc      	b.n	8034504 <UTIL_TIMER_Create+0x30>
 803450a:	2001      	movs	r0, #1
 803450c:	e7fa      	b.n	8034504 <UTIL_TIMER_Create+0x30>
 803450e:	46c0      	nop			; (mov r8, r8)
 8034510:	08034d8c 	.word	0x08034d8c

08034514 <UTIL_TIMER_GetCurrentTime>:
  }
  UTIL_TIMER_EXIT_CRITICAL_SECTION();
}

UTIL_TIMER_Time_t UTIL_TIMER_GetCurrentTime(void)
{
 8034514:	b510      	push	{r4, lr}
  uint32_t now = UTIL_TimerDriver.GetTimerValue( );
 8034516:	4c03      	ldr	r4, [pc, #12]	; (8034524 <UTIL_TIMER_GetCurrentTime+0x10>)
 8034518:	69e3      	ldr	r3, [r4, #28]
 803451a:	4798      	blx	r3
  return  UTIL_TimerDriver.Tick2ms(now);
 803451c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 803451e:	4798      	blx	r3
}
 8034520:	bd10      	pop	{r4, pc}
 8034522:	46c0      	nop			; (mov r8, r8)
 8034524:	08034d8c 	.word	0x08034d8c

08034528 <UTIL_TIMER_GetElapsedTime>:

UTIL_TIMER_Time_t UTIL_TIMER_GetElapsedTime(UTIL_TIMER_Time_t past )
{
 8034528:	b570      	push	{r4, r5, r6, lr}
 803452a:	0006      	movs	r6, r0
  uint32_t nowInTicks = UTIL_TimerDriver.GetTimerValue( );
 803452c:	4d05      	ldr	r5, [pc, #20]	; (8034544 <UTIL_TIMER_GetElapsedTime+0x1c>)
 803452e:	69eb      	ldr	r3, [r5, #28]
 8034530:	4798      	blx	r3
 8034532:	0004      	movs	r4, r0
  uint32_t pastInTicks = UTIL_TimerDriver.ms2Tick( past );
 8034534:	0030      	movs	r0, r6
 8034536:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8034538:	4798      	blx	r3
  /* intentional wrap around. Works Ok if tick duation below 1ms */
  return UTIL_TimerDriver.Tick2ms( nowInTicks- pastInTicks );
 803453a:	6aab      	ldr	r3, [r5, #40]	; 0x28
 803453c:	1a20      	subs	r0, r4, r0
 803453e:	4798      	blx	r3
}
 8034540:	bd70      	pop	{r4, r5, r6, pc}
 8034542:	46c0      	nop			; (mov r8, r8)
 8034544:	08034d8c 	.word	0x08034d8c

08034548 <TimerExists>:
 * @param TimerObject Structure containing the timer object parameters
 * @retval 1 (the object is already in the list) or 0
 */
bool TimerExists( UTIL_TIMER_Object_t *TimerObject )
{
  UTIL_TIMER_Object_t* cur = TimerListHead;
 8034548:	4b05      	ldr	r3, [pc, #20]	; (8034560 <TimerExists+0x18>)
 803454a:	681b      	ldr	r3, [r3, #0]

  while( cur != NULL )
 803454c:	e000      	b.n	8034550 <TimerExists+0x8>
  {
    if( cur == TimerObject )
    {
      return true;
    }
    cur = cur->Next;
 803454e:	695b      	ldr	r3, [r3, #20]
  while( cur != NULL )
 8034550:	2b00      	cmp	r3, #0
 8034552:	d003      	beq.n	803455c <TimerExists+0x14>
    if( cur == TimerObject )
 8034554:	4283      	cmp	r3, r0
 8034556:	d1fa      	bne.n	803454e <TimerExists+0x6>
      return true;
 8034558:	2001      	movs	r0, #1
 803455a:	e000      	b.n	803455e <TimerExists+0x16>
  }
  return false;
 803455c:	2000      	movs	r0, #0
}
 803455e:	4770      	bx	lr
 8034560:	2000c95c 	.word	0x2000c95c

08034564 <TimerSetTimeout>:
 * @brief Sets a timeout with the duration "timestamp"
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerSetTimeout( UTIL_TIMER_Object_t *TimerObject )
{
 8034564:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8034566:	0004      	movs	r4, r0
  uint32_t minTicks= UTIL_TimerDriver.GetMinimumTimeout( );
 8034568:	4e09      	ldr	r6, [pc, #36]	; (8034590 <TimerSetTimeout+0x2c>)
 803456a:	6a33      	ldr	r3, [r6, #32]
 803456c:	4798      	blx	r3
 803456e:	0005      	movs	r5, r0
  TimerObject->IsPending = 1;
 8034570:	2301      	movs	r3, #1
 8034572:	7223      	strb	r3, [r4, #8]

  /* In case deadline too soon */
  if(TimerObject->Timestamp  < (UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks) )
 8034574:	6827      	ldr	r7, [r4, #0]
 8034576:	69b6      	ldr	r6, [r6, #24]
 8034578:	47b0      	blx	r6
 803457a:	1940      	adds	r0, r0, r5
 803457c:	4287      	cmp	r7, r0
 803457e:	d202      	bcs.n	8034586 <TimerSetTimeout+0x22>
  {
	  TimerObject->Timestamp = UTIL_TimerDriver.GetTimerElapsedTime(  ) + minTicks;
 8034580:	47b0      	blx	r6
 8034582:	1945      	adds	r5, r0, r5
 8034584:	6025      	str	r5, [r4, #0]
  }
  UTIL_TimerDriver.StartTimerEvt( TimerObject->Timestamp );
 8034586:	4b02      	ldr	r3, [pc, #8]	; (8034590 <TimerSetTimeout+0x2c>)
 8034588:	689b      	ldr	r3, [r3, #8]
 803458a:	6820      	ldr	r0, [r4, #0]
 803458c:	4798      	blx	r3
}
 803458e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8034590:	08034d8c 	.word	0x08034d8c

08034594 <UTIL_TIMER_Stop>:
{
 8034594:	b510      	push	{r4, lr}
  if (NULL != TimerObject)
 8034596:	2800      	cmp	r0, #0
 8034598:	d02f      	beq.n	80345fa <UTIL_TIMER_Stop+0x66>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803459a:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 803459e:	b672      	cpsid	i
    UTIL_TIMER_Object_t* prev = TimerListHead;
 80345a0:	4b17      	ldr	r3, [pc, #92]	; (8034600 <UTIL_TIMER_Stop+0x6c>)
 80345a2:	681a      	ldr	r2, [r3, #0]
    TimerObject->IsReloadStopped = 1U;
 80345a4:	2301      	movs	r3, #1
 80345a6:	7283      	strb	r3, [r0, #10]
    if(NULL != TimerListHead)
 80345a8:	2a00      	cmp	r2, #0
 80345aa:	d01f      	beq.n	80345ec <UTIL_TIMER_Stop+0x58>
      TimerObject->IsRunning = 0U;
 80345ac:	2300      	movs	r3, #0
 80345ae:	7243      	strb	r3, [r0, #9]
      if( TimerListHead == TimerObject ) /* Stop the Head */
 80345b0:	4290      	cmp	r0, r2
 80345b2:	d007      	beq.n	80345c4 <UTIL_TIMER_Stop+0x30>
    UTIL_TIMER_Object_t* cur = TimerListHead;
 80345b4:	0013      	movs	r3, r2
        while( cur != NULL )
 80345b6:	2b00      	cmp	r3, #0
 80345b8:	d018      	beq.n	80345ec <UTIL_TIMER_Stop+0x58>
          if( cur == TimerObject )
 80345ba:	4283      	cmp	r3, r0
 80345bc:	d012      	beq.n	80345e4 <UTIL_TIMER_Stop+0x50>
            prev = cur;
 80345be:	001a      	movs	r2, r3
            cur = cur->Next;
 80345c0:	695b      	ldr	r3, [r3, #20]
 80345c2:	e7f8      	b.n	80345b6 <UTIL_TIMER_Stop+0x22>
          TimerListHead->IsPending = 0;
 80345c4:	7213      	strb	r3, [r2, #8]
          if( TimerListHead->Next != NULL )
 80345c6:	6950      	ldr	r0, [r2, #20]
 80345c8:	2800      	cmp	r0, #0
 80345ca:	d004      	beq.n	80345d6 <UTIL_TIMER_Stop+0x42>
            TimerListHead = TimerListHead->Next;
 80345cc:	4b0c      	ldr	r3, [pc, #48]	; (8034600 <UTIL_TIMER_Stop+0x6c>)
 80345ce:	6018      	str	r0, [r3, #0]
            TimerSetTimeout( TimerListHead );
 80345d0:	f7ff ffc8 	bl	8034564 <TimerSetTimeout>
 80345d4:	e00a      	b.n	80345ec <UTIL_TIMER_Stop+0x58>
            UTIL_TimerDriver.StopTimerEvt( );
 80345d6:	4b0b      	ldr	r3, [pc, #44]	; (8034604 <UTIL_TIMER_Stop+0x70>)
 80345d8:	68db      	ldr	r3, [r3, #12]
 80345da:	4798      	blx	r3
            TimerListHead = NULL;
 80345dc:	4b08      	ldr	r3, [pc, #32]	; (8034600 <UTIL_TIMER_Stop+0x6c>)
 80345de:	2200      	movs	r2, #0
 80345e0:	601a      	str	r2, [r3, #0]
 80345e2:	e003      	b.n	80345ec <UTIL_TIMER_Stop+0x58>
            if( cur->Next != NULL )
 80345e4:	695b      	ldr	r3, [r3, #20]
 80345e6:	2b00      	cmp	r3, #0
 80345e8:	d004      	beq.n	80345f4 <UTIL_TIMER_Stop+0x60>
              prev->Next = cur;
 80345ea:	6153      	str	r3, [r2, #20]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80345ec:	f384 8810 	msr	PRIMASK, r4
}
 80345f0:	2000      	movs	r0, #0
}
 80345f2:	bd10      	pop	{r4, pc}
              prev->Next = cur;
 80345f4:	2300      	movs	r3, #0
 80345f6:	6153      	str	r3, [r2, #20]
 80345f8:	e7f8      	b.n	80345ec <UTIL_TIMER_Stop+0x58>
    ret = UTIL_TIMER_INVALID_PARAM;
 80345fa:	2001      	movs	r0, #1
 80345fc:	e7f9      	b.n	80345f2 <UTIL_TIMER_Stop+0x5e>
 80345fe:	46c0      	nop			; (mov r8, r8)
 8034600:	2000c95c 	.word	0x2000c95c
 8034604:	08034d8c 	.word	0x08034d8c

08034608 <TimerInsertTimer>:
 *     next timer to expire.
 *
 * @param TimerObject Structure containing the timer object parameters
 */
void TimerInsertTimer( UTIL_TIMER_Object_t *TimerObject)
{
 8034608:	b510      	push	{r4, lr}
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803460a:	4b0a      	ldr	r3, [pc, #40]	; (8034634 <TimerInsertTimer+0x2c>)
 803460c:	681a      	ldr	r2, [r3, #0]
  UTIL_TIMER_Object_t* next = TimerListHead->Next;
 803460e:	6953      	ldr	r3, [r2, #20]

  while (cur->Next != NULL )
 8034610:	e001      	b.n	8034616 <TimerInsertTimer+0xe>
  {  
    if( TimerObject->Timestamp  > next->Timestamp )
    {
        cur = next;
 8034612:	001a      	movs	r2, r3
        next = next->Next;
 8034614:	695b      	ldr	r3, [r3, #20]
  while (cur->Next != NULL )
 8034616:	6951      	ldr	r1, [r2, #20]
 8034618:	2900      	cmp	r1, #0
 803461a:	d006      	beq.n	803462a <TimerInsertTimer+0x22>
    if( TimerObject->Timestamp  > next->Timestamp )
 803461c:	6801      	ldr	r1, [r0, #0]
 803461e:	681c      	ldr	r4, [r3, #0]
 8034620:	42a1      	cmp	r1, r4
 8034622:	d8f6      	bhi.n	8034612 <TimerInsertTimer+0xa>
    }
    else
    {
        cur->Next = TimerObject;
 8034624:	6150      	str	r0, [r2, #20]
        TimerObject->Next = next;
 8034626:	6143      	str	r3, [r0, #20]
        return;
 8034628:	e002      	b.n	8034630 <TimerInsertTimer+0x28>

    }
  }
  cur->Next = TimerObject;
 803462a:	6150      	str	r0, [r2, #20]
  TimerObject->Next = NULL;
 803462c:	2300      	movs	r3, #0
 803462e:	6143      	str	r3, [r0, #20]
}
 8034630:	bd10      	pop	{r4, pc}
 8034632:	46c0      	nop			; (mov r8, r8)
 8034634:	2000c95c 	.word	0x2000c95c

08034638 <TimerInsertNewHeadTimer>:
 *
 * @remark The list is automatically sorted. The list head always contains the
 *         next timer to expire.
 */
void TimerInsertNewHeadTimer( UTIL_TIMER_Object_t *TimerObject )
{
 8034638:	b510      	push	{r4, lr}
  UTIL_TIMER_Object_t* cur = TimerListHead;
 803463a:	4b06      	ldr	r3, [pc, #24]	; (8034654 <TimerInsertNewHeadTimer+0x1c>)
 803463c:	681b      	ldr	r3, [r3, #0]

  if( cur != NULL )
 803463e:	2b00      	cmp	r3, #0
 8034640:	d001      	beq.n	8034646 <TimerInsertNewHeadTimer+0xe>
  {
    cur->IsPending = 0;
 8034642:	2200      	movs	r2, #0
 8034644:	721a      	strb	r2, [r3, #8]
  }

  TimerObject->Next = cur;
 8034646:	6143      	str	r3, [r0, #20]
  TimerListHead = TimerObject;
 8034648:	4b02      	ldr	r3, [pc, #8]	; (8034654 <TimerInsertNewHeadTimer+0x1c>)
 803464a:	6018      	str	r0, [r3, #0]
  TimerSetTimeout( TimerListHead );
 803464c:	f7ff ff8a 	bl	8034564 <TimerSetTimeout>
}
 8034650:	bd10      	pop	{r4, pc}
 8034652:	46c0      	nop			; (mov r8, r8)
 8034654:	2000c95c 	.word	0x2000c95c

08034658 <UTIL_TIMER_Start>:
{
 8034658:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 803465a:	1e04      	subs	r4, r0, #0
  if(( TimerObject != NULL ) && ( TimerExists( TimerObject ) == false ) && (TimerObject->IsRunning == 0U))
 803465c:	d037      	beq.n	80346ce <UTIL_TIMER_Start+0x76>
 803465e:	f7ff ff73 	bl	8034548 <TimerExists>
 8034662:	2800      	cmp	r0, #0
 8034664:	d136      	bne.n	80346d4 <UTIL_TIMER_Start+0x7c>
 8034666:	7a65      	ldrb	r5, [r4, #9]
 8034668:	2d00      	cmp	r5, #0
 803466a:	d135      	bne.n	80346d8 <UTIL_TIMER_Start+0x80>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803466c:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8034670:	b672      	cpsid	i
    ticks = TimerObject->ReloadValue;
 8034672:	6867      	ldr	r7, [r4, #4]
    minValue = UTIL_TimerDriver.GetMinimumTimeout( );
 8034674:	4b19      	ldr	r3, [pc, #100]	; (80346dc <UTIL_TIMER_Start+0x84>)
 8034676:	6a1b      	ldr	r3, [r3, #32]
 8034678:	4798      	blx	r3
    if( ticks < minValue )
 803467a:	4287      	cmp	r7, r0
 803467c:	d300      	bcc.n	8034680 <UTIL_TIMER_Start+0x28>
    ticks = TimerObject->ReloadValue;
 803467e:	0038      	movs	r0, r7
    TimerObject->Timestamp = ticks;
 8034680:	6020      	str	r0, [r4, #0]
    TimerObject->IsPending = 0U;
 8034682:	2300      	movs	r3, #0
 8034684:	7223      	strb	r3, [r4, #8]
    TimerObject->IsRunning = 1U;
 8034686:	2201      	movs	r2, #1
 8034688:	7262      	strb	r2, [r4, #9]
    TimerObject->IsReloadStopped = 0U;
 803468a:	72a3      	strb	r3, [r4, #10]
    if( TimerListHead == NULL )
 803468c:	4b14      	ldr	r3, [pc, #80]	; (80346e0 <UTIL_TIMER_Start+0x88>)
 803468e:	681b      	ldr	r3, [r3, #0]
 8034690:	2b00      	cmp	r3, #0
 8034692:	d011      	beq.n	80346b8 <UTIL_TIMER_Start+0x60>
      elapsedTime = UTIL_TimerDriver.GetTimerElapsedTime( );
 8034694:	4b11      	ldr	r3, [pc, #68]	; (80346dc <UTIL_TIMER_Start+0x84>)
 8034696:	699b      	ldr	r3, [r3, #24]
 8034698:	4798      	blx	r3
      TimerObject->Timestamp += elapsedTime;
 803469a:	6823      	ldr	r3, [r4, #0]
 803469c:	469c      	mov	ip, r3
 803469e:	4460      	add	r0, ip
 80346a0:	6020      	str	r0, [r4, #0]
      if( TimerObject->Timestamp < TimerListHead->Timestamp )
 80346a2:	4b0f      	ldr	r3, [pc, #60]	; (80346e0 <UTIL_TIMER_Start+0x88>)
 80346a4:	681b      	ldr	r3, [r3, #0]
 80346a6:	681b      	ldr	r3, [r3, #0]
 80346a8:	4298      	cmp	r0, r3
 80346aa:	d20c      	bcs.n	80346c6 <UTIL_TIMER_Start+0x6e>
        TimerInsertNewHeadTimer( TimerObject);
 80346ac:	0020      	movs	r0, r4
 80346ae:	f7ff ffc3 	bl	8034638 <TimerInsertNewHeadTimer>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80346b2:	f386 8810 	msr	PRIMASK, r6
}
 80346b6:	e00b      	b.n	80346d0 <UTIL_TIMER_Start+0x78>
      UTIL_TimerDriver.SetTimerContext();
 80346b8:	4b08      	ldr	r3, [pc, #32]	; (80346dc <UTIL_TIMER_Start+0x84>)
 80346ba:	691b      	ldr	r3, [r3, #16]
 80346bc:	4798      	blx	r3
      TimerInsertNewHeadTimer( TimerObject ); /* insert a timeout at now+obj->Timestamp */
 80346be:	0020      	movs	r0, r4
 80346c0:	f7ff ffba 	bl	8034638 <TimerInsertNewHeadTimer>
 80346c4:	e7f5      	b.n	80346b2 <UTIL_TIMER_Start+0x5a>
        TimerInsertTimer( TimerObject);
 80346c6:	0020      	movs	r0, r4
 80346c8:	f7ff ff9e 	bl	8034608 <TimerInsertTimer>
 80346cc:	e7f1      	b.n	80346b2 <UTIL_TIMER_Start+0x5a>
    ret =  UTIL_TIMER_INVALID_PARAM;
 80346ce:	2501      	movs	r5, #1
}
 80346d0:	0028      	movs	r0, r5
 80346d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ret =  UTIL_TIMER_INVALID_PARAM;
 80346d4:	2501      	movs	r5, #1
 80346d6:	e7fb      	b.n	80346d0 <UTIL_TIMER_Start+0x78>
 80346d8:	2501      	movs	r5, #1
 80346da:	e7f9      	b.n	80346d0 <UTIL_TIMER_Start+0x78>
 80346dc:	08034d8c 	.word	0x08034d8c
 80346e0:	2000c95c 	.word	0x2000c95c

080346e4 <UTIL_TIMER_SetPeriod>:
{
 80346e4:	b510      	push	{r4, lr}
 80346e6:	0004      	movs	r4, r0
 80346e8:	0008      	movs	r0, r1
  if(NULL == TimerObject)
 80346ea:	2c00      	cmp	r4, #0
 80346ec:	d011      	beq.n	8034712 <UTIL_TIMER_SetPeriod+0x2e>
    TimerObject->ReloadValue = UTIL_TimerDriver.ms2Tick(NewPeriodValue);
 80346ee:	4b0a      	ldr	r3, [pc, #40]	; (8034718 <UTIL_TIMER_SetPeriod+0x34>)
 80346f0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80346f2:	4798      	blx	r3
 80346f4:	6060      	str	r0, [r4, #4]
    if(TimerExists(TimerObject))
 80346f6:	0020      	movs	r0, r4
 80346f8:	f7ff ff26 	bl	8034548 <TimerExists>
 80346fc:	2800      	cmp	r0, #0
 80346fe:	d101      	bne.n	8034704 <UTIL_TIMER_SetPeriod+0x20>
  UTIL_TIMER_Status_t  ret = UTIL_TIMER_OK;
 8034700:	2000      	movs	r0, #0
}
 8034702:	bd10      	pop	{r4, pc}
      (void)UTIL_TIMER_Stop(TimerObject);
 8034704:	0020      	movs	r0, r4
 8034706:	f7ff ff45 	bl	8034594 <UTIL_TIMER_Stop>
      ret = UTIL_TIMER_Start(TimerObject);
 803470a:	0020      	movs	r0, r4
 803470c:	f7ff ffa4 	bl	8034658 <UTIL_TIMER_Start>
 8034710:	e7f7      	b.n	8034702 <UTIL_TIMER_SetPeriod+0x1e>
	  ret = UTIL_TIMER_INVALID_PARAM;
 8034712:	2001      	movs	r0, #1
 8034714:	e7f5      	b.n	8034702 <UTIL_TIMER_SetPeriod+0x1e>
 8034716:	46c0      	nop			; (mov r8, r8)
 8034718:	08034d8c 	.word	0x08034d8c

0803471c <UTIL_TIMER_IRQ_Handler>:
{
 803471c:	b570      	push	{r4, r5, r6, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 803471e:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 8034722:	b672      	cpsid	i
  old  =  UTIL_TimerDriver.GetTimerContext( );
 8034724:	4c21      	ldr	r4, [pc, #132]	; (80347ac <UTIL_TIMER_IRQ_Handler+0x90>)
 8034726:	6963      	ldr	r3, [r4, #20]
 8034728:	4798      	blx	r3
 803472a:	0006      	movs	r6, r0
  now  =  UTIL_TimerDriver.SetTimerContext( );
 803472c:	6923      	ldr	r3, [r4, #16]
 803472e:	4798      	blx	r3
  DeltaContext = now  - old; /*intentional wrap around */
 8034730:	1b84      	subs	r4, r0, r6
  if ( TimerListHead != NULL )
 8034732:	4b1f      	ldr	r3, [pc, #124]	; (80347b0 <UTIL_TIMER_IRQ_Handler+0x94>)
 8034734:	681b      	ldr	r3, [r3, #0]
 8034736:	2b00      	cmp	r3, #0
 8034738:	d105      	bne.n	8034746 <UTIL_TIMER_IRQ_Handler+0x2a>
 803473a:	e01a      	b.n	8034772 <UTIL_TIMER_IRQ_Handler+0x56>
        cur->Timestamp = 0;
 803473c:	2200      	movs	r2, #0
 803473e:	601a      	str	r2, [r3, #0]
      cur = cur->Next;
 8034740:	695b      	ldr	r3, [r3, #20]
    } while(cur != NULL);
 8034742:	2b00      	cmp	r3, #0
 8034744:	d015      	beq.n	8034772 <UTIL_TIMER_IRQ_Handler+0x56>
      if (cur->Timestamp > DeltaContext)
 8034746:	681a      	ldr	r2, [r3, #0]
 8034748:	42a2      	cmp	r2, r4
 803474a:	d9f7      	bls.n	803473c <UTIL_TIMER_IRQ_Handler+0x20>
        cur->Timestamp -= DeltaContext;
 803474c:	1a31      	subs	r1, r6, r0
 803474e:	188a      	adds	r2, r1, r2
 8034750:	601a      	str	r2, [r3, #0]
 8034752:	e7f5      	b.n	8034740 <UTIL_TIMER_IRQ_Handler+0x24>
      cur = TimerListHead;
 8034754:	4b16      	ldr	r3, [pc, #88]	; (80347b0 <UTIL_TIMER_IRQ_Handler+0x94>)
 8034756:	681c      	ldr	r4, [r3, #0]
      TimerListHead = TimerListHead->Next;
 8034758:	6962      	ldr	r2, [r4, #20]
 803475a:	601a      	str	r2, [r3, #0]
      cur->IsPending = 0;
 803475c:	2300      	movs	r3, #0
 803475e:	7223      	strb	r3, [r4, #8]
      cur->IsRunning = 0;
 8034760:	7263      	strb	r3, [r4, #9]
      cur->Callback(cur->argument);
 8034762:	6920      	ldr	r0, [r4, #16]
 8034764:	68e3      	ldr	r3, [r4, #12]
 8034766:	4798      	blx	r3
      if(( cur->Mode == UTIL_TIMER_PERIODIC) && (cur->IsReloadStopped == 0U))
 8034768:	8962      	ldrh	r2, [r4, #10]
 803476a:	2380      	movs	r3, #128	; 0x80
 803476c:	005b      	lsls	r3, r3, #1
 803476e:	429a      	cmp	r2, r3
 8034770:	d015      	beq.n	803479e <UTIL_TIMER_IRQ_Handler+0x82>
  while ((TimerListHead != NULL) && ((TimerListHead->Timestamp == 0U) || (TimerListHead->Timestamp < UTIL_TimerDriver.GetTimerElapsedTime(  ))))
 8034772:	4b0f      	ldr	r3, [pc, #60]	; (80347b0 <UTIL_TIMER_IRQ_Handler+0x94>)
 8034774:	681b      	ldr	r3, [r3, #0]
 8034776:	2b00      	cmp	r3, #0
 8034778:	d007      	beq.n	803478a <UTIL_TIMER_IRQ_Handler+0x6e>
 803477a:	681c      	ldr	r4, [r3, #0]
 803477c:	2c00      	cmp	r4, #0
 803477e:	d0e9      	beq.n	8034754 <UTIL_TIMER_IRQ_Handler+0x38>
 8034780:	4b0a      	ldr	r3, [pc, #40]	; (80347ac <UTIL_TIMER_IRQ_Handler+0x90>)
 8034782:	699b      	ldr	r3, [r3, #24]
 8034784:	4798      	blx	r3
 8034786:	4284      	cmp	r4, r0
 8034788:	d3e4      	bcc.n	8034754 <UTIL_TIMER_IRQ_Handler+0x38>
  if(( TimerListHead != NULL ) && (TimerListHead->IsPending == 0U))
 803478a:	4b09      	ldr	r3, [pc, #36]	; (80347b0 <UTIL_TIMER_IRQ_Handler+0x94>)
 803478c:	6818      	ldr	r0, [r3, #0]
 803478e:	2800      	cmp	r0, #0
 8034790:	d002      	beq.n	8034798 <UTIL_TIMER_IRQ_Handler+0x7c>
 8034792:	7a03      	ldrb	r3, [r0, #8]
 8034794:	2b00      	cmp	r3, #0
 8034796:	d006      	beq.n	80347a6 <UTIL_TIMER_IRQ_Handler+0x8a>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8034798:	f385 8810 	msr	PRIMASK, r5
}
 803479c:	bd70      	pop	{r4, r5, r6, pc}
        (void)UTIL_TIMER_Start(cur);
 803479e:	0020      	movs	r0, r4
 80347a0:	f7ff ff5a 	bl	8034658 <UTIL_TIMER_Start>
 80347a4:	e7e5      	b.n	8034772 <UTIL_TIMER_IRQ_Handler+0x56>
    TimerSetTimeout( TimerListHead );
 80347a6:	f7ff fedd 	bl	8034564 <TimerSetTimeout>
 80347aa:	e7f5      	b.n	8034798 <UTIL_TIMER_IRQ_Handler+0x7c>
 80347ac:	08034d8c 	.word	0x08034d8c
 80347b0:	2000c95c 	.word	0x2000c95c

080347b4 <ee_skip_atoi>:
  return sc - s;
}
#endif

static int ee_skip_atoi(const char **s)
{
 80347b4:	b510      	push	{r4, lr}
 80347b6:	0004      	movs	r4, r0
  int i = 0;
 80347b8:	2000      	movs	r0, #0
  while (is_digit(**s)) i = i*10 + *((*s)++) - '0';
 80347ba:	e007      	b.n	80347cc <ee_skip_atoi+0x18>
 80347bc:	0083      	lsls	r3, r0, #2
 80347be:	181b      	adds	r3, r3, r0
 80347c0:	005b      	lsls	r3, r3, #1
 80347c2:	1c4a      	adds	r2, r1, #1
 80347c4:	6022      	str	r2, [r4, #0]
 80347c6:	7808      	ldrb	r0, [r1, #0]
 80347c8:	1818      	adds	r0, r3, r0
 80347ca:	3830      	subs	r0, #48	; 0x30
 80347cc:	6821      	ldr	r1, [r4, #0]
 80347ce:	780a      	ldrb	r2, [r1, #0]
 80347d0:	3a30      	subs	r2, #48	; 0x30
 80347d2:	b2d2      	uxtb	r2, r2
 80347d4:	2a09      	cmp	r2, #9
 80347d6:	d9f1      	bls.n	80347bc <ee_skip_atoi+0x8>
  return i;
}
 80347d8:	bd10      	pop	{r4, pc}
	...

080347dc <ee_number>:

#define ASSIGN_STR(_c)  do { *str++ = (_c); max_size--; if (max_size == 0) return str; } while (0)

static char *ee_number(char *str, int max_size, long num, int base, int size, int precision, int type)
{
 80347dc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80347de:	46de      	mov	lr, fp
 80347e0:	4657      	mov	r7, sl
 80347e2:	464e      	mov	r6, r9
 80347e4:	4645      	mov	r5, r8
 80347e6:	b5e0      	push	{r5, r6, r7, lr}
 80347e8:	b095      	sub	sp, #84	; 0x54
 80347ea:	0005      	movs	r5, r0
 80347ec:	000c      	movs	r4, r1
 80347ee:	0016      	movs	r6, r2
 80347f0:	4699      	mov	r9, r3
 80347f2:	9b20      	ldr	r3, [sp, #128]	; 0x80
  char c;
  char sign, tmp[66];
  char *dig = lower_digits;
  int i;

  if (type & UPPERCASE)  dig = upper_digits;
 80347f4:	065a      	lsls	r2, r3, #25
 80347f6:	d415      	bmi.n	8034824 <ee_number+0x48>
  char *dig = lower_digits;
 80347f8:	4a4d      	ldr	r2, [pc, #308]	; (8034930 <ee_number+0x154>)
 80347fa:	4693      	mov	fp, r2
#ifdef TINY_PRINTF
#else
  if (type & LEFT) type &= ~ZEROPAD;
#endif
  if (base < 2 || base > 36) return 0;
 80347fc:	464a      	mov	r2, r9
 80347fe:	3a02      	subs	r2, #2
 8034800:	2a22      	cmp	r2, #34	; 0x22
 8034802:	d900      	bls.n	8034806 <ee_number+0x2a>
 8034804:	e08c      	b.n	8034920 <ee_number+0x144>

  c = (type & ZEROPAD) ? '0' : ' ';
 8034806:	2201      	movs	r2, #1
 8034808:	0011      	movs	r1, r2
 803480a:	4019      	ands	r1, r3
 803480c:	4688      	mov	r8, r1
 803480e:	421a      	tst	r2, r3
 8034810:	d00b      	beq.n	803482a <ee_number+0x4e>
 8034812:	322f      	adds	r2, #47	; 0x2f
 8034814:	4692      	mov	sl, r2
  sign = 0;
  if (type & SIGN)
 8034816:	079b      	lsls	r3, r3, #30
 8034818:	d511      	bpl.n	803483e <ee_number+0x62>
  {
    if (num < 0)
 803481a:	2e00      	cmp	r6, #0
 803481c:	db08      	blt.n	8034830 <ee_number+0x54>
  sign = 0;
 803481e:	2300      	movs	r3, #0
 8034820:	9301      	str	r3, [sp, #4]
 8034822:	e00e      	b.n	8034842 <ee_number+0x66>
  if (type & UPPERCASE)  dig = upper_digits;
 8034824:	4a43      	ldr	r2, [pc, #268]	; (8034934 <ee_number+0x158>)
 8034826:	4693      	mov	fp, r2
 8034828:	e7e8      	b.n	80347fc <ee_number+0x20>
  c = (type & ZEROPAD) ? '0' : ' ';
 803482a:	2220      	movs	r2, #32
 803482c:	4692      	mov	sl, r2
 803482e:	e7f2      	b.n	8034816 <ee_number+0x3a>
    {
      sign = '-';
      num = -num;
 8034830:	4276      	negs	r6, r6
      size--;
 8034832:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8034834:	3b01      	subs	r3, #1
 8034836:	931e      	str	r3, [sp, #120]	; 0x78
      sign = '-';
 8034838:	232d      	movs	r3, #45	; 0x2d
 803483a:	9301      	str	r3, [sp, #4]
 803483c:	e001      	b.n	8034842 <ee_number+0x66>
  sign = 0;
 803483e:	2300      	movs	r3, #0
 8034840:	9301      	str	r3, [sp, #4]
  }
#endif

  i = 0;

  if (num == 0)
 8034842:	2e00      	cmp	r6, #0
 8034844:	d135      	bne.n	80348b2 <ee_number+0xd6>
    tmp[i++] = '0';
 8034846:	ab03      	add	r3, sp, #12
 8034848:	2230      	movs	r2, #48	; 0x30
 803484a:	701a      	strb	r2, [r3, #0]
 803484c:	2701      	movs	r7, #1
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
      num = ((unsigned long) num) / (unsigned) base;
    }
  }

  if (i > precision) precision = i;
 803484e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8034850:	429f      	cmp	r7, r3
 8034852:	dd00      	ble.n	8034856 <ee_number+0x7a>
 8034854:	971f      	str	r7, [sp, #124]	; 0x7c
  size -= precision;
 8034856:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8034858:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 803485a:	1a9b      	subs	r3, r3, r2
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 803485c:	4642      	mov	r2, r8
 803485e:	2a00      	cmp	r2, #0
 8034860:	d029      	beq.n	80348b6 <ee_number+0xda>
  if (sign) ASSIGN_STR(sign);
 8034862:	9a01      	ldr	r2, [sp, #4]
 8034864:	2a00      	cmp	r2, #0
 8034866:	d005      	beq.n	8034874 <ee_number+0x98>
 8034868:	1c68      	adds	r0, r5, #1
 803486a:	702a      	strb	r2, [r5, #0]
 803486c:	3c01      	subs	r4, #1
 803486e:	2c00      	cmp	r4, #0
 8034870:	d057      	beq.n	8034922 <ee_number+0x146>
 8034872:	0005      	movs	r5, r0
    }
  }
#endif

#ifdef TINY_PRINTF
  while (size-- > 0) ASSIGN_STR(c);
 8034874:	001a      	movs	r2, r3
 8034876:	3b01      	subs	r3, #1
 8034878:	2a00      	cmp	r2, #0
 803487a:	dd28      	ble.n	80348ce <ee_number+0xf2>
 803487c:	1c68      	adds	r0, r5, #1
 803487e:	4652      	mov	r2, sl
 8034880:	702a      	strb	r2, [r5, #0]
 8034882:	3c01      	subs	r4, #1
 8034884:	2c00      	cmp	r4, #0
 8034886:	d04c      	beq.n	8034922 <ee_number+0x146>
 8034888:	0005      	movs	r5, r0
 803488a:	e7f3      	b.n	8034874 <ee_number+0x98>
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 803488c:	4649      	mov	r1, r9
 803488e:	0030      	movs	r0, r6
 8034890:	f7eb fcc8 	bl	8020224 <__aeabi_uidivmod>
 8034894:	1c7b      	adds	r3, r7, #1
 8034896:	9300      	str	r3, [sp, #0]
 8034898:	465a      	mov	r2, fp
 803489a:	5c52      	ldrb	r2, [r2, r1]
 803489c:	ab03      	add	r3, sp, #12
 803489e:	55da      	strb	r2, [r3, r7]
      num = ((unsigned long) num) / (unsigned) base;
 80348a0:	4649      	mov	r1, r9
 80348a2:	0030      	movs	r0, r6
 80348a4:	f7eb fc38 	bl	8020118 <__udivsi3>
 80348a8:	0006      	movs	r6, r0
      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
 80348aa:	9f00      	ldr	r7, [sp, #0]
    while (num != 0)
 80348ac:	2e00      	cmp	r6, #0
 80348ae:	d1ed      	bne.n	803488c <ee_number+0xb0>
 80348b0:	e7cd      	b.n	803484e <ee_number+0x72>
  i = 0;
 80348b2:	2700      	movs	r7, #0
 80348b4:	e7fa      	b.n	80348ac <ee_number+0xd0>
  if (!(type & (ZEROPAD /* TINY option   | LEFT */))) while (size-- > 0) ASSIGN_STR(' ');
 80348b6:	001a      	movs	r2, r3
 80348b8:	3b01      	subs	r3, #1
 80348ba:	2a00      	cmp	r2, #0
 80348bc:	ddd1      	ble.n	8034862 <ee_number+0x86>
 80348be:	1c68      	adds	r0, r5, #1
 80348c0:	2220      	movs	r2, #32
 80348c2:	702a      	strb	r2, [r5, #0]
 80348c4:	3c01      	subs	r4, #1
 80348c6:	2c00      	cmp	r4, #0
 80348c8:	d02b      	beq.n	8034922 <ee_number+0x146>
 80348ca:	0005      	movs	r5, r0
 80348cc:	e7f3      	b.n	80348b6 <ee_number+0xda>
#else
  if (!(type & LEFT)) while (size-- > 0) ASSIGN_STR(c);
#endif
  while (i < precision--) ASSIGN_STR('0');
 80348ce:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
 80348d0:	0011      	movs	r1, r2
 80348d2:	3901      	subs	r1, #1
 80348d4:	911f      	str	r1, [sp, #124]	; 0x7c
 80348d6:	42ba      	cmp	r2, r7
 80348d8:	dd07      	ble.n	80348ea <ee_number+0x10e>
 80348da:	1c68      	adds	r0, r5, #1
 80348dc:	2230      	movs	r2, #48	; 0x30
 80348de:	702a      	strb	r2, [r5, #0]
 80348e0:	3c01      	subs	r4, #1
 80348e2:	2c00      	cmp	r4, #0
 80348e4:	d01d      	beq.n	8034922 <ee_number+0x146>
 80348e6:	0005      	movs	r5, r0
 80348e8:	e7f1      	b.n	80348ce <ee_number+0xf2>
  while (i-- > 0) ASSIGN_STR(tmp[i]);
 80348ea:	003a      	movs	r2, r7
 80348ec:	3f01      	subs	r7, #1
 80348ee:	2a00      	cmp	r2, #0
 80348f0:	dd08      	ble.n	8034904 <ee_number+0x128>
 80348f2:	1c68      	adds	r0, r5, #1
 80348f4:	aa03      	add	r2, sp, #12
 80348f6:	5dd2      	ldrb	r2, [r2, r7]
 80348f8:	702a      	strb	r2, [r5, #0]
 80348fa:	3c01      	subs	r4, #1
 80348fc:	2c00      	cmp	r4, #0
 80348fe:	d010      	beq.n	8034922 <ee_number+0x146>
 8034900:	0005      	movs	r5, r0
 8034902:	e7f2      	b.n	80348ea <ee_number+0x10e>
  while (size-- > 0) ASSIGN_STR(' ');
 8034904:	001a      	movs	r2, r3
 8034906:	3b01      	subs	r3, #1
 8034908:	2a00      	cmp	r2, #0
 803490a:	dd07      	ble.n	803491c <ee_number+0x140>
 803490c:	1c68      	adds	r0, r5, #1
 803490e:	2220      	movs	r2, #32
 8034910:	702a      	strb	r2, [r5, #0]
 8034912:	3c01      	subs	r4, #1
 8034914:	2c00      	cmp	r4, #0
 8034916:	d004      	beq.n	8034922 <ee_number+0x146>
 8034918:	0005      	movs	r5, r0
 803491a:	e7f3      	b.n	8034904 <ee_number+0x128>

  return str;
 803491c:	0028      	movs	r0, r5
 803491e:	e000      	b.n	8034922 <ee_number+0x146>
  if (base < 2 || base > 36) return 0;
 8034920:	2000      	movs	r0, #0
}
 8034922:	b015      	add	sp, #84	; 0x54
 8034924:	bcf0      	pop	{r4, r5, r6, r7}
 8034926:	46bb      	mov	fp, r7
 8034928:	46b2      	mov	sl, r6
 803492a:	46a9      	mov	r9, r5
 803492c:	46a0      	mov	r8, r4
 803492e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8034930:	08035f00 	.word	0x08035f00
 8034934:	08035ed8 	.word	0x08035ed8

08034938 <tiny_vsnprintf_like>:

#define CHECK_STR_SIZE(_buf, _str, _size) \
  if ((((_str) - (_buf)) >= ((_size)-1))) { break; }

int tiny_vsnprintf_like(char *buf, const int size, const char *fmt, va_list args)
{
 8034938:	b5f0      	push	{r4, r5, r6, r7, lr}
 803493a:	46ce      	mov	lr, r9
 803493c:	4647      	mov	r7, r8
 803493e:	b580      	push	{r7, lr}
 8034940:	b087      	sub	sp, #28
 8034942:	0006      	movs	r6, r0
 8034944:	1e0f      	subs	r7, r1, #0
 8034946:	9205      	str	r2, [sp, #20]
 8034948:	9304      	str	r3, [sp, #16]

  int field_width;      // Width of output field
  int precision;        // Min. # of digits for integers; max number of chars for from string
  int qualifier;        // 'h', 'l', or 'L' for integer fields

  if (size <= 0)
 803494a:	dc00      	bgt.n	803494e <tiny_vsnprintf_like+0x16>
 803494c:	e0b2      	b.n	8034ab4 <tiny_vsnprintf_like+0x17c>
  {
    return 0;
  }

  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 803494e:	0004      	movs	r4, r0
 8034950:	e004      	b.n	803495c <tiny_vsnprintf_like+0x24>
  {
    CHECK_STR_SIZE(buf, str, size);

    if (*fmt != '%')
    {
      *str++ = *fmt;
 8034952:	7022      	strb	r2, [r4, #0]
 8034954:	3401      	adds	r4, #1
  for (str = buf; *fmt || ((str - buf) >= size-1); fmt++)
 8034956:	9b05      	ldr	r3, [sp, #20]
 8034958:	3301      	adds	r3, #1
 803495a:	9305      	str	r3, [sp, #20]
 803495c:	9905      	ldr	r1, [sp, #20]
 803495e:	780a      	ldrb	r2, [r1, #0]
 8034960:	2a00      	cmp	r2, #0
 8034962:	d104      	bne.n	803496e <tiny_vsnprintf_like+0x36>
 8034964:	1ba3      	subs	r3, r4, r6
 8034966:	1e78      	subs	r0, r7, #1
 8034968:	4283      	cmp	r3, r0
 803496a:	da00      	bge.n	803496e <tiny_vsnprintf_like+0x36>
 803496c:	e09a      	b.n	8034aa4 <tiny_vsnprintf_like+0x16c>
    CHECK_STR_SIZE(buf, str, size);
 803496e:	1ba3      	subs	r3, r4, r6
 8034970:	1e78      	subs	r0, r7, #1
 8034972:	4680      	mov	r8, r0
 8034974:	4283      	cmp	r3, r0
 8034976:	db00      	blt.n	803497a <tiny_vsnprintf_like+0x42>
 8034978:	e094      	b.n	8034aa4 <tiny_vsnprintf_like+0x16c>
    if (*fmt != '%')
 803497a:	2a25      	cmp	r2, #37	; 0x25
 803497c:	d1e9      	bne.n	8034952 <tiny_vsnprintf_like+0x1a>

    // Process flags
    flags = 0;
#ifdef TINY_PRINTF
    /* Support %0, but not %-, %+, %space and %# */
    fmt++;
 803497e:	1c4b      	adds	r3, r1, #1
 8034980:	9305      	str	r3, [sp, #20]
    if (*fmt == '0')
 8034982:	784b      	ldrb	r3, [r1, #1]
 8034984:	2b30      	cmp	r3, #48	; 0x30
 8034986:	d012      	beq.n	80349ae <tiny_vsnprintf_like+0x76>
    flags = 0;
 8034988:	2200      	movs	r2, #0
 803498a:	4691      	mov	r9, r2
    }
#endif

    // Get field width
    field_width = -1;
    if (is_digit(*fmt))
 803498c:	3b30      	subs	r3, #48	; 0x30
 803498e:	b2db      	uxtb	r3, r3
 8034990:	2b09      	cmp	r3, #9
 8034992:	d90f      	bls.n	80349b4 <tiny_vsnprintf_like+0x7c>
    field_width = -1;
 8034994:	2501      	movs	r5, #1
 8034996:	426d      	negs	r5, r5
#endif

    // Default base
    base = 10;

    switch (*fmt)
 8034998:	9b05      	ldr	r3, [sp, #20]
 803499a:	781a      	ldrb	r2, [r3, #0]
 803499c:	0013      	movs	r3, r2
 803499e:	3b58      	subs	r3, #88	; 0x58
 80349a0:	b2d9      	uxtb	r1, r3
 80349a2:	2920      	cmp	r1, #32
 80349a4:	d85e      	bhi.n	8034a64 <tiny_vsnprintf_like+0x12c>
 80349a6:	008b      	lsls	r3, r1, #2
 80349a8:	4943      	ldr	r1, [pc, #268]	; (8034ab8 <tiny_vsnprintf_like+0x180>)
 80349aa:	58cb      	ldr	r3, [r1, r3]
 80349ac:	469f      	mov	pc, r3
      flags |= ZEROPAD;
 80349ae:	2201      	movs	r2, #1
 80349b0:	4691      	mov	r9, r2
 80349b2:	e7eb      	b.n	803498c <tiny_vsnprintf_like+0x54>
      field_width = ee_skip_atoi(&fmt);
 80349b4:	a805      	add	r0, sp, #20
 80349b6:	f7ff fefd 	bl	80347b4 <ee_skip_atoi>
 80349ba:	0005      	movs	r5, r0
 80349bc:	e7ec      	b.n	8034998 <tiny_vsnprintf_like+0x60>
    switch (*fmt)
 80349be:	230a      	movs	r3, #10
 80349c0:	e035      	b.n	8034a2e <tiny_vsnprintf_like+0xf6>
      case 'c':
#ifdef TINY_PRINTF
#else
        if (!(flags & LEFT))
#endif
          while (--field_width > 0) *str++ = ' ';
 80349c2:	2220      	movs	r2, #32
 80349c4:	701a      	strb	r2, [r3, #0]
 80349c6:	3301      	adds	r3, #1
 80349c8:	3d01      	subs	r5, #1
 80349ca:	2d00      	cmp	r5, #0
 80349cc:	dcf9      	bgt.n	80349c2 <tiny_vsnprintf_like+0x8a>
        *str++ = (unsigned char) va_arg(args, int);
 80349ce:	9a04      	ldr	r2, [sp, #16]
 80349d0:	1d11      	adds	r1, r2, #4
 80349d2:	9104      	str	r1, [sp, #16]
 80349d4:	1c5c      	adds	r4, r3, #1
 80349d6:	7812      	ldrb	r2, [r2, #0]
 80349d8:	701a      	strb	r2, [r3, #0]
#ifdef TINY_PRINTF
#else
        while (--field_width > 0) *str++ = ' ';
#endif
        continue;
 80349da:	e7bc      	b.n	8034956 <tiny_vsnprintf_like+0x1e>
    switch (*fmt)
 80349dc:	0023      	movs	r3, r4
 80349de:	e7f3      	b.n	80349c8 <tiny_vsnprintf_like+0x90>

      case 's':
        s = va_arg(args, char *);
 80349e0:	9b04      	ldr	r3, [sp, #16]
 80349e2:	1d1a      	adds	r2, r3, #4
 80349e4:	9204      	str	r2, [sp, #16]
 80349e6:	681b      	ldr	r3, [r3, #0]
 80349e8:	4698      	mov	r8, r3
        if (!s) s = "<NULL>";
 80349ea:	2b00      	cmp	r3, #0
 80349ec:	d003      	beq.n	80349f6 <tiny_vsnprintf_like+0xbe>
#ifdef TINY_PRINTF
        len = strlen(s);
 80349ee:	4640      	mov	r0, r8
 80349f0:	f7eb fb8a 	bl	8020108 <strlen>
#else
        len = strnlen(s, precision);
        if (!(flags & LEFT))
#endif
          while (len < field_width--) *str++ = ' ';
 80349f4:	e006      	b.n	8034a04 <tiny_vsnprintf_like+0xcc>
        if (!s) s = "<NULL>";
 80349f6:	4b31      	ldr	r3, [pc, #196]	; (8034abc <tiny_vsnprintf_like+0x184>)
 80349f8:	4698      	mov	r8, r3
 80349fa:	e7f8      	b.n	80349ee <tiny_vsnprintf_like+0xb6>
          while (len < field_width--) *str++ = ' ';
 80349fc:	2220      	movs	r2, #32
 80349fe:	7022      	strb	r2, [r4, #0]
 8034a00:	001d      	movs	r5, r3
 8034a02:	3401      	adds	r4, #1
 8034a04:	1e6b      	subs	r3, r5, #1
 8034a06:	4285      	cmp	r5, r0
 8034a08:	dcf8      	bgt.n	80349fc <tiny_vsnprintf_like+0xc4>
        for (i = 0; i < len; ++i) *str++ = *s++;
 8034a0a:	2300      	movs	r3, #0
 8034a0c:	e007      	b.n	8034a1e <tiny_vsnprintf_like+0xe6>
 8034a0e:	4642      	mov	r2, r8
 8034a10:	7812      	ldrb	r2, [r2, #0]
 8034a12:	7022      	strb	r2, [r4, #0]
 8034a14:	3301      	adds	r3, #1
 8034a16:	2201      	movs	r2, #1
 8034a18:	4694      	mov	ip, r2
 8034a1a:	44e0      	add	r8, ip
 8034a1c:	3401      	adds	r4, #1
 8034a1e:	4283      	cmp	r3, r0
 8034a20:	dbf5      	blt.n	8034a0e <tiny_vsnprintf_like+0xd6>
 8034a22:	e798      	b.n	8034956 <tiny_vsnprintf_like+0x1e>
        base = 8;
        break;
#endif

      case 'X':
        flags |= UPPERCASE;
 8034a24:	2340      	movs	r3, #64	; 0x40
 8034a26:	464a      	mov	r2, r9
 8034a28:	431a      	orrs	r2, r3
 8034a2a:	4691      	mov	r9, r2

      case 'x':
        base = 16;
 8034a2c:	3b30      	subs	r3, #48	; 0x30
        continue;
    }

    if (qualifier == 'l')
      num = va_arg(args, unsigned long);
    else if (flags & SIGN)
 8034a2e:	464a      	mov	r2, r9
 8034a30:	0792      	lsls	r2, r2, #30
 8034a32:	d532      	bpl.n	8034a9a <tiny_vsnprintf_like+0x162>
      num = va_arg(args, int);
 8034a34:	9a04      	ldr	r2, [sp, #16]
 8034a36:	1d11      	adds	r1, r2, #4
 8034a38:	9104      	str	r1, [sp, #16]
 8034a3a:	6812      	ldr	r2, [r2, #0]
    else
      num = va_arg(args, unsigned int);

    str = ee_number(str, ((size - 1) - (str - buf)), num, base, field_width, precision, flags);
 8034a3c:	1ba1      	subs	r1, r4, r6
 8034a3e:	4640      	mov	r0, r8
 8034a40:	1a41      	subs	r1, r0, r1
 8034a42:	4648      	mov	r0, r9
 8034a44:	9002      	str	r0, [sp, #8]
 8034a46:	2001      	movs	r0, #1
 8034a48:	4240      	negs	r0, r0
 8034a4a:	9001      	str	r0, [sp, #4]
 8034a4c:	9500      	str	r5, [sp, #0]
 8034a4e:	0020      	movs	r0, r4
 8034a50:	f7ff fec4 	bl	80347dc <ee_number>
 8034a54:	0004      	movs	r4, r0
 8034a56:	e77e      	b.n	8034956 <tiny_vsnprintf_like+0x1e>
        flags |= SIGN;
 8034a58:	2302      	movs	r3, #2
 8034a5a:	464a      	mov	r2, r9
 8034a5c:	431a      	orrs	r2, r3
 8034a5e:	4691      	mov	r9, r2
    base = 10;
 8034a60:	3308      	adds	r3, #8
 8034a62:	e7e4      	b.n	8034a2e <tiny_vsnprintf_like+0xf6>
        if (*fmt != '%') *str++ = '%';
 8034a64:	2a25      	cmp	r2, #37	; 0x25
 8034a66:	d002      	beq.n	8034a6e <tiny_vsnprintf_like+0x136>
 8034a68:	2325      	movs	r3, #37	; 0x25
 8034a6a:	7023      	strb	r3, [r4, #0]
 8034a6c:	3401      	adds	r4, #1
        CHECK_STR_SIZE(buf, str, size);
 8034a6e:	1ba3      	subs	r3, r4, r6
 8034a70:	4598      	cmp	r8, r3
 8034a72:	dd10      	ble.n	8034a96 <tiny_vsnprintf_like+0x15e>
        if (*fmt)
 8034a74:	9b05      	ldr	r3, [sp, #20]
 8034a76:	781a      	ldrb	r2, [r3, #0]
 8034a78:	2a00      	cmp	r2, #0
 8034a7a:	d007      	beq.n	8034a8c <tiny_vsnprintf_like+0x154>
          *str++ = *fmt;
 8034a7c:	7022      	strb	r2, [r4, #0]
 8034a7e:	3401      	adds	r4, #1
        CHECK_STR_SIZE(buf, str, size);
 8034a80:	1ba3      	subs	r3, r4, r6
 8034a82:	4598      	cmp	r8, r3
 8034a84:	dd00      	ble.n	8034a88 <tiny_vsnprintf_like+0x150>
 8034a86:	e766      	b.n	8034956 <tiny_vsnprintf_like+0x1e>
    base = 10;
 8034a88:	230a      	movs	r3, #10
    if (qualifier == 'l')
 8034a8a:	e7d0      	b.n	8034a2e <tiny_vsnprintf_like+0xf6>
          --fmt;
 8034a8c:	3b01      	subs	r3, #1
 8034a8e:	9305      	str	r3, [sp, #20]
 8034a90:	e7f6      	b.n	8034a80 <tiny_vsnprintf_like+0x148>
        base = 16;
 8034a92:	2310      	movs	r3, #16
 8034a94:	e7cb      	b.n	8034a2e <tiny_vsnprintf_like+0xf6>
    base = 10;
 8034a96:	230a      	movs	r3, #10
 8034a98:	e7c9      	b.n	8034a2e <tiny_vsnprintf_like+0xf6>
      num = va_arg(args, unsigned int);
 8034a9a:	9a04      	ldr	r2, [sp, #16]
 8034a9c:	1d11      	adds	r1, r2, #4
 8034a9e:	9104      	str	r1, [sp, #16]
 8034aa0:	6812      	ldr	r2, [r2, #0]
 8034aa2:	e7cb      	b.n	8034a3c <tiny_vsnprintf_like+0x104>
  }

  *str = '\0';
 8034aa4:	2300      	movs	r3, #0
 8034aa6:	7023      	strb	r3, [r4, #0]
  return str - buf;
 8034aa8:	1ba0      	subs	r0, r4, r6
}
 8034aaa:	b007      	add	sp, #28
 8034aac:	bcc0      	pop	{r6, r7}
 8034aae:	46b9      	mov	r9, r7
 8034ab0:	46b0      	mov	r8, r6
 8034ab2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return 0;
 8034ab4:	2000      	movs	r0, #0
 8034ab6:	e7f8      	b.n	8034aaa <tiny_vsnprintf_like+0x172>
 8034ab8:	08035f30 	.word	0x08035f30
 8034abc:	08035f28 	.word	0x08035f28

08034ac0 <__libc_init_array>:
 8034ac0:	b570      	push	{r4, r5, r6, lr}
 8034ac2:	2600      	movs	r6, #0
 8034ac4:	4d0c      	ldr	r5, [pc, #48]	; (8034af8 <__libc_init_array+0x38>)
 8034ac6:	4c0d      	ldr	r4, [pc, #52]	; (8034afc <__libc_init_array+0x3c>)
 8034ac8:	1b64      	subs	r4, r4, r5
 8034aca:	10a4      	asrs	r4, r4, #2
 8034acc:	42a6      	cmp	r6, r4
 8034ace:	d109      	bne.n	8034ae4 <__libc_init_array+0x24>
 8034ad0:	2600      	movs	r6, #0
 8034ad2:	f000 f8c3 	bl	8034c5c <_init>
 8034ad6:	4d0a      	ldr	r5, [pc, #40]	; (8034b00 <__libc_init_array+0x40>)
 8034ad8:	4c0a      	ldr	r4, [pc, #40]	; (8034b04 <__libc_init_array+0x44>)
 8034ada:	1b64      	subs	r4, r4, r5
 8034adc:	10a4      	asrs	r4, r4, #2
 8034ade:	42a6      	cmp	r6, r4
 8034ae0:	d105      	bne.n	8034aee <__libc_init_array+0x2e>
 8034ae2:	bd70      	pop	{r4, r5, r6, pc}
 8034ae4:	00b3      	lsls	r3, r6, #2
 8034ae6:	58eb      	ldr	r3, [r5, r3]
 8034ae8:	4798      	blx	r3
 8034aea:	3601      	adds	r6, #1
 8034aec:	e7ee      	b.n	8034acc <__libc_init_array+0xc>
 8034aee:	00b3      	lsls	r3, r6, #2
 8034af0:	58eb      	ldr	r3, [r5, r3]
 8034af2:	4798      	blx	r3
 8034af4:	3601      	adds	r6, #1
 8034af6:	e7f2      	b.n	8034ade <__libc_init_array+0x1e>
 8034af8:	08035fc0 	.word	0x08035fc0
 8034afc:	08035fc0 	.word	0x08035fc0
 8034b00:	08035fc0 	.word	0x08035fc0
 8034b04:	08035fc4 	.word	0x08035fc4

08034b08 <memcmp>:
 8034b08:	b530      	push	{r4, r5, lr}
 8034b0a:	2400      	movs	r4, #0
 8034b0c:	3901      	subs	r1, #1
 8034b0e:	42a2      	cmp	r2, r4
 8034b10:	d101      	bne.n	8034b16 <memcmp+0xe>
 8034b12:	2000      	movs	r0, #0
 8034b14:	e005      	b.n	8034b22 <memcmp+0x1a>
 8034b16:	5d03      	ldrb	r3, [r0, r4]
 8034b18:	3401      	adds	r4, #1
 8034b1a:	5d0d      	ldrb	r5, [r1, r4]
 8034b1c:	42ab      	cmp	r3, r5
 8034b1e:	d0f6      	beq.n	8034b0e <memcmp+0x6>
 8034b20:	1b58      	subs	r0, r3, r5
 8034b22:	bd30      	pop	{r4, r5, pc}

08034b24 <memcpy>:
 8034b24:	2300      	movs	r3, #0
 8034b26:	b510      	push	{r4, lr}
 8034b28:	429a      	cmp	r2, r3
 8034b2a:	d100      	bne.n	8034b2e <memcpy+0xa>
 8034b2c:	bd10      	pop	{r4, pc}
 8034b2e:	5ccc      	ldrb	r4, [r1, r3]
 8034b30:	54c4      	strb	r4, [r0, r3]
 8034b32:	3301      	adds	r3, #1
 8034b34:	e7f8      	b.n	8034b28 <memcpy+0x4>

08034b36 <memset>:
 8034b36:	0003      	movs	r3, r0
 8034b38:	1882      	adds	r2, r0, r2
 8034b3a:	4293      	cmp	r3, r2
 8034b3c:	d100      	bne.n	8034b40 <memset+0xa>
 8034b3e:	4770      	bx	lr
 8034b40:	7019      	strb	r1, [r3, #0]
 8034b42:	3301      	adds	r3, #1
 8034b44:	e7f9      	b.n	8034b3a <memset+0x4>
	...

08034b48 <floor>:
 8034b48:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8034b4a:	004b      	lsls	r3, r1, #1
 8034b4c:	4a3d      	ldr	r2, [pc, #244]	; (8034c44 <floor+0xfc>)
 8034b4e:	0d5b      	lsrs	r3, r3, #21
 8034b50:	189f      	adds	r7, r3, r2
 8034b52:	4684      	mov	ip, r0
 8034b54:	000e      	movs	r6, r1
 8034b56:	000d      	movs	r5, r1
 8034b58:	0004      	movs	r4, r0
 8034b5a:	9001      	str	r0, [sp, #4]
 8034b5c:	2f13      	cmp	r7, #19
 8034b5e:	dc34      	bgt.n	8034bca <floor+0x82>
 8034b60:	2f00      	cmp	r7, #0
 8034b62:	da16      	bge.n	8034b92 <floor+0x4a>
 8034b64:	4a38      	ldr	r2, [pc, #224]	; (8034c48 <floor+0x100>)
 8034b66:	4b39      	ldr	r3, [pc, #228]	; (8034c4c <floor+0x104>)
 8034b68:	4660      	mov	r0, ip
 8034b6a:	0031      	movs	r1, r6
 8034b6c:	f7eb ff92 	bl	8020a94 <__aeabi_dadd>
 8034b70:	2200      	movs	r2, #0
 8034b72:	2300      	movs	r3, #0
 8034b74:	f7eb fc70 	bl	8020458 <__aeabi_dcmpgt>
 8034b78:	2800      	cmp	r0, #0
 8034b7a:	d007      	beq.n	8034b8c <floor+0x44>
 8034b7c:	2e00      	cmp	r6, #0
 8034b7e:	da5d      	bge.n	8034c3c <floor+0xf4>
 8034b80:	0073      	lsls	r3, r6, #1
 8034b82:	085b      	lsrs	r3, r3, #1
 8034b84:	431c      	orrs	r4, r3
 8034b86:	d001      	beq.n	8034b8c <floor+0x44>
 8034b88:	2400      	movs	r4, #0
 8034b8a:	4d31      	ldr	r5, [pc, #196]	; (8034c50 <floor+0x108>)
 8034b8c:	46a4      	mov	ip, r4
 8034b8e:	002e      	movs	r6, r5
 8034b90:	e029      	b.n	8034be6 <floor+0x9e>
 8034b92:	4b30      	ldr	r3, [pc, #192]	; (8034c54 <floor+0x10c>)
 8034b94:	413b      	asrs	r3, r7
 8034b96:	9300      	str	r3, [sp, #0]
 8034b98:	400b      	ands	r3, r1
 8034b9a:	4303      	orrs	r3, r0
 8034b9c:	d023      	beq.n	8034be6 <floor+0x9e>
 8034b9e:	4a2a      	ldr	r2, [pc, #168]	; (8034c48 <floor+0x100>)
 8034ba0:	4b2a      	ldr	r3, [pc, #168]	; (8034c4c <floor+0x104>)
 8034ba2:	4660      	mov	r0, ip
 8034ba4:	0031      	movs	r1, r6
 8034ba6:	f7eb ff75 	bl	8020a94 <__aeabi_dadd>
 8034baa:	2200      	movs	r2, #0
 8034bac:	2300      	movs	r3, #0
 8034bae:	f7eb fc53 	bl	8020458 <__aeabi_dcmpgt>
 8034bb2:	2800      	cmp	r0, #0
 8034bb4:	d0ea      	beq.n	8034b8c <floor+0x44>
 8034bb6:	2e00      	cmp	r6, #0
 8034bb8:	da03      	bge.n	8034bc2 <floor+0x7a>
 8034bba:	2380      	movs	r3, #128	; 0x80
 8034bbc:	035b      	lsls	r3, r3, #13
 8034bbe:	413b      	asrs	r3, r7
 8034bc0:	18f5      	adds	r5, r6, r3
 8034bc2:	9b00      	ldr	r3, [sp, #0]
 8034bc4:	2400      	movs	r4, #0
 8034bc6:	439d      	bics	r5, r3
 8034bc8:	e7e0      	b.n	8034b8c <floor+0x44>
 8034bca:	2f33      	cmp	r7, #51	; 0x33
 8034bcc:	dd0f      	ble.n	8034bee <floor+0xa6>
 8034bce:	2380      	movs	r3, #128	; 0x80
 8034bd0:	00db      	lsls	r3, r3, #3
 8034bd2:	429f      	cmp	r7, r3
 8034bd4:	d107      	bne.n	8034be6 <floor+0x9e>
 8034bd6:	0002      	movs	r2, r0
 8034bd8:	000b      	movs	r3, r1
 8034bda:	4660      	mov	r0, ip
 8034bdc:	0031      	movs	r1, r6
 8034bde:	f7eb ff59 	bl	8020a94 <__aeabi_dadd>
 8034be2:	4684      	mov	ip, r0
 8034be4:	000e      	movs	r6, r1
 8034be6:	4660      	mov	r0, ip
 8034be8:	0031      	movs	r1, r6
 8034bea:	b003      	add	sp, #12
 8034bec:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8034bee:	4a1a      	ldr	r2, [pc, #104]	; (8034c58 <floor+0x110>)
 8034bf0:	189b      	adds	r3, r3, r2
 8034bf2:	2201      	movs	r2, #1
 8034bf4:	4252      	negs	r2, r2
 8034bf6:	40da      	lsrs	r2, r3
 8034bf8:	9200      	str	r2, [sp, #0]
 8034bfa:	4210      	tst	r0, r2
 8034bfc:	d0f3      	beq.n	8034be6 <floor+0x9e>
 8034bfe:	4a12      	ldr	r2, [pc, #72]	; (8034c48 <floor+0x100>)
 8034c00:	4b12      	ldr	r3, [pc, #72]	; (8034c4c <floor+0x104>)
 8034c02:	4660      	mov	r0, ip
 8034c04:	0031      	movs	r1, r6
 8034c06:	f7eb ff45 	bl	8020a94 <__aeabi_dadd>
 8034c0a:	2200      	movs	r2, #0
 8034c0c:	2300      	movs	r3, #0
 8034c0e:	f7eb fc23 	bl	8020458 <__aeabi_dcmpgt>
 8034c12:	2800      	cmp	r0, #0
 8034c14:	d0ba      	beq.n	8034b8c <floor+0x44>
 8034c16:	2e00      	cmp	r6, #0
 8034c18:	da02      	bge.n	8034c20 <floor+0xd8>
 8034c1a:	2f14      	cmp	r7, #20
 8034c1c:	d103      	bne.n	8034c26 <floor+0xde>
 8034c1e:	3501      	adds	r5, #1
 8034c20:	9b00      	ldr	r3, [sp, #0]
 8034c22:	439c      	bics	r4, r3
 8034c24:	e7b2      	b.n	8034b8c <floor+0x44>
 8034c26:	2334      	movs	r3, #52	; 0x34
 8034c28:	1bdf      	subs	r7, r3, r7
 8034c2a:	3b33      	subs	r3, #51	; 0x33
 8034c2c:	40bb      	lsls	r3, r7
 8034c2e:	18e4      	adds	r4, r4, r3
 8034c30:	9b01      	ldr	r3, [sp, #4]
 8034c32:	429c      	cmp	r4, r3
 8034c34:	419b      	sbcs	r3, r3
 8034c36:	425b      	negs	r3, r3
 8034c38:	18f5      	adds	r5, r6, r3
 8034c3a:	e7f1      	b.n	8034c20 <floor+0xd8>
 8034c3c:	2400      	movs	r4, #0
 8034c3e:	0025      	movs	r5, r4
 8034c40:	e7a4      	b.n	8034b8c <floor+0x44>
 8034c42:	46c0      	nop			; (mov r8, r8)
 8034c44:	fffffc01 	.word	0xfffffc01
 8034c48:	8800759c 	.word	0x8800759c
 8034c4c:	7e37e43c 	.word	0x7e37e43c
 8034c50:	bff00000 	.word	0xbff00000
 8034c54:	000fffff 	.word	0x000fffff
 8034c58:	fffffbed 	.word	0xfffffbed

08034c5c <_init>:
 8034c5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8034c5e:	46c0      	nop			; (mov r8, r8)
 8034c60:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8034c62:	bc08      	pop	{r3}
 8034c64:	469e      	mov	lr, r3
 8034c66:	4770      	bx	lr

08034c68 <_fini>:
 8034c68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8034c6a:	46c0      	nop			; (mov r8, r8)
 8034c6c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8034c6e:	bc08      	pop	{r3}
 8034c70:	469e      	mov	lr, r3
 8034c72:	4770      	bx	lr
 8034c74:	0000      	movs	r0, r0
	...

08034c78 <__FLASH_Program_Fast_veneer>:
 8034c78:	b401      	push	{r0}
 8034c7a:	4802      	ldr	r0, [pc, #8]	; (8034c84 <__FLASH_Program_Fast_veneer+0xc>)
 8034c7c:	4684      	mov	ip, r0
 8034c7e:	bc01      	pop	{r0}
 8034c80:	4760      	bx	ip
 8034c82:	bf00      	nop
 8034c84:	2000b145 	.word	0x2000b145

Disassembly of section .data:

2000b000 <callback_mbwrapper>:
2000b000:	08022025 0802200b 08021af9 08021b61     % ... ......a...
2000b010:	08021fe5 08021fbf 08021eb1 08021f9d     ................
2000b020:	080221e9 08022191 08022139 0802207d     .!...!..9!..} ..
2000b030:	08021f7b 0802203d 08021f67 08021f45     {...= ..g...E...
2000b040:	08021f23 08021f01 08021eed              #...........

2000b04c <SystemCoreClock>:
2000b04c:	003d0900                                ..=.

2000b050 <vCKK_AES.4>:
2000b050:	0000001f                                ....

2000b054 <vCKO_SECRET_KEY.5>:
2000b054:	00000004                                ....

2000b058 <JoinParams>:
2000b058:	2000ba38 00ff0000 00000000              8.. ........

2000b064 <RxParams>:
2000b064:	00000000 2000ba38 00000000 00000000     ....8.. ........
2000b074:	000000ff                                ....

2000b078 <TxParams>:
2000b078:	00000000 2000ba38 00000000 00000000     ....8.. ........
	...

2000b094 <CompliancePackage>:
2000b094:	000000e0 0802a3c5 08029fc5 08029fd1     ................
2000b0a4:	0802a311 00000000 00000000 0802a005     ................
2000b0b4:	08029fdd 08029fdf 00000000 00000000     ................
	...

2000b0cc <KeyAddrList>:
2000b0cc:	0d0f0e00 11080901                       ........

2000b0d4 <KeyList>:
2000b0d4:	00000000 00000002 00000001 00000003     ................
2000b0e4:	00000002 00000004 00000008 00000005     ................
2000b0f4:	00000009 00000006 0000000a ffffffff     ................
2000b104:	0000000b ffffffff 0000000c ffffffff     ................
2000b114:	0000000d ffffffff 0000000e ffffffff     ................
2000b124:	0000000f ffffffff 00000010 00000001     ................

2000b134 <next>:
2000b134:	00000001                                ....

2000b138 <MaxPayloadLength>:
2000b138:	000000ff                                ....

2000b13c <SuperMask>:
2000b13c:	ffffffff                                ....

2000b140 <TaskMask>:
2000b140:	ffffffff                                ....

2000b144 <FLASH_Program_Fast>:
#ifdef CORE_CM0PLUS
static __RAM_FUNC void FLASH_Program_Fast(uint32_t Address, uint32_t DataAddress)
#else
static void FLASH_Program_Fast(uint32_t Address, uint32_t DataAddress)
#endif
{
2000b144:	b510      	push	{r4, lr}
  __IO uint32_t *src_addr = (__IO uint32_t *)DataAddress;
  uint32_t primask_bit;

  /* Set FSTPG bit */
#ifdef CORE_CM0PLUS
  SET_BIT(FLASH->C2CR, FLASH_CR_FSTPG);
2000b146:	4a0b      	ldr	r2, [pc, #44]	; (2000b174 <FLASH_Program_Fast+0x30>)
2000b148:	6e54      	ldr	r4, [r2, #100]	; 0x64
2000b14a:	2380      	movs	r3, #128	; 0x80
2000b14c:	02db      	lsls	r3, r3, #11
2000b14e:	4323      	orrs	r3, r4
2000b150:	6653      	str	r3, [r2, #100]	; 0x64
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
2000b152:	f3ef 8c10 	mrs	ip, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
2000b156:	b672      	cpsid	i
  uint8_t row_index = (2 * FLASH_NB_DOUBLE_WORDS_IN_ROW);
2000b158:	2340      	movs	r3, #64	; 0x40
  __disable_irq();

  /* Program the double word of the row */
  do
  {
    *dest_addr = *src_addr;
2000b15a:	c904      	ldmia	r1!, {r2}
2000b15c:	c004      	stmia	r0!, {r2}
    dest_addr++;
    src_addr++;
    row_index--;
2000b15e:	3b01      	subs	r3, #1
2000b160:	b2db      	uxtb	r3, r3
  }
  while (row_index != 0U);
2000b162:	2b00      	cmp	r3, #0
2000b164:	d1f9      	bne.n	2000b15a <FLASH_Program_Fast+0x16>

  /* wait for BSY in order to be sure that flash operation is ended before
     allowing prefetch in flash. Timeout does not return status, as it will
     be anyway done later */
  while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != 0U)
2000b166:	4b03      	ldr	r3, [pc, #12]	; (2000b174 <FLASH_Program_Fast+0x30>)
2000b168:	6e1b      	ldr	r3, [r3, #96]	; 0x60
2000b16a:	03db      	lsls	r3, r3, #15
2000b16c:	d4fb      	bmi.n	2000b166 <FLASH_Program_Fast+0x22>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
2000b16e:	f38c 8810 	msr	PRIMASK, ip
  {
  }

  /* Exit critical section: restore previous priority mask */
  __set_PRIMASK(primask_bit);
}
2000b172:	bd10      	pop	{r4, pc}
2000b174:	58004000 	.word	0x58004000
